module.exports = function (e) {
  var t = {};

  function n(r) {
    if (t[r]) return t[r].exports;
    var i = t[r] = {
      i: r,
      l: !1,
      exports: {}
    };
    return e[r].call(i.exports, i, i.exports, n), i.l = !0, i.exports
  }
  return n.m = e, n.c = t, n.d = function (e, t, r) {
    n.o(e, t) || Object.defineProperty(e, t, {
      enumerable: !0,
      get: r
    })
  }, n.r = function (e) {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
      value: "Module"
    }), Object.defineProperty(e, "__esModule", {
      value: !0
    })
  }, n.t = function (e, t) {
    if (1 & t && (e = n(e)), 8 & t) return e;
    if (4 & t && "object" == typeof e && e && e.__esModule) return e;
    var r = Object.create(null);
    if (n.r(r), Object.defineProperty(r, "default", {
        enumerable: !0,
        value: e
      }), 2 & t && "string" != typeof e)
      for (var i in e) n.d(r, i, function (t) {
        return e[t]
      }.bind(null, i));
    return r
  }, n.n = function (e) {
    var t = e && e.__esModule ? function () {
      return e.default
    } : function () {
      return e
    };
    return n.d(t, "a", t), t
  }, n.o = function (e, t) {
    return Object.prototype.hasOwnProperty.call(e, t)
  }, n.p = "", n(n.s = 308)
}([function (e, t, n) {
  "use strict";
  e.exports = n(148)
}, function (e, t) {
  e.exports = require("path")
}, function (e, t, n) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  var r = n(220);
  t.GitProcess = r.GitProcess;
  var i = n(104);
  t.GitError = i.GitError, t.RepositoryDoesNotExistErrorCode = i.RepositoryDoesNotExistErrorCode, t.GitNotFoundErrorCode = i.GitNotFoundErrorCode
}, function (e, t, n) {
  "use strict";
  e.exports = Object.assign({}, n(95), n(97), n(101), n(175), n(177), n(183), n(17), n(190), n(191), n(192), n(21), n(45));
  const r = n(7);
  Object.getOwnPropertyDescriptor(r, "promises") && Object.defineProperty(e.exports, "promises", {
    get: () => r.promises
  })
}, function (e, t) {
  e.exports = require("electron")
}, function (e, t, n) {
  var r;
  /*!
    Copyright (c) 2016 Jed Watson.
    Licensed under the MIT License (MIT), see
    http://jedwatson.github.io/classnames
  */
  ! function () {
    "use strict";
    var n = {}.hasOwnProperty;

    function i() {
      for (var e = [], t = 0; t < arguments.length; t++) {
        var r = arguments[t];
        if (r) {
          var o = typeof r;
          if ("string" === o || "number" === o) e.push(r);
          else if (Array.isArray(r)) e.push(i.apply(null, r));
          else if ("object" === o)
            for (var s in r) n.call(r, s) && r[s] && e.push(s)
        }
      }
      return e.join(" ")
    }
    e.exports ? e.exports = i : void 0 === (r = function () {
      return i
    }.apply(t, [])) || (e.exports = r)
  }()
}, function (e, t, n) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
      value: !0
    }),
    function (e) {
      for (var n in e) t.hasOwnProperty(n) || (t[n] = e[n])
    }(n(218))
}, function (e, t) {
  e.exports = require("fs")
}, function (e, t) {
  e.exports = require("child_process")
}, function (e, t) {
  e.exports = require("url")
}, , function (e, t, n) {
  (function () {
    t.Emitter = n(152), t.Disposable = n(60), t.CompositeDisposable = n(153)
  }).call(this)
}, function (e, t, n) {
  (function (e) {
    e.exports = function () {
      "use strict";
      var t, n;

      function r() {
        return t.apply(null, arguments)
      }

      function i(e) {
        return e instanceof Array || "[object Array]" === Object.prototype.toString.call(e)
      }

      function o(e) {
        return null != e && "[object Object]" === Object.prototype.toString.call(e)
      }

      function s(e) {
        return void 0 === e
      }

      function a(e) {
        return "number" == typeof e || "[object Number]" === Object.prototype.toString.call(e)
      }

      function l(e) {
        return e instanceof Date || "[object Date]" === Object.prototype.toString.call(e)
      }

      function c(e, t) {
        var n, r = [];
        for (n = 0; n < e.length; ++n) r.push(t(e[n], n));
        return r
      }

      function u(e, t) {
        return Object.prototype.hasOwnProperty.call(e, t)
      }

      function h(e, t) {
        for (var n in t) u(t, n) && (e[n] = t[n]);
        return u(t, "toString") && (e.toString = t.toString), u(t, "valueOf") && (e.valueOf = t.valueOf), e
      }

      function p(e, t, n, r) {
        return Et(e, t, n, r, !0).utc()
      }

      function d(e) {
        return null == e._pf && (e._pf = {
          empty: !1,
          unusedTokens: [],
          unusedInput: [],
          overflow: -2,
          charsLeftOver: 0,
          nullInput: !1,
          invalidMonth: null,
          invalidFormat: !1,
          userInvalidated: !1,
          iso: !1,
          parsedDateParts: [],
          meridiem: null,
          rfc2822: !1,
          weekdayMismatch: !1
        }), e._pf
      }

      function f(e) {
        if (null == e._isValid) {
          var t = d(e),
            r = n.call(t.parsedDateParts, (function (e) {
              return null != e
            })),
            i = !isNaN(e._d.getTime()) && t.overflow < 0 && !t.empty && !t.invalidMonth && !t.invalidWeekday && !t.weekdayMismatch && !t.nullInput && !t.invalidFormat && !t.userInvalidated && (!t.meridiem || t.meridiem && r);
          if (e._strict && (i = i && 0 === t.charsLeftOver && 0 === t.unusedTokens.length && void 0 === t.bigHour), null != Object.isFrozen && Object.isFrozen(e)) return i;
          e._isValid = i
        }
        return e._isValid
      }

      function m(e) {
        var t = p(NaN);
        return null != e ? h(d(t), e) : d(t).userInvalidated = !0, t
      }
      n = Array.prototype.some ? Array.prototype.some : function (e) {
        for (var t = Object(this), n = t.length >>> 0, r = 0; r < n; r++)
          if (r in t && e.call(this, t[r], r, t)) return !0;
        return !1
      };
      var g = r.momentProperties = [];

      function y(e, t) {
        var n, r, i;
        if (s(t._isAMomentObject) || (e._isAMomentObject = t._isAMomentObject), s(t._i) || (e._i = t._i), s(t._f) || (e._f = t._f), s(t._l) || (e._l = t._l), s(t._strict) || (e._strict = t._strict), s(t._tzm) || (e._tzm = t._tzm), s(t._isUTC) || (e._isUTC = t._isUTC), s(t._offset) || (e._offset = t._offset), s(t._pf) || (e._pf = d(t)), s(t._locale) || (e._locale = t._locale), g.length > 0)
          for (n = 0; n < g.length; n++) s(i = t[r = g[n]]) || (e[r] = i);
        return e
      }
      var v = !1;

      function w(e) {
        y(this, e), this._d = new Date(null != e._d ? e._d.getTime() : NaN), this.isValid() || (this._d = new Date(NaN)), !1 === v && (v = !0, r.updateOffset(this), v = !1)
      }

      function b(e) {
        return e instanceof w || null != e && null != e._isAMomentObject
      }

      function S(e) {
        return e < 0 ? Math.ceil(e) || 0 : Math.floor(e)
      }

      function C(e) {
        var t = +e,
          n = 0;
        return 0 !== t && isFinite(t) && (n = S(t)), n
      }

      function E(e, t, n) {
        var r, i = Math.min(e.length, t.length),
          o = Math.abs(e.length - t.length),
          s = 0;
        for (r = 0; r < i; r++)(n && e[r] !== t[r] || !n && C(e[r]) !== C(t[r])) && s++;
        return s + o
      }

      function k(e) {
        !1 === r.suppressDeprecationWarnings && "undefined" != typeof console && console.warn && console.warn("Deprecation warning: " + e)
      }

      function x(e, t) {
        var n = !0;
        return h((function () {
          if (null != r.deprecationHandler && r.deprecationHandler(null, e), n) {
            for (var i, o = [], s = 0; s < arguments.length; s++) {
              if (i = "", "object" == typeof arguments[s]) {
                for (var a in i += "\n[" + s + "] ", arguments[0]) i += a + ": " + arguments[0][a] + ", ";
                i = i.slice(0, -2)
              } else i = arguments[s];
              o.push(i)
            }
            k(e + "\nArguments: " + Array.prototype.slice.call(o).join("") + "\n" + (new Error).stack), n = !1
          }
          return t.apply(this, arguments)
        }), t)
      }
      var T, R = {};

      function D(e, t) {
        null != r.deprecationHandler && r.deprecationHandler(e, t), R[e] || (k(t), R[e] = !0)
      }

      function _(e) {
        return e instanceof Function || "[object Function]" === Object.prototype.toString.call(e)
      }

      function A(e, t) {
        var n, r = h({}, e);
        for (n in t) u(t, n) && (o(e[n]) && o(t[n]) ? (r[n] = {}, h(r[n], e[n]), h(r[n], t[n])) : null != t[n] ? r[n] = t[n] : delete r[n]);
        for (n in e) u(e, n) && !u(t, n) && o(e[n]) && (r[n] = h({}, r[n]));
        return r
      }

      function M(e) {
        null != e && this.set(e)
      }
      r.suppressDeprecationWarnings = !1, r.deprecationHandler = null, T = Object.keys ? Object.keys : function (e) {
        var t, n = [];
        for (t in e) u(e, t) && n.push(t);
        return n
      };
      var P = {};

      function I(e, t) {
        var n = e.toLowerCase();
        P[n] = P[n + "s"] = P[t] = e
      }

      function O(e) {
        return "string" == typeof e ? P[e] || P[e.toLowerCase()] : void 0
      }

      function L(e) {
        var t, n, r = {};
        for (n in e) u(e, n) && (t = O(n)) && (r[t] = e[n]);
        return r
      }
      var N = {};

      function F(e, t) {
        N[e] = t
      }

      function B(e, t, n) {
        var r = "" + Math.abs(e),
          i = t - r.length;
        return (e >= 0 ? n ? "+" : "" : "-") + Math.pow(10, Math.max(0, i)).toString().substr(1) + r
      }
      var H = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
        z = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
        U = {},
        W = {};

      function V(e, t, n, r) {
        var i = r;
        "string" == typeof r && (i = function () {
          return this[r]()
        }), e && (W[e] = i), t && (W[t[0]] = function () {
          return B(i.apply(this, arguments), t[1], t[2])
        }), n && (W[n] = function () {
          return this.localeData().ordinal(i.apply(this, arguments), e)
        })
      }

      function j(e, t) {
        return e.isValid() ? (t = G(t, e.localeData()), U[t] = U[t] || function (e) {
          var t, n, r, i = e.match(H);
          for (t = 0, n = i.length; t < n; t++) W[i[t]] ? i[t] = W[i[t]] : i[t] = (r = i[t]).match(/\[[\s\S]/) ? r.replace(/^\[|\]$/g, "") : r.replace(/\\/g, "");
          return function (t) {
            var r, o = "";
            for (r = 0; r < n; r++) o += _(i[r]) ? i[r].call(t, e) : i[r];
            return o
          }
        }(t), U[t](e)) : e.localeData().invalidDate()
      }

      function G(e, t) {
        var n = 5;

        function r(e) {
          return t.longDateFormat(e) || e
        }
        for (z.lastIndex = 0; n >= 0 && z.test(e);) e = e.replace(z, r), z.lastIndex = 0, n -= 1;
        return e
      }
      var $ = /\d/,
        q = /\d\d/,
        K = /\d{3}/,
        Y = /\d{4}/,
        Q = /[+-]?\d{6}/,
        Z = /\d\d?/,
        X = /\d\d\d\d?/,
        J = /\d\d\d\d\d\d?/,
        ee = /\d{1,3}/,
        te = /\d{1,4}/,
        ne = /[+-]?\d{1,6}/,
        re = /\d+/,
        ie = /[+-]?\d+/,
        oe = /Z|[+-]\d\d:?\d\d/gi,
        se = /Z|[+-]\d\d(?::?\d\d)?/gi,
        ae = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,
        le = {};

      function ce(e, t, n) {
        le[e] = _(t) ? t : function (e, r) {
          return e && n ? n : t
        }
      }

      function ue(e, t) {
        return u(le, e) ? le[e](t._strict, t._locale) : new RegExp(he(e.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, (function (e, t, n, r, i) {
          return t || n || r || i
        }))))
      }

      function he(e) {
        return e.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&")
      }
      var pe = {};

      function de(e, t) {
        var n, r = t;
        for ("string" == typeof e && (e = [e]), a(t) && (r = function (e, n) {
            n[t] = C(e)
          }), n = 0; n < e.length; n++) pe[e[n]] = r
      }

      function fe(e, t) {
        de(e, (function (e, n, r, i) {
          r._w = r._w || {}, t(e, r._w, r, i)
        }))
      }

      function me(e, t, n) {
        null != t && u(pe, e) && pe[e](t, n._a, n, e)
      }

      function ge(e) {
        return ye(e) ? 366 : 365
      }

      function ye(e) {
        return e % 4 == 0 && e % 100 != 0 || e % 400 == 0
      }
      V("Y", 0, 0, (function () {
        var e = this.year();
        return e <= 9999 ? "" + e : "+" + e
      })), V(0, ["YY", 2], 0, (function () {
        return this.year() % 100
      })), V(0, ["YYYY", 4], 0, "year"), V(0, ["YYYYY", 5], 0, "year"), V(0, ["YYYYYY", 6, !0], 0, "year"), I("year", "y"), F("year", 1), ce("Y", ie), ce("YY", Z, q), ce("YYYY", te, Y), ce("YYYYY", ne, Q), ce("YYYYYY", ne, Q), de(["YYYYY", "YYYYYY"], 0), de("YYYY", (function (e, t) {
        t[0] = 2 === e.length ? r.parseTwoDigitYear(e) : C(e)
      })), de("YY", (function (e, t) {
        t[0] = r.parseTwoDigitYear(e)
      })), de("Y", (function (e, t) {
        t[0] = parseInt(e, 10)
      })), r.parseTwoDigitYear = function (e) {
        return C(e) + (C(e) > 68 ? 1900 : 2e3)
      };
      var ve, we = be("FullYear", !0);

      function be(e, t) {
        return function (n) {
          return null != n ? (Ce(this, e, n), r.updateOffset(this, t), this) : Se(this, e)
        }
      }

      function Se(e, t) {
        return e.isValid() ? e._d["get" + (e._isUTC ? "UTC" : "") + t]() : NaN
      }

      function Ce(e, t, n) {
        e.isValid() && !isNaN(n) && ("FullYear" === t && ye(e.year()) && 1 === e.month() && 29 === e.date() ? e._d["set" + (e._isUTC ? "UTC" : "") + t](n, e.month(), Ee(n, e.month())) : e._d["set" + (e._isUTC ? "UTC" : "") + t](n))
      }

      function Ee(e, t) {
        if (isNaN(e) || isNaN(t)) return NaN;
        var n, r = (t % (n = 12) + n) % n;
        return e += (t - r) / 12, 1 === r ? ye(e) ? 29 : 28 : 31 - r % 7 % 2
      }
      ve = Array.prototype.indexOf ? Array.prototype.indexOf : function (e) {
        var t;
        for (t = 0; t < this.length; ++t)
          if (this[t] === e) return t;
        return -1
      }, V("M", ["MM", 2], "Mo", (function () {
        return this.month() + 1
      })), V("MMM", 0, 0, (function (e) {
        return this.localeData().monthsShort(this, e)
      })), V("MMMM", 0, 0, (function (e) {
        return this.localeData().months(this, e)
      })), I("month", "M"), F("month", 8), ce("M", Z), ce("MM", Z, q), ce("MMM", (function (e, t) {
        return t.monthsShortRegex(e)
      })), ce("MMMM", (function (e, t) {
        return t.monthsRegex(e)
      })), de(["M", "MM"], (function (e, t) {
        t[1] = C(e) - 1
      })), de(["MMM", "MMMM"], (function (e, t, n, r) {
        var i = n._locale.monthsParse(e, r, n._strict);
        null != i ? t[1] = i : d(n).invalidMonth = e
      }));
      var ke = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
        xe = "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        Te = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_");

      function Re(e, t, n) {
        var r, i, o, s = e.toLocaleLowerCase();
        if (!this._monthsParse)
          for (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = [], r = 0; r < 12; ++r) o = p([2e3, r]), this._shortMonthsParse[r] = this.monthsShort(o, "").toLocaleLowerCase(), this._longMonthsParse[r] = this.months(o, "").toLocaleLowerCase();
        return n ? "MMM" === t ? -1 !== (i = ve.call(this._shortMonthsParse, s)) ? i : null : -1 !== (i = ve.call(this._longMonthsParse, s)) ? i : null : "MMM" === t ? -1 !== (i = ve.call(this._shortMonthsParse, s)) || -1 !== (i = ve.call(this._longMonthsParse, s)) ? i : null : -1 !== (i = ve.call(this._longMonthsParse, s)) || -1 !== (i = ve.call(this._shortMonthsParse, s)) ? i : null
      }

      function De(e, t) {
        var n;
        if (!e.isValid()) return e;
        if ("string" == typeof t)
          if (/^\d+$/.test(t)) t = C(t);
          else if (!a(t = e.localeData().monthsParse(t))) return e;
        return n = Math.min(e.date(), Ee(e.year(), t)), e._d["set" + (e._isUTC ? "UTC" : "") + "Month"](t, n), e
      }

      function _e(e) {
        return null != e ? (De(this, e), r.updateOffset(this, !0), this) : Se(this, "Month")
      }
      var Ae = ae,
        Me = ae;

      function Pe() {
        function e(e, t) {
          return t.length - e.length
        }
        var t, n, r = [],
          i = [],
          o = [];
        for (t = 0; t < 12; t++) n = p([2e3, t]), r.push(this.monthsShort(n, "")), i.push(this.months(n, "")), o.push(this.months(n, "")), o.push(this.monthsShort(n, ""));
        for (r.sort(e), i.sort(e), o.sort(e), t = 0; t < 12; t++) r[t] = he(r[t]), i[t] = he(i[t]);
        for (t = 0; t < 24; t++) o[t] = he(o[t]);
        this._monthsRegex = new RegExp("^(" + o.join("|") + ")", "i"), this._monthsShortRegex = this._monthsRegex, this._monthsStrictRegex = new RegExp("^(" + i.join("|") + ")", "i"), this._monthsShortStrictRegex = new RegExp("^(" + r.join("|") + ")", "i")
      }

      function Ie(e, t, n, r, i, o, s) {
        var a;
        return e < 100 && e >= 0 ? (a = new Date(e + 400, t, n, r, i, o, s), isFinite(a.getFullYear()) && a.setFullYear(e)) : a = new Date(e, t, n, r, i, o, s), a
      }

      function Oe(e) {
        var t;
        if (e < 100 && e >= 0) {
          var n = Array.prototype.slice.call(arguments);
          n[0] = e + 400, t = new Date(Date.UTC.apply(null, n)), isFinite(t.getUTCFullYear()) && t.setUTCFullYear(e)
        } else t = new Date(Date.UTC.apply(null, arguments));
        return t
      }

      function Le(e, t, n) {
        var r = 7 + t - n;
        return -(7 + Oe(e, 0, r).getUTCDay() - t) % 7 + r - 1
      }

      function Ne(e, t, n, r, i) {
        var o, s, a = 1 + 7 * (t - 1) + (7 + n - r) % 7 + Le(e, r, i);
        return a <= 0 ? s = ge(o = e - 1) + a : a > ge(e) ? (o = e + 1, s = a - ge(e)) : (o = e, s = a), {
          year: o,
          dayOfYear: s
        }
      }

      function Fe(e, t, n) {
        var r, i, o = Le(e.year(), t, n),
          s = Math.floor((e.dayOfYear() - o - 1) / 7) + 1;
        return s < 1 ? r = s + Be(i = e.year() - 1, t, n) : s > Be(e.year(), t, n) ? (r = s - Be(e.year(), t, n), i = e.year() + 1) : (i = e.year(), r = s), {
          week: r,
          year: i
        }
      }

      function Be(e, t, n) {
        var r = Le(e, t, n),
          i = Le(e + 1, t, n);
        return (ge(e) - r + i) / 7
      }

      function He(e, t) {
        return e.slice(t, 7).concat(e.slice(0, t))
      }
      V("w", ["ww", 2], "wo", "week"), V("W", ["WW", 2], "Wo", "isoWeek"), I("week", "w"), I("isoWeek", "W"), F("week", 5), F("isoWeek", 5), ce("w", Z), ce("ww", Z, q), ce("W", Z), ce("WW", Z, q), fe(["w", "ww", "W", "WW"], (function (e, t, n, r) {
        t[r.substr(0, 1)] = C(e)
      })), V("d", 0, "do", "day"), V("dd", 0, 0, (function (e) {
        return this.localeData().weekdaysMin(this, e)
      })), V("ddd", 0, 0, (function (e) {
        return this.localeData().weekdaysShort(this, e)
      })), V("dddd", 0, 0, (function (e) {
        return this.localeData().weekdays(this, e)
      })), V("e", 0, 0, "weekday"), V("E", 0, 0, "isoWeekday"), I("day", "d"), I("weekday", "e"), I("isoWeekday", "E"), F("day", 11), F("weekday", 11), F("isoWeekday", 11), ce("d", Z), ce("e", Z), ce("E", Z), ce("dd", (function (e, t) {
        return t.weekdaysMinRegex(e)
      })), ce("ddd", (function (e, t) {
        return t.weekdaysShortRegex(e)
      })), ce("dddd", (function (e, t) {
        return t.weekdaysRegex(e)
      })), fe(["dd", "ddd", "dddd"], (function (e, t, n, r) {
        var i = n._locale.weekdaysParse(e, r, n._strict);
        null != i ? t.d = i : d(n).invalidWeekday = e
      })), fe(["d", "e", "E"], (function (e, t, n, r) {
        t[r] = C(e)
      }));
      var ze = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        Ue = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        We = "Su_Mo_Tu_We_Th_Fr_Sa".split("_");

      function Ve(e, t, n) {
        var r, i, o, s = e.toLocaleLowerCase();
        if (!this._weekdaysParse)
          for (this._weekdaysParse = [], this._shortWeekdaysParse = [], this._minWeekdaysParse = [], r = 0; r < 7; ++r) o = p([2e3, 1]).day(r), this._minWeekdaysParse[r] = this.weekdaysMin(o, "").toLocaleLowerCase(), this._shortWeekdaysParse[r] = this.weekdaysShort(o, "").toLocaleLowerCase(), this._weekdaysParse[r] = this.weekdays(o, "").toLocaleLowerCase();
        return n ? "dddd" === t ? -1 !== (i = ve.call(this._weekdaysParse, s)) ? i : null : "ddd" === t ? -1 !== (i = ve.call(this._shortWeekdaysParse, s)) ? i : null : -1 !== (i = ve.call(this._minWeekdaysParse, s)) ? i : null : "dddd" === t ? -1 !== (i = ve.call(this._weekdaysParse, s)) || -1 !== (i = ve.call(this._shortWeekdaysParse, s)) || -1 !== (i = ve.call(this._minWeekdaysParse, s)) ? i : null : "ddd" === t ? -1 !== (i = ve.call(this._shortWeekdaysParse, s)) || -1 !== (i = ve.call(this._weekdaysParse, s)) || -1 !== (i = ve.call(this._minWeekdaysParse, s)) ? i : null : -1 !== (i = ve.call(this._minWeekdaysParse, s)) || -1 !== (i = ve.call(this._weekdaysParse, s)) || -1 !== (i = ve.call(this._shortWeekdaysParse, s)) ? i : null
      }
      var je = ae,
        Ge = ae,
        $e = ae;

      function qe() {
        function e(e, t) {
          return t.length - e.length
        }
        var t, n, r, i, o, s = [],
          a = [],
          l = [],
          c = [];
        for (t = 0; t < 7; t++) n = p([2e3, 1]).day(t), r = this.weekdaysMin(n, ""), i = this.weekdaysShort(n, ""), o = this.weekdays(n, ""), s.push(r), a.push(i), l.push(o), c.push(r), c.push(i), c.push(o);
        for (s.sort(e), a.sort(e), l.sort(e), c.sort(e), t = 0; t < 7; t++) a[t] = he(a[t]), l[t] = he(l[t]), c[t] = he(c[t]);
        this._weekdaysRegex = new RegExp("^(" + c.join("|") + ")", "i"), this._weekdaysShortRegex = this._weekdaysRegex, this._weekdaysMinRegex = this._weekdaysRegex, this._weekdaysStrictRegex = new RegExp("^(" + l.join("|") + ")", "i"), this._weekdaysShortStrictRegex = new RegExp("^(" + a.join("|") + ")", "i"), this._weekdaysMinStrictRegex = new RegExp("^(" + s.join("|") + ")", "i")
      }

      function Ke() {
        return this.hours() % 12 || 12
      }

      function Ye(e, t) {
        V(e, 0, 0, (function () {
          return this.localeData().meridiem(this.hours(), this.minutes(), t)
        }))
      }

      function Qe(e, t) {
        return t._meridiemParse
      }
      V("H", ["HH", 2], 0, "hour"), V("h", ["hh", 2], 0, Ke), V("k", ["kk", 2], 0, (function () {
        return this.hours() || 24
      })), V("hmm", 0, 0, (function () {
        return "" + Ke.apply(this) + B(this.minutes(), 2)
      })), V("hmmss", 0, 0, (function () {
        return "" + Ke.apply(this) + B(this.minutes(), 2) + B(this.seconds(), 2)
      })), V("Hmm", 0, 0, (function () {
        return "" + this.hours() + B(this.minutes(), 2)
      })), V("Hmmss", 0, 0, (function () {
        return "" + this.hours() + B(this.minutes(), 2) + B(this.seconds(), 2)
      })), Ye("a", !0), Ye("A", !1), I("hour", "h"), F("hour", 13), ce("a", Qe), ce("A", Qe), ce("H", Z), ce("h", Z), ce("k", Z), ce("HH", Z, q), ce("hh", Z, q), ce("kk", Z, q), ce("hmm", X), ce("hmmss", J), ce("Hmm", X), ce("Hmmss", J), de(["H", "HH"], 3), de(["k", "kk"], (function (e, t, n) {
        var r = C(e);
        t[3] = 24 === r ? 0 : r
      })), de(["a", "A"], (function (e, t, n) {
        n._isPm = n._locale.isPM(e), n._meridiem = e
      })), de(["h", "hh"], (function (e, t, n) {
        t[3] = C(e), d(n).bigHour = !0
      })), de("hmm", (function (e, t, n) {
        var r = e.length - 2;
        t[3] = C(e.substr(0, r)), t[4] = C(e.substr(r)), d(n).bigHour = !0
      })), de("hmmss", (function (e, t, n) {
        var r = e.length - 4,
          i = e.length - 2;
        t[3] = C(e.substr(0, r)), t[4] = C(e.substr(r, 2)), t[5] = C(e.substr(i)), d(n).bigHour = !0
      })), de("Hmm", (function (e, t, n) {
        var r = e.length - 2;
        t[3] = C(e.substr(0, r)), t[4] = C(e.substr(r))
      })), de("Hmmss", (function (e, t, n) {
        var r = e.length - 4,
          i = e.length - 2;
        t[3] = C(e.substr(0, r)), t[4] = C(e.substr(r, 2)), t[5] = C(e.substr(i))
      }));
      var Ze, Xe = be("Hours", !0),
        Je = {
          calendar: {
            sameDay: "[Today at] LT",
            nextDay: "[Tomorrow at] LT",
            nextWeek: "dddd [at] LT",
            lastDay: "[Yesterday at] LT",
            lastWeek: "[Last] dddd [at] LT",
            sameElse: "L"
          },
          longDateFormat: {
            LTS: "h:mm:ss A",
            LT: "h:mm A",
            L: "MM/DD/YYYY",
            LL: "MMMM D, YYYY",
            LLL: "MMMM D, YYYY h:mm A",
            LLLL: "dddd, MMMM D, YYYY h:mm A"
          },
          invalidDate: "Invalid date",
          ordinal: "%d",
          dayOfMonthOrdinalParse: /\d{1,2}/,
          relativeTime: {
            future: "in %s",
            past: "%s ago",
            s: "a few seconds",
            ss: "%d seconds",
            m: "a minute",
            mm: "%d minutes",
            h: "an hour",
            hh: "%d hours",
            d: "a day",
            dd: "%d days",
            M: "a month",
            MM: "%d months",
            y: "a year",
            yy: "%d years"
          },
          months: xe,
          monthsShort: Te,
          week: {
            dow: 0,
            doy: 6
          },
          weekdays: ze,
          weekdaysMin: We,
          weekdaysShort: Ue,
          meridiemParse: /[ap]\.?m?\.?/i
        },
        et = {},
        tt = {};

      function nt(e) {
        return e ? e.toLowerCase().replace("_", "-") : e
      }

      function rt(t) {
        var n = null;
        if (!et[t] && void 0 !== e && e && e.exports) try {
          n = Ze._abbr, ! function () {
            var e = new Error("Cannot find module 'undefined'");
            throw e.code = "MODULE_NOT_FOUND", e
          }(), it(n)
        } catch (e) {}
        return et[t]
      }

      function it(e, t) {
        var n;
        return e && ((n = s(t) ? st(e) : ot(e, t)) ? Ze = n : "undefined" != typeof console && console.warn && console.warn("Locale " + e + " not found. Did you forget to load it?")), Ze._abbr
      }

      function ot(e, t) {
        if (null !== t) {
          var n, r = Je;
          if (t.abbr = e, null != et[e]) D("defineLocaleOverride", "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."), r = et[e]._config;
          else if (null != t.parentLocale)
            if (null != et[t.parentLocale]) r = et[t.parentLocale]._config;
            else {
              if (null == (n = rt(t.parentLocale))) return tt[t.parentLocale] || (tt[t.parentLocale] = []), tt[t.parentLocale].push({
                name: e,
                config: t
              }), null;
              r = n._config
            } return et[e] = new M(A(r, t)), tt[e] && tt[e].forEach((function (e) {
            ot(e.name, e.config)
          })), it(e), et[e]
        }
        return delete et[e], null
      }

      function st(e) {
        var t;
        if (e && e._locale && e._locale._abbr && (e = e._locale._abbr), !e) return Ze;
        if (!i(e)) {
          if (t = rt(e)) return t;
          e = [e]
        }
        return function (e) {
          for (var t, n, r, i, o = 0; o < e.length;) {
            for (t = (i = nt(e[o]).split("-")).length, n = (n = nt(e[o + 1])) ? n.split("-") : null; t > 0;) {
              if (r = rt(i.slice(0, t).join("-"))) return r;
              if (n && n.length >= t && E(i, n, !0) >= t - 1) break;
              t--
            }
            o++
          }
          return Ze
        }(e)
      }

      function at(e) {
        var t, n = e._a;
        return n && -2 === d(e).overflow && (t = n[1] < 0 || n[1] > 11 ? 1 : n[2] < 1 || n[2] > Ee(n[0], n[1]) ? 2 : n[3] < 0 || n[3] > 24 || 24 === n[3] && (0 !== n[4] || 0 !== n[5] || 0 !== n[6]) ? 3 : n[4] < 0 || n[4] > 59 ? 4 : n[5] < 0 || n[5] > 59 ? 5 : n[6] < 0 || n[6] > 999 ? 6 : -1, d(e)._overflowDayOfYear && (t < 0 || t > 2) && (t = 2), d(e)._overflowWeeks && -1 === t && (t = 7), d(e)._overflowWeekday && -1 === t && (t = 8), d(e).overflow = t), e
      }

      function lt(e, t, n) {
        return null != e ? e : null != t ? t : n
      }

      function ct(e) {
        var t, n, i, o, s, a = [];
        if (!e._d) {
          for (i = function (e) {
              var t = new Date(r.now());
              return e._useUTC ? [t.getUTCFullYear(), t.getUTCMonth(), t.getUTCDate()] : [t.getFullYear(), t.getMonth(), t.getDate()]
            }(e), e._w && null == e._a[2] && null == e._a[1] && function (e) {
              var t, n, r, i, o, s, a, l;
              if (null != (t = e._w).GG || null != t.W || null != t.E) o = 1, s = 4, n = lt(t.GG, e._a[0], Fe(kt(), 1, 4).year), r = lt(t.W, 1), ((i = lt(t.E, 1)) < 1 || i > 7) && (l = !0);
              else {
                o = e._locale._week.dow, s = e._locale._week.doy;
                var c = Fe(kt(), o, s);
                n = lt(t.gg, e._a[0], c.year), r = lt(t.w, c.week), null != t.d ? ((i = t.d) < 0 || i > 6) && (l = !0) : null != t.e ? (i = t.e + o, (t.e < 0 || t.e > 6) && (l = !0)) : i = o
              }
              r < 1 || r > Be(n, o, s) ? d(e)._overflowWeeks = !0 : null != l ? d(e)._overflowWeekday = !0 : (a = Ne(n, r, i, o, s), e._a[0] = a.year, e._dayOfYear = a.dayOfYear)
            }(e), null != e._dayOfYear && (s = lt(e._a[0], i[0]), (e._dayOfYear > ge(s) || 0 === e._dayOfYear) && (d(e)._overflowDayOfYear = !0), n = Oe(s, 0, e._dayOfYear), e._a[1] = n.getUTCMonth(), e._a[2] = n.getUTCDate()), t = 0; t < 3 && null == e._a[t]; ++t) e._a[t] = a[t] = i[t];
          for (; t < 7; t++) e._a[t] = a[t] = null == e._a[t] ? 2 === t ? 1 : 0 : e._a[t];
          24 === e._a[3] && 0 === e._a[4] && 0 === e._a[5] && 0 === e._a[6] && (e._nextDay = !0, e._a[3] = 0), e._d = (e._useUTC ? Oe : Ie).apply(null, a), o = e._useUTC ? e._d.getUTCDay() : e._d.getDay(), null != e._tzm && e._d.setUTCMinutes(e._d.getUTCMinutes() - e._tzm), e._nextDay && (e._a[3] = 24), e._w && void 0 !== e._w.d && e._w.d !== o && (d(e).weekdayMismatch = !0)
        }
      }
      var ut = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
        ht = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
        pt = /Z|[+-]\d\d(?::?\d\d)?/,
        dt = [
          ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
          ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
          ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
          ["GGGG-[W]WW", /\d{4}-W\d\d/, !1],
          ["YYYY-DDD", /\d{4}-\d{3}/],
          ["YYYY-MM", /\d{4}-\d\d/, !1],
          ["YYYYYYMMDD", /[+-]\d{10}/],
          ["YYYYMMDD", /\d{8}/],
          ["GGGG[W]WWE", /\d{4}W\d{3}/],
          ["GGGG[W]WW", /\d{4}W\d{2}/, !1],
          ["YYYYDDD", /\d{7}/]
        ],
        ft = [
          ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
          ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
          ["HH:mm:ss", /\d\d:\d\d:\d\d/],
          ["HH:mm", /\d\d:\d\d/],
          ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
          ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
          ["HHmmss", /\d\d\d\d\d\d/],
          ["HHmm", /\d\d\d\d/],
          ["HH", /\d\d/]
        ],
        mt = /^\/?Date\((\-?\d+)/i;

      function gt(e) {
        var t, n, r, i, o, s, a = e._i,
          l = ut.exec(a) || ht.exec(a);
        if (l) {
          for (d(e).iso = !0, t = 0, n = dt.length; t < n; t++)
            if (dt[t][1].exec(l[1])) {
              i = dt[t][0], r = !1 !== dt[t][2];
              break
            } if (null == i) return void(e._isValid = !1);
          if (l[3]) {
            for (t = 0, n = ft.length; t < n; t++)
              if (ft[t][1].exec(l[3])) {
                o = (l[2] || " ") + ft[t][0];
                break
              } if (null == o) return void(e._isValid = !1)
          }
          if (!r && null != o) return void(e._isValid = !1);
          if (l[4]) {
            if (!pt.exec(l[4])) return void(e._isValid = !1);
            s = "Z"
          }
          e._f = i + (o || "") + (s || ""), St(e)
        } else e._isValid = !1
      }
      var yt = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

      function vt(e) {
        var t = parseInt(e, 10);
        return t <= 49 ? 2e3 + t : t <= 999 ? 1900 + t : t
      }
      var wt = {
        UT: 0,
        GMT: 0,
        EDT: -240,
        EST: -300,
        CDT: -300,
        CST: -360,
        MDT: -360,
        MST: -420,
        PDT: -420,
        PST: -480
      };

      function bt(e) {
        var t, n, r, i, o, s, a, l = yt.exec(e._i.replace(/\([^)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, ""));
        if (l) {
          var c = (t = l[4], n = l[3], r = l[2], i = l[5], o = l[6], s = l[7], a = [vt(t), Te.indexOf(n), parseInt(r, 10), parseInt(i, 10), parseInt(o, 10)], s && a.push(parseInt(s, 10)), a);
          if (! function (e, t, n) {
              return !e || Ue.indexOf(e) === new Date(t[0], t[1], t[2]).getDay() || (d(n).weekdayMismatch = !0, n._isValid = !1, !1)
            }(l[1], c, e)) return;
          e._a = c, e._tzm = function (e, t, n) {
            if (e) return wt[e];
            if (t) return 0;
            var r = parseInt(n, 10),
              i = r % 100;
            return (r - i) / 100 * 60 + i
          }(l[8], l[9], l[10]), e._d = Oe.apply(null, e._a), e._d.setUTCMinutes(e._d.getUTCMinutes() - e._tzm), d(e).rfc2822 = !0
        } else e._isValid = !1
      }

      function St(e) {
        if (e._f !== r.ISO_8601)
          if (e._f !== r.RFC_2822) {
            e._a = [], d(e).empty = !0;
            var t, n, i, o, s, a = "" + e._i,
              l = a.length,
              c = 0;
            for (i = G(e._f, e._locale).match(H) || [], t = 0; t < i.length; t++) o = i[t], (n = (a.match(ue(o, e)) || [])[0]) && ((s = a.substr(0, a.indexOf(n))).length > 0 && d(e).unusedInput.push(s), a = a.slice(a.indexOf(n) + n.length), c += n.length), W[o] ? (n ? d(e).empty = !1 : d(e).unusedTokens.push(o), me(o, n, e)) : e._strict && !n && d(e).unusedTokens.push(o);
            d(e).charsLeftOver = l - c, a.length > 0 && d(e).unusedInput.push(a), e._a[3] <= 12 && !0 === d(e).bigHour && e._a[3] > 0 && (d(e).bigHour = void 0), d(e).parsedDateParts = e._a.slice(0), d(e).meridiem = e._meridiem, e._a[3] = function (e, t, n) {
              var r;
              return null == n ? t : null != e.meridiemHour ? e.meridiemHour(t, n) : null != e.isPM ? ((r = e.isPM(n)) && t < 12 && (t += 12), r || 12 !== t || (t = 0), t) : t
            }(e._locale, e._a[3], e._meridiem), ct(e), at(e)
          } else bt(e);
        else gt(e)
      }

      function Ct(e) {
        var t = e._i,
          n = e._f;
        return e._locale = e._locale || st(e._l), null === t || void 0 === n && "" === t ? m({
          nullInput: !0
        }) : ("string" == typeof t && (e._i = t = e._locale.preparse(t)), b(t) ? new w(at(t)) : (l(t) ? e._d = t : i(n) ? function (e) {
          var t, n, r, i, o;
          if (0 === e._f.length) return d(e).invalidFormat = !0, void(e._d = new Date(NaN));
          for (i = 0; i < e._f.length; i++) o = 0, t = y({}, e), null != e._useUTC && (t._useUTC = e._useUTC), t._f = e._f[i], St(t), f(t) && (o += d(t).charsLeftOver, o += 10 * d(t).unusedTokens.length, d(t).score = o, (null == r || o < r) && (r = o, n = t));
          h(e, n || t)
        }(e) : n ? St(e) : function (e) {
          var t = e._i;
          s(t) ? e._d = new Date(r.now()) : l(t) ? e._d = new Date(t.valueOf()) : "string" == typeof t ? function (e) {
            var t = mt.exec(e._i);
            null === t ? (gt(e), !1 === e._isValid && (delete e._isValid, bt(e), !1 === e._isValid && (delete e._isValid, r.createFromInputFallback(e)))) : e._d = new Date(+t[1])
          }(e) : i(t) ? (e._a = c(t.slice(0), (function (e) {
            return parseInt(e, 10)
          })), ct(e)) : o(t) ? function (e) {
            if (!e._d) {
              var t = L(e._i);
              e._a = c([t.year, t.month, t.day || t.date, t.hour, t.minute, t.second, t.millisecond], (function (e) {
                return e && parseInt(e, 10)
              })), ct(e)
            }
          }(e) : a(t) ? e._d = new Date(t) : r.createFromInputFallback(e)
        }(e), f(e) || (e._d = null), e))
      }

      function Et(e, t, n, r, s) {
        var a, l = {};
        return !0 !== n && !1 !== n || (r = n, n = void 0), (o(e) && function (e) {
          if (Object.getOwnPropertyNames) return 0 === Object.getOwnPropertyNames(e).length;
          var t;
          for (t in e)
            if (e.hasOwnProperty(t)) return !1;
          return !0
        }(e) || i(e) && 0 === e.length) && (e = void 0), l._isAMomentObject = !0, l._useUTC = l._isUTC = s, l._l = n, l._i = e, l._f = t, l._strict = r, (a = new w(at(Ct(l))))._nextDay && (a.add(1, "d"), a._nextDay = void 0), a
      }

      function kt(e, t, n, r) {
        return Et(e, t, n, r, !1)
      }
      r.createFromInputFallback = x("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged and will be removed in an upcoming major release. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.", (function (e) {
        e._d = new Date(e._i + (e._useUTC ? " UTC" : ""))
      })), r.ISO_8601 = function () {}, r.RFC_2822 = function () {};
      var xt = x("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", (function () {
          var e = kt.apply(null, arguments);
          return this.isValid() && e.isValid() ? e < this ? this : e : m()
        })),
        Tt = x("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", (function () {
          var e = kt.apply(null, arguments);
          return this.isValid() && e.isValid() ? e > this ? this : e : m()
        }));

      function Rt(e, t) {
        var n, r;
        if (1 === t.length && i(t[0]) && (t = t[0]), !t.length) return kt();
        for (n = t[0], r = 1; r < t.length; ++r) t[r].isValid() && !t[r][e](n) || (n = t[r]);
        return n
      }
      var Dt = ["year", "quarter", "month", "week", "day", "hour", "minute", "second", "millisecond"];

      function _t(e) {
        var t = L(e),
          n = t.year || 0,
          r = t.quarter || 0,
          i = t.month || 0,
          o = t.week || t.isoWeek || 0,
          s = t.day || 0,
          a = t.hour || 0,
          l = t.minute || 0,
          c = t.second || 0,
          u = t.millisecond || 0;
        this._isValid = function (e) {
          for (var t in e)
            if (-1 === ve.call(Dt, t) || null != e[t] && isNaN(e[t])) return !1;
          for (var n = !1, r = 0; r < Dt.length; ++r)
            if (e[Dt[r]]) {
              if (n) return !1;
              parseFloat(e[Dt[r]]) !== C(e[Dt[r]]) && (n = !0)
            } return !0
        }(t), this._milliseconds = +u + 1e3 * c + 6e4 * l + 1e3 * a * 60 * 60, this._days = +s + 7 * o, this._months = +i + 3 * r + 12 * n, this._data = {}, this._locale = st(), this._bubble()
      }

      function At(e) {
        return e instanceof _t
      }

      function Mt(e) {
        return e < 0 ? -1 * Math.round(-1 * e) : Math.round(e)
      }

      function Pt(e, t) {
        V(e, 0, 0, (function () {
          var e = this.utcOffset(),
            n = "+";
          return e < 0 && (e = -e, n = "-"), n + B(~~(e / 60), 2) + t + B(~~e % 60, 2)
        }))
      }
      Pt("Z", ":"), Pt("ZZ", ""), ce("Z", se), ce("ZZ", se), de(["Z", "ZZ"], (function (e, t, n) {
        n._useUTC = !0, n._tzm = Ot(se, e)
      }));
      var It = /([\+\-]|\d\d)/gi;

      function Ot(e, t) {
        var n = (t || "").match(e);
        if (null === n) return null;
        var r = ((n[n.length - 1] || []) + "").match(It) || ["-", 0, 0],
          i = 60 * r[1] + C(r[2]);
        return 0 === i ? 0 : "+" === r[0] ? i : -i
      }

      function Lt(e, t) {
        var n, i;
        return t._isUTC ? (n = t.clone(), i = (b(e) || l(e) ? e.valueOf() : kt(e).valueOf()) - n.valueOf(), n._d.setTime(n._d.valueOf() + i), r.updateOffset(n, !1), n) : kt(e).local()
      }

      function Nt(e) {
        return 15 * -Math.round(e._d.getTimezoneOffset() / 15)
      }

      function Ft() {
        return !!this.isValid() && this._isUTC && 0 === this._offset
      }
      r.updateOffset = function () {};
      var Bt = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/,
        Ht = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

      function zt(e, t) {
        var n, r, i, o, s, l, c = e,
          h = null;
        return At(e) ? c = {
          ms: e._milliseconds,
          d: e._days,
          M: e._months
        } : a(e) ? (c = {}, t ? c[t] = e : c.milliseconds = e) : (h = Bt.exec(e)) ? (n = "-" === h[1] ? -1 : 1, c = {
          y: 0,
          d: C(h[2]) * n,
          h: C(h[3]) * n,
          m: C(h[4]) * n,
          s: C(h[5]) * n,
          ms: C(Mt(1e3 * h[6])) * n
        }) : (h = Ht.exec(e)) ? (n = "-" === h[1] ? -1 : 1, c = {
          y: Ut(h[2], n),
          M: Ut(h[3], n),
          w: Ut(h[4], n),
          d: Ut(h[5], n),
          h: Ut(h[6], n),
          m: Ut(h[7], n),
          s: Ut(h[8], n)
        }) : null == c ? c = {} : "object" == typeof c && ("from" in c || "to" in c) && (o = kt(c.from), s = kt(c.to), i = o.isValid() && s.isValid() ? (s = Lt(s, o), o.isBefore(s) ? l = Wt(o, s) : ((l = Wt(s, o)).milliseconds = -l.milliseconds, l.months = -l.months), l) : {
          milliseconds: 0,
          months: 0
        }, (c = {}).ms = i.milliseconds, c.M = i.months), r = new _t(c), At(e) && u(e, "_locale") && (r._locale = e._locale), r
      }

      function Ut(e, t) {
        var n = e && parseFloat(e.replace(",", "."));
        return (isNaN(n) ? 0 : n) * t
      }

      function Wt(e, t) {
        var n = {};
        return n.months = t.month() - e.month() + 12 * (t.year() - e.year()), e.clone().add(n.months, "M").isAfter(t) && --n.months, n.milliseconds = +t - +e.clone().add(n.months, "M"), n
      }

      function Vt(e, t) {
        return function (n, r) {
          var i;
          return null === r || isNaN(+r) || (D(t, "moment()." + t + "(period, number) is deprecated. Please use moment()." + t + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."), i = n, n = r, r = i), jt(this, zt(n = "string" == typeof n ? +n : n, r), e), this
        }
      }

      function jt(e, t, n, i) {
        var o = t._milliseconds,
          s = Mt(t._days),
          a = Mt(t._months);
        e.isValid() && (i = null == i || i, a && De(e, Se(e, "Month") + a * n), s && Ce(e, "Date", Se(e, "Date") + s * n), o && e._d.setTime(e._d.valueOf() + o * n), i && r.updateOffset(e, s || a))
      }
      zt.fn = _t.prototype, zt.invalid = function () {
        return zt(NaN)
      };
      var Gt = Vt(1, "add"),
        $t = Vt(-1, "subtract");

      function qt(e, t) {
        var n = 12 * (t.year() - e.year()) + (t.month() - e.month()),
          r = e.clone().add(n, "months");
        return -(n + (t - r < 0 ? (t - r) / (r - e.clone().add(n - 1, "months")) : (t - r) / (e.clone().add(n + 1, "months") - r))) || 0
      }

      function Kt(e) {
        var t;
        return void 0 === e ? this._locale._abbr : (null != (t = st(e)) && (this._locale = t), this)
      }
      r.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ", r.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
      var Yt = x("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", (function (e) {
        return void 0 === e ? this.localeData() : this.locale(e)
      }));

      function Qt() {
        return this._locale
      }

      function Zt(e, t) {
        return (e % t + t) % t
      }

      function Xt(e, t, n) {
        return e < 100 && e >= 0 ? new Date(e + 400, t, n) - 126227808e5 : new Date(e, t, n).valueOf()
      }

      function Jt(e, t, n) {
        return e < 100 && e >= 0 ? Date.UTC(e + 400, t, n) - 126227808e5 : Date.UTC(e, t, n)
      }

      function en(e, t) {
        V(0, [e, e.length], 0, t)
      }

      function tn(e, t, n, r, i) {
        var o;
        return null == e ? Fe(this, r, i).year : (t > (o = Be(e, r, i)) && (t = o), nn.call(this, e, t, n, r, i))
      }

      function nn(e, t, n, r, i) {
        var o = Ne(e, t, n, r, i),
          s = Oe(o.year, 0, o.dayOfYear);
        return this.year(s.getUTCFullYear()), this.month(s.getUTCMonth()), this.date(s.getUTCDate()), this
      }
      V(0, ["gg", 2], 0, (function () {
        return this.weekYear() % 100
      })), V(0, ["GG", 2], 0, (function () {
        return this.isoWeekYear() % 100
      })), en("gggg", "weekYear"), en("ggggg", "weekYear"), en("GGGG", "isoWeekYear"), en("GGGGG", "isoWeekYear"), I("weekYear", "gg"), I("isoWeekYear", "GG"), F("weekYear", 1), F("isoWeekYear", 1), ce("G", ie), ce("g", ie), ce("GG", Z, q), ce("gg", Z, q), ce("GGGG", te, Y), ce("gggg", te, Y), ce("GGGGG", ne, Q), ce("ggggg", ne, Q), fe(["gggg", "ggggg", "GGGG", "GGGGG"], (function (e, t, n, r) {
        t[r.substr(0, 2)] = C(e)
      })), fe(["gg", "GG"], (function (e, t, n, i) {
        t[i] = r.parseTwoDigitYear(e)
      })), V("Q", 0, "Qo", "quarter"), I("quarter", "Q"), F("quarter", 7), ce("Q", $), de("Q", (function (e, t) {
        t[1] = 3 * (C(e) - 1)
      })), V("D", ["DD", 2], "Do", "date"), I("date", "D"), F("date", 9), ce("D", Z), ce("DD", Z, q), ce("Do", (function (e, t) {
        return e ? t._dayOfMonthOrdinalParse || t._ordinalParse : t._dayOfMonthOrdinalParseLenient
      })), de(["D", "DD"], 2), de("Do", (function (e, t) {
        t[2] = C(e.match(Z)[0])
      }));
      var rn = be("Date", !0);
      V("DDD", ["DDDD", 3], "DDDo", "dayOfYear"), I("dayOfYear", "DDD"), F("dayOfYear", 4), ce("DDD", ee), ce("DDDD", K), de(["DDD", "DDDD"], (function (e, t, n) {
        n._dayOfYear = C(e)
      })), V("m", ["mm", 2], 0, "minute"), I("minute", "m"), F("minute", 14), ce("m", Z), ce("mm", Z, q), de(["m", "mm"], 4);
      var on = be("Minutes", !1);
      V("s", ["ss", 2], 0, "second"), I("second", "s"), F("second", 15), ce("s", Z), ce("ss", Z, q), de(["s", "ss"], 5);
      var sn, an = be("Seconds", !1);
      for (V("S", 0, 0, (function () {
          return ~~(this.millisecond() / 100)
        })), V(0, ["SS", 2], 0, (function () {
          return ~~(this.millisecond() / 10)
        })), V(0, ["SSS", 3], 0, "millisecond"), V(0, ["SSSS", 4], 0, (function () {
          return 10 * this.millisecond()
        })), V(0, ["SSSSS", 5], 0, (function () {
          return 100 * this.millisecond()
        })), V(0, ["SSSSSS", 6], 0, (function () {
          return 1e3 * this.millisecond()
        })), V(0, ["SSSSSSS", 7], 0, (function () {
          return 1e4 * this.millisecond()
        })), V(0, ["SSSSSSSS", 8], 0, (function () {
          return 1e5 * this.millisecond()
        })), V(0, ["SSSSSSSSS", 9], 0, (function () {
          return 1e6 * this.millisecond()
        })), I("millisecond", "ms"), F("millisecond", 16), ce("S", ee, $), ce("SS", ee, q), ce("SSS", ee, K), sn = "SSSS"; sn.length <= 9; sn += "S") ce(sn, re);

      function ln(e, t) {
        t[6] = C(1e3 * ("0." + e))
      }
      for (sn = "S"; sn.length <= 9; sn += "S") de(sn, ln);
      var cn = be("Milliseconds", !1);
      V("z", 0, 0, "zoneAbbr"), V("zz", 0, 0, "zoneName");
      var un = w.prototype;

      function hn(e) {
        return e
      }
      un.add = Gt, un.calendar = function (e, t) {
        var n = e || kt(),
          i = Lt(n, this).startOf("day"),
          o = r.calendarFormat(this, i) || "sameElse",
          s = t && (_(t[o]) ? t[o].call(this, n) : t[o]);
        return this.format(s || this.localeData().calendar(o, this, kt(n)))
      }, un.clone = function () {
        return new w(this)
      }, un.diff = function (e, t, n) {
        var r, i, o;
        if (!this.isValid()) return NaN;
        if (!(r = Lt(e, this)).isValid()) return NaN;
        switch (i = 6e4 * (r.utcOffset() - this.utcOffset()), t = O(t)) {
          case "year":
            o = qt(this, r) / 12;
            break;
          case "month":
            o = qt(this, r);
            break;
          case "quarter":
            o = qt(this, r) / 3;
            break;
          case "second":
            o = (this - r) / 1e3;
            break;
          case "minute":
            o = (this - r) / 6e4;
            break;
          case "hour":
            o = (this - r) / 36e5;
            break;
          case "day":
            o = (this - r - i) / 864e5;
            break;
          case "week":
            o = (this - r - i) / 6048e5;
            break;
          default:
            o = this - r
        }
        return n ? o : S(o)
      }, un.endOf = function (e) {
        var t;
        if (void 0 === (e = O(e)) || "millisecond" === e || !this.isValid()) return this;
        var n = this._isUTC ? Jt : Xt;
        switch (e) {
          case "year":
            t = n(this.year() + 1, 0, 1) - 1;
            break;
          case "quarter":
            t = n(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
            break;
          case "month":
            t = n(this.year(), this.month() + 1, 1) - 1;
            break;
          case "week":
            t = n(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
            break;
          case "isoWeek":
            t = n(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
            break;
          case "day":
          case "date":
            t = n(this.year(), this.month(), this.date() + 1) - 1;
            break;
          case "hour":
            t = this._d.valueOf(), t += 36e5 - Zt(t + (this._isUTC ? 0 : 6e4 * this.utcOffset()), 36e5) - 1;
            break;
          case "minute":
            t = this._d.valueOf(), t += 6e4 - Zt(t, 6e4) - 1;
            break;
          case "second":
            t = this._d.valueOf(), t += 1e3 - Zt(t, 1e3) - 1
        }
        return this._d.setTime(t), r.updateOffset(this, !0), this
      }, un.format = function (e) {
        e || (e = this.isUtc() ? r.defaultFormatUtc : r.defaultFormat);
        var t = j(this, e);
        return this.localeData().postformat(t)
      }, un.from = function (e, t) {
        return this.isValid() && (b(e) && e.isValid() || kt(e).isValid()) ? zt({
          to: this,
          from: e
        }).locale(this.locale()).humanize(!t) : this.localeData().invalidDate()
      }, un.fromNow = function (e) {
        return this.from(kt(), e)
      }, un.to = function (e, t) {
        return this.isValid() && (b(e) && e.isValid() || kt(e).isValid()) ? zt({
          from: this,
          to: e
        }).locale(this.locale()).humanize(!t) : this.localeData().invalidDate()
      }, un.toNow = function (e) {
        return this.to(kt(), e)
      }, un.get = function (e) {
        return _(this[e = O(e)]) ? this[e]() : this
      }, un.invalidAt = function () {
        return d(this).overflow
      }, un.isAfter = function (e, t) {
        var n = b(e) ? e : kt(e);
        return !(!this.isValid() || !n.isValid()) && ("millisecond" === (t = O(t) || "millisecond") ? this.valueOf() > n.valueOf() : n.valueOf() < this.clone().startOf(t).valueOf())
      }, un.isBefore = function (e, t) {
        var n = b(e) ? e : kt(e);
        return !(!this.isValid() || !n.isValid()) && ("millisecond" === (t = O(t) || "millisecond") ? this.valueOf() < n.valueOf() : this.clone().endOf(t).valueOf() < n.valueOf())
      }, un.isBetween = function (e, t, n, r) {
        var i = b(e) ? e : kt(e),
          o = b(t) ? t : kt(t);
        return !!(this.isValid() && i.isValid() && o.isValid()) && ("(" === (r = r || "()")[0] ? this.isAfter(i, n) : !this.isBefore(i, n)) && (")" === r[1] ? this.isBefore(o, n) : !this.isAfter(o, n))
      }, un.isSame = function (e, t) {
        var n, r = b(e) ? e : kt(e);
        return !(!this.isValid() || !r.isValid()) && ("millisecond" === (t = O(t) || "millisecond") ? this.valueOf() === r.valueOf() : (n = r.valueOf(), this.clone().startOf(t).valueOf() <= n && n <= this.clone().endOf(t).valueOf()))
      }, un.isSameOrAfter = function (e, t) {
        return this.isSame(e, t) || this.isAfter(e, t)
      }, un.isSameOrBefore = function (e, t) {
        return this.isSame(e, t) || this.isBefore(e, t)
      }, un.isValid = function () {
        return f(this)
      }, un.lang = Yt, un.locale = Kt, un.localeData = Qt, un.max = Tt, un.min = xt, un.parsingFlags = function () {
        return h({}, d(this))
      }, un.set = function (e, t) {
        if ("object" == typeof e)
          for (var n = function (e) {
              var t = [];
              for (var n in e) t.push({
                unit: n,
                priority: N[n]
              });
              return t.sort((function (e, t) {
                return e.priority - t.priority
              })), t
            }(e = L(e)), r = 0; r < n.length; r++) this[n[r].unit](e[n[r].unit]);
        else if (_(this[e = O(e)])) return this[e](t);
        return this
      }, un.startOf = function (e) {
        var t;
        if (void 0 === (e = O(e)) || "millisecond" === e || !this.isValid()) return this;
        var n = this._isUTC ? Jt : Xt;
        switch (e) {
          case "year":
            t = n(this.year(), 0, 1);
            break;
          case "quarter":
            t = n(this.year(), this.month() - this.month() % 3, 1);
            break;
          case "month":
            t = n(this.year(), this.month(), 1);
            break;
          case "week":
            t = n(this.year(), this.month(), this.date() - this.weekday());
            break;
          case "isoWeek":
            t = n(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
            break;
          case "day":
          case "date":
            t = n(this.year(), this.month(), this.date());
            break;
          case "hour":
            t = this._d.valueOf(), t -= Zt(t + (this._isUTC ? 0 : 6e4 * this.utcOffset()), 36e5);
            break;
          case "minute":
            t = this._d.valueOf(), t -= Zt(t, 6e4);
            break;
          case "second":
            t = this._d.valueOf(), t -= Zt(t, 1e3)
        }
        return this._d.setTime(t), r.updateOffset(this, !0), this
      }, un.subtract = $t, un.toArray = function () {
        var e = this;
        return [e.year(), e.month(), e.date(), e.hour(), e.minute(), e.second(), e.millisecond()]
      }, un.toObject = function () {
        var e = this;
        return {
          years: e.year(),
          months: e.month(),
          date: e.date(),
          hours: e.hours(),
          minutes: e.minutes(),
          seconds: e.seconds(),
          milliseconds: e.milliseconds()
        }
      }, un.toDate = function () {
        return new Date(this.valueOf())
      }, un.toISOString = function (e) {
        if (!this.isValid()) return null;
        var t = !0 !== e,
          n = t ? this.clone().utc() : this;
        return n.year() < 0 || n.year() > 9999 ? j(n, t ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ") : _(Date.prototype.toISOString) ? t ? this.toDate().toISOString() : new Date(this.valueOf() + 60 * this.utcOffset() * 1e3).toISOString().replace("Z", j(n, "Z")) : j(n, t ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ")
      }, un.inspect = function () {
        if (!this.isValid()) return "moment.invalid(/* " + this._i + " */)";
        var e = "moment",
          t = "";
        this.isLocal() || (e = 0 === this.utcOffset() ? "moment.utc" : "moment.parseZone", t = "Z");
        var n = "[" + e + '("]',
          r = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY",
          i = t + '[")]';
        return this.format(n + r + "-MM-DD[T]HH:mm:ss.SSS" + i)
      }, un.toJSON = function () {
        return this.isValid() ? this.toISOString() : null
      }, un.toString = function () {
        return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ")
      }, un.unix = function () {
        return Math.floor(this.valueOf() / 1e3)
      }, un.valueOf = function () {
        return this._d.valueOf() - 6e4 * (this._offset || 0)
      }, un.creationData = function () {
        return {
          input: this._i,
          format: this._f,
          locale: this._locale,
          isUTC: this._isUTC,
          strict: this._strict
        }
      }, un.year = we, un.isLeapYear = function () {
        return ye(this.year())
      }, un.weekYear = function (e) {
        return tn.call(this, e, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy)
      }, un.isoWeekYear = function (e) {
        return tn.call(this, e, this.isoWeek(), this.isoWeekday(), 1, 4)
      }, un.quarter = un.quarters = function (e) {
        return null == e ? Math.ceil((this.month() + 1) / 3) : this.month(3 * (e - 1) + this.month() % 3)
      }, un.month = _e, un.daysInMonth = function () {
        return Ee(this.year(), this.month())
      }, un.week = un.weeks = function (e) {
        var t = this.localeData().week(this);
        return null == e ? t : this.add(7 * (e - t), "d")
      }, un.isoWeek = un.isoWeeks = function (e) {
        var t = Fe(this, 1, 4).week;
        return null == e ? t : this.add(7 * (e - t), "d")
      }, un.weeksInYear = function () {
        var e = this.localeData()._week;
        return Be(this.year(), e.dow, e.doy)
      }, un.isoWeeksInYear = function () {
        return Be(this.year(), 1, 4)
      }, un.date = rn, un.day = un.days = function (e) {
        if (!this.isValid()) return null != e ? this : NaN;
        var t = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        return null != e ? (e = function (e, t) {
          return "string" != typeof e ? e : isNaN(e) ? "number" == typeof (e = t.weekdaysParse(e)) ? e : null : parseInt(e, 10)
        }(e, this.localeData()), this.add(e - t, "d")) : t
      }, un.weekday = function (e) {
        if (!this.isValid()) return null != e ? this : NaN;
        var t = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return null == e ? t : this.add(e - t, "d")
      }, un.isoWeekday = function (e) {
        if (!this.isValid()) return null != e ? this : NaN;
        if (null != e) {
          var t = function (e, t) {
            return "string" == typeof e ? t.weekdaysParse(e) % 7 || 7 : isNaN(e) ? null : e
          }(e, this.localeData());
          return this.day(this.day() % 7 ? t : t - 7)
        }
        return this.day() || 7
      }, un.dayOfYear = function (e) {
        var t = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1;
        return null == e ? t : this.add(e - t, "d")
      }, un.hour = un.hours = Xe, un.minute = un.minutes = on, un.second = un.seconds = an, un.millisecond = un.milliseconds = cn, un.utcOffset = function (e, t, n) {
        var i, o = this._offset || 0;
        if (!this.isValid()) return null != e ? this : NaN;
        if (null != e) {
          if ("string" == typeof e) {
            if (null === (e = Ot(se, e))) return this
          } else Math.abs(e) < 16 && !n && (e *= 60);
          return !this._isUTC && t && (i = Nt(this)), this._offset = e, this._isUTC = !0, null != i && this.add(i, "m"), o !== e && (!t || this._changeInProgress ? jt(this, zt(e - o, "m"), 1, !1) : this._changeInProgress || (this._changeInProgress = !0, r.updateOffset(this, !0), this._changeInProgress = null)), this
        }
        return this._isUTC ? o : Nt(this)
      }, un.utc = function (e) {
        return this.utcOffset(0, e)
      }, un.local = function (e) {
        return this._isUTC && (this.utcOffset(0, e), this._isUTC = !1, e && this.subtract(Nt(this), "m")), this
      }, un.parseZone = function () {
        if (null != this._tzm) this.utcOffset(this._tzm, !1, !0);
        else if ("string" == typeof this._i) {
          var e = Ot(oe, this._i);
          null != e ? this.utcOffset(e) : this.utcOffset(0, !0)
        }
        return this
      }, un.hasAlignedHourOffset = function (e) {
        return !!this.isValid() && (e = e ? kt(e).utcOffset() : 0, (this.utcOffset() - e) % 60 == 0)
      }, un.isDST = function () {
        return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset()
      }, un.isLocal = function () {
        return !!this.isValid() && !this._isUTC
      }, un.isUtcOffset = function () {
        return !!this.isValid() && this._isUTC
      }, un.isUtc = Ft, un.isUTC = Ft, un.zoneAbbr = function () {
        return this._isUTC ? "UTC" : ""
      }, un.zoneName = function () {
        return this._isUTC ? "Coordinated Universal Time" : ""
      }, un.dates = x("dates accessor is deprecated. Use date instead.", rn), un.months = x("months accessor is deprecated. Use month instead", _e), un.years = x("years accessor is deprecated. Use year instead", we), un.zone = x("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", (function (e, t) {
        return null != e ? ("string" != typeof e && (e = -e), this.utcOffset(e, t), this) : -this.utcOffset()
      })), un.isDSTShifted = x("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", (function () {
        if (!s(this._isDSTShifted)) return this._isDSTShifted;
        var e = {};
        if (y(e, this), (e = Ct(e))._a) {
          var t = e._isUTC ? p(e._a) : kt(e._a);
          this._isDSTShifted = this.isValid() && E(e._a, t.toArray()) > 0
        } else this._isDSTShifted = !1;
        return this._isDSTShifted
      }));
      var pn = M.prototype;

      function dn(e, t, n, r) {
        var i = st(),
          o = p().set(r, t);
        return i[n](o, e)
      }

      function fn(e, t, n) {
        if (a(e) && (t = e, e = void 0), e = e || "", null != t) return dn(e, t, n, "month");
        var r, i = [];
        for (r = 0; r < 12; r++) i[r] = dn(e, r, n, "month");
        return i
      }

      function mn(e, t, n, r) {
        "boolean" == typeof e ? (a(t) && (n = t, t = void 0), t = t || "") : (n = t = e, e = !1, a(t) && (n = t, t = void 0), t = t || "");
        var i, o = st(),
          s = e ? o._week.dow : 0;
        if (null != n) return dn(t, (n + s) % 7, r, "day");
        var l = [];
        for (i = 0; i < 7; i++) l[i] = dn(t, (i + s) % 7, r, "day");
        return l
      }
      pn.calendar = function (e, t, n) {
        var r = this._calendar[e] || this._calendar.sameElse;
        return _(r) ? r.call(t, n) : r
      }, pn.longDateFormat = function (e) {
        var t = this._longDateFormat[e],
          n = this._longDateFormat[e.toUpperCase()];
        return t || !n ? t : (this._longDateFormat[e] = n.replace(/MMMM|MM|DD|dddd/g, (function (e) {
          return e.slice(1)
        })), this._longDateFormat[e])
      }, pn.invalidDate = function () {
        return this._invalidDate
      }, pn.ordinal = function (e) {
        return this._ordinal.replace("%d", e)
      }, pn.preparse = hn, pn.postformat = hn, pn.relativeTime = function (e, t, n, r) {
        var i = this._relativeTime[n];
        return _(i) ? i(e, t, n, r) : i.replace(/%d/i, e)
      }, pn.pastFuture = function (e, t) {
        var n = this._relativeTime[e > 0 ? "future" : "past"];
        return _(n) ? n(t) : n.replace(/%s/i, t)
      }, pn.set = function (e) {
        var t, n;
        for (n in e) _(t = e[n]) ? this[n] = t : this["_" + n] = t;
        this._config = e, this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source)
      }, pn.months = function (e, t) {
        return e ? i(this._months) ? this._months[e.month()] : this._months[(this._months.isFormat || ke).test(t) ? "format" : "standalone"][e.month()] : i(this._months) ? this._months : this._months.standalone
      }, pn.monthsShort = function (e, t) {
        return e ? i(this._monthsShort) ? this._monthsShort[e.month()] : this._monthsShort[ke.test(t) ? "format" : "standalone"][e.month()] : i(this._monthsShort) ? this._monthsShort : this._monthsShort.standalone
      }, pn.monthsParse = function (e, t, n) {
        var r, i, o;
        if (this._monthsParseExact) return Re.call(this, e, t, n);
        for (this._monthsParse || (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = []), r = 0; r < 12; r++) {
          if (i = p([2e3, r]), n && !this._longMonthsParse[r] && (this._longMonthsParse[r] = new RegExp("^" + this.months(i, "").replace(".", "") + "$", "i"), this._shortMonthsParse[r] = new RegExp("^" + this.monthsShort(i, "").replace(".", "") + "$", "i")), n || this._monthsParse[r] || (o = "^" + this.months(i, "") + "|^" + this.monthsShort(i, ""), this._monthsParse[r] = new RegExp(o.replace(".", ""), "i")), n && "MMMM" === t && this._longMonthsParse[r].test(e)) return r;
          if (n && "MMM" === t && this._shortMonthsParse[r].test(e)) return r;
          if (!n && this._monthsParse[r].test(e)) return r
        }
      }, pn.monthsRegex = function (e) {
        return this._monthsParseExact ? (u(this, "_monthsRegex") || Pe.call(this), e ? this._monthsStrictRegex : this._monthsRegex) : (u(this, "_monthsRegex") || (this._monthsRegex = Me), this._monthsStrictRegex && e ? this._monthsStrictRegex : this._monthsRegex)
      }, pn.monthsShortRegex = function (e) {
        return this._monthsParseExact ? (u(this, "_monthsRegex") || Pe.call(this), e ? this._monthsShortStrictRegex : this._monthsShortRegex) : (u(this, "_monthsShortRegex") || (this._monthsShortRegex = Ae), this._monthsShortStrictRegex && e ? this._monthsShortStrictRegex : this._monthsShortRegex)
      }, pn.week = function (e) {
        return Fe(e, this._week.dow, this._week.doy).week
      }, pn.firstDayOfYear = function () {
        return this._week.doy
      }, pn.firstDayOfWeek = function () {
        return this._week.dow
      }, pn.weekdays = function (e, t) {
        var n = i(this._weekdays) ? this._weekdays : this._weekdays[e && !0 !== e && this._weekdays.isFormat.test(t) ? "format" : "standalone"];
        return !0 === e ? He(n, this._week.dow) : e ? n[e.day()] : n
      }, pn.weekdaysMin = function (e) {
        return !0 === e ? He(this._weekdaysMin, this._week.dow) : e ? this._weekdaysMin[e.day()] : this._weekdaysMin
      }, pn.weekdaysShort = function (e) {
        return !0 === e ? He(this._weekdaysShort, this._week.dow) : e ? this._weekdaysShort[e.day()] : this._weekdaysShort
      }, pn.weekdaysParse = function (e, t, n) {
        var r, i, o;
        if (this._weekdaysParseExact) return Ve.call(this, e, t, n);
        for (this._weekdaysParse || (this._weekdaysParse = [], this._minWeekdaysParse = [], this._shortWeekdaysParse = [], this._fullWeekdaysParse = []), r = 0; r < 7; r++) {
          if (i = p([2e3, 1]).day(r), n && !this._fullWeekdaysParse[r] && (this._fullWeekdaysParse[r] = new RegExp("^" + this.weekdays(i, "").replace(".", "\\.?") + "$", "i"), this._shortWeekdaysParse[r] = new RegExp("^" + this.weekdaysShort(i, "").replace(".", "\\.?") + "$", "i"), this._minWeekdaysParse[r] = new RegExp("^" + this.weekdaysMin(i, "").replace(".", "\\.?") + "$", "i")), this._weekdaysParse[r] || (o = "^" + this.weekdays(i, "") + "|^" + this.weekdaysShort(i, "") + "|^" + this.weekdaysMin(i, ""), this._weekdaysParse[r] = new RegExp(o.replace(".", ""), "i")), n && "dddd" === t && this._fullWeekdaysParse[r].test(e)) return r;
          if (n && "ddd" === t && this._shortWeekdaysParse[r].test(e)) return r;
          if (n && "dd" === t && this._minWeekdaysParse[r].test(e)) return r;
          if (!n && this._weekdaysParse[r].test(e)) return r
        }
      }, pn.weekdaysRegex = function (e) {
        return this._weekdaysParseExact ? (u(this, "_weekdaysRegex") || qe.call(this), e ? this._weekdaysStrictRegex : this._weekdaysRegex) : (u(this, "_weekdaysRegex") || (this._weekdaysRegex = je), this._weekdaysStrictRegex && e ? this._weekdaysStrictRegex : this._weekdaysRegex)
      }, pn.weekdaysShortRegex = function (e) {
        return this._weekdaysParseExact ? (u(this, "_weekdaysRegex") || qe.call(this), e ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex) : (u(this, "_weekdaysShortRegex") || (this._weekdaysShortRegex = Ge), this._weekdaysShortStrictRegex && e ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex)
      }, pn.weekdaysMinRegex = function (e) {
        return this._weekdaysParseExact ? (u(this, "_weekdaysRegex") || qe.call(this), e ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex) : (u(this, "_weekdaysMinRegex") || (this._weekdaysMinRegex = $e), this._weekdaysMinStrictRegex && e ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex)
      }, pn.isPM = function (e) {
        return "p" === (e + "").toLowerCase().charAt(0)
      }, pn.meridiem = function (e, t, n) {
        return e > 11 ? n ? "pm" : "PM" : n ? "am" : "AM"
      }, it("en", {
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function (e) {
          var t = e % 10;
          return e + (1 === C(e % 100 / 10) ? "th" : 1 === t ? "st" : 2 === t ? "nd" : 3 === t ? "rd" : "th")
        }
      }), r.lang = x("moment.lang is deprecated. Use moment.locale instead.", it), r.langData = x("moment.langData is deprecated. Use moment.localeData instead.", st);
      var gn = Math.abs;

      function yn(e, t, n, r) {
        var i = zt(t, n);
        return e._milliseconds += r * i._milliseconds, e._days += r * i._days, e._months += r * i._months, e._bubble()
      }

      function vn(e) {
        return e < 0 ? Math.floor(e) : Math.ceil(e)
      }

      function wn(e) {
        return 4800 * e / 146097
      }

      function bn(e) {
        return 146097 * e / 4800
      }

      function Sn(e) {
        return function () {
          return this.as(e)
        }
      }
      var Cn = Sn("ms"),
        En = Sn("s"),
        kn = Sn("m"),
        xn = Sn("h"),
        Tn = Sn("d"),
        Rn = Sn("w"),
        Dn = Sn("M"),
        _n = Sn("Q"),
        An = Sn("y");

      function Mn(e) {
        return function () {
          return this.isValid() ? this._data[e] : NaN
        }
      }
      var Pn = Mn("milliseconds"),
        In = Mn("seconds"),
        On = Mn("minutes"),
        Ln = Mn("hours"),
        Nn = Mn("days"),
        Fn = Mn("months"),
        Bn = Mn("years"),
        Hn = Math.round,
        zn = {
          ss: 44,
          s: 45,
          m: 45,
          h: 22,
          d: 26,
          M: 11
        };

      function Un(e, t, n, r, i) {
        return i.relativeTime(t || 1, !!n, e, r)
      }
      var Wn = Math.abs;

      function Vn(e) {
        return (e > 0) - (e < 0) || +e
      }

      function jn() {
        if (!this.isValid()) return this.localeData().invalidDate();
        var e, t, n = Wn(this._milliseconds) / 1e3,
          r = Wn(this._days),
          i = Wn(this._months);
        e = S(n / 60), t = S(e / 60), n %= 60, e %= 60;
        var o = S(i / 12),
          s = i %= 12,
          a = r,
          l = t,
          c = e,
          u = n ? n.toFixed(3).replace(/\.?0+$/, "") : "",
          h = this.asSeconds();
        if (!h) return "P0D";
        var p = h < 0 ? "-" : "",
          d = Vn(this._months) !== Vn(h) ? "-" : "",
          f = Vn(this._days) !== Vn(h) ? "-" : "",
          m = Vn(this._milliseconds) !== Vn(h) ? "-" : "";
        return p + "P" + (o ? d + o + "Y" : "") + (s ? d + s + "M" : "") + (a ? f + a + "D" : "") + (l || c || u ? "T" : "") + (l ? m + l + "H" : "") + (c ? m + c + "M" : "") + (u ? m + u + "S" : "")
      }
      var Gn = _t.prototype;
      return Gn.isValid = function () {
        return this._isValid
      }, Gn.abs = function () {
        var e = this._data;
        return this._milliseconds = gn(this._milliseconds), this._days = gn(this._days), this._months = gn(this._months), e.milliseconds = gn(e.milliseconds), e.seconds = gn(e.seconds), e.minutes = gn(e.minutes), e.hours = gn(e.hours), e.months = gn(e.months), e.years = gn(e.years), this
      }, Gn.add = function (e, t) {
        return yn(this, e, t, 1)
      }, Gn.subtract = function (e, t) {
        return yn(this, e, t, -1)
      }, Gn.as = function (e) {
        if (!this.isValid()) return NaN;
        var t, n, r = this._milliseconds;
        if ("month" === (e = O(e)) || "quarter" === e || "year" === e) switch (t = this._days + r / 864e5, n = this._months + wn(t), e) {
          case "month":
            return n;
          case "quarter":
            return n / 3;
          case "year":
            return n / 12
        } else switch (t = this._days + Math.round(bn(this._months)), e) {
          case "week":
            return t / 7 + r / 6048e5;
          case "day":
            return t + r / 864e5;
          case "hour":
            return 24 * t + r / 36e5;
          case "minute":
            return 1440 * t + r / 6e4;
          case "second":
            return 86400 * t + r / 1e3;
          case "millisecond":
            return Math.floor(864e5 * t) + r;
          default:
            throw new Error("Unknown unit " + e)
        }
      }, Gn.asMilliseconds = Cn, Gn.asSeconds = En, Gn.asMinutes = kn, Gn.asHours = xn, Gn.asDays = Tn, Gn.asWeeks = Rn, Gn.asMonths = Dn, Gn.asQuarters = _n, Gn.asYears = An, Gn.valueOf = function () {
        return this.isValid() ? this._milliseconds + 864e5 * this._days + this._months % 12 * 2592e6 + 31536e6 * C(this._months / 12) : NaN
      }, Gn._bubble = function () {
        var e, t, n, r, i, o = this._milliseconds,
          s = this._days,
          a = this._months,
          l = this._data;
        return o >= 0 && s >= 0 && a >= 0 || o <= 0 && s <= 0 && a <= 0 || (o += 864e5 * vn(bn(a) + s), s = 0, a = 0), l.milliseconds = o % 1e3, e = S(o / 1e3), l.seconds = e % 60, t = S(e / 60), l.minutes = t % 60, n = S(t / 60), l.hours = n % 24, s += S(n / 24), i = S(wn(s)), a += i, s -= vn(bn(i)), r = S(a / 12), a %= 12, l.days = s, l.months = a, l.years = r, this
      }, Gn.clone = function () {
        return zt(this)
      }, Gn.get = function (e) {
        return e = O(e), this.isValid() ? this[e + "s"]() : NaN
      }, Gn.milliseconds = Pn, Gn.seconds = In, Gn.minutes = On, Gn.hours = Ln, Gn.days = Nn, Gn.weeks = function () {
        return S(this.days() / 7)
      }, Gn.months = Fn, Gn.years = Bn, Gn.humanize = function (e) {
        if (!this.isValid()) return this.localeData().invalidDate();
        var t = this.localeData(),
          n = function (e, t, n) {
            var r = zt(e).abs(),
              i = Hn(r.as("s")),
              o = Hn(r.as("m")),
              s = Hn(r.as("h")),
              a = Hn(r.as("d")),
              l = Hn(r.as("M")),
              c = Hn(r.as("y")),
              u = i <= zn.ss && ["s", i] || i < zn.s && ["ss", i] || o <= 1 && ["m"] || o < zn.m && ["mm", o] || s <= 1 && ["h"] || s < zn.h && ["hh", s] || a <= 1 && ["d"] || a < zn.d && ["dd", a] || l <= 1 && ["M"] || l < zn.M && ["MM", l] || c <= 1 && ["y"] || ["yy", c];
            return u[2] = t, u[3] = +e > 0, u[4] = n, Un.apply(null, u)
          }(this, !e, t);
        return e && (n = t.pastFuture(+this, n)), t.postformat(n)
      }, Gn.toISOString = jn, Gn.toString = jn, Gn.toJSON = jn, Gn.locale = Kt, Gn.localeData = Qt, Gn.toIsoString = x("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", jn), Gn.lang = Yt, V("X", 0, 0, "unix"), V("x", 0, 0, "valueOf"), ce("x", ie), ce("X", /[+-]?\d+(\.\d{1,3})?/), de("X", (function (e, t, n) {
        n._d = new Date(1e3 * parseFloat(e, 10))
      })), de("x", (function (e, t, n) {
        n._d = new Date(C(e))
      })), r.version = "2.24.0", t = kt, r.fn = un, r.min = function () {
        var e = [].slice.call(arguments, 0);
        return Rt("isBefore", e)
      }, r.max = function () {
        var e = [].slice.call(arguments, 0);
        return Rt("isAfter", e)
      }, r.now = function () {
        return Date.now ? Date.now() : +new Date
      }, r.utc = p, r.unix = function (e) {
        return kt(1e3 * e)
      }, r.months = function (e, t) {
        return fn(e, t, "months")
      }, r.isDate = l, r.locale = it, r.invalid = m, r.duration = zt, r.isMoment = b, r.weekdays = function (e, t, n) {
        return mn(e, t, n, "weekdays")
      }, r.parseZone = function () {
        return kt.apply(null, arguments).parseZone()
      }, r.localeData = st, r.isDuration = At, r.monthsShort = function (e, t) {
        return fn(e, t, "monthsShort")
      }, r.weekdaysMin = function (e, t, n) {
        return mn(e, t, n, "weekdaysMin")
      }, r.defineLocale = ot, r.updateLocale = function (e, t) {
        if (null != t) {
          var n, r, i = Je;
          null != (r = rt(e)) && (i = r._config), t = A(i, t), (n = new M(t)).parentLocale = et[e], et[e] = n, it(e)
        } else null != et[e] && (null != et[e].parentLocale ? et[e] = et[e].parentLocale : null != et[e] && delete et[e]);
        return et[e]
      }, r.locales = function () {
        return T(et)
      }, r.weekdaysShort = function (e, t, n) {
        return mn(e, t, n, "weekdaysShort")
      }, r.normalizeUnits = O, r.relativeTimeRounding = function (e) {
        return void 0 === e ? Hn : "function" == typeof e && (Hn = e, !0)
      }, r.relativeTimeThreshold = function (e, t) {
        return void 0 !== zn[e] && (void 0 === t ? zn[e] : (zn[e] = t, "s" === e && (zn.ss = t - 1), !0))
      }, r.calendarFormat = function (e, t) {
        var n = e.diff(t, "days", !0);
        return n < -6 ? "sameElse" : n < -1 ? "lastWeek" : n < 0 ? "lastDay" : n < 1 ? "sameDay" : n < 2 ? "nextDay" : n < 7 ? "nextWeek" : "sameElse"
      }, r.prototype = un, r.HTML5_FMT = {
        DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
        DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
        DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
        DATE: "YYYY-MM-DD",
        TIME: "HH:mm",
        TIME_SECONDS: "HH:mm:ss",
        TIME_MS: "HH:mm:ss.SSS",
        WEEK: "GGGG-[W]WW",
        MONTH: "YYYY-MM"
      }, r
    }()
  }).call(this, n(42)(e))
}, function (e, t, n) {
  var r, i, o = n(7),
    s = n(168),
    a = n(169),
    l = n(170),
    c = n(36);
  "function" == typeof Symbol && "function" == typeof Symbol.for ? (r = Symbol.for("graceful-fs.queue"), i = Symbol.for("graceful-fs.previous")) : (r = "___graceful-fs.queue", i = "___graceful-fs.previous");
  var u = function () {};
  if (c.debuglog ? u = c.debuglog("gfs4") : /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") && (u = function () {
      var e = c.format.apply(c, arguments);
      e = "GFS4: " + e.split(/\n/).join("\nGFS4: "), console.error(e)
    }), !global[r]) {
    var h = [];
    Object.defineProperty(global, r, {
      get: function () {
        return h
      }
    }), o.close = function (e) {
      function t(t, n) {
        return e.call(o, t, (function (e) {
          e || f(), "function" == typeof n && n.apply(this, arguments)
        }))
      }
      return Object.defineProperty(t, i, {
        value: e
      }), t
    }(o.close), o.closeSync = function (e) {
      function t(t) {
        e.apply(o, arguments), f()
      }
      return Object.defineProperty(t, i, {
        value: e
      }), t
    }(o.closeSync), /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") && process.on("exit", (function () {
      u(global[r]), n(44).equal(global[r].length, 0)
    }))
  }

  function p(e) {
    s(e), e.gracefulify = p, e.createReadStream = function (t, n) {
      return new e.ReadStream(t, n)
    }, e.createWriteStream = function (t, n) {
      return new e.WriteStream(t, n)
    };
    var t = e.readFile;
    e.readFile = function (e, n, r) {
      "function" == typeof n && (r = n, n = null);
      return function e(n, r, i) {
        return t(n, r, (function (t) {
          !t || "EMFILE" !== t.code && "ENFILE" !== t.code ? ("function" == typeof i && i.apply(this, arguments), f()) : d([e, [n, r, i]])
        }))
      }(e, n, r)
    };
    var n = e.writeFile;
    e.writeFile = function (e, t, r, i) {
      "function" == typeof r && (i = r, r = null);
      return function e(t, r, i, o) {
        return n(t, r, i, (function (n) {
          !n || "EMFILE" !== n.code && "ENFILE" !== n.code ? ("function" == typeof o && o.apply(this, arguments), f()) : d([e, [t, r, i, o]])
        }))
      }(e, t, r, i)
    };
    var r = e.appendFile;
    r && (e.appendFile = function (e, t, n, i) {
      "function" == typeof n && (i = n, n = null);
      return function e(t, n, i, o) {
        return r(t, n, i, (function (r) {
          !r || "EMFILE" !== r.code && "ENFILE" !== r.code ? ("function" == typeof o && o.apply(this, arguments), f()) : d([e, [t, n, i, o]])
        }))
      }(e, t, n, i)
    });
    var i = e.readdir;

    function o(t) {
      return i.apply(e, t)
    }
    if (e.readdir = function (e, t, n) {
        var r = [e];
        "function" != typeof t ? r.push(t) : n = t;
        return r.push((function (e, t) {
          t && t.sort && t.sort();
          !e || "EMFILE" !== e.code && "ENFILE" !== e.code ? ("function" == typeof n && n.apply(this, arguments), f()) : d([o, [r]])
        })), o(r)
      }, "v0.8" === process.version.substr(0, 4)) {
      var l = a(e);
      g = l.ReadStream, y = l.WriteStream
    }
    var c = e.ReadStream;
    c && (g.prototype = Object.create(c.prototype), g.prototype.open = function () {
      var e = this;
      w(e.path, e.flags, e.mode, (function (t, n) {
        t ? (e.autoClose && e.destroy(), e.emit("error", t)) : (e.fd = n, e.emit("open", n), e.read())
      }))
    });
    var u = e.WriteStream;
    u && (y.prototype = Object.create(u.prototype), y.prototype.open = function () {
      var e = this;
      w(e.path, e.flags, e.mode, (function (t, n) {
        t ? (e.destroy(), e.emit("error", t)) : (e.fd = n, e.emit("open", n))
      }))
    }), Object.defineProperty(e, "ReadStream", {
      get: function () {
        return g
      },
      set: function (e) {
        g = e
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e, "WriteStream", {
      get: function () {
        return y
      },
      set: function (e) {
        y = e
      },
      enumerable: !0,
      configurable: !0
    });
    var h = g;
    Object.defineProperty(e, "FileReadStream", {
      get: function () {
        return h
      },
      set: function (e) {
        h = e
      },
      enumerable: !0,
      configurable: !0
    });
    var m = y;

    function g(e, t) {
      return this instanceof g ? (c.apply(this, arguments), this) : g.apply(Object.create(g.prototype), arguments)
    }

    function y(e, t) {
      return this instanceof y ? (u.apply(this, arguments), this) : y.apply(Object.create(y.prototype), arguments)
    }
    Object.defineProperty(e, "FileWriteStream", {
      get: function () {
        return m
      },
      set: function (e) {
        m = e
      },
      enumerable: !0,
      configurable: !0
    });
    var v = e.open;

    function w(e, t, n, r) {
      return "function" == typeof n && (r = n, n = null),
        function e(t, n, r, i) {
          return v(t, n, r, (function (o, s) {
            !o || "EMFILE" !== o.code && "ENFILE" !== o.code ? ("function" == typeof i && i.apply(this, arguments), f()) : d([e, [t, n, r, i]])
          }))
        }(e, t, n, r)
    }
    return e.open = w, e
  }

  function d(e) {
    u("ENQUEUE", e[0].name, e[1]), global[r].push(e)
  }

  function f() {
    var e = global[r].shift();
    e && (u("RETRY", e[0].name, e[1]), e[0].apply(null, e[1]))
  }
  e.exports = p(l(o)), process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !o.__patched && (e.exports = p(o), o.__patched = !0)
}, function (e, t, n) {
  e.exports = function () {
    "use strict";
    var e = navigator.userAgent,
      t = navigator.platform,
      n = /gecko\/\d/i.test(e),
      r = /MSIE \d/.test(e),
      i = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(e),
      o = /Edge\/(\d+)/.exec(e),
      s = r || i || o,
      a = s && (r ? document.documentMode || 6 : +(o || i)[1]),
      l = !o && /WebKit\//.test(e),
      c = l && /Qt\/\d+\.\d+/.test(e),
      u = !o && /Chrome\//.test(e),
      h = /Opera\//.test(e),
      p = /Apple Computer/.test(navigator.vendor),
      d = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(e),
      f = /PhantomJS/.test(e),
      m = !o && /AppleWebKit/.test(e) && /Mobile\/\w+/.test(e),
      g = /Android/.test(e),
      y = m || g || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(e),
      v = m || /Mac/.test(t),
      w = /\bCrOS\b/.test(e),
      b = /win/i.test(t),
      S = h && e.match(/Version\/(\d*\.\d*)/);
    S && (S = Number(S[1])), S && S >= 15 && (h = !1, l = !0);
    var C = v && (c || h && (null == S || S < 12.11)),
      E = n || s && a >= 9;

    function k(e) {
      return new RegExp("(^|\\s)" + e + "(?:$|\\s)\\s*")
    }
    var x, T = function (e, t) {
      var n = e.className,
        r = k(t).exec(n);
      if (r) {
        var i = n.slice(r.index + r[0].length);
        e.className = n.slice(0, r.index) + (i ? r[1] + i : "")
      }
    };

    function R(e) {
      for (var t = e.childNodes.length; t > 0; --t) e.removeChild(e.firstChild);
      return e
    }

    function D(e, t) {
      return R(e).appendChild(t)
    }

    function _(e, t, n, r) {
      var i = document.createElement(e);
      if (n && (i.className = n), r && (i.style.cssText = r), "string" == typeof t) i.appendChild(document.createTextNode(t));
      else if (t)
        for (var o = 0; o < t.length; ++o) i.appendChild(t[o]);
      return i
    }

    function A(e, t, n, r) {
      var i = _(e, t, n, r);
      return i.setAttribute("role", "presentation"), i
    }

    function M(e, t) {
      if (3 == t.nodeType && (t = t.parentNode), e.contains) return e.contains(t);
      do {
        if (11 == t.nodeType && (t = t.host), t == e) return !0
      } while (t = t.parentNode)
    }

    function P() {
      var e;
      try {
        e = document.activeElement
      } catch (t) {
        e = document.body || null
      }
      for (; e && e.shadowRoot && e.shadowRoot.activeElement;) e = e.shadowRoot.activeElement;
      return e
    }

    function I(e, t) {
      var n = e.className;
      k(t).test(n) || (e.className += (n ? " " : "") + t)
    }

    function O(e, t) {
      for (var n = e.split(" "), r = 0; r < n.length; r++) n[r] && !k(n[r]).test(t) && (t += " " + n[r]);
      return t
    }
    x = document.createRange ? function (e, t, n, r) {
      var i = document.createRange();
      return i.setEnd(r || e, n), i.setStart(e, t), i
    } : function (e, t, n) {
      var r = document.body.createTextRange();
      try {
        r.moveToElementText(e.parentNode)
      } catch (e) {
        return r
      }
      return r.collapse(!0), r.moveEnd("character", n), r.moveStart("character", t), r
    };
    var L = function (e) {
      e.select()
    };

    function N(e) {
      var t = Array.prototype.slice.call(arguments, 1);
      return function () {
        return e.apply(null, t)
      }
    }

    function F(e, t, n) {
      for (var r in t || (t = {}), e) !e.hasOwnProperty(r) || !1 === n && t.hasOwnProperty(r) || (t[r] = e[r]);
      return t
    }

    function B(e, t, n, r, i) {
      null == t && -1 == (t = e.search(/[^\s\u00a0]/)) && (t = e.length);
      for (var o = r || 0, s = i || 0;;) {
        var a = e.indexOf("\t", o);
        if (a < 0 || a >= t) return s + (t - o);
        s += a - o, s += n - s % n, o = a + 1
      }
    }
    m ? L = function (e) {
      e.selectionStart = 0, e.selectionEnd = e.value.length
    } : s && (L = function (e) {
      try {
        e.select()
      } catch (e) {}
    });
    var H = function () {
      this.id = null, this.f = null, this.time = 0, this.handler = N(this.onTimeout, this)
    };

    function z(e, t) {
      for (var n = 0; n < e.length; ++n)
        if (e[n] == t) return n;
      return -1
    }
    H.prototype.onTimeout = function (e) {
      e.id = 0, e.time <= +new Date ? e.f() : setTimeout(e.handler, e.time - +new Date)
    }, H.prototype.set = function (e, t) {
      this.f = t;
      var n = +new Date + e;
      (!this.id || n < this.time) && (clearTimeout(this.id), this.id = setTimeout(this.handler, e), this.time = n)
    };
    var U = {
        toString: function () {
          return "CodeMirror.Pass"
        }
      },
      W = {
        scroll: !1
      },
      V = {
        origin: "*mouse"
      },
      j = {
        origin: "+move"
      };

    function G(e, t, n) {
      for (var r = 0, i = 0;;) {
        var o = e.indexOf("\t", r); - 1 == o && (o = e.length);
        var s = o - r;
        if (o == e.length || i + s >= t) return r + Math.min(s, t - i);
        if (i += o - r, r = o + 1, (i += n - i % n) >= t) return r
      }
    }
    var $ = [""];

    function q(e) {
      for (; $.length <= e;) $.push(K($) + " ");
      return $[e]
    }

    function K(e) {
      return e[e.length - 1]
    }

    function Y(e, t) {
      for (var n = [], r = 0; r < e.length; r++) n[r] = t(e[r], r);
      return n
    }

    function Q() {}

    function Z(e, t) {
      var n;
      return Object.create ? n = Object.create(e) : (Q.prototype = e, n = new Q), t && F(t, n), n
    }
    var X = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;

    function J(e) {
      return /\w/.test(e) || e > "" && (e.toUpperCase() != e.toLowerCase() || X.test(e))
    }

    function ee(e, t) {
      return t ? !!(t.source.indexOf("\\w") > -1 && J(e)) || t.test(e) : J(e)
    }

    function te(e) {
      for (var t in e)
        if (e.hasOwnProperty(t) && e[t]) return !1;
      return !0
    }
    var ne = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;

    function re(e) {
      return e.charCodeAt(0) >= 768 && ne.test(e)
    }

    function ie(e, t, n) {
      for (;
        (n < 0 ? t > 0 : t < e.length) && re(e.charAt(t));) t += n;
      return t
    }

    function oe(e, t, n) {
      for (var r = t > n ? -1 : 1;;) {
        if (t == n) return t;
        var i = (t + n) / 2,
          o = r < 0 ? Math.ceil(i) : Math.floor(i);
        if (o == t) return e(o) ? t : n;
        e(o) ? n = o : t = o + r
      }
    }
    var se = null;

    function ae(e, t, n) {
      var r;
      se = null;
      for (var i = 0; i < e.length; ++i) {
        var o = e[i];
        if (o.from < t && o.to > t) return i;
        o.to == t && (o.from != o.to && "before" == n ? r = i : se = i), o.from == t && (o.from != o.to && "before" != n ? r = i : se = i)
      }
      return null != r ? r : se
    }
    var le = function () {
      var e = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,
        t = /[stwN]/,
        n = /[LRr]/,
        r = /[Lb1n]/,
        i = /[1n]/;

      function o(e, t, n) {
        this.level = e, this.from = t, this.to = n
      }
      return function (s, a) {
        var l = "ltr" == a ? "L" : "R";
        if (0 == s.length || "ltr" == a && !e.test(s)) return !1;
        for (var c, u = s.length, h = [], p = 0; p < u; ++p) h.push((c = s.charCodeAt(p)) <= 247 ? "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN".charAt(c) : 1424 <= c && c <= 1524 ? "R" : 1536 <= c && c <= 1785 ? "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111".charAt(c - 1536) : 1774 <= c && c <= 2220 ? "r" : 8192 <= c && c <= 8203 ? "w" : 8204 == c ? "b" : "L");
        for (var d = 0, f = l; d < u; ++d) {
          var m = h[d];
          "m" == m ? h[d] = f : f = m
        }
        for (var g = 0, y = l; g < u; ++g) {
          var v = h[g];
          "1" == v && "r" == y ? h[g] = "n" : n.test(v) && (y = v, "r" == v && (h[g] = "R"))
        }
        for (var w = 1, b = h[0]; w < u - 1; ++w) {
          var S = h[w];
          "+" == S && "1" == b && "1" == h[w + 1] ? h[w] = "1" : "," != S || b != h[w + 1] || "1" != b && "n" != b || (h[w] = b), b = S
        }
        for (var C = 0; C < u; ++C) {
          var E = h[C];
          if ("," == E) h[C] = "N";
          else if ("%" == E) {
            var k = void 0;
            for (k = C + 1; k < u && "%" == h[k]; ++k);
            for (var x = C && "!" == h[C - 1] || k < u && "1" == h[k] ? "1" : "N", T = C; T < k; ++T) h[T] = x;
            C = k - 1
          }
        }
        for (var R = 0, D = l; R < u; ++R) {
          var _ = h[R];
          "L" == D && "1" == _ ? h[R] = "L" : n.test(_) && (D = _)
        }
        for (var A = 0; A < u; ++A)
          if (t.test(h[A])) {
            var M = void 0;
            for (M = A + 1; M < u && t.test(h[M]); ++M);
            for (var P = "L" == (A ? h[A - 1] : l), I = P == ("L" == (M < u ? h[M] : l)) ? P ? "L" : "R" : l, O = A; O < M; ++O) h[O] = I;
            A = M - 1
          } for (var L, N = [], F = 0; F < u;)
          if (r.test(h[F])) {
            var B = F;
            for (++F; F < u && r.test(h[F]); ++F);
            N.push(new o(0, B, F))
          } else {
            var H = F,
              z = N.length;
            for (++F; F < u && "L" != h[F]; ++F);
            for (var U = H; U < F;)
              if (i.test(h[U])) {
                H < U && N.splice(z, 0, new o(1, H, U));
                var W = U;
                for (++U; U < F && i.test(h[U]); ++U);
                N.splice(z, 0, new o(2, W, U)), H = U
              } else ++U;
            H < F && N.splice(z, 0, new o(1, H, F))
          } return "ltr" == a && (1 == N[0].level && (L = s.match(/^\s+/)) && (N[0].from = L[0].length, N.unshift(new o(0, 0, L[0].length))), 1 == K(N).level && (L = s.match(/\s+$/)) && (K(N).to -= L[0].length, N.push(new o(0, u - L[0].length, u)))), "rtl" == a ? N.reverse() : N
      }
    }();

    function ce(e, t) {
      var n = e.order;
      return null == n && (n = e.order = le(e.text, t)), n
    }
    var ue = [],
      he = function (e, t, n) {
        if (e.addEventListener) e.addEventListener(t, n, !1);
        else if (e.attachEvent) e.attachEvent("on" + t, n);
        else {
          var r = e._handlers || (e._handlers = {});
          r[t] = (r[t] || ue).concat(n)
        }
      };

    function pe(e, t) {
      return e._handlers && e._handlers[t] || ue
    }

    function de(e, t, n) {
      if (e.removeEventListener) e.removeEventListener(t, n, !1);
      else if (e.detachEvent) e.detachEvent("on" + t, n);
      else {
        var r = e._handlers,
          i = r && r[t];
        if (i) {
          var o = z(i, n);
          o > -1 && (r[t] = i.slice(0, o).concat(i.slice(o + 1)))
        }
      }
    }

    function fe(e, t) {
      var n = pe(e, t);
      if (n.length)
        for (var r = Array.prototype.slice.call(arguments, 2), i = 0; i < n.length; ++i) n[i].apply(null, r)
    }

    function me(e, t, n) {
      return "string" == typeof t && (t = {
        type: t,
        preventDefault: function () {
          this.defaultPrevented = !0
        }
      }), fe(e, n || t.type, e, t), Se(t) || t.codemirrorIgnore
    }

    function ge(e) {
      var t = e._handlers && e._handlers.cursorActivity;
      if (t)
        for (var n = e.curOp.cursorActivityHandlers || (e.curOp.cursorActivityHandlers = []), r = 0; r < t.length; ++r) - 1 == z(n, t[r]) && n.push(t[r])
    }

    function ye(e, t) {
      return pe(e, t).length > 0
    }

    function ve(e) {
      e.prototype.on = function (e, t) {
        he(this, e, t)
      }, e.prototype.off = function (e, t) {
        de(this, e, t)
      }
    }

    function we(e) {
      e.preventDefault ? e.preventDefault() : e.returnValue = !1
    }

    function be(e) {
      e.stopPropagation ? e.stopPropagation() : e.cancelBubble = !0
    }

    function Se(e) {
      return null != e.defaultPrevented ? e.defaultPrevented : 0 == e.returnValue
    }

    function Ce(e) {
      we(e), be(e)
    }

    function Ee(e) {
      return e.target || e.srcElement
    }

    function ke(e) {
      var t = e.which;
      return null == t && (1 & e.button ? t = 1 : 2 & e.button ? t = 3 : 4 & e.button && (t = 2)), v && e.ctrlKey && 1 == t && (t = 3), t
    }
    var xe, Te, Re = function () {
      if (s && a < 9) return !1;
      var e = _("div");
      return "draggable" in e || "dragDrop" in e
    }();

    function De(e) {
      if (null == xe) {
        var t = _("span", "​");
        D(e, _("span", [t, document.createTextNode("x")])), 0 != e.firstChild.offsetHeight && (xe = t.offsetWidth <= 1 && t.offsetHeight > 2 && !(s && a < 8))
      }
      var n = xe ? _("span", "​") : _("span", " ", null, "display: inline-block; width: 1px; margin-right: -1px");
      return n.setAttribute("cm-text", ""), n
    }

    function _e(e) {
      if (null != Te) return Te;
      var t = D(e, document.createTextNode("AخA")),
        n = x(t, 0, 1).getBoundingClientRect(),
        r = x(t, 1, 2).getBoundingClientRect();
      return R(e), !(!n || n.left == n.right) && (Te = r.right - n.right < 3)
    }
    var Ae, Me = 3 != "\n\nb".split(/\n/).length ? function (e) {
        for (var t = 0, n = [], r = e.length; t <= r;) {
          var i = e.indexOf("\n", t); - 1 == i && (i = e.length);
          var o = e.slice(t, "\r" == e.charAt(i - 1) ? i - 1 : i),
            s = o.indexOf("\r"); - 1 != s ? (n.push(o.slice(0, s)), t += s + 1) : (n.push(o), t = i + 1)
        }
        return n
      } : function (e) {
        return e.split(/\r\n?|\n/)
      },
      Pe = window.getSelection ? function (e) {
        try {
          return e.selectionStart != e.selectionEnd
        } catch (e) {
          return !1
        }
      } : function (e) {
        var t;
        try {
          t = e.ownerDocument.selection.createRange()
        } catch (e) {}
        return !(!t || t.parentElement() != e) && 0 != t.compareEndPoints("StartToEnd", t)
      },
      Ie = "oncopy" in (Ae = _("div")) || (Ae.setAttribute("oncopy", "return;"), "function" == typeof Ae.oncopy),
      Oe = null,
      Le = {},
      Ne = {};

    function Fe(e, t) {
      arguments.length > 2 && (t.dependencies = Array.prototype.slice.call(arguments, 2)), Le[e] = t
    }

    function Be(e) {
      if ("string" == typeof e && Ne.hasOwnProperty(e)) e = Ne[e];
      else if (e && "string" == typeof e.name && Ne.hasOwnProperty(e.name)) {
        var t = Ne[e.name];
        "string" == typeof t && (t = {
          name: t
        }), (e = Z(t, e)).name = t.name
      } else {
        if ("string" == typeof e && /^[\w\-]+\/[\w\-]+\+xml$/.test(e)) return Be("application/xml");
        if ("string" == typeof e && /^[\w\-]+\/[\w\-]+\+json$/.test(e)) return Be("application/json")
      }
      return "string" == typeof e ? {
        name: e
      } : e || {
        name: "null"
      }
    }

    function He(e, t) {
      t = Be(t);
      var n = Le[t.name];
      if (!n) return He(e, "text/plain");
      var r = n(e, t);
      if (ze.hasOwnProperty(t.name)) {
        var i = ze[t.name];
        for (var o in i) i.hasOwnProperty(o) && (r.hasOwnProperty(o) && (r["_" + o] = r[o]), r[o] = i[o])
      }
      if (r.name = t.name, t.helperType && (r.helperType = t.helperType), t.modeProps)
        for (var s in t.modeProps) r[s] = t.modeProps[s];
      return r
    }
    var ze = {};

    function Ue(e, t) {
      F(t, ze.hasOwnProperty(e) ? ze[e] : ze[e] = {})
    }

    function We(e, t) {
      if (!0 === t) return t;
      if (e.copyState) return e.copyState(t);
      var n = {};
      for (var r in t) {
        var i = t[r];
        i instanceof Array && (i = i.concat([])), n[r] = i
      }
      return n
    }

    function Ve(e, t) {
      for (var n; e.innerMode && (n = e.innerMode(t)) && n.mode != e;) t = n.state, e = n.mode;
      return n || {
        mode: e,
        state: t
      }
    }

    function je(e, t, n) {
      return !e.startState || e.startState(t, n)
    }
    var Ge = function (e, t, n) {
      this.pos = this.start = 0, this.string = e, this.tabSize = t || 8, this.lastColumnPos = this.lastColumnValue = 0, this.lineStart = 0, this.lineOracle = n
    };

    function $e(e, t) {
      if ((t -= e.first) < 0 || t >= e.size) throw new Error("There is no line " + (t + e.first) + " in the document.");
      for (var n = e; !n.lines;)
        for (var r = 0;; ++r) {
          var i = n.children[r],
            o = i.chunkSize();
          if (t < o) {
            n = i;
            break
          }
          t -= o
        }
      return n.lines[t]
    }

    function qe(e, t, n) {
      var r = [],
        i = t.line;
      return e.iter(t.line, n.line + 1, (function (e) {
        var o = e.text;
        i == n.line && (o = o.slice(0, n.ch)), i == t.line && (o = o.slice(t.ch)), r.push(o), ++i
      })), r
    }

    function Ke(e, t, n) {
      var r = [];
      return e.iter(t, n, (function (e) {
        r.push(e.text)
      })), r
    }

    function Ye(e, t) {
      var n = t - e.height;
      if (n)
        for (var r = e; r; r = r.parent) r.height += n
    }

    function Qe(e) {
      if (null == e.parent) return null;
      for (var t = e.parent, n = z(t.lines, e), r = t.parent; r; t = r, r = r.parent)
        for (var i = 0; r.children[i] != t; ++i) n += r.children[i].chunkSize();
      return n + t.first
    }

    function Ze(e, t) {
      var n = e.first;
      e: do {
        for (var r = 0; r < e.children.length; ++r) {
          var i = e.children[r],
            o = i.height;
          if (t < o) {
            e = i;
            continue e
          }
          t -= o, n += i.chunkSize()
        }
        return n
      } while (!e.lines);
      for (var s = 0; s < e.lines.length; ++s) {
        var a = e.lines[s].height;
        if (t < a) break;
        t -= a
      }
      return n + s
    }

    function Xe(e, t) {
      return t >= e.first && t < e.first + e.size
    }

    function Je(e, t) {
      return String(e.lineNumberFormatter(t + e.firstLineNumber))
    }

    function et(e, t, n) {
      if (void 0 === n && (n = null), !(this instanceof et)) return new et(e, t, n);
      this.line = e, this.ch = t, this.sticky = n
    }

    function tt(e, t) {
      return e.line - t.line || e.ch - t.ch
    }

    function nt(e, t) {
      return e.sticky == t.sticky && 0 == tt(e, t)
    }

    function rt(e) {
      return et(e.line, e.ch)
    }

    function it(e, t) {
      return tt(e, t) < 0 ? t : e
    }

    function ot(e, t) {
      return tt(e, t) < 0 ? e : t
    }

    function st(e, t) {
      return Math.max(e.first, Math.min(t, e.first + e.size - 1))
    }

    function at(e, t) {
      if (t.line < e.first) return et(e.first, 0);
      var n = e.first + e.size - 1;
      return t.line > n ? et(n, $e(e, n).text.length) : function (e, t) {
        var n = e.ch;
        return null == n || n > t ? et(e.line, t) : n < 0 ? et(e.line, 0) : e
      }(t, $e(e, t.line).text.length)
    }

    function lt(e, t) {
      for (var n = [], r = 0; r < t.length; r++) n[r] = at(e, t[r]);
      return n
    }
    Ge.prototype.eol = function () {
      return this.pos >= this.string.length
    }, Ge.prototype.sol = function () {
      return this.pos == this.lineStart
    }, Ge.prototype.peek = function () {
      return this.string.charAt(this.pos) || void 0
    }, Ge.prototype.next = function () {
      if (this.pos < this.string.length) return this.string.charAt(this.pos++)
    }, Ge.prototype.eat = function (e) {
      var t = this.string.charAt(this.pos);
      if ("string" == typeof e ? t == e : t && (e.test ? e.test(t) : e(t))) return ++this.pos, t
    }, Ge.prototype.eatWhile = function (e) {
      for (var t = this.pos; this.eat(e););
      return this.pos > t
    }, Ge.prototype.eatSpace = function () {
      for (var e = this.pos;
        /[\s\u00a0]/.test(this.string.charAt(this.pos));) ++this.pos;
      return this.pos > e
    }, Ge.prototype.skipToEnd = function () {
      this.pos = this.string.length
    }, Ge.prototype.skipTo = function (e) {
      var t = this.string.indexOf(e, this.pos);
      if (t > -1) return this.pos = t, !0
    }, Ge.prototype.backUp = function (e) {
      this.pos -= e
    }, Ge.prototype.column = function () {
      return this.lastColumnPos < this.start && (this.lastColumnValue = B(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue), this.lastColumnPos = this.start), this.lastColumnValue - (this.lineStart ? B(this.string, this.lineStart, this.tabSize) : 0)
    }, Ge.prototype.indentation = function () {
      return B(this.string, null, this.tabSize) - (this.lineStart ? B(this.string, this.lineStart, this.tabSize) : 0)
    }, Ge.prototype.match = function (e, t, n) {
      if ("string" != typeof e) {
        var r = this.string.slice(this.pos).match(e);
        return r && r.index > 0 ? null : (r && !1 !== t && (this.pos += r[0].length), r)
      }
      var i = function (e) {
        return n ? e.toLowerCase() : e
      };
      if (i(this.string.substr(this.pos, e.length)) == i(e)) return !1 !== t && (this.pos += e.length), !0
    }, Ge.prototype.current = function () {
      return this.string.slice(this.start, this.pos)
    }, Ge.prototype.hideFirstChars = function (e, t) {
      this.lineStart += e;
      try {
        return t()
      } finally {
        this.lineStart -= e
      }
    }, Ge.prototype.lookAhead = function (e) {
      var t = this.lineOracle;
      return t && t.lookAhead(e)
    }, Ge.prototype.baseToken = function () {
      var e = this.lineOracle;
      return e && e.baseToken(this.pos)
    };
    var ct = function (e, t) {
        this.state = e, this.lookAhead = t
      },
      ut = function (e, t, n, r) {
        this.state = t, this.doc = e, this.line = n, this.maxLookAhead = r || 0, this.baseTokens = null, this.baseTokenPos = 1
      };

    function ht(e, t, n, r) {
      var i = [e.state.modeGen],
        o = {};
      bt(e, t.text, e.doc.mode, n, (function (e, t) {
        return i.push(e, t)
      }), o, r);
      for (var s = n.state, a = function (r) {
          n.baseTokens = i;
          var a = e.state.overlays[r],
            l = 1,
            c = 0;
          n.state = !0, bt(e, t.text, a.mode, n, (function (e, t) {
            for (var n = l; c < e;) {
              var r = i[l];
              r > e && i.splice(l, 1, e, i[l + 1], r), l += 2, c = Math.min(e, r)
            }
            if (t)
              if (a.opaque) i.splice(n, l - n, e, "overlay " + t), l = n + 2;
              else
                for (; n < l; n += 2) {
                  var o = i[n + 1];
                  i[n + 1] = (o ? o + " " : "") + "overlay " + t
                }
          }), o), n.state = s, n.baseTokens = null, n.baseTokenPos = 1
        }, l = 0; l < e.state.overlays.length; ++l) a(l);
      return {
        styles: i,
        classes: o.bgClass || o.textClass ? o : null
      }
    }

    function pt(e, t, n) {
      if (!t.styles || t.styles[0] != e.state.modeGen) {
        var r = dt(e, Qe(t)),
          i = t.text.length > e.options.maxHighlightLength && We(e.doc.mode, r.state),
          o = ht(e, t, r);
        i && (r.state = i), t.stateAfter = r.save(!i), t.styles = o.styles, o.classes ? t.styleClasses = o.classes : t.styleClasses && (t.styleClasses = null), n === e.doc.highlightFrontier && (e.doc.modeFrontier = Math.max(e.doc.modeFrontier, ++e.doc.highlightFrontier))
      }
      return t.styles
    }

    function dt(e, t, n) {
      var r = e.doc,
        i = e.display;
      if (!r.mode.startState) return new ut(r, !0, t);
      var o = function (e, t, n) {
          for (var r, i, o = e.doc, s = n ? -1 : t - (e.doc.mode.innerMode ? 1e3 : 100), a = t; a > s; --a) {
            if (a <= o.first) return o.first;
            var l = $e(o, a - 1),
              c = l.stateAfter;
            if (c && (!n || a + (c instanceof ct ? c.lookAhead : 0) <= o.modeFrontier)) return a;
            var u = B(l.text, null, e.options.tabSize);
            (null == i || r > u) && (i = a - 1, r = u)
          }
          return i
        }(e, t, n),
        s = o > r.first && $e(r, o - 1).stateAfter,
        a = s ? ut.fromSaved(r, s, o) : new ut(r, je(r.mode), o);
      return r.iter(o, t, (function (n) {
        ft(e, n.text, a);
        var r = a.line;
        n.stateAfter = r == t - 1 || r % 5 == 0 || r >= i.viewFrom && r < i.viewTo ? a.save() : null, a.nextLine()
      })), n && (r.modeFrontier = a.line), a
    }

    function ft(e, t, n, r) {
      var i = e.doc.mode,
        o = new Ge(t, e.options.tabSize, n);
      for (o.start = o.pos = r || 0, "" == t && mt(i, n.state); !o.eol();) gt(i, o, n.state), o.start = o.pos
    }

    function mt(e, t) {
      if (e.blankLine) return e.blankLine(t);
      if (e.innerMode) {
        var n = Ve(e, t);
        return n.mode.blankLine ? n.mode.blankLine(n.state) : void 0
      }
    }

    function gt(e, t, n, r) {
      for (var i = 0; i < 10; i++) {
        r && (r[0] = Ve(e, n).mode);
        var o = e.token(t, n);
        if (t.pos > t.start) return o
      }
      throw new Error("Mode " + e.name + " failed to advance stream.")
    }
    ut.prototype.lookAhead = function (e) {
      var t = this.doc.getLine(this.line + e);
      return null != t && e > this.maxLookAhead && (this.maxLookAhead = e), t
    }, ut.prototype.baseToken = function (e) {
      if (!this.baseTokens) return null;
      for (; this.baseTokens[this.baseTokenPos] <= e;) this.baseTokenPos += 2;
      var t = this.baseTokens[this.baseTokenPos + 1];
      return {
        type: t && t.replace(/( |^)overlay .*/, ""),
        size: this.baseTokens[this.baseTokenPos] - e
      }
    }, ut.prototype.nextLine = function () {
      this.line++, this.maxLookAhead > 0 && this.maxLookAhead--
    }, ut.fromSaved = function (e, t, n) {
      return t instanceof ct ? new ut(e, We(e.mode, t.state), n, t.lookAhead) : new ut(e, We(e.mode, t), n)
    }, ut.prototype.save = function (e) {
      var t = !1 !== e ? We(this.doc.mode, this.state) : this.state;
      return this.maxLookAhead > 0 ? new ct(t, this.maxLookAhead) : t
    };
    var yt = function (e, t, n) {
      this.start = e.start, this.end = e.pos, this.string = e.current(), this.type = t || null, this.state = n
    };

    function vt(e, t, n, r) {
      var i, o, s = e.doc,
        a = s.mode,
        l = $e(s, (t = at(s, t)).line),
        c = dt(e, t.line, n),
        u = new Ge(l.text, e.options.tabSize, c);
      for (r && (o = []);
        (r || u.pos < t.ch) && !u.eol();) u.start = u.pos, i = gt(a, u, c.state), r && o.push(new yt(u, i, We(s.mode, c.state)));
      return r ? o : new yt(u, i, c.state)
    }

    function wt(e, t) {
      if (e)
        for (;;) {
          var n = e.match(/(?:^|\s+)line-(background-)?(\S+)/);
          if (!n) break;
          e = e.slice(0, n.index) + e.slice(n.index + n[0].length);
          var r = n[1] ? "bgClass" : "textClass";
          null == t[r] ? t[r] = n[2] : new RegExp("(?:^|s)" + n[2] + "(?:$|s)").test(t[r]) || (t[r] += " " + n[2])
        }
      return e
    }

    function bt(e, t, n, r, i, o, s) {
      var a = n.flattenSpans;
      null == a && (a = e.options.flattenSpans);
      var l, c = 0,
        u = null,
        h = new Ge(t, e.options.tabSize, r),
        p = e.options.addModeClass && [null];
      for ("" == t && wt(mt(n, r.state), o); !h.eol();) {
        if (h.pos > e.options.maxHighlightLength ? (a = !1, s && ft(e, t, r, h.pos), h.pos = t.length, l = null) : l = wt(gt(n, h, r.state, p), o), p) {
          var d = p[0].name;
          d && (l = "m-" + (l ? d + " " + l : d))
        }
        if (!a || u != l) {
          for (; c < h.start;) i(c = Math.min(h.start, c + 5e3), u);
          u = l
        }
        h.start = h.pos
      }
      for (; c < h.pos;) {
        var f = Math.min(h.pos, c + 5e3);
        i(f, u), c = f
      }
    }
    var St = !1,
      Ct = !1;

    function Et(e, t, n) {
      this.marker = e, this.from = t, this.to = n
    }

    function kt(e, t) {
      if (e)
        for (var n = 0; n < e.length; ++n) {
          var r = e[n];
          if (r.marker == t) return r
        }
    }

    function xt(e, t) {
      for (var n, r = 0; r < e.length; ++r) e[r] != t && (n || (n = [])).push(e[r]);
      return n
    }

    function Tt(e, t) {
      if (t.full) return null;
      var n = Xe(e, t.from.line) && $e(e, t.from.line).markedSpans,
        r = Xe(e, t.to.line) && $e(e, t.to.line).markedSpans;
      if (!n && !r) return null;
      var i = t.from.ch,
        o = t.to.ch,
        s = 0 == tt(t.from, t.to),
        a = function (e, t, n) {
          var r;
          if (e)
            for (var i = 0; i < e.length; ++i) {
              var o = e[i],
                s = o.marker;
              if (null == o.from || (s.inclusiveLeft ? o.from <= t : o.from < t) || o.from == t && "bookmark" == s.type && (!n || !o.marker.insertLeft)) {
                var a = null == o.to || (s.inclusiveRight ? o.to >= t : o.to > t);
                (r || (r = [])).push(new Et(s, o.from, a ? null : o.to))
              }
            }
          return r
        }(n, i, s),
        l = function (e, t, n) {
          var r;
          if (e)
            for (var i = 0; i < e.length; ++i) {
              var o = e[i],
                s = o.marker;
              if (null == o.to || (s.inclusiveRight ? o.to >= t : o.to > t) || o.from == t && "bookmark" == s.type && (!n || o.marker.insertLeft)) {
                var a = null == o.from || (s.inclusiveLeft ? o.from <= t : o.from < t);
                (r || (r = [])).push(new Et(s, a ? null : o.from - t, null == o.to ? null : o.to - t))
              }
            }
          return r
        }(r, o, s),
        c = 1 == t.text.length,
        u = K(t.text).length + (c ? i : 0);
      if (a)
        for (var h = 0; h < a.length; ++h) {
          var p = a[h];
          if (null == p.to) {
            var d = kt(l, p.marker);
            d ? c && (p.to = null == d.to ? null : d.to + u) : p.to = i
          }
        }
      if (l)
        for (var f = 0; f < l.length; ++f) {
          var m = l[f];
          null != m.to && (m.to += u), null == m.from ? kt(a, m.marker) || (m.from = u, c && (a || (a = [])).push(m)) : (m.from += u, c && (a || (a = [])).push(m))
        }
      a && (a = Rt(a)), l && l != a && (l = Rt(l));
      var g = [a];
      if (!c) {
        var y, v = t.text.length - 2;
        if (v > 0 && a)
          for (var w = 0; w < a.length; ++w) null == a[w].to && (y || (y = [])).push(new Et(a[w].marker, null, null));
        for (var b = 0; b < v; ++b) g.push(y);
        g.push(l)
      }
      return g
    }

    function Rt(e) {
      for (var t = 0; t < e.length; ++t) {
        var n = e[t];
        null != n.from && n.from == n.to && !1 !== n.marker.clearWhenEmpty && e.splice(t--, 1)
      }
      return e.length ? e : null
    }

    function Dt(e) {
      var t = e.markedSpans;
      if (t) {
        for (var n = 0; n < t.length; ++n) t[n].marker.detachLine(e);
        e.markedSpans = null
      }
    }

    function _t(e, t) {
      if (t) {
        for (var n = 0; n < t.length; ++n) t[n].marker.attachLine(e);
        e.markedSpans = t
      }
    }

    function At(e) {
      return e.inclusiveLeft ? -1 : 0
    }

    function Mt(e) {
      return e.inclusiveRight ? 1 : 0
    }

    function Pt(e, t) {
      var n = e.lines.length - t.lines.length;
      if (0 != n) return n;
      var r = e.find(),
        i = t.find(),
        o = tt(r.from, i.from) || At(e) - At(t);
      if (o) return -o;
      var s = tt(r.to, i.to) || Mt(e) - Mt(t);
      return s || t.id - e.id
    }

    function It(e, t) {
      var n, r = Ct && e.markedSpans;
      if (r)
        for (var i = void 0, o = 0; o < r.length; ++o)(i = r[o]).marker.collapsed && null == (t ? i.from : i.to) && (!n || Pt(n, i.marker) < 0) && (n = i.marker);
      return n
    }

    function Ot(e) {
      return It(e, !0)
    }

    function Lt(e) {
      return It(e, !1)
    }

    function Nt(e, t) {
      var n, r = Ct && e.markedSpans;
      if (r)
        for (var i = 0; i < r.length; ++i) {
          var o = r[i];
          o.marker.collapsed && (null == o.from || o.from < t) && (null == o.to || o.to > t) && (!n || Pt(n, o.marker) < 0) && (n = o.marker)
        }
      return n
    }

    function Ft(e, t, n, r, i) {
      var o = $e(e, t),
        s = Ct && o.markedSpans;
      if (s)
        for (var a = 0; a < s.length; ++a) {
          var l = s[a];
          if (l.marker.collapsed) {
            var c = l.marker.find(0),
              u = tt(c.from, n) || At(l.marker) - At(i),
              h = tt(c.to, r) || Mt(l.marker) - Mt(i);
            if (!(u >= 0 && h <= 0 || u <= 0 && h >= 0) && (u <= 0 && (l.marker.inclusiveRight && i.inclusiveLeft ? tt(c.to, n) >= 0 : tt(c.to, n) > 0) || u >= 0 && (l.marker.inclusiveRight && i.inclusiveLeft ? tt(c.from, r) <= 0 : tt(c.from, r) < 0))) return !0
          }
        }
    }

    function Bt(e) {
      for (var t; t = Ot(e);) e = t.find(-1, !0).line;
      return e
    }

    function Ht(e, t) {
      var n = $e(e, t),
        r = Bt(n);
      return n == r ? t : Qe(r)
    }

    function zt(e, t) {
      if (t > e.lastLine()) return t;
      var n, r = $e(e, t);
      if (!Ut(e, r)) return t;
      for (; n = Lt(r);) r = n.find(1, !0).line;
      return Qe(r) + 1
    }

    function Ut(e, t) {
      var n = Ct && t.markedSpans;
      if (n)
        for (var r = void 0, i = 0; i < n.length; ++i)
          if ((r = n[i]).marker.collapsed) {
            if (null == r.from) return !0;
            if (!r.marker.widgetNode && 0 == r.from && r.marker.inclusiveLeft && Wt(e, t, r)) return !0
          }
    }

    function Wt(e, t, n) {
      if (null == n.to) {
        var r = n.marker.find(1, !0);
        return Wt(e, r.line, kt(r.line.markedSpans, n.marker))
      }
      if (n.marker.inclusiveRight && n.to == t.text.length) return !0;
      for (var i = void 0, o = 0; o < t.markedSpans.length; ++o)
        if ((i = t.markedSpans[o]).marker.collapsed && !i.marker.widgetNode && i.from == n.to && (null == i.to || i.to != n.from) && (i.marker.inclusiveLeft || n.marker.inclusiveRight) && Wt(e, t, i)) return !0
    }

    function Vt(e) {
      for (var t = 0, n = (e = Bt(e)).parent, r = 0; r < n.lines.length; ++r) {
        var i = n.lines[r];
        if (i == e) break;
        t += i.height
      }
      for (var o = n.parent; o; o = (n = o).parent)
        for (var s = 0; s < o.children.length; ++s) {
          var a = o.children[s];
          if (a == n) break;
          t += a.height
        }
      return t
    }

    function jt(e) {
      if (0 == e.height) return 0;
      for (var t, n = e.text.length, r = e; t = Ot(r);) {
        var i = t.find(0, !0);
        r = i.from.line, n += i.from.ch - i.to.ch
      }
      for (r = e; t = Lt(r);) {
        var o = t.find(0, !0);
        n -= r.text.length - o.from.ch, n += (r = o.to.line).text.length - o.to.ch
      }
      return n
    }

    function Gt(e) {
      var t = e.display,
        n = e.doc;
      t.maxLine = $e(n, n.first), t.maxLineLength = jt(t.maxLine), t.maxLineChanged = !0, n.iter((function (e) {
        var n = jt(e);
        n > t.maxLineLength && (t.maxLineLength = n, t.maxLine = e)
      }))
    }
    var $t = function (e, t, n) {
      this.text = e, _t(this, t), this.height = n ? n(this) : 1
    };

    function qt(e) {
      e.parent = null, Dt(e)
    }
    $t.prototype.lineNo = function () {
      return Qe(this)
    }, ve($t);
    var Kt = {},
      Yt = {};

    function Qt(e, t) {
      if (!e || /^\s*$/.test(e)) return null;
      var n = t.addModeClass ? Yt : Kt;
      return n[e] || (n[e] = e.replace(/\S+/g, "cm-$&"))
    }

    function Zt(e, t) {
      var n = A("span", null, null, l ? "padding-right: .1px" : null),
        r = {
          pre: A("pre", [n], "CodeMirror-line"),
          content: n,
          col: 0,
          pos: 0,
          cm: e,
          trailingSpace: !1,
          splitSpaces: e.getOption("lineWrapping")
        };
      t.measure = {};
      for (var i = 0; i <= (t.rest ? t.rest.length : 0); i++) {
        var o = i ? t.rest[i - 1] : t.line,
          s = void 0;
        r.pos = 0, r.addToken = Jt, _e(e.display.measure) && (s = ce(o, e.doc.direction)) && (r.addToken = en(r.addToken, s)), r.map = [], nn(o, r, pt(e, o, t != e.display.externalMeasured && Qe(o))), o.styleClasses && (o.styleClasses.bgClass && (r.bgClass = O(o.styleClasses.bgClass, r.bgClass || "")), o.styleClasses.textClass && (r.textClass = O(o.styleClasses.textClass, r.textClass || ""))), 0 == r.map.length && r.map.push(0, 0, r.content.appendChild(De(e.display.measure))), 0 == i ? (t.measure.map = r.map, t.measure.cache = {}) : ((t.measure.maps || (t.measure.maps = [])).push(r.map), (t.measure.caches || (t.measure.caches = [])).push({}))
      }
      if (l) {
        var a = r.content.lastChild;
        (/\bcm-tab\b/.test(a.className) || a.querySelector && a.querySelector(".cm-tab")) && (r.content.className = "cm-tab-wrap-hack")
      }
      return fe(e, "renderLine", e, t.line, r.pre), r.pre.className && (r.textClass = O(r.pre.className, r.textClass || "")), r
    }

    function Xt(e) {
      var t = _("span", "•", "cm-invalidchar");
      return t.title = "\\u" + e.charCodeAt(0).toString(16), t.setAttribute("aria-label", t.title), t
    }

    function Jt(e, t, n, r, i, o, l) {
      if (t) {
        var c, u = e.splitSpaces ? function (e, t) {
            if (e.length > 1 && !/  /.test(e)) return e;
            for (var n = t, r = "", i = 0; i < e.length; i++) {
              var o = e.charAt(i);
              " " != o || !n || i != e.length - 1 && 32 != e.charCodeAt(i + 1) || (o = " "), r += o, n = " " == o
            }
            return r
          }(t, e.trailingSpace) : t,
          h = e.cm.state.specialChars,
          p = !1;
        if (h.test(t)) {
          c = document.createDocumentFragment();
          for (var d = 0;;) {
            h.lastIndex = d;
            var f = h.exec(t),
              m = f ? f.index - d : t.length - d;
            if (m) {
              var g = document.createTextNode(u.slice(d, d + m));
              s && a < 9 ? c.appendChild(_("span", [g])) : c.appendChild(g), e.map.push(e.pos, e.pos + m, g), e.col += m, e.pos += m
            }
            if (!f) break;
            d += m + 1;
            var y = void 0;
            if ("\t" == f[0]) {
              var v = e.cm.options.tabSize,
                w = v - e.col % v;
              (y = c.appendChild(_("span", q(w), "cm-tab"))).setAttribute("role", "presentation"), y.setAttribute("cm-text", "\t"), e.col += w
            } else "\r" == f[0] || "\n" == f[0] ? ((y = c.appendChild(_("span", "\r" == f[0] ? "␍" : "␤", "cm-invalidchar"))).setAttribute("cm-text", f[0]), e.col += 1) : ((y = e.cm.options.specialCharPlaceholder(f[0])).setAttribute("cm-text", f[0]), s && a < 9 ? c.appendChild(_("span", [y])) : c.appendChild(y), e.col += 1);
            e.map.push(e.pos, e.pos + 1, y), e.pos++
          }
        } else e.col += t.length, c = document.createTextNode(u), e.map.push(e.pos, e.pos + t.length, c), s && a < 9 && (p = !0), e.pos += t.length;
        if (e.trailingSpace = 32 == u.charCodeAt(t.length - 1), n || r || i || p || o) {
          var b = n || "";
          r && (b += r), i && (b += i);
          var S = _("span", [c], b, o);
          if (l)
            for (var C in l) l.hasOwnProperty(C) && "style" != C && "class" != C && S.setAttribute(C, l[C]);
          return e.content.appendChild(S)
        }
        e.content.appendChild(c)
      }
    }

    function en(e, t) {
      return function (n, r, i, o, s, a, l) {
        i = i ? i + " cm-force-border" : "cm-force-border";
        for (var c = n.pos, u = c + r.length;;) {
          for (var h = void 0, p = 0; p < t.length && !((h = t[p]).to > c && h.from <= c); p++);
          if (h.to >= u) return e(n, r, i, o, s, a, l);
          e(n, r.slice(0, h.to - c), i, o, null, a, l), o = null, r = r.slice(h.to - c), c = h.to
        }
      }
    }

    function tn(e, t, n, r) {
      var i = !r && n.widgetNode;
      i && e.map.push(e.pos, e.pos + t, i), !r && e.cm.display.input.needsContentAttribute && (i || (i = e.content.appendChild(document.createElement("span"))), i.setAttribute("cm-marker", n.id)), i && (e.cm.display.input.setUneditable(i), e.content.appendChild(i)), e.pos += t, e.trailingSpace = !1
    }

    function nn(e, t, n) {
      var r = e.markedSpans,
        i = e.text,
        o = 0;
      if (r)
        for (var s, a, l, c, u, h, p, d = i.length, f = 0, m = 1, g = "", y = 0;;) {
          if (y == f) {
            l = c = u = a = "", p = null, h = null, y = 1 / 0;
            for (var v = [], w = void 0, b = 0; b < r.length; ++b) {
              var S = r[b],
                C = S.marker;
              if ("bookmark" == C.type && S.from == f && C.widgetNode) v.push(C);
              else if (S.from <= f && (null == S.to || S.to > f || C.collapsed && S.to == f && S.from == f)) {
                if (null != S.to && S.to != f && y > S.to && (y = S.to, c = ""), C.className && (l += " " + C.className), C.css && (a = (a ? a + ";" : "") + C.css), C.startStyle && S.from == f && (u += " " + C.startStyle), C.endStyle && S.to == y && (w || (w = [])).push(C.endStyle, S.to), C.title && ((p || (p = {})).title = C.title), C.attributes)
                  for (var E in C.attributes)(p || (p = {}))[E] = C.attributes[E];
                C.collapsed && (!h || Pt(h.marker, C) < 0) && (h = S)
              } else S.from > f && y > S.from && (y = S.from)
            }
            if (w)
              for (var k = 0; k < w.length; k += 2) w[k + 1] == y && (c += " " + w[k]);
            if (!h || h.from == f)
              for (var x = 0; x < v.length; ++x) tn(t, 0, v[x]);
            if (h && (h.from || 0) == f) {
              if (tn(t, (null == h.to ? d + 1 : h.to) - f, h.marker, null == h.from), null == h.to) return;
              h.to == f && (h = !1)
            }
          }
          if (f >= d) break;
          for (var T = Math.min(d, y);;) {
            if (g) {
              var R = f + g.length;
              if (!h) {
                var D = R > T ? g.slice(0, T - f) : g;
                t.addToken(t, D, s ? s + l : l, u, f + D.length == y ? c : "", a, p)
              }
              if (R >= T) {
                g = g.slice(T - f), f = T;
                break
              }
              f = R, u = ""
            }
            g = i.slice(o, o = n[m++]), s = Qt(n[m++], t.cm.options)
          }
        } else
          for (var _ = 1; _ < n.length; _ += 2) t.addToken(t, i.slice(o, o = n[_]), Qt(n[_ + 1], t.cm.options))
    }

    function rn(e, t, n) {
      this.line = t, this.rest = function (e) {
        for (var t, n; t = Lt(e);) e = t.find(1, !0).line, (n || (n = [])).push(e);
        return n
      }(t), this.size = this.rest ? Qe(K(this.rest)) - n + 1 : 1, this.node = this.text = null, this.hidden = Ut(e, t)
    }

    function on(e, t, n) {
      for (var r, i = [], o = t; o < n; o = r) {
        var s = new rn(e.doc, $e(e.doc, o), o);
        r = o + s.size, i.push(s)
      }
      return i
    }
    var sn = null,
      an = null;

    function ln(e, t) {
      var n = pe(e, t);
      if (n.length) {
        var r, i = Array.prototype.slice.call(arguments, 2);
        sn ? r = sn.delayedCallbacks : an ? r = an : (r = an = [], setTimeout(cn, 0));
        for (var o = function (e) {
            r.push((function () {
              return n[e].apply(null, i)
            }))
          }, s = 0; s < n.length; ++s) o(s)
      }
    }

    function cn() {
      var e = an;
      an = null;
      for (var t = 0; t < e.length; ++t) e[t]()
    }

    function un(e, t, n, r) {
      for (var i = 0; i < t.changes.length; i++) {
        var o = t.changes[i];
        "text" == o ? dn(e, t) : "gutter" == o ? mn(e, t, n, r) : "class" == o ? fn(e, t) : "widget" == o && gn(e, t, r)
      }
      t.changes = null
    }

    function hn(e) {
      return e.node == e.text && (e.node = _("div", null, null, "position: relative"), e.text.parentNode && e.text.parentNode.replaceChild(e.node, e.text), e.node.appendChild(e.text), s && a < 8 && (e.node.style.zIndex = 2)), e.node
    }

    function pn(e, t) {
      var n = e.display.externalMeasured;
      return n && n.line == t.line ? (e.display.externalMeasured = null, t.measure = n.measure, n.built) : Zt(e, t)
    }

    function dn(e, t) {
      var n = t.text.className,
        r = pn(e, t);
      t.text == t.node && (t.node = r.pre), t.text.parentNode.replaceChild(r.pre, t.text), t.text = r.pre, r.bgClass != t.bgClass || r.textClass != t.textClass ? (t.bgClass = r.bgClass, t.textClass = r.textClass, fn(e, t)) : n && (t.text.className = n)
    }

    function fn(e, t) {
      ! function (e, t) {
        var n = t.bgClass ? t.bgClass + " " + (t.line.bgClass || "") : t.line.bgClass;
        if (n && (n += " CodeMirror-linebackground"), t.background) n ? t.background.className = n : (t.background.parentNode.removeChild(t.background), t.background = null);
        else if (n) {
          var r = hn(t);
          t.background = r.insertBefore(_("div", null, n), r.firstChild), e.display.input.setUneditable(t.background)
        }
      }(e, t), t.line.wrapClass ? hn(t).className = t.line.wrapClass : t.node != t.text && (t.node.className = "");
      var n = t.textClass ? t.textClass + " " + (t.line.textClass || "") : t.line.textClass;
      t.text.className = n || ""
    }

    function mn(e, t, n, r) {
      if (t.gutter && (t.node.removeChild(t.gutter), t.gutter = null), t.gutterBackground && (t.node.removeChild(t.gutterBackground), t.gutterBackground = null), t.line.gutterClass) {
        var i = hn(t);
        t.gutterBackground = _("div", null, "CodeMirror-gutter-background " + t.line.gutterClass, "left: " + (e.options.fixedGutter ? r.fixedPos : -r.gutterTotalWidth) + "px; width: " + r.gutterTotalWidth + "px"), e.display.input.setUneditable(t.gutterBackground), i.insertBefore(t.gutterBackground, t.text)
      }
      var o = t.line.gutterMarkers;
      if (e.options.lineNumbers || o) {
        var s = hn(t),
          a = t.gutter = _("div", null, "CodeMirror-gutter-wrapper", "left: " + (e.options.fixedGutter ? r.fixedPos : -r.gutterTotalWidth) + "px");
        if (e.display.input.setUneditable(a), s.insertBefore(a, t.text), t.line.gutterClass && (a.className += " " + t.line.gutterClass), !e.options.lineNumbers || o && o["CodeMirror-linenumbers"] || (t.lineNumber = a.appendChild(_("div", Je(e.options, n), "CodeMirror-linenumber CodeMirror-gutter-elt", "left: " + r.gutterLeft["CodeMirror-linenumbers"] + "px; width: " + e.display.lineNumInnerWidth + "px"))), o)
          for (var l = 0; l < e.display.gutterSpecs.length; ++l) {
            var c = e.display.gutterSpecs[l].className,
              u = o.hasOwnProperty(c) && o[c];
            u && a.appendChild(_("div", [u], "CodeMirror-gutter-elt", "left: " + r.gutterLeft[c] + "px; width: " + r.gutterWidth[c] + "px"))
          }
      }
    }

    function gn(e, t, n) {
      t.alignable && (t.alignable = null);
      for (var r = t.node.firstChild, i = void 0; r; r = i) i = r.nextSibling, "CodeMirror-linewidget" == r.className && t.node.removeChild(r);
      vn(e, t, n)
    }

    function yn(e, t, n, r) {
      var i = pn(e, t);
      return t.text = t.node = i.pre, i.bgClass && (t.bgClass = i.bgClass), i.textClass && (t.textClass = i.textClass), fn(e, t), mn(e, t, n, r), vn(e, t, r), t.node
    }

    function vn(e, t, n) {
      if (wn(e, t.line, t, n, !0), t.rest)
        for (var r = 0; r < t.rest.length; r++) wn(e, t.rest[r], t, n, !1)
    }

    function wn(e, t, n, r, i) {
      if (t.widgets)
        for (var o = hn(n), s = 0, a = t.widgets; s < a.length; ++s) {
          var l = a[s],
            c = _("div", [l.node], "CodeMirror-linewidget");
          l.handleMouseEvents || c.setAttribute("cm-ignore-events", "true"), bn(l, c, n, r), e.display.input.setUneditable(c), i && l.above ? o.insertBefore(c, n.gutter || n.text) : o.appendChild(c), ln(l, "redraw")
        }
    }

    function bn(e, t, n, r) {
      if (e.noHScroll) {
        (n.alignable || (n.alignable = [])).push(t);
        var i = r.wrapperWidth;
        t.style.left = r.fixedPos + "px", e.coverGutter || (i -= r.gutterTotalWidth, t.style.paddingLeft = r.gutterTotalWidth + "px"), t.style.width = i + "px"
      }
      e.coverGutter && (t.style.zIndex = 5, t.style.position = "relative", e.noHScroll || (t.style.marginLeft = -r.gutterTotalWidth + "px"))
    }

    function Sn(e) {
      if (null != e.height) return e.height;
      var t = e.doc.cm;
      if (!t) return 0;
      if (!M(document.body, e.node)) {
        var n = "position: relative;";
        e.coverGutter && (n += "margin-left: -" + t.display.gutters.offsetWidth + "px;"), e.noHScroll && (n += "width: " + t.display.wrapper.clientWidth + "px;"), D(t.display.measure, _("div", [e.node], null, n))
      }
      return e.height = e.node.parentNode.offsetHeight
    }

    function Cn(e, t) {
      for (var n = Ee(t); n != e.wrapper; n = n.parentNode)
        if (!n || 1 == n.nodeType && "true" == n.getAttribute("cm-ignore-events") || n.parentNode == e.sizer && n != e.mover) return !0
    }

    function En(e) {
      return e.lineSpace.offsetTop
    }

    function kn(e) {
      return e.mover.offsetHeight - e.lineSpace.offsetHeight
    }

    function xn(e) {
      if (e.cachedPaddingH) return e.cachedPaddingH;
      var t = D(e.measure, _("pre", "x", "CodeMirror-line-like")),
        n = window.getComputedStyle ? window.getComputedStyle(t) : t.currentStyle,
        r = {
          left: parseInt(n.paddingLeft),
          right: parseInt(n.paddingRight)
        };
      return isNaN(r.left) || isNaN(r.right) || (e.cachedPaddingH = r), r
    }

    function Tn(e) {
      return 30 - e.display.nativeBarWidth
    }

    function Rn(e) {
      return e.display.scroller.clientWidth - Tn(e) - e.display.barWidth
    }

    function Dn(e) {
      return e.display.scroller.clientHeight - Tn(e) - e.display.barHeight
    }

    function _n(e, t, n) {
      if (e.line == t) return {
        map: e.measure.map,
        cache: e.measure.cache
      };
      for (var r = 0; r < e.rest.length; r++)
        if (e.rest[r] == t) return {
          map: e.measure.maps[r],
          cache: e.measure.caches[r]
        };
      for (var i = 0; i < e.rest.length; i++)
        if (Qe(e.rest[i]) > n) return {
          map: e.measure.maps[i],
          cache: e.measure.caches[i],
          before: !0
        }
    }

    function An(e, t, n, r) {
      return In(e, Pn(e, t), n, r)
    }

    function Mn(e, t) {
      if (t >= e.display.viewFrom && t < e.display.viewTo) return e.display.view[ur(e, t)];
      var n = e.display.externalMeasured;
      return n && t >= n.lineN && t < n.lineN + n.size ? n : void 0
    }

    function Pn(e, t) {
      var n = Qe(t),
        r = Mn(e, n);
      r && !r.text ? r = null : r && r.changes && (un(e, r, n, or(e)), e.curOp.forceUpdate = !0), r || (r = function (e, t) {
        var n = Qe(t = Bt(t)),
          r = e.display.externalMeasured = new rn(e.doc, t, n);
        r.lineN = n;
        var i = r.built = Zt(e, r);
        return r.text = i.pre, D(e.display.lineMeasure, i.pre), r
      }(e, t));
      var i = _n(r, t, n);
      return {
        line: t,
        view: r,
        rect: null,
        map: i.map,
        cache: i.cache,
        before: i.before,
        hasHeights: !1
      }
    }

    function In(e, t, n, r, i) {
      t.before && (n = -1);
      var o, l = n + (r || "");
      return t.cache.hasOwnProperty(l) ? o = t.cache[l] : (t.rect || (t.rect = t.view.text.getBoundingClientRect()), t.hasHeights || (function (e, t, n) {
        var r = e.options.lineWrapping,
          i = r && Rn(e);
        if (!t.measure.heights || r && t.measure.width != i) {
          var o = t.measure.heights = [];
          if (r) {
            t.measure.width = i;
            for (var s = t.text.firstChild.getClientRects(), a = 0; a < s.length - 1; a++) {
              var l = s[a],
                c = s[a + 1];
              Math.abs(l.bottom - c.bottom) > 2 && o.push((l.bottom + c.top) / 2 - n.top)
            }
          }
          o.push(n.bottom - n.top)
        }
      }(e, t.view, t.rect), t.hasHeights = !0), (o = function (e, t, n, r) {
        var i, o = Nn(t.map, n, r),
          l = o.node,
          c = o.start,
          u = o.end,
          h = o.collapse;
        if (3 == l.nodeType) {
          for (var p = 0; p < 4; p++) {
            for (; c && re(t.line.text.charAt(o.coverStart + c));) --c;
            for (; o.coverStart + u < o.coverEnd && re(t.line.text.charAt(o.coverStart + u));) ++u;
            if ((i = s && a < 9 && 0 == c && u == o.coverEnd - o.coverStart ? l.parentNode.getBoundingClientRect() : Fn(x(l, c, u).getClientRects(), r)).left || i.right || 0 == c) break;
            u = c, c -= 1, h = "right"
          }
          s && a < 11 && (i = function (e, t) {
            if (!window.screen || null == screen.logicalXDPI || screen.logicalXDPI == screen.deviceXDPI || ! function (e) {
                if (null != Oe) return Oe;
                var t = D(e, _("span", "x")),
                  n = t.getBoundingClientRect(),
                  r = x(t, 0, 1).getBoundingClientRect();
                return Oe = Math.abs(n.left - r.left) > 1
              }(e)) return t;
            var n = screen.logicalXDPI / screen.deviceXDPI,
              r = screen.logicalYDPI / screen.deviceYDPI;
            return {
              left: t.left * n,
              right: t.right * n,
              top: t.top * r,
              bottom: t.bottom * r
            }
          }(e.display.measure, i))
        } else {
          var d;
          c > 0 && (h = r = "right"), i = e.options.lineWrapping && (d = l.getClientRects()).length > 1 ? d["right" == r ? d.length - 1 : 0] : l.getBoundingClientRect()
        }
        if (s && a < 9 && !c && (!i || !i.left && !i.right)) {
          var f = l.parentNode.getClientRects()[0];
          i = f ? {
            left: f.left,
            right: f.left + ir(e.display),
            top: f.top,
            bottom: f.bottom
          } : Ln
        }
        for (var m = i.top - t.rect.top, g = i.bottom - t.rect.top, y = (m + g) / 2, v = t.view.measure.heights, w = 0; w < v.length - 1 && !(y < v[w]); w++);
        var b = w ? v[w - 1] : 0,
          S = v[w],
          C = {
            left: ("right" == h ? i.right : i.left) - t.rect.left,
            right: ("left" == h ? i.left : i.right) - t.rect.left,
            top: b,
            bottom: S
          };
        return i.left || i.right || (C.bogus = !0), e.options.singleCursorHeightPerLine || (C.rtop = m, C.rbottom = g), C
      }(e, t, n, r)).bogus || (t.cache[l] = o)), {
        left: o.left,
        right: o.right,
        top: i ? o.rtop : o.top,
        bottom: i ? o.rbottom : o.bottom
      }
    }
    var On, Ln = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    };

    function Nn(e, t, n) {
      for (var r, i, o, s, a, l, c = 0; c < e.length; c += 3)
        if (a = e[c], l = e[c + 1], t < a ? (i = 0, o = 1, s = "left") : t < l ? o = 1 + (i = t - a) : (c == e.length - 3 || t == l && e[c + 3] > t) && (i = (o = l - a) - 1, t >= l && (s = "right")), null != i) {
          if (r = e[c + 2], a == l && n == (r.insertLeft ? "left" : "right") && (s = n), "left" == n && 0 == i)
            for (; c && e[c - 2] == e[c - 3] && e[c - 1].insertLeft;) r = e[2 + (c -= 3)], s = "left";
          if ("right" == n && i == l - a)
            for (; c < e.length - 3 && e[c + 3] == e[c + 4] && !e[c + 5].insertLeft;) r = e[(c += 3) + 2], s = "right";
          break
        } return {
        node: r,
        start: i,
        end: o,
        collapse: s,
        coverStart: a,
        coverEnd: l
      }
    }

    function Fn(e, t) {
      var n = Ln;
      if ("left" == t)
        for (var r = 0; r < e.length && (n = e[r]).left == n.right; r++);
      else
        for (var i = e.length - 1; i >= 0 && (n = e[i]).left == n.right; i--);
      return n
    }

    function Bn(e) {
      if (e.measure && (e.measure.cache = {}, e.measure.heights = null, e.rest))
        for (var t = 0; t < e.rest.length; t++) e.measure.caches[t] = {}
    }

    function Hn(e) {
      e.display.externalMeasure = null, R(e.display.lineMeasure);
      for (var t = 0; t < e.display.view.length; t++) Bn(e.display.view[t])
    }

    function zn(e) {
      Hn(e), e.display.cachedCharWidth = e.display.cachedTextHeight = e.display.cachedPaddingH = null, e.options.lineWrapping || (e.display.maxLineChanged = !0), e.display.lineNumChars = null
    }

    function Un() {
      return u && g ? -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft)) : window.pageXOffset || (document.documentElement || document.body).scrollLeft
    }

    function Wn() {
      return u && g ? -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop)) : window.pageYOffset || (document.documentElement || document.body).scrollTop
    }

    function Vn(e) {
      var t = 0;
      if (e.widgets)
        for (var n = 0; n < e.widgets.length; ++n) e.widgets[n].above && (t += Sn(e.widgets[n]));
      return t
    }

    function jn(e, t, n, r, i) {
      if (!i) {
        var o = Vn(t);
        n.top += o, n.bottom += o
      }
      if ("line" == r) return n;
      r || (r = "local");
      var s = Vt(t);
      if ("local" == r ? s += En(e.display) : s -= e.display.viewOffset, "page" == r || "window" == r) {
        var a = e.display.lineSpace.getBoundingClientRect();
        s += a.top + ("window" == r ? 0 : Wn());
        var l = a.left + ("window" == r ? 0 : Un());
        n.left += l, n.right += l
      }
      return n.top += s, n.bottom += s, n
    }

    function Gn(e, t, n) {
      if ("div" == n) return t;
      var r = t.left,
        i = t.top;
      if ("page" == n) r -= Un(), i -= Wn();
      else if ("local" == n || !n) {
        var o = e.display.sizer.getBoundingClientRect();
        r += o.left, i += o.top
      }
      var s = e.display.lineSpace.getBoundingClientRect();
      return {
        left: r - s.left,
        top: i - s.top
      }
    }

    function $n(e, t, n, r, i) {
      return r || (r = $e(e.doc, t.line)), jn(e, r, An(e, r, t.ch, i), n)
    }

    function qn(e, t, n, r, i, o) {
      function s(t, s) {
        var a = In(e, i, t, s ? "right" : "left", o);
        return s ? a.left = a.right : a.right = a.left, jn(e, r, a, n)
      }
      r = r || $e(e.doc, t.line), i || (i = Pn(e, r));
      var a = ce(r, e.doc.direction),
        l = t.ch,
        c = t.sticky;
      if (l >= r.text.length ? (l = r.text.length, c = "before") : l <= 0 && (l = 0, c = "after"), !a) return s("before" == c ? l - 1 : l, "before" == c);

      function u(e, t, n) {
        return s(n ? e - 1 : e, 1 == a[t].level != n)
      }
      var h = ae(a, l, c),
        p = se,
        d = u(l, h, "before" == c);
      return null != p && (d.other = u(l, p, "before" != c)), d
    }

    function Kn(e, t) {
      var n = 0;
      t = at(e.doc, t), e.options.lineWrapping || (n = ir(e.display) * t.ch);
      var r = $e(e.doc, t.line),
        i = Vt(r) + En(e.display);
      return {
        left: n,
        right: n,
        top: i,
        bottom: i + r.height
      }
    }

    function Yn(e, t, n, r, i) {
      var o = et(e, t, n);
      return o.xRel = i, r && (o.outside = r), o
    }

    function Qn(e, t, n) {
      var r = e.doc;
      if ((n += e.display.viewOffset) < 0) return Yn(r.first, 0, null, -1, -1);
      var i = Ze(r, n),
        o = r.first + r.size - 1;
      if (i > o) return Yn(r.first + r.size - 1, $e(r, o).text.length, null, 1, 1);
      t < 0 && (t = 0);
      for (var s = $e(r, i);;) {
        var a = er(e, s, i, t, n),
          l = Nt(s, a.ch + (a.xRel > 0 || a.outside > 0 ? 1 : 0));
        if (!l) return a;
        var c = l.find(1);
        if (c.line == i) return c;
        s = $e(r, i = c.line)
      }
    }

    function Zn(e, t, n, r) {
      r -= Vn(t);
      var i = t.text.length,
        o = oe((function (t) {
          return In(e, n, t - 1).bottom <= r
        }), i, 0);
      return {
        begin: o,
        end: i = oe((function (t) {
          return In(e, n, t).top > r
        }), o, i)
      }
    }

    function Xn(e, t, n, r) {
      return n || (n = Pn(e, t)), Zn(e, t, n, jn(e, t, In(e, n, r), "line").top)
    }

    function Jn(e, t, n, r) {
      return !(e.bottom <= n) && (e.top > n || (r ? e.left : e.right) > t)
    }

    function er(e, t, n, r, i) {
      i -= Vt(t);
      var o = Pn(e, t),
        s = Vn(t),
        a = 0,
        l = t.text.length,
        c = !0,
        u = ce(t, e.doc.direction);
      if (u) {
        var h = (e.options.lineWrapping ? nr : tr)(e, t, n, o, u, r, i);
        a = (c = 1 != h.level) ? h.from : h.to - 1, l = c ? h.to : h.from - 1
      }
      var p, d, f = null,
        m = null,
        g = oe((function (t) {
          var n = In(e, o, t);
          return n.top += s, n.bottom += s, !!Jn(n, r, i, !1) && (n.top <= i && n.left <= r && (f = t, m = n), !0)
        }), a, l),
        y = !1;
      if (m) {
        var v = r - m.left < m.right - r,
          w = v == c;
        g = f + (w ? 0 : 1), d = w ? "after" : "before", p = v ? m.left : m.right
      } else {
        c || g != l && g != a || g++, d = 0 == g ? "after" : g == t.text.length ? "before" : In(e, o, g - (c ? 1 : 0)).bottom + s <= i == c ? "after" : "before";
        var b = qn(e, et(n, g, d), "line", t, o);
        p = b.left, y = i < b.top ? -1 : i >= b.bottom ? 1 : 0
      }
      return Yn(n, g = ie(t.text, g, 1), d, y, r - p)
    }

    function tr(e, t, n, r, i, o, s) {
      var a = oe((function (a) {
          var l = i[a],
            c = 1 != l.level;
          return Jn(qn(e, et(n, c ? l.to : l.from, c ? "before" : "after"), "line", t, r), o, s, !0)
        }), 0, i.length - 1),
        l = i[a];
      if (a > 0) {
        var c = 1 != l.level,
          u = qn(e, et(n, c ? l.from : l.to, c ? "after" : "before"), "line", t, r);
        Jn(u, o, s, !0) && u.top > s && (l = i[a - 1])
      }
      return l
    }

    function nr(e, t, n, r, i, o, s) {
      var a = Zn(e, t, r, s),
        l = a.begin,
        c = a.end;
      /\s/.test(t.text.charAt(c - 1)) && c--;
      for (var u = null, h = null, p = 0; p < i.length; p++) {
        var d = i[p];
        if (!(d.from >= c || d.to <= l)) {
          var f = In(e, r, 1 != d.level ? Math.min(c, d.to) - 1 : Math.max(l, d.from)).right,
            m = f < o ? o - f + 1e9 : f - o;
          (!u || h > m) && (u = d, h = m)
        }
      }
      return u || (u = i[i.length - 1]), u.from < l && (u = {
        from: l,
        to: u.to,
        level: u.level
      }), u.to > c && (u = {
        from: u.from,
        to: c,
        level: u.level
      }), u
    }

    function rr(e) {
      if (null != e.cachedTextHeight) return e.cachedTextHeight;
      if (null == On) {
        On = _("pre", null, "CodeMirror-line-like");
        for (var t = 0; t < 49; ++t) On.appendChild(document.createTextNode("x")), On.appendChild(_("br"));
        On.appendChild(document.createTextNode("x"))
      }
      D(e.measure, On);
      var n = On.offsetHeight / 50;
      return n > 3 && (e.cachedTextHeight = n), R(e.measure), n || 1
    }

    function ir(e) {
      if (null != e.cachedCharWidth) return e.cachedCharWidth;
      var t = _("span", "xxxxxxxxxx"),
        n = _("pre", [t], "CodeMirror-line-like");
      D(e.measure, n);
      var r = t.getBoundingClientRect(),
        i = (r.right - r.left) / 10;
      return i > 2 && (e.cachedCharWidth = i), i || 10
    }

    function or(e) {
      for (var t = e.display, n = {}, r = {}, i = t.gutters.clientLeft, o = t.gutters.firstChild, s = 0; o; o = o.nextSibling, ++s) {
        var a = e.display.gutterSpecs[s].className;
        n[a] = o.offsetLeft + o.clientLeft + i, r[a] = o.clientWidth
      }
      return {
        fixedPos: sr(t),
        gutterTotalWidth: t.gutters.offsetWidth,
        gutterLeft: n,
        gutterWidth: r,
        wrapperWidth: t.wrapper.clientWidth
      }
    }

    function sr(e) {
      return e.scroller.getBoundingClientRect().left - e.sizer.getBoundingClientRect().left
    }

    function ar(e) {
      var t = rr(e.display),
        n = e.options.lineWrapping,
        r = n && Math.max(5, e.display.scroller.clientWidth / ir(e.display) - 3);
      return function (i) {
        if (Ut(e.doc, i)) return 0;
        var o = 0;
        if (i.widgets)
          for (var s = 0; s < i.widgets.length; s++) i.widgets[s].height && (o += i.widgets[s].height);
        return n ? o + (Math.ceil(i.text.length / r) || 1) * t : o + t
      }
    }

    function lr(e) {
      var t = e.doc,
        n = ar(e);
      t.iter((function (e) {
        var t = n(e);
        t != e.height && Ye(e, t)
      }))
    }

    function cr(e, t, n, r) {
      var i = e.display;
      if (!n && "true" == Ee(t).getAttribute("cm-not-content")) return null;
      var o, s, a = i.lineSpace.getBoundingClientRect();
      try {
        o = t.clientX - a.left, s = t.clientY - a.top
      } catch (t) {
        return null
      }
      var l, c = Qn(e, o, s);
      if (r && 1 == c.xRel && (l = $e(e.doc, c.line).text).length == c.ch) {
        var u = B(l, l.length, e.options.tabSize) - l.length;
        c = et(c.line, Math.max(0, Math.round((o - xn(e.display).left) / ir(e.display)) - u))
      }
      return c
    }

    function ur(e, t) {
      if (t >= e.display.viewTo) return null;
      if ((t -= e.display.viewFrom) < 0) return null;
      for (var n = e.display.view, r = 0; r < n.length; r++)
        if ((t -= n[r].size) < 0) return r
    }

    function hr(e, t, n, r) {
      null == t && (t = e.doc.first), null == n && (n = e.doc.first + e.doc.size), r || (r = 0);
      var i = e.display;
      if (r && n < i.viewTo && (null == i.updateLineNumbers || i.updateLineNumbers > t) && (i.updateLineNumbers = t), e.curOp.viewChanged = !0, t >= i.viewTo) Ct && Ht(e.doc, t) < i.viewTo && dr(e);
      else if (n <= i.viewFrom) Ct && zt(e.doc, n + r) > i.viewFrom ? dr(e) : (i.viewFrom += r, i.viewTo += r);
      else if (t <= i.viewFrom && n >= i.viewTo) dr(e);
      else if (t <= i.viewFrom) {
        var o = fr(e, n, n + r, 1);
        o ? (i.view = i.view.slice(o.index), i.viewFrom = o.lineN, i.viewTo += r) : dr(e)
      } else if (n >= i.viewTo) {
        var s = fr(e, t, t, -1);
        s ? (i.view = i.view.slice(0, s.index), i.viewTo = s.lineN) : dr(e)
      } else {
        var a = fr(e, t, t, -1),
          l = fr(e, n, n + r, 1);
        a && l ? (i.view = i.view.slice(0, a.index).concat(on(e, a.lineN, l.lineN)).concat(i.view.slice(l.index)), i.viewTo += r) : dr(e)
      }
      var c = i.externalMeasured;
      c && (n < c.lineN ? c.lineN += r : t < c.lineN + c.size && (i.externalMeasured = null))
    }

    function pr(e, t, n) {
      e.curOp.viewChanged = !0;
      var r = e.display,
        i = e.display.externalMeasured;
      if (i && t >= i.lineN && t < i.lineN + i.size && (r.externalMeasured = null), !(t < r.viewFrom || t >= r.viewTo)) {
        var o = r.view[ur(e, t)];
        if (null != o.node) {
          var s = o.changes || (o.changes = []); - 1 == z(s, n) && s.push(n)
        }
      }
    }

    function dr(e) {
      e.display.viewFrom = e.display.viewTo = e.doc.first, e.display.view = [], e.display.viewOffset = 0
    }

    function fr(e, t, n, r) {
      var i, o = ur(e, t),
        s = e.display.view;
      if (!Ct || n == e.doc.first + e.doc.size) return {
        index: o,
        lineN: n
      };
      for (var a = e.display.viewFrom, l = 0; l < o; l++) a += s[l].size;
      if (a != t) {
        if (r > 0) {
          if (o == s.length - 1) return null;
          i = a + s[o].size - t, o++
        } else i = a - t;
        t += i, n += i
      }
      for (; Ht(e.doc, n) != n;) {
        if (o == (r < 0 ? 0 : s.length - 1)) return null;
        n += r * s[o - (r < 0 ? 1 : 0)].size, o += r
      }
      return {
        index: o,
        lineN: n
      }
    }

    function mr(e) {
      for (var t = e.display.view, n = 0, r = 0; r < t.length; r++) {
        var i = t[r];
        i.hidden || i.node && !i.changes || ++n
      }
      return n
    }

    function gr(e) {
      e.display.input.showSelection(e.display.input.prepareSelection())
    }

    function yr(e, t) {
      void 0 === t && (t = !0);
      for (var n = e.doc, r = {}, i = r.cursors = document.createDocumentFragment(), o = r.selection = document.createDocumentFragment(), s = 0; s < n.sel.ranges.length; s++)
        if (t || s != n.sel.primIndex) {
          var a = n.sel.ranges[s];
          if (!(a.from().line >= e.display.viewTo || a.to().line < e.display.viewFrom)) {
            var l = a.empty();
            (l || e.options.showCursorWhenSelecting) && vr(e, a.head, i), l || br(e, a, o)
          }
        } return r
    }

    function vr(e, t, n) {
      var r = qn(e, t, "div", null, null, !e.options.singleCursorHeightPerLine),
        i = n.appendChild(_("div", " ", "CodeMirror-cursor"));
      if (i.style.left = r.left + "px", i.style.top = r.top + "px", i.style.height = Math.max(0, r.bottom - r.top) * e.options.cursorHeight + "px", r.other) {
        var o = n.appendChild(_("div", " ", "CodeMirror-cursor CodeMirror-secondarycursor"));
        o.style.display = "", o.style.left = r.other.left + "px", o.style.top = r.other.top + "px", o.style.height = .85 * (r.other.bottom - r.other.top) + "px"
      }
    }

    function wr(e, t) {
      return e.top - t.top || e.left - t.left
    }

    function br(e, t, n) {
      var r = e.display,
        i = e.doc,
        o = document.createDocumentFragment(),
        s = xn(e.display),
        a = s.left,
        l = Math.max(r.sizerWidth, Rn(e) - r.sizer.offsetLeft) - s.right,
        c = "ltr" == i.direction;

      function u(e, t, n, r) {
        t < 0 && (t = 0), t = Math.round(t), r = Math.round(r), o.appendChild(_("div", null, "CodeMirror-selected", "position: absolute; left: " + e + "px;\n                             top: " + t + "px; width: " + (null == n ? l - e : n) + "px;\n                             height: " + (r - t) + "px"))
      }

      function h(t, n, r) {
        var o, s, h = $e(i, t),
          p = h.text.length;

        function d(n, r) {
          return $n(e, et(t, n), "div", h, r)
        }

        function f(t, n, r) {
          var i = Xn(e, h, null, t),
            o = "ltr" == n == ("after" == r) ? "left" : "right";
          return d("after" == r ? i.begin : i.end - (/\s/.test(h.text.charAt(i.end - 1)) ? 2 : 1), o)[o]
        }
        var m = ce(h, i.direction);
        return function (e, t, n, r) {
          if (!e) return r(t, n, "ltr", 0);
          for (var i = !1, o = 0; o < e.length; ++o) {
            var s = e[o];
            (s.from < n && s.to > t || t == n && s.to == t) && (r(Math.max(s.from, t), Math.min(s.to, n), 1 == s.level ? "rtl" : "ltr", o), i = !0)
          }
          i || r(t, n, "ltr")
        }(m, n || 0, null == r ? p : r, (function (e, t, i, h) {
          var g = "ltr" == i,
            y = d(e, g ? "left" : "right"),
            v = d(t - 1, g ? "right" : "left"),
            w = null == n && 0 == e,
            b = null == r && t == p,
            S = 0 == h,
            C = !m || h == m.length - 1;
          if (v.top - y.top <= 3) {
            var E = (c ? b : w) && C,
              k = (c ? w : b) && S ? a : (g ? y : v).left,
              x = E ? l : (g ? v : y).right;
            u(k, y.top, x - k, y.bottom)
          } else {
            var T, R, D, _;
            g ? (T = c && w && S ? a : y.left, R = c ? l : f(e, i, "before"), D = c ? a : f(t, i, "after"), _ = c && b && C ? l : v.right) : (T = c ? f(e, i, "before") : a, R = !c && w && S ? l : y.right, D = !c && b && C ? a : v.left, _ = c ? f(t, i, "after") : l), u(T, y.top, R - T, y.bottom), y.bottom < v.top && u(a, y.bottom, null, v.top), u(D, v.top, _ - D, v.bottom)
          }(!o || wr(y, o) < 0) && (o = y), wr(v, o) < 0 && (o = v), (!s || wr(y, s) < 0) && (s = y), wr(v, s) < 0 && (s = v)
        })), {
          start: o,
          end: s
        }
      }
      var p = t.from(),
        d = t.to();
      if (p.line == d.line) h(p.line, p.ch, d.ch);
      else {
        var f = $e(i, p.line),
          m = $e(i, d.line),
          g = Bt(f) == Bt(m),
          y = h(p.line, p.ch, g ? f.text.length + 1 : null).end,
          v = h(d.line, g ? 0 : null, d.ch).start;
        g && (y.top < v.top - 2 ? (u(y.right, y.top, null, y.bottom), u(a, v.top, v.left, v.bottom)) : u(y.right, y.top, v.left - y.right, y.bottom)), y.bottom < v.top && u(a, y.bottom, null, v.top)
      }
      n.appendChild(o)
    }

    function Sr(e) {
      if (e.state.focused) {
        var t = e.display;
        clearInterval(t.blinker);
        var n = !0;
        t.cursorDiv.style.visibility = "", e.options.cursorBlinkRate > 0 ? t.blinker = setInterval((function () {
          return t.cursorDiv.style.visibility = (n = !n) ? "" : "hidden"
        }), e.options.cursorBlinkRate) : e.options.cursorBlinkRate < 0 && (t.cursorDiv.style.visibility = "hidden")
      }
    }

    function Cr(e) {
      e.state.focused || (e.display.input.focus(), kr(e))
    }

    function Er(e) {
      e.state.delayingBlurEvent = !0, setTimeout((function () {
        e.state.delayingBlurEvent && (e.state.delayingBlurEvent = !1, xr(e))
      }), 100)
    }

    function kr(e, t) {
      e.state.delayingBlurEvent && (e.state.delayingBlurEvent = !1), "nocursor" != e.options.readOnly && (e.state.focused || (fe(e, "focus", e, t), e.state.focused = !0, I(e.display.wrapper, "CodeMirror-focused"), e.curOp || e.display.selForContextMenu == e.doc.sel || (e.display.input.reset(), l && setTimeout((function () {
        return e.display.input.reset(!0)
      }), 20)), e.display.input.receivedFocus()), Sr(e))
    }

    function xr(e, t) {
      e.state.delayingBlurEvent || (e.state.focused && (fe(e, "blur", e, t), e.state.focused = !1, T(e.display.wrapper, "CodeMirror-focused")), clearInterval(e.display.blinker), setTimeout((function () {
        e.state.focused || (e.display.shift = !1)
      }), 150))
    }

    function Tr(e) {
      for (var t = e.display, n = t.lineDiv.offsetTop, r = 0; r < t.view.length; r++) {
        var i = t.view[r],
          o = e.options.lineWrapping,
          l = void 0,
          c = 0;
        if (!i.hidden) {
          if (s && a < 8) {
            var u = i.node.offsetTop + i.node.offsetHeight;
            l = u - n, n = u
          } else {
            var h = i.node.getBoundingClientRect();
            l = h.bottom - h.top, !o && i.text.firstChild && (c = i.text.firstChild.getBoundingClientRect().right - h.left - 1)
          }
          var p = i.line.height - l;
          if ((p > .005 || p < -.005) && (Ye(i.line, l), Rr(i.line), i.rest))
            for (var d = 0; d < i.rest.length; d++) Rr(i.rest[d]);
          if (c > e.display.sizerWidth) {
            var f = Math.ceil(c / ir(e.display));
            f > e.display.maxLineLength && (e.display.maxLineLength = f, e.display.maxLine = i.line, e.display.maxLineChanged = !0)
          }
        }
      }
    }

    function Rr(e) {
      if (e.widgets)
        for (var t = 0; t < e.widgets.length; ++t) {
          var n = e.widgets[t],
            r = n.node.parentNode;
          r && (n.height = r.offsetHeight)
        }
    }

    function Dr(e, t, n) {
      var r = n && null != n.top ? Math.max(0, n.top) : e.scroller.scrollTop;
      r = Math.floor(r - En(e));
      var i = n && null != n.bottom ? n.bottom : r + e.wrapper.clientHeight,
        o = Ze(t, r),
        s = Ze(t, i);
      if (n && n.ensure) {
        var a = n.ensure.from.line,
          l = n.ensure.to.line;
        a < o ? (o = a, s = Ze(t, Vt($e(t, a)) + e.wrapper.clientHeight)) : Math.min(l, t.lastLine()) >= s && (o = Ze(t, Vt($e(t, l)) - e.wrapper.clientHeight), s = l)
      }
      return {
        from: o,
        to: Math.max(s, o + 1)
      }
    }

    function _r(e, t) {
      var n = e.display,
        r = rr(e.display);
      t.top < 0 && (t.top = 0);
      var i = e.curOp && null != e.curOp.scrollTop ? e.curOp.scrollTop : n.scroller.scrollTop,
        o = Dn(e),
        s = {};
      t.bottom - t.top > o && (t.bottom = t.top + o);
      var a = e.doc.height + kn(n),
        l = t.top < r,
        c = t.bottom > a - r;
      if (t.top < i) s.scrollTop = l ? 0 : t.top;
      else if (t.bottom > i + o) {
        var u = Math.min(t.top, (c ? a : t.bottom) - o);
        u != i && (s.scrollTop = u)
      }
      var h = e.curOp && null != e.curOp.scrollLeft ? e.curOp.scrollLeft : n.scroller.scrollLeft,
        p = Rn(e) - (e.options.fixedGutter ? n.gutters.offsetWidth : 0),
        d = t.right - t.left > p;
      return d && (t.right = t.left + p), t.left < 10 ? s.scrollLeft = 0 : t.left < h ? s.scrollLeft = Math.max(0, t.left - (d ? 0 : 10)) : t.right > p + h - 3 && (s.scrollLeft = t.right + (d ? 0 : 10) - p), s
    }

    function Ar(e, t) {
      null != t && (Ir(e), e.curOp.scrollTop = (null == e.curOp.scrollTop ? e.doc.scrollTop : e.curOp.scrollTop) + t)
    }

    function Mr(e) {
      Ir(e);
      var t = e.getCursor();
      e.curOp.scrollToPos = {
        from: t,
        to: t,
        margin: e.options.cursorScrollMargin
      }
    }

    function Pr(e, t, n) {
      null == t && null == n || Ir(e), null != t && (e.curOp.scrollLeft = t), null != n && (e.curOp.scrollTop = n)
    }

    function Ir(e) {
      var t = e.curOp.scrollToPos;
      t && (e.curOp.scrollToPos = null, Or(e, Kn(e, t.from), Kn(e, t.to), t.margin))
    }

    function Or(e, t, n, r) {
      var i = _r(e, {
        left: Math.min(t.left, n.left),
        top: Math.min(t.top, n.top) - r,
        right: Math.max(t.right, n.right),
        bottom: Math.max(t.bottom, n.bottom) + r
      });
      Pr(e, i.scrollLeft, i.scrollTop)
    }

    function Lr(e, t) {
      Math.abs(e.doc.scrollTop - t) < 2 || (n || li(e, {
        top: t
      }), Nr(e, t, !0), n && li(e), ri(e, 100))
    }

    function Nr(e, t, n) {
      t = Math.min(e.display.scroller.scrollHeight - e.display.scroller.clientHeight, t), (e.display.scroller.scrollTop != t || n) && (e.doc.scrollTop = t, e.display.scrollbars.setScrollTop(t), e.display.scroller.scrollTop != t && (e.display.scroller.scrollTop = t))
    }

    function Fr(e, t, n, r) {
      t = Math.min(t, e.display.scroller.scrollWidth - e.display.scroller.clientWidth), (n ? t == e.doc.scrollLeft : Math.abs(e.doc.scrollLeft - t) < 2) && !r || (e.doc.scrollLeft = t, hi(e), e.display.scroller.scrollLeft != t && (e.display.scroller.scrollLeft = t), e.display.scrollbars.setScrollLeft(t))
    }

    function Br(e) {
      var t = e.display,
        n = t.gutters.offsetWidth,
        r = Math.round(e.doc.height + kn(e.display));
      return {
        clientHeight: t.scroller.clientHeight,
        viewHeight: t.wrapper.clientHeight,
        scrollWidth: t.scroller.scrollWidth,
        clientWidth: t.scroller.clientWidth,
        viewWidth: t.wrapper.clientWidth,
        barLeft: e.options.fixedGutter ? n : 0,
        docHeight: r,
        scrollHeight: r + Tn(e) + t.barHeight,
        nativeBarWidth: t.nativeBarWidth,
        gutterWidth: n
      }
    }
    var Hr = function (e, t, n) {
      this.cm = n;
      var r = this.vert = _("div", [_("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar"),
        i = this.horiz = _("div", [_("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
      r.tabIndex = i.tabIndex = -1, e(r), e(i), he(r, "scroll", (function () {
        r.clientHeight && t(r.scrollTop, "vertical")
      })), he(i, "scroll", (function () {
        i.clientWidth && t(i.scrollLeft, "horizontal")
      })), this.checkedZeroWidth = !1, s && a < 8 && (this.horiz.style.minHeight = this.vert.style.minWidth = "18px")
    };
    Hr.prototype.update = function (e) {
      var t = e.scrollWidth > e.clientWidth + 1,
        n = e.scrollHeight > e.clientHeight + 1,
        r = e.nativeBarWidth;
      if (n) {
        this.vert.style.display = "block", this.vert.style.bottom = t ? r + "px" : "0";
        var i = e.viewHeight - (t ? r : 0);
        this.vert.firstChild.style.height = Math.max(0, e.scrollHeight - e.clientHeight + i) + "px"
      } else this.vert.style.display = "", this.vert.firstChild.style.height = "0";
      if (t) {
        this.horiz.style.display = "block", this.horiz.style.right = n ? r + "px" : "0", this.horiz.style.left = e.barLeft + "px";
        var o = e.viewWidth - e.barLeft - (n ? r : 0);
        this.horiz.firstChild.style.width = Math.max(0, e.scrollWidth - e.clientWidth + o) + "px"
      } else this.horiz.style.display = "", this.horiz.firstChild.style.width = "0";
      return !this.checkedZeroWidth && e.clientHeight > 0 && (0 == r && this.zeroWidthHack(), this.checkedZeroWidth = !0), {
        right: n ? r : 0,
        bottom: t ? r : 0
      }
    }, Hr.prototype.setScrollLeft = function (e) {
      this.horiz.scrollLeft != e && (this.horiz.scrollLeft = e), this.disableHoriz && this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz")
    }, Hr.prototype.setScrollTop = function (e) {
      this.vert.scrollTop != e && (this.vert.scrollTop = e), this.disableVert && this.enableZeroWidthBar(this.vert, this.disableVert, "vert")
    }, Hr.prototype.zeroWidthHack = function () {
      var e = v && !d ? "12px" : "18px";
      this.horiz.style.height = this.vert.style.width = e, this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none", this.disableHoriz = new H, this.disableVert = new H
    }, Hr.prototype.enableZeroWidthBar = function (e, t, n) {
      e.style.pointerEvents = "auto", t.set(1e3, (function r() {
        var i = e.getBoundingClientRect();
        ("vert" == n ? document.elementFromPoint(i.right - 1, (i.top + i.bottom) / 2) : document.elementFromPoint((i.right + i.left) / 2, i.bottom - 1)) != e ? e.style.pointerEvents = "none" : t.set(1e3, r)
      }))
    }, Hr.prototype.clear = function () {
      var e = this.horiz.parentNode;
      e.removeChild(this.horiz), e.removeChild(this.vert)
    };
    var zr = function () {};

    function Ur(e, t) {
      t || (t = Br(e));
      var n = e.display.barWidth,
        r = e.display.barHeight;
      Wr(e, t);
      for (var i = 0; i < 4 && n != e.display.barWidth || r != e.display.barHeight; i++) n != e.display.barWidth && e.options.lineWrapping && Tr(e), Wr(e, Br(e)), n = e.display.barWidth, r = e.display.barHeight
    }

    function Wr(e, t) {
      var n = e.display,
        r = n.scrollbars.update(t);
      n.sizer.style.paddingRight = (n.barWidth = r.right) + "px", n.sizer.style.paddingBottom = (n.barHeight = r.bottom) + "px", n.heightForcer.style.borderBottom = r.bottom + "px solid transparent", r.right && r.bottom ? (n.scrollbarFiller.style.display = "block", n.scrollbarFiller.style.height = r.bottom + "px", n.scrollbarFiller.style.width = r.right + "px") : n.scrollbarFiller.style.display = "", r.bottom && e.options.coverGutterNextToScrollbar && e.options.fixedGutter ? (n.gutterFiller.style.display = "block", n.gutterFiller.style.height = r.bottom + "px", n.gutterFiller.style.width = t.gutterWidth + "px") : n.gutterFiller.style.display = ""
    }
    zr.prototype.update = function () {
      return {
        bottom: 0,
        right: 0
      }
    }, zr.prototype.setScrollLeft = function () {}, zr.prototype.setScrollTop = function () {}, zr.prototype.clear = function () {};
    var Vr = {
      native: Hr,
      null: zr
    };

    function jr(e) {
      e.display.scrollbars && (e.display.scrollbars.clear(), e.display.scrollbars.addClass && T(e.display.wrapper, e.display.scrollbars.addClass)), e.display.scrollbars = new Vr[e.options.scrollbarStyle]((function (t) {
        e.display.wrapper.insertBefore(t, e.display.scrollbarFiller), he(t, "mousedown", (function () {
          e.state.focused && setTimeout((function () {
            return e.display.input.focus()
          }), 0)
        })), t.setAttribute("cm-not-content", "true")
      }), (function (t, n) {
        "horizontal" == n ? Fr(e, t) : Lr(e, t)
      }), e), e.display.scrollbars.addClass && I(e.display.wrapper, e.display.scrollbars.addClass)
    }
    var Gr = 0;

    function $r(e) {
      var t;
      e.curOp = {
        cm: e,
        viewChanged: !1,
        startHeight: e.doc.height,
        forceUpdate: !1,
        updateInput: 0,
        typing: !1,
        changeObjs: null,
        cursorActivityHandlers: null,
        cursorActivityCalled: 0,
        selectionChanged: !1,
        updateMaxLine: !1,
        scrollLeft: null,
        scrollTop: null,
        scrollToPos: null,
        focus: !1,
        id: ++Gr
      }, t = e.curOp, sn ? sn.ops.push(t) : t.ownsGroup = sn = {
        ops: [t],
        delayedCallbacks: []
      }
    }

    function qr(e) {
      var t = e.curOp;
      t && function (e, t) {
        var n = e.ownsGroup;
        if (n) try {
          ! function (e) {
            var t = e.delayedCallbacks,
              n = 0;
            do {
              for (; n < t.length; n++) t[n].call(null);
              for (var r = 0; r < e.ops.length; r++) {
                var i = e.ops[r];
                if (i.cursorActivityHandlers)
                  for (; i.cursorActivityCalled < i.cursorActivityHandlers.length;) i.cursorActivityHandlers[i.cursorActivityCalled++].call(null, i.cm)
              }
            } while (n < t.length)
          }(n)
        } finally {
          sn = null, t(n)
        }
      }(t, (function (e) {
        for (var t = 0; t < e.ops.length; t++) e.ops[t].cm.curOp = null;
        ! function (e) {
          for (var t = e.ops, n = 0; n < t.length; n++) Kr(t[n]);
          for (var r = 0; r < t.length; r++) Yr(t[r]);
          for (var i = 0; i < t.length; i++) Qr(t[i]);
          for (var o = 0; o < t.length; o++) Zr(t[o]);
          for (var s = 0; s < t.length; s++) Xr(t[s])
        }(e)
      }))
    }

    function Kr(e) {
      var t = e.cm,
        n = t.display;
      ! function (e) {
        var t = e.display;
        !t.scrollbarsClipped && t.scroller.offsetWidth && (t.nativeBarWidth = t.scroller.offsetWidth - t.scroller.clientWidth, t.heightForcer.style.height = Tn(e) + "px", t.sizer.style.marginBottom = -t.nativeBarWidth + "px", t.sizer.style.borderRightWidth = Tn(e) + "px", t.scrollbarsClipped = !0)
      }(t), e.updateMaxLine && Gt(t), e.mustUpdate = e.viewChanged || e.forceUpdate || null != e.scrollTop || e.scrollToPos && (e.scrollToPos.from.line < n.viewFrom || e.scrollToPos.to.line >= n.viewTo) || n.maxLineChanged && t.options.lineWrapping, e.update = e.mustUpdate && new oi(t, e.mustUpdate && {
        top: e.scrollTop,
        ensure: e.scrollToPos
      }, e.forceUpdate)
    }

    function Yr(e) {
      e.updatedDisplay = e.mustUpdate && si(e.cm, e.update)
    }

    function Qr(e) {
      var t = e.cm,
        n = t.display;
      e.updatedDisplay && Tr(t), e.barMeasure = Br(t), n.maxLineChanged && !t.options.lineWrapping && (e.adjustWidthTo = An(t, n.maxLine, n.maxLine.text.length).left + 3, t.display.sizerWidth = e.adjustWidthTo, e.barMeasure.scrollWidth = Math.max(n.scroller.clientWidth, n.sizer.offsetLeft + e.adjustWidthTo + Tn(t) + t.display.barWidth), e.maxScrollLeft = Math.max(0, n.sizer.offsetLeft + e.adjustWidthTo - Rn(t))), (e.updatedDisplay || e.selectionChanged) && (e.preparedSelection = n.input.prepareSelection())
    }

    function Zr(e) {
      var t = e.cm;
      null != e.adjustWidthTo && (t.display.sizer.style.minWidth = e.adjustWidthTo + "px", e.maxScrollLeft < t.doc.scrollLeft && Fr(t, Math.min(t.display.scroller.scrollLeft, e.maxScrollLeft), !0), t.display.maxLineChanged = !1);
      var n = e.focus && e.focus == P();
      e.preparedSelection && t.display.input.showSelection(e.preparedSelection, n), (e.updatedDisplay || e.startHeight != t.doc.height) && Ur(t, e.barMeasure), e.updatedDisplay && ui(t, e.barMeasure), e.selectionChanged && Sr(t), t.state.focused && e.updateInput && t.display.input.reset(e.typing), n && Cr(e.cm)
    }

    function Xr(e) {
      var t = e.cm,
        n = t.display,
        r = t.doc;
      e.updatedDisplay && ai(t, e.update), null == n.wheelStartX || null == e.scrollTop && null == e.scrollLeft && !e.scrollToPos || (n.wheelStartX = n.wheelStartY = null), null != e.scrollTop && Nr(t, e.scrollTop, e.forceScroll), null != e.scrollLeft && Fr(t, e.scrollLeft, !0, !0), e.scrollToPos && function (e, t) {
        if (!me(e, "scrollCursorIntoView")) {
          var n = e.display,
            r = n.sizer.getBoundingClientRect(),
            i = null;
          if (t.top + r.top < 0 ? i = !0 : t.bottom + r.top > (window.innerHeight || document.documentElement.clientHeight) && (i = !1), null != i && !f) {
            var o = _("div", "​", null, "position: absolute;\n                         top: " + (t.top - n.viewOffset - En(e.display)) + "px;\n                         height: " + (t.bottom - t.top + Tn(e) + n.barHeight) + "px;\n                         left: " + t.left + "px; width: " + Math.max(2, t.right - t.left) + "px;");
            e.display.lineSpace.appendChild(o), o.scrollIntoView(i), e.display.lineSpace.removeChild(o)
          }
        }
      }(t, function (e, t, n, r) {
        var i;
        null == r && (r = 0), e.options.lineWrapping || t != n || (n = "before" == (t = t.ch ? et(t.line, "before" == t.sticky ? t.ch - 1 : t.ch, "after") : t).sticky ? et(t.line, t.ch + 1, "before") : t);
        for (var o = 0; o < 5; o++) {
          var s = !1,
            a = qn(e, t),
            l = n && n != t ? qn(e, n) : a,
            c = _r(e, i = {
              left: Math.min(a.left, l.left),
              top: Math.min(a.top, l.top) - r,
              right: Math.max(a.left, l.left),
              bottom: Math.max(a.bottom, l.bottom) + r
            }),
            u = e.doc.scrollTop,
            h = e.doc.scrollLeft;
          if (null != c.scrollTop && (Lr(e, c.scrollTop), Math.abs(e.doc.scrollTop - u) > 1 && (s = !0)), null != c.scrollLeft && (Fr(e, c.scrollLeft), Math.abs(e.doc.scrollLeft - h) > 1 && (s = !0)), !s) break
        }
        return i
      }(t, at(r, e.scrollToPos.from), at(r, e.scrollToPos.to), e.scrollToPos.margin));
      var i = e.maybeHiddenMarkers,
        o = e.maybeUnhiddenMarkers;
      if (i)
        for (var s = 0; s < i.length; ++s) i[s].lines.length || fe(i[s], "hide");
      if (o)
        for (var a = 0; a < o.length; ++a) o[a].lines.length && fe(o[a], "unhide");
      n.wrapper.offsetHeight && (r.scrollTop = t.display.scroller.scrollTop), e.changeObjs && fe(t, "changes", t, e.changeObjs), e.update && e.update.finish()
    }

    function Jr(e, t) {
      if (e.curOp) return t();
      $r(e);
      try {
        return t()
      } finally {
        qr(e)
      }
    }

    function ei(e, t) {
      return function () {
        if (e.curOp) return t.apply(e, arguments);
        $r(e);
        try {
          return t.apply(e, arguments)
        } finally {
          qr(e)
        }
      }
    }

    function ti(e) {
      return function () {
        if (this.curOp) return e.apply(this, arguments);
        $r(this);
        try {
          return e.apply(this, arguments)
        } finally {
          qr(this)
        }
      }
    }

    function ni(e) {
      return function () {
        var t = this.cm;
        if (!t || t.curOp) return e.apply(this, arguments);
        $r(t);
        try {
          return e.apply(this, arguments)
        } finally {
          qr(t)
        }
      }
    }

    function ri(e, t) {
      e.doc.highlightFrontier < e.display.viewTo && e.state.highlight.set(t, N(ii, e))
    }

    function ii(e) {
      var t = e.doc;
      if (!(t.highlightFrontier >= e.display.viewTo)) {
        var n = +new Date + e.options.workTime,
          r = dt(e, t.highlightFrontier),
          i = [];
        t.iter(r.line, Math.min(t.first + t.size, e.display.viewTo + 500), (function (o) {
          if (r.line >= e.display.viewFrom) {
            var s = o.styles,
              a = o.text.length > e.options.maxHighlightLength ? We(t.mode, r.state) : null,
              l = ht(e, o, r, !0);
            a && (r.state = a), o.styles = l.styles;
            var c = o.styleClasses,
              u = l.classes;
            u ? o.styleClasses = u : c && (o.styleClasses = null);
            for (var h = !s || s.length != o.styles.length || c != u && (!c || !u || c.bgClass != u.bgClass || c.textClass != u.textClass), p = 0; !h && p < s.length; ++p) h = s[p] != o.styles[p];
            h && i.push(r.line), o.stateAfter = r.save(), r.nextLine()
          } else o.text.length <= e.options.maxHighlightLength && ft(e, o.text, r), o.stateAfter = r.line % 5 == 0 ? r.save() : null, r.nextLine();
          if (+new Date > n) return ri(e, e.options.workDelay), !0
        })), t.highlightFrontier = r.line, t.modeFrontier = Math.max(t.modeFrontier, r.line), i.length && Jr(e, (function () {
          for (var t = 0; t < i.length; t++) pr(e, i[t], "text")
        }))
      }
    }
    var oi = function (e, t, n) {
      var r = e.display;
      this.viewport = t, this.visible = Dr(r, e.doc, t), this.editorIsHidden = !r.wrapper.offsetWidth, this.wrapperHeight = r.wrapper.clientHeight, this.wrapperWidth = r.wrapper.clientWidth, this.oldDisplayWidth = Rn(e), this.force = n, this.dims = or(e), this.events = []
    };

    function si(e, t) {
      var n = e.display,
        r = e.doc;
      if (t.editorIsHidden) return dr(e), !1;
      if (!t.force && t.visible.from >= n.viewFrom && t.visible.to <= n.viewTo && (null == n.updateLineNumbers || n.updateLineNumbers >= n.viewTo) && n.renderedView == n.view && 0 == mr(e)) return !1;
      pi(e) && (dr(e), t.dims = or(e));
      var i = r.first + r.size,
        o = Math.max(t.visible.from - e.options.viewportMargin, r.first),
        s = Math.min(i, t.visible.to + e.options.viewportMargin);
      n.viewFrom < o && o - n.viewFrom < 20 && (o = Math.max(r.first, n.viewFrom)), n.viewTo > s && n.viewTo - s < 20 && (s = Math.min(i, n.viewTo)), Ct && (o = Ht(e.doc, o), s = zt(e.doc, s));
      var a = o != n.viewFrom || s != n.viewTo || n.lastWrapHeight != t.wrapperHeight || n.lastWrapWidth != t.wrapperWidth;
      ! function (e, t, n) {
        var r = e.display;
        0 == r.view.length || t >= r.viewTo || n <= r.viewFrom ? (r.view = on(e, t, n), r.viewFrom = t) : (r.viewFrom > t ? r.view = on(e, t, r.viewFrom).concat(r.view) : r.viewFrom < t && (r.view = r.view.slice(ur(e, t))), r.viewFrom = t, r.viewTo < n ? r.view = r.view.concat(on(e, r.viewTo, n)) : r.viewTo > n && (r.view = r.view.slice(0, ur(e, n)))), r.viewTo = n
      }(e, o, s), n.viewOffset = Vt($e(e.doc, n.viewFrom)), e.display.mover.style.top = n.viewOffset + "px";
      var c = mr(e);
      if (!a && 0 == c && !t.force && n.renderedView == n.view && (null == n.updateLineNumbers || n.updateLineNumbers >= n.viewTo)) return !1;
      var u = function (e) {
        if (e.hasFocus()) return null;
        var t = P();
        if (!t || !M(e.display.lineDiv, t)) return null;
        var n = {
          activeElt: t
        };
        if (window.getSelection) {
          var r = window.getSelection();
          r.anchorNode && r.extend && M(e.display.lineDiv, r.anchorNode) && (n.anchorNode = r.anchorNode, n.anchorOffset = r.anchorOffset, n.focusNode = r.focusNode, n.focusOffset = r.focusOffset)
        }
        return n
      }(e);
      return c > 4 && (n.lineDiv.style.display = "none"),
        function (e, t, n) {
          var r = e.display,
            i = e.options.lineNumbers,
            o = r.lineDiv,
            s = o.firstChild;

          function a(t) {
            var n = t.nextSibling;
            return l && v && e.display.currentWheelTarget == t ? t.style.display = "none" : t.parentNode.removeChild(t), n
          }
          for (var c = r.view, u = r.viewFrom, h = 0; h < c.length; h++) {
            var p = c[h];
            if (p.hidden);
            else if (p.node && p.node.parentNode == o) {
              for (; s != p.node;) s = a(s);
              var d = i && null != t && t <= u && p.lineNumber;
              p.changes && (z(p.changes, "gutter") > -1 && (d = !1), un(e, p, u, n)), d && (R(p.lineNumber), p.lineNumber.appendChild(document.createTextNode(Je(e.options, u)))), s = p.node.nextSibling
            } else {
              var f = yn(e, p, u, n);
              o.insertBefore(f, s)
            }
            u += p.size
          }
          for (; s;) s = a(s)
        }(e, n.updateLineNumbers, t.dims), c > 4 && (n.lineDiv.style.display = ""), n.renderedView = n.view,
        function (e) {
          if (e && e.activeElt && e.activeElt != P() && (e.activeElt.focus(), e.anchorNode && M(document.body, e.anchorNode) && M(document.body, e.focusNode))) {
            var t = window.getSelection(),
              n = document.createRange();
            n.setEnd(e.anchorNode, e.anchorOffset), n.collapse(!1), t.removeAllRanges(), t.addRange(n), t.extend(e.focusNode, e.focusOffset)
          }
        }(u), R(n.cursorDiv), R(n.selectionDiv), n.gutters.style.height = n.sizer.style.minHeight = 0, a && (n.lastWrapHeight = t.wrapperHeight, n.lastWrapWidth = t.wrapperWidth, ri(e, 400)), n.updateLineNumbers = null, !0
    }

    function ai(e, t) {
      for (var n = t.viewport, r = !0;
        (r && e.options.lineWrapping && t.oldDisplayWidth != Rn(e) || (n && null != n.top && (n = {
          top: Math.min(e.doc.height + kn(e.display) - Dn(e), n.top)
        }), t.visible = Dr(e.display, e.doc, n), !(t.visible.from >= e.display.viewFrom && t.visible.to <= e.display.viewTo))) && si(e, t); r = !1) {
        Tr(e);
        var i = Br(e);
        gr(e), Ur(e, i), ui(e, i), t.force = !1
      }
      t.signal(e, "update", e), e.display.viewFrom == e.display.reportedViewFrom && e.display.viewTo == e.display.reportedViewTo || (t.signal(e, "viewportChange", e, e.display.viewFrom, e.display.viewTo), e.display.reportedViewFrom = e.display.viewFrom, e.display.reportedViewTo = e.display.viewTo)
    }

    function li(e, t) {
      var n = new oi(e, t);
      if (si(e, n)) {
        Tr(e), ai(e, n);
        var r = Br(e);
        gr(e), Ur(e, r), ui(e, r), n.finish()
      }
    }

    function ci(e) {
      var t = e.gutters.offsetWidth;
      e.sizer.style.marginLeft = t + "px"
    }

    function ui(e, t) {
      e.display.sizer.style.minHeight = t.docHeight + "px", e.display.heightForcer.style.top = t.docHeight + "px", e.display.gutters.style.height = t.docHeight + e.display.barHeight + Tn(e) + "px"
    }

    function hi(e) {
      var t = e.display,
        n = t.view;
      if (t.alignWidgets || t.gutters.firstChild && e.options.fixedGutter) {
        for (var r = sr(t) - t.scroller.scrollLeft + e.doc.scrollLeft, i = t.gutters.offsetWidth, o = r + "px", s = 0; s < n.length; s++)
          if (!n[s].hidden) {
            e.options.fixedGutter && (n[s].gutter && (n[s].gutter.style.left = o), n[s].gutterBackground && (n[s].gutterBackground.style.left = o));
            var a = n[s].alignable;
            if (a)
              for (var l = 0; l < a.length; l++) a[l].style.left = o
          } e.options.fixedGutter && (t.gutters.style.left = r + i + "px")
      }
    }

    function pi(e) {
      if (!e.options.lineNumbers) return !1;
      var t = e.doc,
        n = Je(e.options, t.first + t.size - 1),
        r = e.display;
      if (n.length != r.lineNumChars) {
        var i = r.measure.appendChild(_("div", [_("div", n)], "CodeMirror-linenumber CodeMirror-gutter-elt")),
          o = i.firstChild.offsetWidth,
          s = i.offsetWidth - o;
        return r.lineGutter.style.width = "", r.lineNumInnerWidth = Math.max(o, r.lineGutter.offsetWidth - s) + 1, r.lineNumWidth = r.lineNumInnerWidth + s, r.lineNumChars = r.lineNumInnerWidth ? n.length : -1, r.lineGutter.style.width = r.lineNumWidth + "px", ci(e.display), !0
      }
      return !1
    }

    function di(e, t) {
      for (var n = [], r = !1, i = 0; i < e.length; i++) {
        var o = e[i],
          s = null;
        if ("string" != typeof o && (s = o.style, o = o.className), "CodeMirror-linenumbers" == o) {
          if (!t) continue;
          r = !0
        }
        n.push({
          className: o,
          style: s
        })
      }
      return t && !r && n.push({
        className: "CodeMirror-linenumbers",
        style: null
      }), n
    }

    function fi(e) {
      var t = e.gutters,
        n = e.gutterSpecs;
      R(t), e.lineGutter = null;
      for (var r = 0; r < n.length; ++r) {
        var i = n[r],
          o = i.className,
          s = i.style,
          a = t.appendChild(_("div", null, "CodeMirror-gutter " + o));
        s && (a.style.cssText = s), "CodeMirror-linenumbers" == o && (e.lineGutter = a, a.style.width = (e.lineNumWidth || 1) + "px")
      }
      t.style.display = n.length ? "" : "none", ci(e)
    }

    function mi(e) {
      fi(e.display), hr(e), hi(e)
    }

    function gi(e, t, r, i) {
      var o = this;
      this.input = r, o.scrollbarFiller = _("div", null, "CodeMirror-scrollbar-filler"), o.scrollbarFiller.setAttribute("cm-not-content", "true"), o.gutterFiller = _("div", null, "CodeMirror-gutter-filler"), o.gutterFiller.setAttribute("cm-not-content", "true"), o.lineDiv = A("div", null, "CodeMirror-code"), o.selectionDiv = _("div", null, null, "position: relative; z-index: 1"), o.cursorDiv = _("div", null, "CodeMirror-cursors"), o.measure = _("div", null, "CodeMirror-measure"), o.lineMeasure = _("div", null, "CodeMirror-measure"), o.lineSpace = A("div", [o.measure, o.lineMeasure, o.selectionDiv, o.cursorDiv, o.lineDiv], null, "position: relative; outline: none");
      var c = A("div", [o.lineSpace], "CodeMirror-lines");
      o.mover = _("div", [c], null, "position: relative"), o.sizer = _("div", [o.mover], "CodeMirror-sizer"), o.sizerWidth = null, o.heightForcer = _("div", null, null, "position: absolute; height: 30px; width: 1px;"), o.gutters = _("div", null, "CodeMirror-gutters"), o.lineGutter = null, o.scroller = _("div", [o.sizer, o.heightForcer, o.gutters], "CodeMirror-scroll"), o.scroller.setAttribute("tabIndex", "-1"), o.wrapper = _("div", [o.scrollbarFiller, o.gutterFiller, o.scroller], "CodeMirror"), s && a < 8 && (o.gutters.style.zIndex = -1, o.scroller.style.paddingRight = 0), l || n && y || (o.scroller.draggable = !0), e && (e.appendChild ? e.appendChild(o.wrapper) : e(o.wrapper)), o.viewFrom = o.viewTo = t.first, o.reportedViewFrom = o.reportedViewTo = t.first, o.view = [], o.renderedView = null, o.externalMeasured = null, o.viewOffset = 0, o.lastWrapHeight = o.lastWrapWidth = 0, o.updateLineNumbers = null, o.nativeBarWidth = o.barHeight = o.barWidth = 0, o.scrollbarsClipped = !1, o.lineNumWidth = o.lineNumInnerWidth = o.lineNumChars = null, o.alignWidgets = !1, o.cachedCharWidth = o.cachedTextHeight = o.cachedPaddingH = null, o.maxLine = null, o.maxLineLength = 0, o.maxLineChanged = !1, o.wheelDX = o.wheelDY = o.wheelStartX = o.wheelStartY = null, o.shift = !1, o.selForContextMenu = null, o.activeTouch = null, o.gutterSpecs = di(i.gutters, i.lineNumbers), fi(o), r.init(o)
    }
    oi.prototype.signal = function (e, t) {
      ye(e, t) && this.events.push(arguments)
    }, oi.prototype.finish = function () {
      for (var e = 0; e < this.events.length; e++) fe.apply(null, this.events[e])
    };
    var yi = 0,
      vi = null;

    function wi(e) {
      var t = e.wheelDeltaX,
        n = e.wheelDeltaY;
      return null == t && e.detail && e.axis == e.HORIZONTAL_AXIS && (t = e.detail), null == n && e.detail && e.axis == e.VERTICAL_AXIS ? n = e.detail : null == n && (n = e.wheelDelta), {
        x: t,
        y: n
      }
    }

    function bi(e) {
      var t = wi(e);
      return t.x *= vi, t.y *= vi, t
    }

    function Si(e, t) {
      var r = wi(t),
        i = r.x,
        o = r.y,
        s = e.display,
        a = s.scroller,
        c = a.scrollWidth > a.clientWidth,
        u = a.scrollHeight > a.clientHeight;
      if (i && c || o && u) {
        if (o && v && l) e: for (var p = t.target, d = s.view; p != a; p = p.parentNode)
          for (var f = 0; f < d.length; f++)
            if (d[f].node == p) {
              e.display.currentWheelTarget = p;
              break e
            } if (i && !n && !h && null != vi) return o && u && Lr(e, Math.max(0, a.scrollTop + o * vi)), Fr(e, Math.max(0, a.scrollLeft + i * vi)), (!o || o && u) && we(t), void(s.wheelStartX = null);
        if (o && null != vi) {
          var m = o * vi,
            g = e.doc.scrollTop,
            y = g + s.wrapper.clientHeight;
          m < 0 ? g = Math.max(0, g + m - 50) : y = Math.min(e.doc.height, y + m + 50), li(e, {
            top: g,
            bottom: y
          })
        }
        yi < 20 && (null == s.wheelStartX ? (s.wheelStartX = a.scrollLeft, s.wheelStartY = a.scrollTop, s.wheelDX = i, s.wheelDY = o, setTimeout((function () {
          if (null != s.wheelStartX) {
            var e = a.scrollLeft - s.wheelStartX,
              t = a.scrollTop - s.wheelStartY,
              n = t && s.wheelDY && t / s.wheelDY || e && s.wheelDX && e / s.wheelDX;
            s.wheelStartX = s.wheelStartY = null, n && (vi = (vi * yi + n) / (yi + 1), ++yi)
          }
        }), 200)) : (s.wheelDX += i, s.wheelDY += o))
      }
    }
    s ? vi = -.53 : n ? vi = 15 : u ? vi = -.7 : p && (vi = -1 / 3);
    var Ci = function (e, t) {
      this.ranges = e, this.primIndex = t
    };
    Ci.prototype.primary = function () {
      return this.ranges[this.primIndex]
    }, Ci.prototype.equals = function (e) {
      if (e == this) return !0;
      if (e.primIndex != this.primIndex || e.ranges.length != this.ranges.length) return !1;
      for (var t = 0; t < this.ranges.length; t++) {
        var n = this.ranges[t],
          r = e.ranges[t];
        if (!nt(n.anchor, r.anchor) || !nt(n.head, r.head)) return !1
      }
      return !0
    }, Ci.prototype.deepCopy = function () {
      for (var e = [], t = 0; t < this.ranges.length; t++) e[t] = new Ei(rt(this.ranges[t].anchor), rt(this.ranges[t].head));
      return new Ci(e, this.primIndex)
    }, Ci.prototype.somethingSelected = function () {
      for (var e = 0; e < this.ranges.length; e++)
        if (!this.ranges[e].empty()) return !0;
      return !1
    }, Ci.prototype.contains = function (e, t) {
      t || (t = e);
      for (var n = 0; n < this.ranges.length; n++) {
        var r = this.ranges[n];
        if (tt(t, r.from()) >= 0 && tt(e, r.to()) <= 0) return n
      }
      return -1
    };
    var Ei = function (e, t) {
      this.anchor = e, this.head = t
    };

    function ki(e, t, n) {
      var r = e && e.options.selectionsMayTouch,
        i = t[n];
      t.sort((function (e, t) {
        return tt(e.from(), t.from())
      })), n = z(t, i);
      for (var o = 1; o < t.length; o++) {
        var s = t[o],
          a = t[o - 1],
          l = tt(a.to(), s.from());
        if (r && !s.empty() ? l > 0 : l >= 0) {
          var c = ot(a.from(), s.from()),
            u = it(a.to(), s.to()),
            h = a.empty() ? s.from() == s.head : a.from() == a.head;
          o <= n && --n, t.splice(--o, 2, new Ei(h ? u : c, h ? c : u))
        }
      }
      return new Ci(t, n)
    }

    function xi(e, t) {
      return new Ci([new Ei(e, t || e)], 0)
    }

    function Ti(e) {
      return e.text ? et(e.from.line + e.text.length - 1, K(e.text).length + (1 == e.text.length ? e.from.ch : 0)) : e.to
    }

    function Ri(e, t) {
      if (tt(e, t.from) < 0) return e;
      if (tt(e, t.to) <= 0) return Ti(t);
      var n = e.line + t.text.length - (t.to.line - t.from.line) - 1,
        r = e.ch;
      return e.line == t.to.line && (r += Ti(t).ch - t.to.ch), et(n, r)
    }

    function Di(e, t) {
      for (var n = [], r = 0; r < e.sel.ranges.length; r++) {
        var i = e.sel.ranges[r];
        n.push(new Ei(Ri(i.anchor, t), Ri(i.head, t)))
      }
      return ki(e.cm, n, e.sel.primIndex)
    }

    function _i(e, t, n) {
      return e.line == t.line ? et(n.line, e.ch - t.ch + n.ch) : et(n.line + (e.line - t.line), e.ch)
    }

    function Ai(e) {
      e.doc.mode = He(e.options, e.doc.modeOption), Mi(e)
    }

    function Mi(e) {
      e.doc.iter((function (e) {
        e.stateAfter && (e.stateAfter = null), e.styles && (e.styles = null)
      })), e.doc.modeFrontier = e.doc.highlightFrontier = e.doc.first, ri(e, 100), e.state.modeGen++, e.curOp && hr(e)
    }

    function Pi(e, t) {
      return 0 == t.from.ch && 0 == t.to.ch && "" == K(t.text) && (!e.cm || e.cm.options.wholeLineUpdateBefore)
    }

    function Ii(e, t, n, r) {
      function i(e) {
        return n ? n[e] : null
      }

      function o(e, n, i) {
        ! function (e, t, n, r) {
          e.text = t, e.stateAfter && (e.stateAfter = null), e.styles && (e.styles = null), null != e.order && (e.order = null), Dt(e), _t(e, n);
          var i = r ? r(e) : 1;
          i != e.height && Ye(e, i)
        }(e, n, i, r), ln(e, "change", e, t)
      }

      function s(e, t) {
        for (var n = [], o = e; o < t; ++o) n.push(new $t(c[o], i(o), r));
        return n
      }
      var a = t.from,
        l = t.to,
        c = t.text,
        u = $e(e, a.line),
        h = $e(e, l.line),
        p = K(c),
        d = i(c.length - 1),
        f = l.line - a.line;
      if (t.full) e.insert(0, s(0, c.length)), e.remove(c.length, e.size - c.length);
      else if (Pi(e, t)) {
        var m = s(0, c.length - 1);
        o(h, h.text, d), f && e.remove(a.line, f), m.length && e.insert(a.line, m)
      } else if (u == h)
        if (1 == c.length) o(u, u.text.slice(0, a.ch) + p + u.text.slice(l.ch), d);
        else {
          var g = s(1, c.length - 1);
          g.push(new $t(p + u.text.slice(l.ch), d, r)), o(u, u.text.slice(0, a.ch) + c[0], i(0)), e.insert(a.line + 1, g)
        }
      else if (1 == c.length) o(u, u.text.slice(0, a.ch) + c[0] + h.text.slice(l.ch), i(0)), e.remove(a.line + 1, f);
      else {
        o(u, u.text.slice(0, a.ch) + c[0], i(0)), o(h, p + h.text.slice(l.ch), d);
        var y = s(1, c.length - 1);
        f > 1 && e.remove(a.line + 1, f - 1), e.insert(a.line + 1, y)
      }
      ln(e, "change", e, t)
    }

    function Oi(e, t, n) {
      ! function e(r, i, o) {
        if (r.linked)
          for (var s = 0; s < r.linked.length; ++s) {
            var a = r.linked[s];
            if (a.doc != i) {
              var l = o && a.sharedHist;
              n && !l || (t(a.doc, l), e(a.doc, r, l))
            }
          }
      }(e, null, !0)
    }

    function Li(e, t) {
      if (t.cm) throw new Error("This document is already in use.");
      e.doc = t, t.cm = e, lr(e), Ai(e), Ni(e), e.options.lineWrapping || Gt(e), e.options.mode = t.modeOption, hr(e)
    }

    function Ni(e) {
      ("rtl" == e.doc.direction ? I : T)(e.display.lineDiv, "CodeMirror-rtl")
    }

    function Fi(e) {
      this.done = [], this.undone = [], this.undoDepth = 1 / 0, this.lastModTime = this.lastSelTime = 0, this.lastOp = this.lastSelOp = null, this.lastOrigin = this.lastSelOrigin = null, this.generation = this.maxGeneration = e || 1
    }

    function Bi(e, t) {
      var n = {
        from: rt(t.from),
        to: Ti(t),
        text: qe(e, t.from, t.to)
      };
      return Vi(e, n, t.from.line, t.to.line + 1), Oi(e, (function (e) {
        return Vi(e, n, t.from.line, t.to.line + 1)
      }), !0), n
    }

    function Hi(e) {
      for (; e.length && K(e).ranges;) e.pop()
    }

    function zi(e, t, n, r) {
      var i = e.history;
      i.undone.length = 0;
      var o, s, a = +new Date;
      if ((i.lastOp == r || i.lastOrigin == t.origin && t.origin && ("+" == t.origin.charAt(0) && i.lastModTime > a - (e.cm ? e.cm.options.historyEventDelay : 500) || "*" == t.origin.charAt(0))) && (o = function (e, t) {
          return t ? (Hi(e.done), K(e.done)) : e.done.length && !K(e.done).ranges ? K(e.done) : e.done.length > 1 && !e.done[e.done.length - 2].ranges ? (e.done.pop(), K(e.done)) : void 0
        }(i, i.lastOp == r))) s = K(o.changes), 0 == tt(t.from, t.to) && 0 == tt(t.from, s.to) ? s.to = Ti(t) : o.changes.push(Bi(e, t));
      else {
        var l = K(i.done);
        for (l && l.ranges || Wi(e.sel, i.done), o = {
            changes: [Bi(e, t)],
            generation: i.generation
          }, i.done.push(o); i.done.length > i.undoDepth;) i.done.shift(), i.done[0].ranges || i.done.shift()
      }
      i.done.push(n), i.generation = ++i.maxGeneration, i.lastModTime = i.lastSelTime = a, i.lastOp = i.lastSelOp = r, i.lastOrigin = i.lastSelOrigin = t.origin, s || fe(e, "historyAdded")
    }

    function Ui(e, t, n, r) {
      var i = e.history,
        o = r && r.origin;
      n == i.lastSelOp || o && i.lastSelOrigin == o && (i.lastModTime == i.lastSelTime && i.lastOrigin == o || function (e, t, n, r) {
        var i = t.charAt(0);
        return "*" == i || "+" == i && n.ranges.length == r.ranges.length && n.somethingSelected() == r.somethingSelected() && new Date - e.history.lastSelTime <= (e.cm ? e.cm.options.historyEventDelay : 500)
      }(e, o, K(i.done), t)) ? i.done[i.done.length - 1] = t : Wi(t, i.done), i.lastSelTime = +new Date, i.lastSelOrigin = o, i.lastSelOp = n, r && !1 !== r.clearRedo && Hi(i.undone)
    }

    function Wi(e, t) {
      var n = K(t);
      n && n.ranges && n.equals(e) || t.push(e)
    }

    function Vi(e, t, n, r) {
      var i = t["spans_" + e.id],
        o = 0;
      e.iter(Math.max(e.first, n), Math.min(e.first + e.size, r), (function (n) {
        n.markedSpans && ((i || (i = t["spans_" + e.id] = {}))[o] = n.markedSpans), ++o
      }))
    }

    function ji(e) {
      if (!e) return null;
      for (var t, n = 0; n < e.length; ++n) e[n].marker.explicitlyCleared ? t || (t = e.slice(0, n)) : t && t.push(e[n]);
      return t ? t.length ? t : null : e
    }

    function Gi(e, t) {
      var n = function (e, t) {
          var n = t["spans_" + e.id];
          if (!n) return null;
          for (var r = [], i = 0; i < t.text.length; ++i) r.push(ji(n[i]));
          return r
        }(e, t),
        r = Tt(e, t);
      if (!n) return r;
      if (!r) return n;
      for (var i = 0; i < n.length; ++i) {
        var o = n[i],
          s = r[i];
        if (o && s) e: for (var a = 0; a < s.length; ++a) {
          for (var l = s[a], c = 0; c < o.length; ++c)
            if (o[c].marker == l.marker) continue e;
          o.push(l)
        } else s && (n[i] = s)
      }
      return n
    }

    function $i(e, t, n) {
      for (var r = [], i = 0; i < e.length; ++i) {
        var o = e[i];
        if (o.ranges) r.push(n ? Ci.prototype.deepCopy.call(o) : o);
        else {
          var s = o.changes,
            a = [];
          r.push({
            changes: a
          });
          for (var l = 0; l < s.length; ++l) {
            var c = s[l],
              u = void 0;
            if (a.push({
                from: c.from,
                to: c.to,
                text: c.text
              }), t)
              for (var h in c)(u = h.match(/^spans_(\d+)$/)) && z(t, Number(u[1])) > -1 && (K(a)[h] = c[h], delete c[h])
          }
        }
      }
      return r
    }

    function qi(e, t, n, r) {
      if (r) {
        var i = e.anchor;
        if (n) {
          var o = tt(t, i) < 0;
          o != tt(n, i) < 0 ? (i = t, t = n) : o != tt(t, n) < 0 && (t = n)
        }
        return new Ei(i, t)
      }
      return new Ei(n || t, t)
    }

    function Ki(e, t, n, r, i) {
      null == i && (i = e.cm && (e.cm.display.shift || e.extend)), Ji(e, new Ci([qi(e.sel.primary(), t, n, i)], 0), r)
    }

    function Yi(e, t, n) {
      for (var r = [], i = e.cm && (e.cm.display.shift || e.extend), o = 0; o < e.sel.ranges.length; o++) r[o] = qi(e.sel.ranges[o], t[o], null, i);
      Ji(e, ki(e.cm, r, e.sel.primIndex), n)
    }

    function Qi(e, t, n, r) {
      var i = e.sel.ranges.slice(0);
      i[t] = n, Ji(e, ki(e.cm, i, e.sel.primIndex), r)
    }

    function Zi(e, t, n, r) {
      Ji(e, xi(t, n), r)
    }

    function Xi(e, t, n) {
      var r = e.history.done,
        i = K(r);
      i && i.ranges ? (r[r.length - 1] = t, eo(e, t, n)) : Ji(e, t, n)
    }

    function Ji(e, t, n) {
      eo(e, t, n), Ui(e, e.sel, e.cm ? e.cm.curOp.id : NaN, n)
    }

    function eo(e, t, n) {
      (ye(e, "beforeSelectionChange") || e.cm && ye(e.cm, "beforeSelectionChange")) && (t = function (e, t, n) {
        var r = {
          ranges: t.ranges,
          update: function (t) {
            this.ranges = [];
            for (var n = 0; n < t.length; n++) this.ranges[n] = new Ei(at(e, t[n].anchor), at(e, t[n].head))
          },
          origin: n && n.origin
        };
        return fe(e, "beforeSelectionChange", e, r), e.cm && fe(e.cm, "beforeSelectionChange", e.cm, r), r.ranges != t.ranges ? ki(e.cm, r.ranges, r.ranges.length - 1) : t
      }(e, t, n));
      var r = n && n.bias || (tt(t.primary().head, e.sel.primary().head) < 0 ? -1 : 1);
      to(e, ro(e, t, r, !0)), n && !1 === n.scroll || !e.cm || Mr(e.cm)
    }

    function to(e, t) {
      t.equals(e.sel) || (e.sel = t, e.cm && (e.cm.curOp.updateInput = 1, e.cm.curOp.selectionChanged = !0, ge(e.cm)), ln(e, "cursorActivity", e))
    }

    function no(e) {
      to(e, ro(e, e.sel, null, !1))
    }

    function ro(e, t, n, r) {
      for (var i, o = 0; o < t.ranges.length; o++) {
        var s = t.ranges[o],
          a = t.ranges.length == e.sel.ranges.length && e.sel.ranges[o],
          l = oo(e, s.anchor, a && a.anchor, n, r),
          c = oo(e, s.head, a && a.head, n, r);
        (i || l != s.anchor || c != s.head) && (i || (i = t.ranges.slice(0, o)), i[o] = new Ei(l, c))
      }
      return i ? ki(e.cm, i, t.primIndex) : t
    }

    function io(e, t, n, r, i) {
      var o = $e(e, t.line);
      if (o.markedSpans)
        for (var s = 0; s < o.markedSpans.length; ++s) {
          var a = o.markedSpans[s],
            l = a.marker,
            c = "selectLeft" in l ? !l.selectLeft : l.inclusiveLeft,
            u = "selectRight" in l ? !l.selectRight : l.inclusiveRight;
          if ((null == a.from || (c ? a.from <= t.ch : a.from < t.ch)) && (null == a.to || (u ? a.to >= t.ch : a.to > t.ch))) {
            if (i && (fe(l, "beforeCursorEnter"), l.explicitlyCleared)) {
              if (o.markedSpans) {
                --s;
                continue
              }
              break
            }
            if (!l.atomic) continue;
            if (n) {
              var h = l.find(r < 0 ? 1 : -1),
                p = void 0;
              if ((r < 0 ? u : c) && (h = so(e, h, -r, h && h.line == t.line ? o : null)), h && h.line == t.line && (p = tt(h, n)) && (r < 0 ? p < 0 : p > 0)) return io(e, h, t, r, i)
            }
            var d = l.find(r < 0 ? -1 : 1);
            return (r < 0 ? c : u) && (d = so(e, d, r, d.line == t.line ? o : null)), d ? io(e, d, t, r, i) : null
          }
        }
      return t
    }

    function oo(e, t, n, r, i) {
      var o = r || 1,
        s = io(e, t, n, o, i) || !i && io(e, t, n, o, !0) || io(e, t, n, -o, i) || !i && io(e, t, n, -o, !0);
      return s || (e.cantEdit = !0, et(e.first, 0))
    }

    function so(e, t, n, r) {
      return n < 0 && 0 == t.ch ? t.line > e.first ? at(e, et(t.line - 1)) : null : n > 0 && t.ch == (r || $e(e, t.line)).text.length ? t.line < e.first + e.size - 1 ? et(t.line + 1, 0) : null : new et(t.line, t.ch + n)
    }

    function ao(e) {
      e.setSelection(et(e.firstLine(), 0), et(e.lastLine()), W)
    }

    function lo(e, t, n) {
      var r = {
        canceled: !1,
        from: t.from,
        to: t.to,
        text: t.text,
        origin: t.origin,
        cancel: function () {
          return r.canceled = !0
        }
      };
      return n && (r.update = function (t, n, i, o) {
        t && (r.from = at(e, t)), n && (r.to = at(e, n)), i && (r.text = i), void 0 !== o && (r.origin = o)
      }), fe(e, "beforeChange", e, r), e.cm && fe(e.cm, "beforeChange", e.cm, r), r.canceled ? (e.cm && (e.cm.curOp.updateInput = 2), null) : {
        from: r.from,
        to: r.to,
        text: r.text,
        origin: r.origin
      }
    }

    function co(e, t, n) {
      if (e.cm) {
        if (!e.cm.curOp) return ei(e.cm, co)(e, t, n);
        if (e.cm.state.suppressEdits) return
      }
      if (!(ye(e, "beforeChange") || e.cm && ye(e.cm, "beforeChange")) || (t = lo(e, t, !0))) {
        var r = St && !n && function (e, t, n) {
          var r = null;
          if (e.iter(t.line, n.line + 1, (function (e) {
              if (e.markedSpans)
                for (var t = 0; t < e.markedSpans.length; ++t) {
                  var n = e.markedSpans[t].marker;
                  !n.readOnly || r && -1 != z(r, n) || (r || (r = [])).push(n)
                }
            })), !r) return null;
          for (var i = [{
              from: t,
              to: n
            }], o = 0; o < r.length; ++o)
            for (var s = r[o], a = s.find(0), l = 0; l < i.length; ++l) {
              var c = i[l];
              if (!(tt(c.to, a.from) < 0 || tt(c.from, a.to) > 0)) {
                var u = [l, 1],
                  h = tt(c.from, a.from),
                  p = tt(c.to, a.to);
                (h < 0 || !s.inclusiveLeft && !h) && u.push({
                  from: c.from,
                  to: a.from
                }), (p > 0 || !s.inclusiveRight && !p) && u.push({
                  from: a.to,
                  to: c.to
                }), i.splice.apply(i, u), l += u.length - 3
              }
            }
          return i
        }(e, t.from, t.to);
        if (r)
          for (var i = r.length - 1; i >= 0; --i) uo(e, {
            from: r[i].from,
            to: r[i].to,
            text: i ? [""] : t.text,
            origin: t.origin
          });
        else uo(e, t)
      }
    }

    function uo(e, t) {
      if (1 != t.text.length || "" != t.text[0] || 0 != tt(t.from, t.to)) {
        var n = Di(e, t);
        zi(e, t, n, e.cm ? e.cm.curOp.id : NaN), fo(e, t, n, Tt(e, t));
        var r = [];
        Oi(e, (function (e, n) {
          n || -1 != z(r, e.history) || (vo(e.history, t), r.push(e.history)), fo(e, t, null, Tt(e, t))
        }))
      }
    }

    function ho(e, t, n) {
      var r = e.cm && e.cm.state.suppressEdits;
      if (!r || n) {
        for (var i, o = e.history, s = e.sel, a = "undo" == t ? o.done : o.undone, l = "undo" == t ? o.undone : o.done, c = 0; c < a.length && (i = a[c], n ? !i.ranges || i.equals(e.sel) : i.ranges); c++);
        if (c != a.length) {
          for (o.lastOrigin = o.lastSelOrigin = null;;) {
            if (!(i = a.pop()).ranges) {
              if (r) return void a.push(i);
              break
            }
            if (Wi(i, l), n && !i.equals(e.sel)) return void Ji(e, i, {
              clearRedo: !1
            });
            s = i
          }
          var u = [];
          Wi(s, l), l.push({
            changes: u,
            generation: o.generation
          }), o.generation = i.generation || ++o.maxGeneration;
          for (var h = ye(e, "beforeChange") || e.cm && ye(e.cm, "beforeChange"), p = function (n) {
              var r = i.changes[n];
              if (r.origin = t, h && !lo(e, r, !1)) return a.length = 0, {};
              u.push(Bi(e, r));
              var o = n ? Di(e, r) : K(a);
              fo(e, r, o, Gi(e, r)), !n && e.cm && e.cm.scrollIntoView({
                from: r.from,
                to: Ti(r)
              });
              var s = [];
              Oi(e, (function (e, t) {
                t || -1 != z(s, e.history) || (vo(e.history, r), s.push(e.history)), fo(e, r, null, Gi(e, r))
              }))
            }, d = i.changes.length - 1; d >= 0; --d) {
            var f = p(d);
            if (f) return f.v
          }
        }
      }
    }

    function po(e, t) {
      if (0 != t && (e.first += t, e.sel = new Ci(Y(e.sel.ranges, (function (e) {
          return new Ei(et(e.anchor.line + t, e.anchor.ch), et(e.head.line + t, e.head.ch))
        })), e.sel.primIndex), e.cm)) {
        hr(e.cm, e.first, e.first - t, t);
        for (var n = e.cm.display, r = n.viewFrom; r < n.viewTo; r++) pr(e.cm, r, "gutter")
      }
    }

    function fo(e, t, n, r) {
      if (e.cm && !e.cm.curOp) return ei(e.cm, fo)(e, t, n, r);
      if (t.to.line < e.first) po(e, t.text.length - 1 - (t.to.line - t.from.line));
      else if (!(t.from.line > e.lastLine())) {
        if (t.from.line < e.first) {
          var i = t.text.length - 1 - (e.first - t.from.line);
          po(e, i), t = {
            from: et(e.first, 0),
            to: et(t.to.line + i, t.to.ch),
            text: [K(t.text)],
            origin: t.origin
          }
        }
        var o = e.lastLine();
        t.to.line > o && (t = {
          from: t.from,
          to: et(o, $e(e, o).text.length),
          text: [t.text[0]],
          origin: t.origin
        }), t.removed = qe(e, t.from, t.to), n || (n = Di(e, t)), e.cm ? function (e, t, n) {
          var r = e.doc,
            i = e.display,
            o = t.from,
            s = t.to,
            a = !1,
            l = o.line;
          e.options.lineWrapping || (l = Qe(Bt($e(r, o.line))), r.iter(l, s.line + 1, (function (e) {
              if (e == i.maxLine) return a = !0, !0
            }))), r.sel.contains(t.from, t.to) > -1 && ge(e), Ii(r, t, n, ar(e)), e.options.lineWrapping || (r.iter(l, o.line + t.text.length, (function (e) {
              var t = jt(e);
              t > i.maxLineLength && (i.maxLine = e, i.maxLineLength = t, i.maxLineChanged = !0, a = !1)
            })), a && (e.curOp.updateMaxLine = !0)),
            function (e, t) {
              if (e.modeFrontier = Math.min(e.modeFrontier, t), !(e.highlightFrontier < t - 10)) {
                for (var n = e.first, r = t - 1; r > n; r--) {
                  var i = $e(e, r).stateAfter;
                  if (i && (!(i instanceof ct) || r + i.lookAhead < t)) {
                    n = r + 1;
                    break
                  }
                }
                e.highlightFrontier = Math.min(e.highlightFrontier, n)
              }
            }(r, o.line), ri(e, 400);
          var c = t.text.length - (s.line - o.line) - 1;
          t.full ? hr(e) : o.line != s.line || 1 != t.text.length || Pi(e.doc, t) ? hr(e, o.line, s.line + 1, c) : pr(e, o.line, "text");
          var u = ye(e, "changes"),
            h = ye(e, "change");
          if (h || u) {
            var p = {
              from: o,
              to: s,
              text: t.text,
              removed: t.removed,
              origin: t.origin
            };
            h && ln(e, "change", e, p), u && (e.curOp.changeObjs || (e.curOp.changeObjs = [])).push(p)
          }
          e.display.selForContextMenu = null
        }(e.cm, t, r) : Ii(e, t, r), eo(e, n, W), e.cantEdit && oo(e, et(e.firstLine(), 0)) && (e.cantEdit = !1)
      }
    }

    function mo(e, t, n, r, i) {
      var o;
      r || (r = n), tt(r, n) < 0 && (n = (o = [r, n])[0], r = o[1]), "string" == typeof t && (t = e.splitLines(t)), co(e, {
        from: n,
        to: r,
        text: t,
        origin: i
      })
    }

    function go(e, t, n, r) {
      n < e.line ? e.line += r : t < e.line && (e.line = t, e.ch = 0)
    }

    function yo(e, t, n, r) {
      for (var i = 0; i < e.length; ++i) {
        var o = e[i],
          s = !0;
        if (o.ranges) {
          o.copied || ((o = e[i] = o.deepCopy()).copied = !0);
          for (var a = 0; a < o.ranges.length; a++) go(o.ranges[a].anchor, t, n, r), go(o.ranges[a].head, t, n, r)
        } else {
          for (var l = 0; l < o.changes.length; ++l) {
            var c = o.changes[l];
            if (n < c.from.line) c.from = et(c.from.line + r, c.from.ch), c.to = et(c.to.line + r, c.to.ch);
            else if (t <= c.to.line) {
              s = !1;
              break
            }
          }
          s || (e.splice(0, i + 1), i = 0)
        }
      }
    }

    function vo(e, t) {
      var n = t.from.line,
        r = t.to.line,
        i = t.text.length - (r - n) - 1;
      yo(e.done, n, r, i), yo(e.undone, n, r, i)
    }

    function wo(e, t, n, r) {
      var i = t,
        o = t;
      return "number" == typeof t ? o = $e(e, st(e, t)) : i = Qe(t), null == i ? null : (r(o, i) && e.cm && pr(e.cm, i, n), o)
    }

    function bo(e) {
      this.lines = e, this.parent = null;
      for (var t = 0, n = 0; n < e.length; ++n) e[n].parent = this, t += e[n].height;
      this.height = t
    }

    function So(e) {
      this.children = e;
      for (var t = 0, n = 0, r = 0; r < e.length; ++r) {
        var i = e[r];
        t += i.chunkSize(), n += i.height, i.parent = this
      }
      this.size = t, this.height = n, this.parent = null
    }
    Ei.prototype.from = function () {
      return ot(this.anchor, this.head)
    }, Ei.prototype.to = function () {
      return it(this.anchor, this.head)
    }, Ei.prototype.empty = function () {
      return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch
    }, bo.prototype = {
      chunkSize: function () {
        return this.lines.length
      },
      removeInner: function (e, t) {
        for (var n = e, r = e + t; n < r; ++n) {
          var i = this.lines[n];
          this.height -= i.height, qt(i), ln(i, "delete")
        }
        this.lines.splice(e, t)
      },
      collapse: function (e) {
        e.push.apply(e, this.lines)
      },
      insertInner: function (e, t, n) {
        this.height += n, this.lines = this.lines.slice(0, e).concat(t).concat(this.lines.slice(e));
        for (var r = 0; r < t.length; ++r) t[r].parent = this
      },
      iterN: function (e, t, n) {
        for (var r = e + t; e < r; ++e)
          if (n(this.lines[e])) return !0
      }
    }, So.prototype = {
      chunkSize: function () {
        return this.size
      },
      removeInner: function (e, t) {
        this.size -= t;
        for (var n = 0; n < this.children.length; ++n) {
          var r = this.children[n],
            i = r.chunkSize();
          if (e < i) {
            var o = Math.min(t, i - e),
              s = r.height;
            if (r.removeInner(e, o), this.height -= s - r.height, i == o && (this.children.splice(n--, 1), r.parent = null), 0 == (t -= o)) break;
            e = 0
          } else e -= i
        }
        if (this.size - t < 25 && (this.children.length > 1 || !(this.children[0] instanceof bo))) {
          var a = [];
          this.collapse(a), this.children = [new bo(a)], this.children[0].parent = this
        }
      },
      collapse: function (e) {
        for (var t = 0; t < this.children.length; ++t) this.children[t].collapse(e)
      },
      insertInner: function (e, t, n) {
        this.size += t.length, this.height += n;
        for (var r = 0; r < this.children.length; ++r) {
          var i = this.children[r],
            o = i.chunkSize();
          if (e <= o) {
            if (i.insertInner(e, t, n), i.lines && i.lines.length > 50) {
              for (var s = i.lines.length % 25 + 25, a = s; a < i.lines.length;) {
                var l = new bo(i.lines.slice(a, a += 25));
                i.height -= l.height, this.children.splice(++r, 0, l), l.parent = this
              }
              i.lines = i.lines.slice(0, s), this.maybeSpill()
            }
            break
          }
          e -= o
        }
      },
      maybeSpill: function () {
        if (!(this.children.length <= 10)) {
          var e = this;
          do {
            var t = new So(e.children.splice(e.children.length - 5, 5));
            if (e.parent) {
              e.size -= t.size, e.height -= t.height;
              var n = z(e.parent.children, e);
              e.parent.children.splice(n + 1, 0, t)
            } else {
              var r = new So(e.children);
              r.parent = e, e.children = [r, t], e = r
            }
            t.parent = e.parent
          } while (e.children.length > 10);
          e.parent.maybeSpill()
        }
      },
      iterN: function (e, t, n) {
        for (var r = 0; r < this.children.length; ++r) {
          var i = this.children[r],
            o = i.chunkSize();
          if (e < o) {
            var s = Math.min(t, o - e);
            if (i.iterN(e, s, n)) return !0;
            if (0 == (t -= s)) break;
            e = 0
          } else e -= o
        }
      }
    };
    var Co = function (e, t, n) {
      if (n)
        for (var r in n) n.hasOwnProperty(r) && (this[r] = n[r]);
      this.doc = e, this.node = t
    };

    function Eo(e, t, n) {
      Vt(t) < (e.curOp && e.curOp.scrollTop || e.doc.scrollTop) && Ar(e, n)
    }
    Co.prototype.clear = function () {
      var e = this.doc.cm,
        t = this.line.widgets,
        n = this.line,
        r = Qe(n);
      if (null != r && t) {
        for (var i = 0; i < t.length; ++i) t[i] == this && t.splice(i--, 1);
        t.length || (n.widgets = null);
        var o = Sn(this);
        Ye(n, Math.max(0, n.height - o)), e && (Jr(e, (function () {
          Eo(e, n, -o), pr(e, r, "widget")
        })), ln(e, "lineWidgetCleared", e, this, r))
      }
    }, Co.prototype.changed = function () {
      var e = this,
        t = this.height,
        n = this.doc.cm,
        r = this.line;
      this.height = null;
      var i = Sn(this) - t;
      i && (Ut(this.doc, r) || Ye(r, r.height + i), n && Jr(n, (function () {
        n.curOp.forceUpdate = !0, Eo(n, r, i), ln(n, "lineWidgetChanged", n, e, Qe(r))
      })))
    }, ve(Co);
    var ko = 0,
      xo = function (e, t) {
        this.lines = [], this.type = t, this.doc = e, this.id = ++ko
      };

    function To(e, t, n, r, i) {
      if (r && r.shared) return function (e, t, n, r, i) {
        (r = F(r)).shared = !1;
        var o = [To(e, t, n, r, i)],
          s = o[0],
          a = r.widgetNode;
        return Oi(e, (function (e) {
          a && (r.widgetNode = a.cloneNode(!0)), o.push(To(e, at(e, t), at(e, n), r, i));
          for (var l = 0; l < e.linked.length; ++l)
            if (e.linked[l].isParent) return;
          s = K(o)
        })), new Ro(o, s)
      }(e, t, n, r, i);
      if (e.cm && !e.cm.curOp) return ei(e.cm, To)(e, t, n, r, i);
      var o = new xo(e, i),
        s = tt(t, n);
      if (r && F(r, o, !1), s > 0 || 0 == s && !1 !== o.clearWhenEmpty) return o;
      if (o.replacedWith && (o.collapsed = !0, o.widgetNode = A("span", [o.replacedWith], "CodeMirror-widget"), r.handleMouseEvents || o.widgetNode.setAttribute("cm-ignore-events", "true"), r.insertLeft && (o.widgetNode.insertLeft = !0)), o.collapsed) {
        if (Ft(e, t.line, t, n, o) || t.line != n.line && Ft(e, n.line, t, n, o)) throw new Error("Inserting collapsed marker partially overlapping an existing one");
        Ct = !0
      }
      o.addToHistory && zi(e, {
        from: t,
        to: n,
        origin: "markText"
      }, e.sel, NaN);
      var a, l = t.line,
        c = e.cm;
      if (e.iter(l, n.line + 1, (function (e) {
          c && o.collapsed && !c.options.lineWrapping && Bt(e) == c.display.maxLine && (a = !0), o.collapsed && l != t.line && Ye(e, 0),
            function (e, t) {
              e.markedSpans = e.markedSpans ? e.markedSpans.concat([t]) : [t], t.marker.attachLine(e)
            }(e, new Et(o, l == t.line ? t.ch : null, l == n.line ? n.ch : null)), ++l
        })), o.collapsed && e.iter(t.line, n.line + 1, (function (t) {
          Ut(e, t) && Ye(t, 0)
        })), o.clearOnEnter && he(o, "beforeCursorEnter", (function () {
          return o.clear()
        })), o.readOnly && (St = !0, (e.history.done.length || e.history.undone.length) && e.clearHistory()), o.collapsed && (o.id = ++ko, o.atomic = !0), c) {
        if (a && (c.curOp.updateMaxLine = !0), o.collapsed) hr(c, t.line, n.line + 1);
        else if (o.className || o.startStyle || o.endStyle || o.css || o.attributes || o.title)
          for (var u = t.line; u <= n.line; u++) pr(c, u, "text");
        o.atomic && no(c.doc), ln(c, "markerAdded", c, o)
      }
      return o
    }
    xo.prototype.clear = function () {
      if (!this.explicitlyCleared) {
        var e = this.doc.cm,
          t = e && !e.curOp;
        if (t && $r(e), ye(this, "clear")) {
          var n = this.find();
          n && ln(this, "clear", n.from, n.to)
        }
        for (var r = null, i = null, o = 0; o < this.lines.length; ++o) {
          var s = this.lines[o],
            a = kt(s.markedSpans, this);
          e && !this.collapsed ? pr(e, Qe(s), "text") : e && (null != a.to && (i = Qe(s)), null != a.from && (r = Qe(s))), s.markedSpans = xt(s.markedSpans, a), null == a.from && this.collapsed && !Ut(this.doc, s) && e && Ye(s, rr(e.display))
        }
        if (e && this.collapsed && !e.options.lineWrapping)
          for (var l = 0; l < this.lines.length; ++l) {
            var c = Bt(this.lines[l]),
              u = jt(c);
            u > e.display.maxLineLength && (e.display.maxLine = c, e.display.maxLineLength = u, e.display.maxLineChanged = !0)
          }
        null != r && e && this.collapsed && hr(e, r, i + 1), this.lines.length = 0, this.explicitlyCleared = !0, this.atomic && this.doc.cantEdit && (this.doc.cantEdit = !1, e && no(e.doc)), e && ln(e, "markerCleared", e, this, r, i), t && qr(e), this.parent && this.parent.clear()
      }
    }, xo.prototype.find = function (e, t) {
      var n, r;
      null == e && "bookmark" == this.type && (e = 1);
      for (var i = 0; i < this.lines.length; ++i) {
        var o = this.lines[i],
          s = kt(o.markedSpans, this);
        if (null != s.from && (n = et(t ? o : Qe(o), s.from), -1 == e)) return n;
        if (null != s.to && (r = et(t ? o : Qe(o), s.to), 1 == e)) return r
      }
      return n && {
        from: n,
        to: r
      }
    }, xo.prototype.changed = function () {
      var e = this,
        t = this.find(-1, !0),
        n = this,
        r = this.doc.cm;
      t && r && Jr(r, (function () {
        var i = t.line,
          o = Qe(t.line),
          s = Mn(r, o);
        if (s && (Bn(s), r.curOp.selectionChanged = r.curOp.forceUpdate = !0), r.curOp.updateMaxLine = !0, !Ut(n.doc, i) && null != n.height) {
          var a = n.height;
          n.height = null;
          var l = Sn(n) - a;
          l && Ye(i, i.height + l)
        }
        ln(r, "markerChanged", r, e)
      }))
    }, xo.prototype.attachLine = function (e) {
      if (!this.lines.length && this.doc.cm) {
        var t = this.doc.cm.curOp;
        t.maybeHiddenMarkers && -1 != z(t.maybeHiddenMarkers, this) || (t.maybeUnhiddenMarkers || (t.maybeUnhiddenMarkers = [])).push(this)
      }
      this.lines.push(e)
    }, xo.prototype.detachLine = function (e) {
      if (this.lines.splice(z(this.lines, e), 1), !this.lines.length && this.doc.cm) {
        var t = this.doc.cm.curOp;
        (t.maybeHiddenMarkers || (t.maybeHiddenMarkers = [])).push(this)
      }
    }, ve(xo);
    var Ro = function (e, t) {
      this.markers = e, this.primary = t;
      for (var n = 0; n < e.length; ++n) e[n].parent = this
    };

    function Do(e) {
      return e.findMarks(et(e.first, 0), e.clipPos(et(e.lastLine())), (function (e) {
        return e.parent
      }))
    }

    function _o(e) {
      for (var t = function (t) {
          var n = e[t],
            r = [n.primary.doc];
          Oi(n.primary.doc, (function (e) {
            return r.push(e)
          }));
          for (var i = 0; i < n.markers.length; i++) {
            var o = n.markers[i]; - 1 == z(r, o.doc) && (o.parent = null, n.markers.splice(i--, 1))
          }
        }, n = 0; n < e.length; n++) t(n)
    }
    Ro.prototype.clear = function () {
      if (!this.explicitlyCleared) {
        this.explicitlyCleared = !0;
        for (var e = 0; e < this.markers.length; ++e) this.markers[e].clear();
        ln(this, "clear")
      }
    }, Ro.prototype.find = function (e, t) {
      return this.primary.find(e, t)
    }, ve(Ro);
    var Ao = 0,
      Mo = function (e, t, n, r, i) {
        if (!(this instanceof Mo)) return new Mo(e, t, n, r, i);
        null == n && (n = 0), So.call(this, [new bo([new $t("", null)])]), this.first = n, this.scrollTop = this.scrollLeft = 0, this.cantEdit = !1, this.cleanGeneration = 1, this.modeFrontier = this.highlightFrontier = n;
        var o = et(n, 0);
        this.sel = xi(o), this.history = new Fi(null), this.id = ++Ao, this.modeOption = t, this.lineSep = r, this.direction = "rtl" == i ? "rtl" : "ltr", this.extend = !1, "string" == typeof e && (e = this.splitLines(e)), Ii(this, {
          from: o,
          to: o,
          text: e
        }), Ji(this, xi(o), W)
      };
    Mo.prototype = Z(So.prototype, {
      constructor: Mo,
      iter: function (e, t, n) {
        n ? this.iterN(e - this.first, t - e, n) : this.iterN(this.first, this.first + this.size, e)
      },
      insert: function (e, t) {
        for (var n = 0, r = 0; r < t.length; ++r) n += t[r].height;
        this.insertInner(e - this.first, t, n)
      },
      remove: function (e, t) {
        this.removeInner(e - this.first, t)
      },
      getValue: function (e) {
        var t = Ke(this, this.first, this.first + this.size);
        return !1 === e ? t : t.join(e || this.lineSeparator())
      },
      setValue: ni((function (e) {
        var t = et(this.first, 0),
          n = this.first + this.size - 1;
        co(this, {
          from: t,
          to: et(n, $e(this, n).text.length),
          text: this.splitLines(e),
          origin: "setValue",
          full: !0
        }, !0), this.cm && Pr(this.cm, 0, 0), Ji(this, xi(t), W)
      })),
      replaceRange: function (e, t, n, r) {
        mo(this, e, t = at(this, t), n = n ? at(this, n) : t, r)
      },
      getRange: function (e, t, n) {
        var r = qe(this, at(this, e), at(this, t));
        return !1 === n ? r : r.join(n || this.lineSeparator())
      },
      getLine: function (e) {
        var t = this.getLineHandle(e);
        return t && t.text
      },
      getLineHandle: function (e) {
        if (Xe(this, e)) return $e(this, e)
      },
      getLineNumber: function (e) {
        return Qe(e)
      },
      getLineHandleVisualStart: function (e) {
        return "number" == typeof e && (e = $e(this, e)), Bt(e)
      },
      lineCount: function () {
        return this.size
      },
      firstLine: function () {
        return this.first
      },
      lastLine: function () {
        return this.first + this.size - 1
      },
      clipPos: function (e) {
        return at(this, e)
      },
      getCursor: function (e) {
        var t = this.sel.primary();
        return null == e || "head" == e ? t.head : "anchor" == e ? t.anchor : "end" == e || "to" == e || !1 === e ? t.to() : t.from()
      },
      listSelections: function () {
        return this.sel.ranges
      },
      somethingSelected: function () {
        return this.sel.somethingSelected()
      },
      setCursor: ni((function (e, t, n) {
        Zi(this, at(this, "number" == typeof e ? et(e, t || 0) : e), null, n)
      })),
      setSelection: ni((function (e, t, n) {
        Zi(this, at(this, e), at(this, t || e), n)
      })),
      extendSelection: ni((function (e, t, n) {
        Ki(this, at(this, e), t && at(this, t), n)
      })),
      extendSelections: ni((function (e, t) {
        Yi(this, lt(this, e), t)
      })),
      extendSelectionsBy: ni((function (e, t) {
        Yi(this, lt(this, Y(this.sel.ranges, e)), t)
      })),
      setSelections: ni((function (e, t, n) {
        if (e.length) {
          for (var r = [], i = 0; i < e.length; i++) r[i] = new Ei(at(this, e[i].anchor), at(this, e[i].head));
          null == t && (t = Math.min(e.length - 1, this.sel.primIndex)), Ji(this, ki(this.cm, r, t), n)
        }
      })),
      addSelection: ni((function (e, t, n) {
        var r = this.sel.ranges.slice(0);
        r.push(new Ei(at(this, e), at(this, t || e))), Ji(this, ki(this.cm, r, r.length - 1), n)
      })),
      getSelection: function (e) {
        for (var t, n = this.sel.ranges, r = 0; r < n.length; r++) {
          var i = qe(this, n[r].from(), n[r].to());
          t = t ? t.concat(i) : i
        }
        return !1 === e ? t : t.join(e || this.lineSeparator())
      },
      getSelections: function (e) {
        for (var t = [], n = this.sel.ranges, r = 0; r < n.length; r++) {
          var i = qe(this, n[r].from(), n[r].to());
          !1 !== e && (i = i.join(e || this.lineSeparator())), t[r] = i
        }
        return t
      },
      replaceSelection: function (e, t, n) {
        for (var r = [], i = 0; i < this.sel.ranges.length; i++) r[i] = e;
        this.replaceSelections(r, t, n || "+input")
      },
      replaceSelections: ni((function (e, t, n) {
        for (var r = [], i = this.sel, o = 0; o < i.ranges.length; o++) {
          var s = i.ranges[o];
          r[o] = {
            from: s.from(),
            to: s.to(),
            text: this.splitLines(e[o]),
            origin: n
          }
        }
        for (var a = t && "end" != t && function (e, t, n) {
            for (var r = [], i = et(e.first, 0), o = i, s = 0; s < t.length; s++) {
              var a = t[s],
                l = _i(a.from, i, o),
                c = _i(Ti(a), i, o);
              if (i = a.to, o = c, "around" == n) {
                var u = e.sel.ranges[s],
                  h = tt(u.head, u.anchor) < 0;
                r[s] = new Ei(h ? c : l, h ? l : c)
              } else r[s] = new Ei(l, l)
            }
            return new Ci(r, e.sel.primIndex)
          }(this, r, t), l = r.length - 1; l >= 0; l--) co(this, r[l]);
        a ? Xi(this, a) : this.cm && Mr(this.cm)
      })),
      undo: ni((function () {
        ho(this, "undo")
      })),
      redo: ni((function () {
        ho(this, "redo")
      })),
      undoSelection: ni((function () {
        ho(this, "undo", !0)
      })),
      redoSelection: ni((function () {
        ho(this, "redo", !0)
      })),
      setExtending: function (e) {
        this.extend = e
      },
      getExtending: function () {
        return this.extend
      },
      historySize: function () {
        for (var e = this.history, t = 0, n = 0, r = 0; r < e.done.length; r++) e.done[r].ranges || ++t;
        for (var i = 0; i < e.undone.length; i++) e.undone[i].ranges || ++n;
        return {
          undo: t,
          redo: n
        }
      },
      clearHistory: function () {
        this.history = new Fi(this.history.maxGeneration)
      },
      markClean: function () {
        this.cleanGeneration = this.changeGeneration(!0)
      },
      changeGeneration: function (e) {
        return e && (this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null), this.history.generation
      },
      isClean: function (e) {
        return this.history.generation == (e || this.cleanGeneration)
      },
      getHistory: function () {
        return {
          done: $i(this.history.done),
          undone: $i(this.history.undone)
        }
      },
      setHistory: function (e) {
        var t = this.history = new Fi(this.history.maxGeneration);
        t.done = $i(e.done.slice(0), null, !0), t.undone = $i(e.undone.slice(0), null, !0)
      },
      setGutterMarker: ni((function (e, t, n) {
        return wo(this, e, "gutter", (function (e) {
          var r = e.gutterMarkers || (e.gutterMarkers = {});
          return r[t] = n, !n && te(r) && (e.gutterMarkers = null), !0
        }))
      })),
      clearGutter: ni((function (e) {
        var t = this;
        this.iter((function (n) {
          n.gutterMarkers && n.gutterMarkers[e] && wo(t, n, "gutter", (function () {
            return n.gutterMarkers[e] = null, te(n.gutterMarkers) && (n.gutterMarkers = null), !0
          }))
        }))
      })),
      lineInfo: function (e) {
        var t;
        if ("number" == typeof e) {
          if (!Xe(this, e)) return null;
          if (t = e, !(e = $e(this, e))) return null
        } else if (null == (t = Qe(e))) return null;
        return {
          line: t,
          handle: e,
          text: e.text,
          gutterMarkers: e.gutterMarkers,
          textClass: e.textClass,
          bgClass: e.bgClass,
          wrapClass: e.wrapClass,
          widgets: e.widgets
        }
      },
      addLineClass: ni((function (e, t, n) {
        return wo(this, e, "gutter" == t ? "gutter" : "class", (function (e) {
          var r = "text" == t ? "textClass" : "background" == t ? "bgClass" : "gutter" == t ? "gutterClass" : "wrapClass";
          if (e[r]) {
            if (k(n).test(e[r])) return !1;
            e[r] += " " + n
          } else e[r] = n;
          return !0
        }))
      })),
      removeLineClass: ni((function (e, t, n) {
        return wo(this, e, "gutter" == t ? "gutter" : "class", (function (e) {
          var r = "text" == t ? "textClass" : "background" == t ? "bgClass" : "gutter" == t ? "gutterClass" : "wrapClass",
            i = e[r];
          if (!i) return !1;
          if (null == n) e[r] = null;
          else {
            var o = i.match(k(n));
            if (!o) return !1;
            var s = o.index + o[0].length;
            e[r] = i.slice(0, o.index) + (o.index && s != i.length ? " " : "") + i.slice(s) || null
          }
          return !0
        }))
      })),
      addLineWidget: ni((function (e, t, n) {
        return function (e, t, n, r) {
          var i = new Co(e, n, r),
            o = e.cm;
          return o && i.noHScroll && (o.display.alignWidgets = !0), wo(e, t, "widget", (function (t) {
            var n = t.widgets || (t.widgets = []);
            if (null == i.insertAt ? n.push(i) : n.splice(Math.min(n.length - 1, Math.max(0, i.insertAt)), 0, i), i.line = t, o && !Ut(e, t)) {
              var r = Vt(t) < e.scrollTop;
              Ye(t, t.height + Sn(i)), r && Ar(o, i.height), o.curOp.forceUpdate = !0
            }
            return !0
          })), o && ln(o, "lineWidgetAdded", o, i, "number" == typeof t ? t : Qe(t)), i
        }(this, e, t, n)
      })),
      removeLineWidget: function (e) {
        e.clear()
      },
      markText: function (e, t, n) {
        return To(this, at(this, e), at(this, t), n, n && n.type || "range")
      },
      setBookmark: function (e, t) {
        var n = {
          replacedWith: t && (null == t.nodeType ? t.widget : t),
          insertLeft: t && t.insertLeft,
          clearWhenEmpty: !1,
          shared: t && t.shared,
          handleMouseEvents: t && t.handleMouseEvents
        };
        return To(this, e = at(this, e), e, n, "bookmark")
      },
      findMarksAt: function (e) {
        var t = [],
          n = $e(this, (e = at(this, e)).line).markedSpans;
        if (n)
          for (var r = 0; r < n.length; ++r) {
            var i = n[r];
            (null == i.from || i.from <= e.ch) && (null == i.to || i.to >= e.ch) && t.push(i.marker.parent || i.marker)
          }
        return t
      },
      findMarks: function (e, t, n) {
        e = at(this, e), t = at(this, t);
        var r = [],
          i = e.line;
        return this.iter(e.line, t.line + 1, (function (o) {
          var s = o.markedSpans;
          if (s)
            for (var a = 0; a < s.length; a++) {
              var l = s[a];
              null != l.to && i == e.line && e.ch >= l.to || null == l.from && i != e.line || null != l.from && i == t.line && l.from >= t.ch || n && !n(l.marker) || r.push(l.marker.parent || l.marker)
            }++i
        })), r
      },
      getAllMarks: function () {
        var e = [];
        return this.iter((function (t) {
          var n = t.markedSpans;
          if (n)
            for (var r = 0; r < n.length; ++r) null != n[r].from && e.push(n[r].marker)
        })), e
      },
      posFromIndex: function (e) {
        var t, n = this.first,
          r = this.lineSeparator().length;
        return this.iter((function (i) {
          var o = i.text.length + r;
          if (o > e) return t = e, !0;
          e -= o, ++n
        })), at(this, et(n, t))
      },
      indexFromPos: function (e) {
        var t = (e = at(this, e)).ch;
        if (e.line < this.first || e.ch < 0) return 0;
        var n = this.lineSeparator().length;
        return this.iter(this.first, e.line, (function (e) {
          t += e.text.length + n
        })), t
      },
      copy: function (e) {
        var t = new Mo(Ke(this, this.first, this.first + this.size), this.modeOption, this.first, this.lineSep, this.direction);
        return t.scrollTop = this.scrollTop, t.scrollLeft = this.scrollLeft, t.sel = this.sel, t.extend = !1, e && (t.history.undoDepth = this.history.undoDepth, t.setHistory(this.getHistory())), t
      },
      linkedDoc: function (e) {
        e || (e = {});
        var t = this.first,
          n = this.first + this.size;
        null != e.from && e.from > t && (t = e.from), null != e.to && e.to < n && (n = e.to);
        var r = new Mo(Ke(this, t, n), e.mode || this.modeOption, t, this.lineSep, this.direction);
        return e.sharedHist && (r.history = this.history), (this.linked || (this.linked = [])).push({
            doc: r,
            sharedHist: e.sharedHist
          }), r.linked = [{
            doc: this,
            isParent: !0,
            sharedHist: e.sharedHist
          }],
          function (e, t) {
            for (var n = 0; n < t.length; n++) {
              var r = t[n],
                i = r.find(),
                o = e.clipPos(i.from),
                s = e.clipPos(i.to);
              if (tt(o, s)) {
                var a = To(e, o, s, r.primary, r.primary.type);
                r.markers.push(a), a.parent = r
              }
            }
          }(r, Do(this)), r
      },
      unlinkDoc: function (e) {
        if (e instanceof Rs && (e = e.doc), this.linked)
          for (var t = 0; t < this.linked.length; ++t)
            if (this.linked[t].doc == e) {
              this.linked.splice(t, 1), e.unlinkDoc(this), _o(Do(this));
              break
            } if (e.history == this.history) {
          var n = [e.id];
          Oi(e, (function (e) {
            return n.push(e.id)
          }), !0), e.history = new Fi(null), e.history.done = $i(this.history.done, n), e.history.undone = $i(this.history.undone, n)
        }
      },
      iterLinkedDocs: function (e) {
        Oi(this, e)
      },
      getMode: function () {
        return this.mode
      },
      getEditor: function () {
        return this.cm
      },
      splitLines: function (e) {
        return this.lineSep ? e.split(this.lineSep) : Me(e)
      },
      lineSeparator: function () {
        return this.lineSep || "\n"
      },
      setDirection: ni((function (e) {
        var t;
        "rtl" != e && (e = "ltr"), e != this.direction && (this.direction = e, this.iter((function (e) {
          return e.order = null
        })), this.cm && Jr(t = this.cm, (function () {
          Ni(t), hr(t)
        })))
      }))
    }), Mo.prototype.eachLine = Mo.prototype.iter;
    var Po = 0;

    function Io(e) {
      var t = this;
      if (Oo(t), !me(t, e) && !Cn(t.display, e)) {
        we(e), s && (Po = +new Date);
        var n = cr(t, e, !0),
          r = e.dataTransfer.files;
        if (n && !t.isReadOnly())
          if (r && r.length && window.FileReader && window.File)
            for (var i = r.length, o = Array(i), a = 0, l = function (e, r) {
                if (!t.options.allowDropFileTypes || -1 != z(t.options.allowDropFileTypes, e.type)) {
                  var s = new FileReader;
                  s.onload = ei(t, (function () {
                    var e = s.result;
                    if (/[\x00-\x08\x0e-\x1f]{2}/.test(e) && (e = ""), o[r] = e, ++a == i) {
                      var l = {
                        from: n = at(t.doc, n),
                        to: n,
                        text: t.doc.splitLines(o.join(t.doc.lineSeparator())),
                        origin: "paste"
                      };
                      co(t.doc, l), Xi(t.doc, xi(n, Ti(l)))
                    }
                  })), s.readAsText(e)
                }
              }, c = 0; c < i; ++c) l(r[c], c);
          else {
            if (t.state.draggingText && t.doc.sel.contains(n) > -1) return t.state.draggingText(e), void setTimeout((function () {
              return t.display.input.focus()
            }), 20);
            try {
              var u = e.dataTransfer.getData("Text");
              if (u) {
                var h;
                if (t.state.draggingText && !t.state.draggingText.copy && (h = t.listSelections()), eo(t.doc, xi(n, n)), h)
                  for (var p = 0; p < h.length; ++p) mo(t.doc, "", h[p].anchor, h[p].head, "drag");
                t.replaceSelection(u, "around", "paste"), t.display.input.focus()
              }
            } catch (e) {}
          }
      }
    }

    function Oo(e) {
      e.display.dragCursor && (e.display.lineSpace.removeChild(e.display.dragCursor), e.display.dragCursor = null)
    }

    function Lo(e) {
      if (document.getElementsByClassName) {
        for (var t = document.getElementsByClassName("CodeMirror"), n = [], r = 0; r < t.length; r++) {
          var i = t[r].CodeMirror;
          i && n.push(i)
        }
        n.length && n[0].operation((function () {
          for (var t = 0; t < n.length; t++) e(n[t])
        }))
      }
    }
    var No = !1;

    function Fo() {
      var e;
      No || (he(window, "resize", (function () {
        null == e && (e = setTimeout((function () {
          e = null, Lo(Bo)
        }), 100))
      })), he(window, "blur", (function () {
        return Lo(xr)
      })), No = !0)
    }

    function Bo(e) {
      var t = e.display;
      t.cachedCharWidth = t.cachedTextHeight = t.cachedPaddingH = null, t.scrollbarsClipped = !1, e.setSize()
    }
    for (var Ho = {
        3: "Pause",
        8: "Backspace",
        9: "Tab",
        13: "Enter",
        16: "Shift",
        17: "Ctrl",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Esc",
        32: "Space",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "Left",
        38: "Up",
        39: "Right",
        40: "Down",
        44: "PrintScrn",
        45: "Insert",
        46: "Delete",
        59: ";",
        61: "=",
        91: "Mod",
        92: "Mod",
        93: "Mod",
        106: "*",
        107: "=",
        109: "-",
        110: ".",
        111: "/",
        145: "ScrollLock",
        173: "-",
        186: ";",
        187: "=",
        188: ",",
        189: "-",
        190: ".",
        191: "/",
        192: "`",
        219: "[",
        220: "\\",
        221: "]",
        222: "'",
        63232: "Up",
        63233: "Down",
        63234: "Left",
        63235: "Right",
        63272: "Delete",
        63273: "Home",
        63275: "End",
        63276: "PageUp",
        63277: "PageDown",
        63302: "Insert"
      }, zo = 0; zo < 10; zo++) Ho[zo + 48] = Ho[zo + 96] = String(zo);
    for (var Uo = 65; Uo <= 90; Uo++) Ho[Uo] = String.fromCharCode(Uo);
    for (var Wo = 1; Wo <= 12; Wo++) Ho[Wo + 111] = Ho[Wo + 63235] = "F" + Wo;
    var Vo = {};

    function jo(e) {
      var t, n, r, i, o = e.split(/-(?!$)/);
      e = o[o.length - 1];
      for (var s = 0; s < o.length - 1; s++) {
        var a = o[s];
        if (/^(cmd|meta|m)$/i.test(a)) i = !0;
        else if (/^a(lt)?$/i.test(a)) t = !0;
        else if (/^(c|ctrl|control)$/i.test(a)) n = !0;
        else {
          if (!/^s(hift)?$/i.test(a)) throw new Error("Unrecognized modifier name: " + a);
          r = !0
        }
      }
      return t && (e = "Alt-" + e), n && (e = "Ctrl-" + e), i && (e = "Cmd-" + e), r && (e = "Shift-" + e), e
    }

    function Go(e) {
      var t = {};
      for (var n in e)
        if (e.hasOwnProperty(n)) {
          var r = e[n];
          if (/^(name|fallthrough|(de|at)tach)$/.test(n)) continue;
          if ("..." == r) {
            delete e[n];
            continue
          }
          for (var i = Y(n.split(" "), jo), o = 0; o < i.length; o++) {
            var s = void 0,
              a = void 0;
            o == i.length - 1 ? (a = i.join(" "), s = r) : (a = i.slice(0, o + 1).join(" "), s = "...");
            var l = t[a];
            if (l) {
              if (l != s) throw new Error("Inconsistent bindings for " + a)
            } else t[a] = s
          }
          delete e[n]
        } for (var c in t) e[c] = t[c];
      return e
    }

    function $o(e, t, n, r) {
      var i = (t = Qo(t)).call ? t.call(e, r) : t[e];
      if (!1 === i) return "nothing";
      if ("..." === i) return "multi";
      if (null != i && n(i)) return "handled";
      if (t.fallthrough) {
        if ("[object Array]" != Object.prototype.toString.call(t.fallthrough)) return $o(e, t.fallthrough, n, r);
        for (var o = 0; o < t.fallthrough.length; o++) {
          var s = $o(e, t.fallthrough[o], n, r);
          if (s) return s
        }
      }
    }

    function qo(e) {
      var t = "string" == typeof e ? e : Ho[e.keyCode];
      return "Ctrl" == t || "Alt" == t || "Shift" == t || "Mod" == t
    }

    function Ko(e, t, n) {
      var r = e;
      return t.altKey && "Alt" != r && (e = "Alt-" + e), (C ? t.metaKey : t.ctrlKey) && "Ctrl" != r && (e = "Ctrl-" + e), (C ? t.ctrlKey : t.metaKey) && "Cmd" != r && (e = "Cmd-" + e), !n && t.shiftKey && "Shift" != r && (e = "Shift-" + e), e
    }

    function Yo(e, t) {
      if (h && 34 == e.keyCode && e.char) return !1;
      var n = Ho[e.keyCode];
      return null != n && !e.altGraphKey && (3 == e.keyCode && e.code && (n = e.code), Ko(n, e, t))
    }

    function Qo(e) {
      return "string" == typeof e ? Vo[e] : e
    }

    function Zo(e, t) {
      for (var n = e.doc.sel.ranges, r = [], i = 0; i < n.length; i++) {
        for (var o = t(n[i]); r.length && tt(o.from, K(r).to) <= 0;) {
          var s = r.pop();
          if (tt(s.from, o.from) < 0) {
            o.from = s.from;
            break
          }
        }
        r.push(o)
      }
      Jr(e, (function () {
        for (var t = r.length - 1; t >= 0; t--) mo(e.doc, "", r[t].from, r[t].to, "+delete");
        Mr(e)
      }))
    }

    function Xo(e, t, n) {
      var r = ie(e.text, t + n, n);
      return r < 0 || r > e.text.length ? null : r
    }

    function Jo(e, t, n) {
      var r = Xo(e, t.ch, n);
      return null == r ? null : new et(t.line, r, n < 0 ? "after" : "before")
    }

    function es(e, t, n, r, i) {
      if (e) {
        var o = ce(n, t.doc.direction);
        if (o) {
          var s, a = i < 0 ? K(o) : o[0],
            l = i < 0 == (1 == a.level) ? "after" : "before";
          if (a.level > 0 || "rtl" == t.doc.direction) {
            var c = Pn(t, n);
            s = i < 0 ? n.text.length - 1 : 0;
            var u = In(t, c, s).top;
            s = oe((function (e) {
              return In(t, c, e).top == u
            }), i < 0 == (1 == a.level) ? a.from : a.to - 1, s), "before" == l && (s = Xo(n, s, 1))
          } else s = i < 0 ? a.to : a.from;
          return new et(r, s, l)
        }
      }
      return new et(r, i < 0 ? n.text.length : 0, i < 0 ? "before" : "after")
    }
    Vo.basic = {
      Left: "goCharLeft",
      Right: "goCharRight",
      Up: "goLineUp",
      Down: "goLineDown",
      End: "goLineEnd",
      Home: "goLineStartSmart",
      PageUp: "goPageUp",
      PageDown: "goPageDown",
      Delete: "delCharAfter",
      Backspace: "delCharBefore",
      "Shift-Backspace": "delCharBefore",
      Tab: "defaultTab",
      "Shift-Tab": "indentAuto",
      Enter: "newlineAndIndent",
      Insert: "toggleOverwrite",
      Esc: "singleSelection"
    }, Vo.pcDefault = {
      "Ctrl-A": "selectAll",
      "Ctrl-D": "deleteLine",
      "Ctrl-Z": "undo",
      "Shift-Ctrl-Z": "redo",
      "Ctrl-Y": "redo",
      "Ctrl-Home": "goDocStart",
      "Ctrl-End": "goDocEnd",
      "Ctrl-Up": "goLineUp",
      "Ctrl-Down": "goLineDown",
      "Ctrl-Left": "goGroupLeft",
      "Ctrl-Right": "goGroupRight",
      "Alt-Left": "goLineStart",
      "Alt-Right": "goLineEnd",
      "Ctrl-Backspace": "delGroupBefore",
      "Ctrl-Delete": "delGroupAfter",
      "Ctrl-S": "save",
      "Ctrl-F": "find",
      "Ctrl-G": "findNext",
      "Shift-Ctrl-G": "findPrev",
      "Shift-Ctrl-F": "replace",
      "Shift-Ctrl-R": "replaceAll",
      "Ctrl-[": "indentLess",
      "Ctrl-]": "indentMore",
      "Ctrl-U": "undoSelection",
      "Shift-Ctrl-U": "redoSelection",
      "Alt-U": "redoSelection",
      fallthrough: "basic"
    }, Vo.emacsy = {
      "Ctrl-F": "goCharRight",
      "Ctrl-B": "goCharLeft",
      "Ctrl-P": "goLineUp",
      "Ctrl-N": "goLineDown",
      "Alt-F": "goWordRight",
      "Alt-B": "goWordLeft",
      "Ctrl-A": "goLineStart",
      "Ctrl-E": "goLineEnd",
      "Ctrl-V": "goPageDown",
      "Shift-Ctrl-V": "goPageUp",
      "Ctrl-D": "delCharAfter",
      "Ctrl-H": "delCharBefore",
      "Alt-D": "delWordAfter",
      "Alt-Backspace": "delWordBefore",
      "Ctrl-K": "killLine",
      "Ctrl-T": "transposeChars",
      "Ctrl-O": "openLine"
    }, Vo.macDefault = {
      "Cmd-A": "selectAll",
      "Cmd-D": "deleteLine",
      "Cmd-Z": "undo",
      "Shift-Cmd-Z": "redo",
      "Cmd-Y": "redo",
      "Cmd-Home": "goDocStart",
      "Cmd-Up": "goDocStart",
      "Cmd-End": "goDocEnd",
      "Cmd-Down": "goDocEnd",
      "Alt-Left": "goGroupLeft",
      "Alt-Right": "goGroupRight",
      "Cmd-Left": "goLineLeft",
      "Cmd-Right": "goLineRight",
      "Alt-Backspace": "delGroupBefore",
      "Ctrl-Alt-Backspace": "delGroupAfter",
      "Alt-Delete": "delGroupAfter",
      "Cmd-S": "save",
      "Cmd-F": "find",
      "Cmd-G": "findNext",
      "Shift-Cmd-G": "findPrev",
      "Cmd-Alt-F": "replace",
      "Shift-Cmd-Alt-F": "replaceAll",
      "Cmd-[": "indentLess",
      "Cmd-]": "indentMore",
      "Cmd-Backspace": "delWrappedLineLeft",
      "Cmd-Delete": "delWrappedLineRight",
      "Cmd-U": "undoSelection",
      "Shift-Cmd-U": "redoSelection",
      "Ctrl-Up": "goDocStart",
      "Ctrl-Down": "goDocEnd",
      fallthrough: ["basic", "emacsy"]
    }, Vo.default = v ? Vo.macDefault : Vo.pcDefault;
    var ts = {
      selectAll: ao,
      singleSelection: function (e) {
        return e.setSelection(e.getCursor("anchor"), e.getCursor("head"), W)
      },
      killLine: function (e) {
        return Zo(e, (function (t) {
          if (t.empty()) {
            var n = $e(e.doc, t.head.line).text.length;
            return t.head.ch == n && t.head.line < e.lastLine() ? {
              from: t.head,
              to: et(t.head.line + 1, 0)
            } : {
              from: t.head,
              to: et(t.head.line, n)
            }
          }
          return {
            from: t.from(),
            to: t.to()
          }
        }))
      },
      deleteLine: function (e) {
        return Zo(e, (function (t) {
          return {
            from: et(t.from().line, 0),
            to: at(e.doc, et(t.to().line + 1, 0))
          }
        }))
      },
      delLineLeft: function (e) {
        return Zo(e, (function (e) {
          return {
            from: et(e.from().line, 0),
            to: e.from()
          }
        }))
      },
      delWrappedLineLeft: function (e) {
        return Zo(e, (function (t) {
          var n = e.charCoords(t.head, "div").top + 5;
          return {
            from: e.coordsChar({
              left: 0,
              top: n
            }, "div"),
            to: t.from()
          }
        }))
      },
      delWrappedLineRight: function (e) {
        return Zo(e, (function (t) {
          var n = e.charCoords(t.head, "div").top + 5,
            r = e.coordsChar({
              left: e.display.lineDiv.offsetWidth + 100,
              top: n
            }, "div");
          return {
            from: t.from(),
            to: r
          }
        }))
      },
      undo: function (e) {
        return e.undo()
      },
      redo: function (e) {
        return e.redo()
      },
      undoSelection: function (e) {
        return e.undoSelection()
      },
      redoSelection: function (e) {
        return e.redoSelection()
      },
      goDocStart: function (e) {
        return e.extendSelection(et(e.firstLine(), 0))
      },
      goDocEnd: function (e) {
        return e.extendSelection(et(e.lastLine()))
      },
      goLineStart: function (e) {
        return e.extendSelectionsBy((function (t) {
          return ns(e, t.head.line)
        }), {
          origin: "+move",
          bias: 1
        })
      },
      goLineStartSmart: function (e) {
        return e.extendSelectionsBy((function (t) {
          return rs(e, t.head)
        }), {
          origin: "+move",
          bias: 1
        })
      },
      goLineEnd: function (e) {
        return e.extendSelectionsBy((function (t) {
          return function (e, t) {
            var n = $e(e.doc, t),
              r = function (e) {
                for (var t; t = Lt(e);) e = t.find(1, !0).line;
                return e
              }(n);
            return r != n && (t = Qe(r)), es(!0, e, n, t, -1)
          }(e, t.head.line)
        }), {
          origin: "+move",
          bias: -1
        })
      },
      goLineRight: function (e) {
        return e.extendSelectionsBy((function (t) {
          var n = e.cursorCoords(t.head, "div").top + 5;
          return e.coordsChar({
            left: e.display.lineDiv.offsetWidth + 100,
            top: n
          }, "div")
        }), j)
      },
      goLineLeft: function (e) {
        return e.extendSelectionsBy((function (t) {
          var n = e.cursorCoords(t.head, "div").top + 5;
          return e.coordsChar({
            left: 0,
            top: n
          }, "div")
        }), j)
      },
      goLineLeftSmart: function (e) {
        return e.extendSelectionsBy((function (t) {
          var n = e.cursorCoords(t.head, "div").top + 5,
            r = e.coordsChar({
              left: 0,
              top: n
            }, "div");
          return r.ch < e.getLine(r.line).search(/\S/) ? rs(e, t.head) : r
        }), j)
      },
      goLineUp: function (e) {
        return e.moveV(-1, "line")
      },
      goLineDown: function (e) {
        return e.moveV(1, "line")
      },
      goPageUp: function (e) {
        return e.moveV(-1, "page")
      },
      goPageDown: function (e) {
        return e.moveV(1, "page")
      },
      goCharLeft: function (e) {
        return e.moveH(-1, "char")
      },
      goCharRight: function (e) {
        return e.moveH(1, "char")
      },
      goColumnLeft: function (e) {
        return e.moveH(-1, "column")
      },
      goColumnRight: function (e) {
        return e.moveH(1, "column")
      },
      goWordLeft: function (e) {
        return e.moveH(-1, "word")
      },
      goGroupRight: function (e) {
        return e.moveH(1, "group")
      },
      goGroupLeft: function (e) {
        return e.moveH(-1, "group")
      },
      goWordRight: function (e) {
        return e.moveH(1, "word")
      },
      delCharBefore: function (e) {
        return e.deleteH(-1, "char")
      },
      delCharAfter: function (e) {
        return e.deleteH(1, "char")
      },
      delWordBefore: function (e) {
        return e.deleteH(-1, "word")
      },
      delWordAfter: function (e) {
        return e.deleteH(1, "word")
      },
      delGroupBefore: function (e) {
        return e.deleteH(-1, "group")
      },
      delGroupAfter: function (e) {
        return e.deleteH(1, "group")
      },
      indentAuto: function (e) {
        return e.indentSelection("smart")
      },
      indentMore: function (e) {
        return e.indentSelection("add")
      },
      indentLess: function (e) {
        return e.indentSelection("subtract")
      },
      insertTab: function (e) {
        return e.replaceSelection("\t")
      },
      insertSoftTab: function (e) {
        for (var t = [], n = e.listSelections(), r = e.options.tabSize, i = 0; i < n.length; i++) {
          var o = n[i].from(),
            s = B(e.getLine(o.line), o.ch, r);
          t.push(q(r - s % r))
        }
        e.replaceSelections(t)
      },
      defaultTab: function (e) {
        e.somethingSelected() ? e.indentSelection("add") : e.execCommand("insertTab")
      },
      transposeChars: function (e) {
        return Jr(e, (function () {
          for (var t = e.listSelections(), n = [], r = 0; r < t.length; r++)
            if (t[r].empty()) {
              var i = t[r].head,
                o = $e(e.doc, i.line).text;
              if (o)
                if (i.ch == o.length && (i = new et(i.line, i.ch - 1)), i.ch > 0) i = new et(i.line, i.ch + 1), e.replaceRange(o.charAt(i.ch - 1) + o.charAt(i.ch - 2), et(i.line, i.ch - 2), i, "+transpose");
                else if (i.line > e.doc.first) {
                var s = $e(e.doc, i.line - 1).text;
                s && (i = new et(i.line, 1), e.replaceRange(o.charAt(0) + e.doc.lineSeparator() + s.charAt(s.length - 1), et(i.line - 1, s.length - 1), i, "+transpose"))
              }
              n.push(new Ei(i, i))
            } e.setSelections(n)
        }))
      },
      newlineAndIndent: function (e) {
        return Jr(e, (function () {
          for (var t = e.listSelections(), n = t.length - 1; n >= 0; n--) e.replaceRange(e.doc.lineSeparator(), t[n].anchor, t[n].head, "+input");
          t = e.listSelections();
          for (var r = 0; r < t.length; r++) e.indentLine(t[r].from().line, null, !0);
          Mr(e)
        }))
      },
      openLine: function (e) {
        return e.replaceSelection("\n", "start")
      },
      toggleOverwrite: function (e) {
        return e.toggleOverwrite()
      }
    };

    function ns(e, t) {
      var n = $e(e.doc, t),
        r = Bt(n);
      return r != n && (t = Qe(r)), es(!0, e, r, t, 1)
    }

    function rs(e, t) {
      var n = ns(e, t.line),
        r = $e(e.doc, n.line),
        i = ce(r, e.doc.direction);
      if (!i || 0 == i[0].level) {
        var o = Math.max(0, r.text.search(/\S/)),
          s = t.line == n.line && t.ch <= o && t.ch;
        return et(n.line, s ? 0 : o, n.sticky)
      }
      return n
    }

    function is(e, t, n) {
      if ("string" == typeof t && !(t = ts[t])) return !1;
      e.display.input.ensurePolled();
      var r = e.display.shift,
        i = !1;
      try {
        e.isReadOnly() && (e.state.suppressEdits = !0), n && (e.display.shift = !1), i = t(e) != U
      } finally {
        e.display.shift = r, e.state.suppressEdits = !1
      }
      return i
    }
    var os = new H;

    function ss(e, t, n, r) {
      var i = e.state.keySeq;
      if (i) {
        if (qo(t)) return "handled";
        if (/\'$/.test(t) ? e.state.keySeq = null : os.set(50, (function () {
            e.state.keySeq == i && (e.state.keySeq = null, e.display.input.reset())
          })), as(e, i + " " + t, n, r)) return !0
      }
      return as(e, t, n, r)
    }

    function as(e, t, n, r) {
      var i = function (e, t, n) {
        for (var r = 0; r < e.state.keyMaps.length; r++) {
          var i = $o(t, e.state.keyMaps[r], n, e);
          if (i) return i
        }
        return e.options.extraKeys && $o(t, e.options.extraKeys, n, e) || $o(t, e.options.keyMap, n, e)
      }(e, t, r);
      return "multi" == i && (e.state.keySeq = t), "handled" == i && ln(e, "keyHandled", e, t, n), "handled" != i && "multi" != i || (we(n), Sr(e)), !!i
    }

    function ls(e, t) {
      var n = Yo(t, !0);
      return !!n && (t.shiftKey && !e.state.keySeq ? ss(e, "Shift-" + n, t, (function (t) {
        return is(e, t, !0)
      })) || ss(e, n, t, (function (t) {
        if ("string" == typeof t ? /^go[A-Z]/.test(t) : t.motion) return is(e, t)
      })) : ss(e, n, t, (function (t) {
        return is(e, t)
      })))
    }
    var cs = null;

    function us(e) {
      var t = this;
      if (t.curOp.focus = P(), !me(t, e)) {
        s && a < 11 && 27 == e.keyCode && (e.returnValue = !1);
        var n = e.keyCode;
        t.display.shift = 16 == n || e.shiftKey;
        var r = ls(t, e);
        h && (cs = r ? n : null, r || 88 != n || Ie || !(v ? e.metaKey : e.ctrlKey) || t.replaceSelection("", null, "cut")), 18 != n || /\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className) || function (e) {
          var t = e.display.lineDiv;

          function n(e) {
            18 != e.keyCode && e.altKey || (T(t, "CodeMirror-crosshair"), de(document, "keyup", n), de(document, "mouseover", n))
          }
          I(t, "CodeMirror-crosshair"), he(document, "keyup", n), he(document, "mouseover", n)
        }(t)
      }
    }

    function hs(e) {
      16 == e.keyCode && (this.doc.sel.shift = !1), me(this, e)
    }

    function ps(e) {
      var t = this;
      if (!(Cn(t.display, e) || me(t, e) || e.ctrlKey && !e.altKey || v && e.metaKey)) {
        var n = e.keyCode,
          r = e.charCode;
        if (h && n == cs) return cs = null, void we(e);
        if (!h || e.which && !(e.which < 10) || !ls(t, e)) {
          var i = String.fromCharCode(null == r ? n : r);
          "\b" != i && (function (e, t, n) {
            return ss(e, "'" + n + "'", t, (function (t) {
              return is(e, t, !0)
            }))
          }(t, e, i) || t.display.input.onKeyPress(e))
        }
      }
    }
    var ds, fs, ms = function (e, t, n) {
      this.time = e, this.pos = t, this.button = n
    };

    function gs(e) {
      var t = this,
        n = t.display;
      if (!(me(t, e) || n.activeTouch && n.input.supportsTouch()))
        if (n.input.ensurePolled(), n.shift = e.shiftKey, Cn(n, e)) l || (n.scroller.draggable = !1, setTimeout((function () {
          return n.scroller.draggable = !0
        }), 100));
        else if (!ws(t, e)) {
        var r = cr(t, e),
          i = ke(e),
          o = r ? function (e, t) {
            var n = +new Date;
            return fs && fs.compare(n, e, t) ? (ds = fs = null, "triple") : ds && ds.compare(n, e, t) ? (fs = new ms(n, e, t), ds = null, "double") : (ds = new ms(n, e, t), fs = null, "single")
          }(r, i) : "single";
        window.focus(), 1 == i && t.state.selectingText && t.state.selectingText(e), r && function (e, t, n, r, i) {
          var o = "Click";
          return "double" == r ? o = "Double" + o : "triple" == r && (o = "Triple" + o), ss(e, Ko(o = (1 == t ? "Left" : 2 == t ? "Middle" : "Right") + o, i), i, (function (t) {
            if ("string" == typeof t && (t = ts[t]), !t) return !1;
            var r = !1;
            try {
              e.isReadOnly() && (e.state.suppressEdits = !0), r = t(e, n) != U
            } finally {
              e.state.suppressEdits = !1
            }
            return r
          }))
        }(t, i, r, o, e) || (1 == i ? r ? function (e, t, n, r) {
          s ? setTimeout(N(Cr, e), 0) : e.curOp.focus = P();
          var i, o = function (e, t, n) {
              var r = e.getOption("configureMouse"),
                i = r ? r(e, t, n) : {};
              if (null == i.unit) {
                var o = w ? n.shiftKey && n.metaKey : n.altKey;
                i.unit = o ? "rectangle" : "single" == t ? "char" : "double" == t ? "word" : "line"
              }
              return (null == i.extend || e.doc.extend) && (i.extend = e.doc.extend || n.shiftKey), null == i.addNew && (i.addNew = v ? n.metaKey : n.ctrlKey), null == i.moveOnDrag && (i.moveOnDrag = !(v ? n.altKey : n.ctrlKey)), i
            }(e, n, r),
            c = e.doc.sel;
          e.options.dragDrop && Re && !e.isReadOnly() && "single" == n && (i = c.contains(t)) > -1 && (tt((i = c.ranges[i]).from(), t) < 0 || t.xRel > 0) && (tt(i.to(), t) > 0 || t.xRel < 0) ? function (e, t, n, r) {
            var i = e.display,
              o = !1,
              c = ei(e, (function (t) {
                l && (i.scroller.draggable = !1), e.state.draggingText = !1, de(i.wrapper.ownerDocument, "mouseup", c), de(i.wrapper.ownerDocument, "mousemove", u), de(i.scroller, "dragstart", h), de(i.scroller, "drop", c), o || (we(t), r.addNew || Ki(e.doc, n, null, null, r.extend), l || s && 9 == a ? setTimeout((function () {
                  i.wrapper.ownerDocument.body.focus(), i.input.focus()
                }), 20) : i.input.focus())
              })),
              u = function (e) {
                o = o || Math.abs(t.clientX - e.clientX) + Math.abs(t.clientY - e.clientY) >= 10
              },
              h = function () {
                return o = !0
              };
            l && (i.scroller.draggable = !0), e.state.draggingText = c, c.copy = !r.moveOnDrag, i.scroller.dragDrop && i.scroller.dragDrop(), he(i.wrapper.ownerDocument, "mouseup", c), he(i.wrapper.ownerDocument, "mousemove", u), he(i.scroller, "dragstart", h), he(i.scroller, "drop", c), Er(e), setTimeout((function () {
              return i.input.focus()
            }), 20)
          }(e, r, t, o) : function (e, t, n, r) {
            var i = e.display,
              o = e.doc;
            we(t);
            var s, a, l = o.sel,
              c = l.ranges;
            if (r.addNew && !r.extend ? (a = o.sel.contains(n), s = a > -1 ? c[a] : new Ei(n, n)) : (s = o.sel.primary(), a = o.sel.primIndex), "rectangle" == r.unit) r.addNew || (s = new Ei(n, n)), n = cr(e, t, !0, !0), a = -1;
            else {
              var u = ys(e, n, r.unit);
              s = r.extend ? qi(s, u.anchor, u.head, r.extend) : u
            }
            r.addNew ? -1 == a ? (a = c.length, Ji(o, ki(e, c.concat([s]), a), {
              scroll: !1,
              origin: "*mouse"
            })) : c.length > 1 && c[a].empty() && "char" == r.unit && !r.extend ? (Ji(o, ki(e, c.slice(0, a).concat(c.slice(a + 1)), 0), {
              scroll: !1,
              origin: "*mouse"
            }), l = o.sel) : Qi(o, a, s, V) : (a = 0, Ji(o, new Ci([s], 0), V), l = o.sel);
            var h = n;

            function p(t) {
              if (0 != tt(h, t))
                if (h = t, "rectangle" == r.unit) {
                  for (var i = [], c = e.options.tabSize, u = B($e(o, n.line).text, n.ch, c), p = B($e(o, t.line).text, t.ch, c), d = Math.min(u, p), f = Math.max(u, p), m = Math.min(n.line, t.line), g = Math.min(e.lastLine(), Math.max(n.line, t.line)); m <= g; m++) {
                    var y = $e(o, m).text,
                      v = G(y, d, c);
                    d == f ? i.push(new Ei(et(m, v), et(m, v))) : y.length > v && i.push(new Ei(et(m, v), et(m, G(y, f, c))))
                  }
                  i.length || i.push(new Ei(n, n)), Ji(o, ki(e, l.ranges.slice(0, a).concat(i), a), {
                    origin: "*mouse",
                    scroll: !1
                  }), e.scrollIntoView(t)
                } else {
                  var w, b = s,
                    S = ys(e, t, r.unit),
                    C = b.anchor;
                  tt(S.anchor, C) > 0 ? (w = S.head, C = ot(b.from(), S.anchor)) : (w = S.anchor, C = it(b.to(), S.head));
                  var E = l.ranges.slice(0);
                  E[a] = function (e, t) {
                    var n = t.anchor,
                      r = t.head,
                      i = $e(e.doc, n.line);
                    if (0 == tt(n, r) && n.sticky == r.sticky) return t;
                    var o = ce(i);
                    if (!o) return t;
                    var s = ae(o, n.ch, n.sticky),
                      a = o[s];
                    if (a.from != n.ch && a.to != n.ch) return t;
                    var l, c = s + (a.from == n.ch == (1 != a.level) ? 0 : 1);
                    if (0 == c || c == o.length) return t;
                    if (r.line != n.line) l = (r.line - n.line) * ("ltr" == e.doc.direction ? 1 : -1) > 0;
                    else {
                      var u = ae(o, r.ch, r.sticky),
                        h = u - s || (r.ch - n.ch) * (1 == a.level ? -1 : 1);
                      l = u == c - 1 || u == c ? h < 0 : h > 0
                    }
                    var p = o[c + (l ? -1 : 0)],
                      d = l == (1 == p.level),
                      f = d ? p.from : p.to,
                      m = d ? "after" : "before";
                    return n.ch == f && n.sticky == m ? t : new Ei(new et(n.line, f, m), r)
                  }(e, new Ei(at(o, C), w)), Ji(o, ki(e, E, a), V)
                }
            }
            var d = i.wrapper.getBoundingClientRect(),
              f = 0;

            function m(t) {
              e.state.selectingText = !1, f = 1 / 0, t && (we(t), i.input.focus()), de(i.wrapper.ownerDocument, "mousemove", g), de(i.wrapper.ownerDocument, "mouseup", y), o.history.lastSelOrigin = null
            }
            var g = ei(e, (function (t) {
                0 !== t.buttons && ke(t) ? function t(n) {
                  var s = ++f,
                    a = cr(e, n, !0, "rectangle" == r.unit);
                  if (a)
                    if (0 != tt(a, h)) {
                      e.curOp.focus = P(), p(a);
                      var l = Dr(i, o);
                      (a.line >= l.to || a.line < l.from) && setTimeout(ei(e, (function () {
                        f == s && t(n)
                      })), 150)
                    } else {
                      var c = n.clientY < d.top ? -20 : n.clientY > d.bottom ? 20 : 0;
                      c && setTimeout(ei(e, (function () {
                        f == s && (i.scroller.scrollTop += c, t(n))
                      })), 50)
                    }
                }(t) : m(t)
              })),
              y = ei(e, m);
            e.state.selectingText = y, he(i.wrapper.ownerDocument, "mousemove", g), he(i.wrapper.ownerDocument, "mouseup", y)
          }(e, r, t, o)
        }(t, r, o, e) : Ee(e) == n.scroller && we(e) : 2 == i ? (r && Ki(t.doc, r), setTimeout((function () {
          return n.input.focus()
        }), 20)) : 3 == i && (E ? t.display.input.onContextMenu(e) : Er(t)))
      }
    }

    function ys(e, t, n) {
      if ("char" == n) return new Ei(t, t);
      if ("word" == n) return e.findWordAt(t);
      if ("line" == n) return new Ei(et(t.line, 0), at(e.doc, et(t.line + 1, 0)));
      var r = n(e, t);
      return new Ei(r.from, r.to)
    }

    function vs(e, t, n, r) {
      var i, o;
      if (t.touches) i = t.touches[0].clientX, o = t.touches[0].clientY;
      else try {
        i = t.clientX, o = t.clientY
      } catch (t) {
        return !1
      }
      if (i >= Math.floor(e.display.gutters.getBoundingClientRect().right)) return !1;
      r && we(t);
      var s = e.display,
        a = s.lineDiv.getBoundingClientRect();
      if (o > a.bottom || !ye(e, n)) return Se(t);
      o -= a.top - s.viewOffset;
      for (var l = 0; l < e.display.gutterSpecs.length; ++l) {
        var c = s.gutters.childNodes[l];
        if (c && c.getBoundingClientRect().right >= i) return fe(e, n, e, Ze(e.doc, o), e.display.gutterSpecs[l].className, t), Se(t)
      }
    }

    function ws(e, t) {
      return vs(e, t, "gutterClick", !0)
    }

    function bs(e, t) {
      Cn(e.display, t) || function (e, t) {
        return !!ye(e, "gutterContextMenu") && vs(e, t, "gutterContextMenu", !1)
      }(e, t) || me(e, t, "contextmenu") || E || e.display.input.onContextMenu(t)
    }

    function Ss(e) {
      e.display.wrapper.className = e.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") + e.options.theme.replace(/(^|\s)\s*/g, " cm-s-"), zn(e)
    }
    ms.prototype.compare = function (e, t, n) {
      return this.time + 400 > e && 0 == tt(t, this.pos) && n == this.button
    };
    var Cs = {
        toString: function () {
          return "CodeMirror.Init"
        }
      },
      Es = {},
      ks = {};

    function xs(e, t, n) {
      if (!t != !(n && n != Cs)) {
        var r = e.display.dragFunctions,
          i = t ? he : de;
        i(e.display.scroller, "dragstart", r.start), i(e.display.scroller, "dragenter", r.enter), i(e.display.scroller, "dragover", r.over), i(e.display.scroller, "dragleave", r.leave), i(e.display.scroller, "drop", r.drop)
      }
    }

    function Ts(e) {
      e.options.lineWrapping ? (I(e.display.wrapper, "CodeMirror-wrap"), e.display.sizer.style.minWidth = "", e.display.sizerWidth = null) : (T(e.display.wrapper, "CodeMirror-wrap"), Gt(e)), lr(e), hr(e), zn(e), setTimeout((function () {
        return Ur(e)
      }), 100)
    }

    function Rs(e, t) {
      var n = this;
      if (!(this instanceof Rs)) return new Rs(e, t);
      this.options = t = t ? F(t) : {}, F(Es, t, !1);
      var r = t.value;
      "string" == typeof r ? r = new Mo(r, t.mode, null, t.lineSeparator, t.direction) : t.mode && (r.modeOption = t.mode), this.doc = r;
      var i = new Rs.inputStyles[t.inputStyle](this),
        o = this.display = new gi(e, r, i, t);
      for (var c in o.wrapper.CodeMirror = this, Ss(this), t.lineWrapping && (this.display.wrapper.className += " CodeMirror-wrap"), jr(this), this.state = {
            keyMaps: [],
            overlays: [],
            modeGen: 0,
            overwrite: !1,
            delayingBlurEvent: !1,
            focused: !1,
            suppressEdits: !1,
            pasteIncoming: -1,
            cutIncoming: -1,
            selectingText: !1,
            draggingText: !1,
            highlight: new H,
            keySeq: null,
            specialChars: null
          }, t.autofocus && !y && o.input.focus(), s && a < 11 && setTimeout((function () {
            return n.display.input.reset(!0)
          }), 20),
          function (e) {
            var t = e.display;
            he(t.scroller, "mousedown", ei(e, gs)), he(t.scroller, "dblclick", s && a < 11 ? ei(e, (function (t) {
              if (!me(e, t)) {
                var n = cr(e, t);
                if (n && !ws(e, t) && !Cn(e.display, t)) {
                  we(t);
                  var r = e.findWordAt(n);
                  Ki(e.doc, r.anchor, r.head)
                }
              }
            })) : function (t) {
              return me(e, t) || we(t)
            }), he(t.scroller, "contextmenu", (function (t) {
              return bs(e, t)
            }));
            var n, r = {
              end: 0
            };

            function i() {
              t.activeTouch && (n = setTimeout((function () {
                return t.activeTouch = null
              }), 1e3), (r = t.activeTouch).end = +new Date)
            }

            function o(e, t) {
              if (null == t.left) return !0;
              var n = t.left - e.left,
                r = t.top - e.top;
              return n * n + r * r > 400
            }
            he(t.scroller, "touchstart", (function (i) {
              if (!me(e, i) && ! function (e) {
                  if (1 != e.touches.length) return !1;
                  var t = e.touches[0];
                  return t.radiusX <= 1 && t.radiusY <= 1
                }(i) && !ws(e, i)) {
                t.input.ensurePolled(), clearTimeout(n);
                var o = +new Date;
                t.activeTouch = {
                  start: o,
                  moved: !1,
                  prev: o - r.end <= 300 ? r : null
                }, 1 == i.touches.length && (t.activeTouch.left = i.touches[0].pageX, t.activeTouch.top = i.touches[0].pageY)
              }
            })), he(t.scroller, "touchmove", (function () {
              t.activeTouch && (t.activeTouch.moved = !0)
            })), he(t.scroller, "touchend", (function (n) {
              var r = t.activeTouch;
              if (r && !Cn(t, n) && null != r.left && !r.moved && new Date - r.start < 300) {
                var s, a = e.coordsChar(t.activeTouch, "page");
                s = !r.prev || o(r, r.prev) ? new Ei(a, a) : !r.prev.prev || o(r, r.prev.prev) ? e.findWordAt(a) : new Ei(et(a.line, 0), at(e.doc, et(a.line + 1, 0))), e.setSelection(s.anchor, s.head), e.focus(), we(n)
              }
              i()
            })), he(t.scroller, "touchcancel", i), he(t.scroller, "scroll", (function () {
              t.scroller.clientHeight && (Lr(e, t.scroller.scrollTop), Fr(e, t.scroller.scrollLeft, !0), fe(e, "scroll", e))
            })), he(t.scroller, "mousewheel", (function (t) {
              return Si(e, t)
            })), he(t.scroller, "DOMMouseScroll", (function (t) {
              return Si(e, t)
            })), he(t.wrapper, "scroll", (function () {
              return t.wrapper.scrollTop = t.wrapper.scrollLeft = 0
            })), t.dragFunctions = {
              enter: function (t) {
                me(e, t) || Ce(t)
              },
              over: function (t) {
                me(e, t) || (function (e, t) {
                  var n = cr(e, t);
                  if (n) {
                    var r = document.createDocumentFragment();
                    vr(e, n, r), e.display.dragCursor || (e.display.dragCursor = _("div", null, "CodeMirror-cursors CodeMirror-dragcursors"), e.display.lineSpace.insertBefore(e.display.dragCursor, e.display.cursorDiv)), D(e.display.dragCursor, r)
                  }
                }(e, t), Ce(t))
              },
              start: function (t) {
                return function (e, t) {
                  if (s && (!e.state.draggingText || +new Date - Po < 100)) Ce(t);
                  else if (!me(e, t) && !Cn(e.display, t) && (t.dataTransfer.setData("Text", e.getSelection()), t.dataTransfer.effectAllowed = "copyMove", t.dataTransfer.setDragImage && !p)) {
                    var n = _("img", null, null, "position: fixed; left: 0; top: 0;");
                    n.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==", h && (n.width = n.height = 1, e.display.wrapper.appendChild(n), n._top = n.offsetTop), t.dataTransfer.setDragImage(n, 0, 0), h && n.parentNode.removeChild(n)
                  }
                }(e, t)
              },
              drop: ei(e, Io),
              leave: function (t) {
                me(e, t) || Oo(e)
              }
            };
            var l = t.input.getField();
            he(l, "keyup", (function (t) {
              return hs.call(e, t)
            })), he(l, "keydown", ei(e, us)), he(l, "keypress", ei(e, ps)), he(l, "focus", (function (t) {
              return kr(e, t)
            })), he(l, "blur", (function (t) {
              return xr(e, t)
            }))
          }(this), Fo(), $r(this), this.curOp.forceUpdate = !0, Li(this, r), t.autofocus && !y || this.hasFocus() ? setTimeout(N(kr, this), 20) : xr(this), ks) ks.hasOwnProperty(c) && ks[c](n, t[c], Cs);
      pi(this), t.finishInit && t.finishInit(this);
      for (var u = 0; u < Ds.length; ++u) Ds[u](n);
      qr(this), l && t.lineWrapping && "optimizelegibility" == getComputedStyle(o.lineDiv).textRendering && (o.lineDiv.style.textRendering = "auto")
    }
    Rs.defaults = Es, Rs.optionHandlers = ks;
    var Ds = [];

    function _s(e, t, n, r) {
      var i, o = e.doc;
      null == n && (n = "add"), "smart" == n && (o.mode.indent ? i = dt(e, t).state : n = "prev");
      var s = e.options.tabSize,
        a = $e(o, t),
        l = B(a.text, null, s);
      a.stateAfter && (a.stateAfter = null);
      var c, u = a.text.match(/^\s*/)[0];
      if (r || /\S/.test(a.text)) {
        if ("smart" == n && ((c = o.mode.indent(i, a.text.slice(u.length), a.text)) == U || c > 150)) {
          if (!r) return;
          n = "prev"
        }
      } else c = 0, n = "not";
      "prev" == n ? c = t > o.first ? B($e(o, t - 1).text, null, s) : 0 : "add" == n ? c = l + e.options.indentUnit : "subtract" == n ? c = l - e.options.indentUnit : "number" == typeof n && (c = l + n), c = Math.max(0, c);
      var h = "",
        p = 0;
      if (e.options.indentWithTabs)
        for (var d = Math.floor(c / s); d; --d) p += s, h += "\t";
      if (p < c && (h += q(c - p)), h != u) return mo(o, h, et(t, 0), et(t, u.length), "+input"), a.stateAfter = null, !0;
      for (var f = 0; f < o.sel.ranges.length; f++) {
        var m = o.sel.ranges[f];
        if (m.head.line == t && m.head.ch < u.length) {
          var g = et(t, u.length);
          Qi(o, f, new Ei(g, g));
          break
        }
      }
    }
    Rs.defineInitHook = function (e) {
      return Ds.push(e)
    };
    var As = null;

    function Ms(e) {
      As = e
    }

    function Ps(e, t, n, r, i) {
      var o = e.doc;
      e.display.shift = !1, r || (r = o.sel);
      var s = +new Date - 200,
        a = "paste" == i || e.state.pasteIncoming > s,
        l = Me(t),
        c = null;
      if (a && r.ranges.length > 1)
        if (As && As.text.join("\n") == t) {
          if (r.ranges.length % As.text.length == 0) {
            c = [];
            for (var u = 0; u < As.text.length; u++) c.push(o.splitLines(As.text[u]))
          }
        } else l.length == r.ranges.length && e.options.pasteLinesPerSelection && (c = Y(l, (function (e) {
          return [e]
        })));
      for (var h = e.curOp.updateInput, p = r.ranges.length - 1; p >= 0; p--) {
        var d = r.ranges[p],
          f = d.from(),
          m = d.to();
        d.empty() && (n && n > 0 ? f = et(f.line, f.ch - n) : e.state.overwrite && !a ? m = et(m.line, Math.min($e(o, m.line).text.length, m.ch + K(l).length)) : a && As && As.lineWise && As.text.join("\n") == t && (f = m = et(f.line, 0)));
        var g = {
          from: f,
          to: m,
          text: c ? c[p % c.length] : l,
          origin: i || (a ? "paste" : e.state.cutIncoming > s ? "cut" : "+input")
        };
        co(e.doc, g), ln(e, "inputRead", e, g)
      }
      t && !a && Os(e, t), Mr(e), e.curOp.updateInput < 2 && (e.curOp.updateInput = h), e.curOp.typing = !0, e.state.pasteIncoming = e.state.cutIncoming = -1
    }

    function Is(e, t) {
      var n = e.clipboardData && e.clipboardData.getData("Text");
      if (n) return e.preventDefault(), t.isReadOnly() || t.options.disableInput || Jr(t, (function () {
        return Ps(t, n, 0, null, "paste")
      })), !0
    }

    function Os(e, t) {
      if (e.options.electricChars && e.options.smartIndent)
        for (var n = e.doc.sel, r = n.ranges.length - 1; r >= 0; r--) {
          var i = n.ranges[r];
          if (!(i.head.ch > 100 || r && n.ranges[r - 1].head.line == i.head.line)) {
            var o = e.getModeAt(i.head),
              s = !1;
            if (o.electricChars) {
              for (var a = 0; a < o.electricChars.length; a++)
                if (t.indexOf(o.electricChars.charAt(a)) > -1) {
                  s = _s(e, i.head.line, "smart");
                  break
                }
            } else o.electricInput && o.electricInput.test($e(e.doc, i.head.line).text.slice(0, i.head.ch)) && (s = _s(e, i.head.line, "smart"));
            s && ln(e, "electricInput", e, i.head.line)
          }
        }
    }

    function Ls(e) {
      for (var t = [], n = [], r = 0; r < e.doc.sel.ranges.length; r++) {
        var i = e.doc.sel.ranges[r].head.line,
          o = {
            anchor: et(i, 0),
            head: et(i + 1, 0)
          };
        n.push(o), t.push(e.getRange(o.anchor, o.head))
      }
      return {
        text: t,
        ranges: n
      }
    }

    function Ns(e, t, n, r) {
      e.setAttribute("autocorrect", n ? "" : "off"), e.setAttribute("autocapitalize", r ? "" : "off"), e.setAttribute("spellcheck", !!t)
    }

    function Fs() {
      var e = _("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),
        t = _("div", [e], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
      return l ? e.style.width = "1000px" : e.setAttribute("wrap", "off"), m && (e.style.border = "1px solid black"), Ns(e), t
    }

    function Bs(e, t, n, r, i) {
      var o = t,
        s = n,
        a = $e(e, t.line);

      function l(r) {
        var o, s;
        if (null == (o = i ? function (e, t, n, r) {
            var i = ce(t, e.doc.direction);
            if (!i) return Jo(t, n, r);
            n.ch >= t.text.length ? (n.ch = t.text.length, n.sticky = "before") : n.ch <= 0 && (n.ch = 0, n.sticky = "after");
            var o = ae(i, n.ch, n.sticky),
              s = i[o];
            if ("ltr" == e.doc.direction && s.level % 2 == 0 && (r > 0 ? s.to > n.ch : s.from < n.ch)) return Jo(t, n, r);
            var a, l = function (e, n) {
                return Xo(t, e instanceof et ? e.ch : e, n)
              },
              c = function (n) {
                return e.options.lineWrapping ? (a = a || Pn(e, t), Xn(e, t, a, n)) : {
                  begin: 0,
                  end: t.text.length
                }
              },
              u = c("before" == n.sticky ? l(n, -1) : n.ch);
            if ("rtl" == e.doc.direction || 1 == s.level) {
              var h = 1 == s.level == r < 0,
                p = l(n, h ? 1 : -1);
              if (null != p && (h ? p <= s.to && p <= u.end : p >= s.from && p >= u.begin)) {
                var d = h ? "before" : "after";
                return new et(n.line, p, d)
              }
            }
            var f = function (e, t, r) {
                for (var o = function (e, t) {
                    return t ? new et(n.line, l(e, 1), "before") : new et(n.line, e, "after")
                  }; e >= 0 && e < i.length; e += t) {
                  var s = i[e],
                    a = t > 0 == (1 != s.level),
                    c = a ? r.begin : l(r.end, -1);
                  if (s.from <= c && c < s.to) return o(c, a);
                  if (c = a ? s.from : l(s.to, -1), r.begin <= c && c < r.end) return o(c, a)
                }
              },
              m = f(o + r, r, u);
            if (m) return m;
            var g = r > 0 ? u.end : l(u.begin, -1);
            return null == g || r > 0 && g == t.text.length || !(m = f(r > 0 ? 0 : i.length - 1, r, c(g))) ? null : m
          }(e.cm, a, t, n) : Jo(a, t, n))) {
          if (r || (s = t.line + n) < e.first || s >= e.first + e.size || (t = new et(s, t.ch, t.sticky), !(a = $e(e, s)))) return !1;
          t = es(i, e.cm, a, t.line, n)
        } else t = o;
        return !0
      }
      if ("char" == r) l();
      else if ("column" == r) l(!0);
      else if ("word" == r || "group" == r)
        for (var c = null, u = "group" == r, h = e.cm && e.cm.getHelper(t, "wordChars"), p = !0; !(n < 0) || l(!p); p = !1) {
          var d = a.text.charAt(t.ch) || "\n",
            f = ee(d, h) ? "w" : u && "\n" == d ? "n" : !u || /\s/.test(d) ? null : "p";
          if (!u || p || f || (f = "s"), c && c != f) {
            n < 0 && (n = 1, l(), t.sticky = "after");
            break
          }
          if (f && (c = f), n > 0 && !l(!p)) break
        }
      var m = oo(e, t, o, s, !0);
      return nt(o, m) && (m.hitSide = !0), m
    }

    function Hs(e, t, n, r) {
      var i, o, s = e.doc,
        a = t.left;
      if ("page" == r) {
        var l = Math.min(e.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight),
          c = Math.max(l - .5 * rr(e.display), 3);
        i = (n > 0 ? t.bottom : t.top) + n * c
      } else "line" == r && (i = n > 0 ? t.bottom + 3 : t.top - 3);
      for (;
        (o = Qn(e, a, i)).outside;) {
        if (n < 0 ? i <= 0 : i >= s.height) {
          o.hitSide = !0;
          break
        }
        i += 5 * n
      }
      return o
    }
    var zs = function (e) {
      this.cm = e, this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null, this.polling = new H, this.composing = null, this.gracePeriod = !1, this.readDOMTimeout = null
    };

    function Us(e, t) {
      var n = Mn(e, t.line);
      if (!n || n.hidden) return null;
      var r = $e(e.doc, t.line),
        i = _n(n, r, t.line),
        o = ce(r, e.doc.direction),
        s = "left";
      o && (s = ae(o, t.ch) % 2 ? "right" : "left");
      var a = Nn(i.map, t.ch, s);
      return a.offset = "right" == a.collapse ? a.end : a.start, a
    }

    function Ws(e, t) {
      return t && (e.bad = !0), e
    }

    function Vs(e, t, n) {
      var r;
      if (t == e.display.lineDiv) {
        if (!(r = e.display.lineDiv.childNodes[n])) return Ws(e.clipPos(et(e.display.viewTo - 1)), !0);
        t = null, n = 0
      } else
        for (r = t;; r = r.parentNode) {
          if (!r || r == e.display.lineDiv) return null;
          if (r.parentNode && r.parentNode == e.display.lineDiv) break
        }
      for (var i = 0; i < e.display.view.length; i++) {
        var o = e.display.view[i];
        if (o.node == r) return js(o, t, n)
      }
    }

    function js(e, t, n) {
      var r = e.text.firstChild,
        i = !1;
      if (!t || !M(r, t)) return Ws(et(Qe(e.line), 0), !0);
      if (t == r && (i = !0, t = r.childNodes[n], n = 0, !t)) {
        var o = e.rest ? K(e.rest) : e.line;
        return Ws(et(Qe(o), o.text.length), i)
      }
      var s = 3 == t.nodeType ? t : null,
        a = t;
      for (s || 1 != t.childNodes.length || 3 != t.firstChild.nodeType || (s = t.firstChild, n && (n = s.nodeValue.length)); a.parentNode != r;) a = a.parentNode;
      var l = e.measure,
        c = l.maps;

      function u(t, n, r) {
        for (var i = -1; i < (c ? c.length : 0); i++)
          for (var o = i < 0 ? l.map : c[i], s = 0; s < o.length; s += 3) {
            var a = o[s + 2];
            if (a == t || a == n) {
              var u = Qe(i < 0 ? e.line : e.rest[i]),
                h = o[s] + r;
              return (r < 0 || a != t) && (h = o[s + (r ? 1 : 0)]), et(u, h)
            }
          }
      }
      var h = u(s, a, n);
      if (h) return Ws(h, i);
      for (var p = a.nextSibling, d = s ? s.nodeValue.length - n : 0; p; p = p.nextSibling) {
        if (h = u(p, p.firstChild, 0)) return Ws(et(h.line, h.ch - d), i);
        d += p.textContent.length
      }
      for (var f = a.previousSibling, m = n; f; f = f.previousSibling) {
        if (h = u(f, f.firstChild, -1)) return Ws(et(h.line, h.ch + m), i);
        m += f.textContent.length
      }
    }
    zs.prototype.init = function (e) {
      var t = this,
        n = this,
        r = n.cm,
        i = n.div = e.lineDiv;

      function o(e) {
        if (!me(r, e)) {
          if (r.somethingSelected()) Ms({
            lineWise: !1,
            text: r.getSelections()
          }), "cut" == e.type && r.replaceSelection("", null, "cut");
          else {
            if (!r.options.lineWiseCopyCut) return;
            var t = Ls(r);
            Ms({
              lineWise: !0,
              text: t.text
            }), "cut" == e.type && r.operation((function () {
              r.setSelections(t.ranges, 0, W), r.replaceSelection("", null, "cut")
            }))
          }
          if (e.clipboardData) {
            e.clipboardData.clearData();
            var o = As.text.join("\n");
            if (e.clipboardData.setData("Text", o), e.clipboardData.getData("Text") == o) return void e.preventDefault()
          }
          var s = Fs(),
            a = s.firstChild;
          r.display.lineSpace.insertBefore(s, r.display.lineSpace.firstChild), a.value = As.text.join("\n");
          var l = document.activeElement;
          L(a), setTimeout((function () {
            r.display.lineSpace.removeChild(s), l.focus(), l == i && n.showPrimarySelection()
          }), 50)
        }
      }
      Ns(i, r.options.spellcheck, r.options.autocorrect, r.options.autocapitalize), he(i, "paste", (function (e) {
        me(r, e) || Is(e, r) || a <= 11 && setTimeout(ei(r, (function () {
          return t.updateFromDOM()
        })), 20)
      })), he(i, "compositionstart", (function (e) {
        t.composing = {
          data: e.data,
          done: !1
        }
      })), he(i, "compositionupdate", (function (e) {
        t.composing || (t.composing = {
          data: e.data,
          done: !1
        })
      })), he(i, "compositionend", (function (e) {
        t.composing && (e.data != t.composing.data && t.readFromDOMSoon(), t.composing.done = !0)
      })), he(i, "touchstart", (function () {
        return n.forceCompositionEnd()
      })), he(i, "input", (function () {
        t.composing || t.readFromDOMSoon()
      })), he(i, "copy", o), he(i, "cut", o)
    }, zs.prototype.prepareSelection = function () {
      var e = yr(this.cm, !1);
      return e.focus = this.cm.state.focused, e
    }, zs.prototype.showSelection = function (e, t) {
      e && this.cm.display.view.length && ((e.focus || t) && this.showPrimarySelection(), this.showMultipleSelections(e))
    }, zs.prototype.getSelection = function () {
      return this.cm.display.wrapper.ownerDocument.getSelection()
    }, zs.prototype.showPrimarySelection = function () {
      var e = this.getSelection(),
        t = this.cm,
        r = t.doc.sel.primary(),
        i = r.from(),
        o = r.to();
      if (t.display.viewTo == t.display.viewFrom || i.line >= t.display.viewTo || o.line < t.display.viewFrom) e.removeAllRanges();
      else {
        var s = Vs(t, e.anchorNode, e.anchorOffset),
          a = Vs(t, e.focusNode, e.focusOffset);
        if (!s || s.bad || !a || a.bad || 0 != tt(ot(s, a), i) || 0 != tt(it(s, a), o)) {
          var l = t.display.view,
            c = i.line >= t.display.viewFrom && Us(t, i) || {
              node: l[0].measure.map[2],
              offset: 0
            },
            u = o.line < t.display.viewTo && Us(t, o);
          if (!u) {
            var h = l[l.length - 1].measure,
              p = h.maps ? h.maps[h.maps.length - 1] : h.map;
            u = {
              node: p[p.length - 1],
              offset: p[p.length - 2] - p[p.length - 3]
            }
          }
          if (c && u) {
            var d, f = e.rangeCount && e.getRangeAt(0);
            try {
              d = x(c.node, c.offset, u.offset, u.node)
            } catch (e) {}
            d && (!n && t.state.focused ? (e.collapse(c.node, c.offset), d.collapsed || (e.removeAllRanges(), e.addRange(d))) : (e.removeAllRanges(), e.addRange(d)), f && null == e.anchorNode ? e.addRange(f) : n && this.startGracePeriod()), this.rememberSelection()
          } else e.removeAllRanges()
        }
      }
    }, zs.prototype.startGracePeriod = function () {
      var e = this;
      clearTimeout(this.gracePeriod), this.gracePeriod = setTimeout((function () {
        e.gracePeriod = !1, e.selectionChanged() && e.cm.operation((function () {
          return e.cm.curOp.selectionChanged = !0
        }))
      }), 20)
    }, zs.prototype.showMultipleSelections = function (e) {
      D(this.cm.display.cursorDiv, e.cursors), D(this.cm.display.selectionDiv, e.selection)
    }, zs.prototype.rememberSelection = function () {
      var e = this.getSelection();
      this.lastAnchorNode = e.anchorNode, this.lastAnchorOffset = e.anchorOffset, this.lastFocusNode = e.focusNode, this.lastFocusOffset = e.focusOffset
    }, zs.prototype.selectionInEditor = function () {
      var e = this.getSelection();
      if (!e.rangeCount) return !1;
      var t = e.getRangeAt(0).commonAncestorContainer;
      return M(this.div, t)
    }, zs.prototype.focus = function () {
      "nocursor" != this.cm.options.readOnly && (this.selectionInEditor() || this.showSelection(this.prepareSelection(), !0), this.div.focus())
    }, zs.prototype.blur = function () {
      this.div.blur()
    }, zs.prototype.getField = function () {
      return this.div
    }, zs.prototype.supportsTouch = function () {
      return !0
    }, zs.prototype.receivedFocus = function () {
      var e = this;
      this.selectionInEditor() ? this.pollSelection() : Jr(this.cm, (function () {
        return e.cm.curOp.selectionChanged = !0
      })), this.polling.set(this.cm.options.pollInterval, (function t() {
        e.cm.state.focused && (e.pollSelection(), e.polling.set(e.cm.options.pollInterval, t))
      }))
    }, zs.prototype.selectionChanged = function () {
      var e = this.getSelection();
      return e.anchorNode != this.lastAnchorNode || e.anchorOffset != this.lastAnchorOffset || e.focusNode != this.lastFocusNode || e.focusOffset != this.lastFocusOffset
    }, zs.prototype.pollSelection = function () {
      if (null == this.readDOMTimeout && !this.gracePeriod && this.selectionChanged()) {
        var e = this.getSelection(),
          t = this.cm;
        if (g && u && this.cm.display.gutterSpecs.length && function (e) {
            for (var t = e; t; t = t.parentNode)
              if (/CodeMirror-gutter-wrapper/.test(t.className)) return !0;
            return !1
          }(e.anchorNode)) return this.cm.triggerOnKeyDown({
          type: "keydown",
          keyCode: 8,
          preventDefault: Math.abs
        }), this.blur(), void this.focus();
        if (!this.composing) {
          this.rememberSelection();
          var n = Vs(t, e.anchorNode, e.anchorOffset),
            r = Vs(t, e.focusNode, e.focusOffset);
          n && r && Jr(t, (function () {
            Ji(t.doc, xi(n, r), W), (n.bad || r.bad) && (t.curOp.selectionChanged = !0)
          }))
        }
      }
    }, zs.prototype.pollContent = function () {
      null != this.readDOMTimeout && (clearTimeout(this.readDOMTimeout), this.readDOMTimeout = null);
      var e, t, n, r = this.cm,
        i = r.display,
        o = r.doc.sel.primary(),
        s = o.from(),
        a = o.to();
      if (0 == s.ch && s.line > r.firstLine() && (s = et(s.line - 1, $e(r.doc, s.line - 1).length)), a.ch == $e(r.doc, a.line).text.length && a.line < r.lastLine() && (a = et(a.line + 1, 0)), s.line < i.viewFrom || a.line > i.viewTo - 1) return !1;
      s.line == i.viewFrom || 0 == (e = ur(r, s.line)) ? (t = Qe(i.view[0].line), n = i.view[0].node) : (t = Qe(i.view[e].line), n = i.view[e - 1].node.nextSibling);
      var l, c, u = ur(r, a.line);
      if (u == i.view.length - 1 ? (l = i.viewTo - 1, c = i.lineDiv.lastChild) : (l = Qe(i.view[u + 1].line) - 1, c = i.view[u + 1].node.previousSibling), !n) return !1;
      for (var h = r.doc.splitLines(function (e, t, n, r, i) {
          var o = "",
            s = !1,
            a = e.doc.lineSeparator(),
            l = !1;

          function c() {
            s && (o += a, l && (o += a), s = l = !1)
          }

          function u(e) {
            e && (c(), o += e)
          }

          function h(t) {
            if (1 == t.nodeType) {
              var n = t.getAttribute("cm-text");
              if (n) return void u(n);
              var o, p = t.getAttribute("cm-marker");
              if (p) {
                var d = e.findMarks(et(r, 0), et(i + 1, 0), (g = +p, function (e) {
                  return e.id == g
                }));
                return void(d.length && (o = d[0].find(0)) && u(qe(e.doc, o.from, o.to).join(a)))
              }
              if ("false" == t.getAttribute("contenteditable")) return;
              var f = /^(pre|div|p|li|table|br)$/i.test(t.nodeName);
              if (!/^br$/i.test(t.nodeName) && 0 == t.textContent.length) return;
              f && c();
              for (var m = 0; m < t.childNodes.length; m++) h(t.childNodes[m]);
              /^(pre|p)$/i.test(t.nodeName) && (l = !0), f && (s = !0)
            } else 3 == t.nodeType && u(t.nodeValue.replace(/\u200b/g, "").replace(/\u00a0/g, " "));
            var g
          }
          for (; h(t), t != n;) t = t.nextSibling, l = !1;
          return o
        }(r, n, c, t, l)), p = qe(r.doc, et(t, 0), et(l, $e(r.doc, l).text.length)); h.length > 1 && p.length > 1;)
        if (K(h) == K(p)) h.pop(), p.pop(), l--;
        else {
          if (h[0] != p[0]) break;
          h.shift(), p.shift(), t++
        } for (var d = 0, f = 0, m = h[0], g = p[0], y = Math.min(m.length, g.length); d < y && m.charCodeAt(d) == g.charCodeAt(d);) ++d;
      for (var v = K(h), w = K(p), b = Math.min(v.length - (1 == h.length ? d : 0), w.length - (1 == p.length ? d : 0)); f < b && v.charCodeAt(v.length - f - 1) == w.charCodeAt(w.length - f - 1);) ++f;
      if (1 == h.length && 1 == p.length && t == s.line)
        for (; d && d > s.ch && v.charCodeAt(v.length - f - 1) == w.charCodeAt(w.length - f - 1);) d--, f++;
      h[h.length - 1] = v.slice(0, v.length - f).replace(/^\u200b+/, ""), h[0] = h[0].slice(d).replace(/\u200b+$/, "");
      var S = et(t, d),
        C = et(l, p.length ? K(p).length - f : 0);
      return h.length > 1 || h[0] || tt(S, C) ? (mo(r.doc, h, S, C, "+input"), !0) : void 0
    }, zs.prototype.ensurePolled = function () {
      this.forceCompositionEnd()
    }, zs.prototype.reset = function () {
      this.forceCompositionEnd()
    }, zs.prototype.forceCompositionEnd = function () {
      this.composing && (clearTimeout(this.readDOMTimeout), this.composing = null, this.updateFromDOM(), this.div.blur(), this.div.focus())
    }, zs.prototype.readFromDOMSoon = function () {
      var e = this;
      null == this.readDOMTimeout && (this.readDOMTimeout = setTimeout((function () {
        if (e.readDOMTimeout = null, e.composing) {
          if (!e.composing.done) return;
          e.composing = null
        }
        e.updateFromDOM()
      }), 80))
    }, zs.prototype.updateFromDOM = function () {
      var e = this;
      !this.cm.isReadOnly() && this.pollContent() || Jr(this.cm, (function () {
        return hr(e.cm)
      }))
    }, zs.prototype.setUneditable = function (e) {
      e.contentEditable = "false"
    }, zs.prototype.onKeyPress = function (e) {
      0 == e.charCode || this.composing || (e.preventDefault(), this.cm.isReadOnly() || ei(this.cm, Ps)(this.cm, String.fromCharCode(null == e.charCode ? e.keyCode : e.charCode), 0))
    }, zs.prototype.readOnlyChanged = function (e) {
      this.div.contentEditable = String("nocursor" != e)
    }, zs.prototype.onContextMenu = function () {}, zs.prototype.resetPosition = function () {}, zs.prototype.needsContentAttribute = !0;
    var Gs = function (e) {
      this.cm = e, this.prevInput = "", this.pollingFast = !1, this.polling = new H, this.hasSelection = !1, this.composing = null
    };
    Gs.prototype.init = function (e) {
        var t = this,
          n = this,
          r = this.cm;
        this.createField(e);
        var i = this.textarea;

        function o(e) {
          if (!me(r, e)) {
            if (r.somethingSelected()) Ms({
              lineWise: !1,
              text: r.getSelections()
            });
            else {
              if (!r.options.lineWiseCopyCut) return;
              var t = Ls(r);
              Ms({
                lineWise: !0,
                text: t.text
              }), "cut" == e.type ? r.setSelections(t.ranges, null, W) : (n.prevInput = "", i.value = t.text.join("\n"), L(i))
            }
            "cut" == e.type && (r.state.cutIncoming = +new Date)
          }
        }
        e.wrapper.insertBefore(this.wrapper, e.wrapper.firstChild), m && (i.style.width = "0px"), he(i, "input", (function () {
          s && a >= 9 && t.hasSelection && (t.hasSelection = null), n.poll()
        })), he(i, "paste", (function (e) {
          me(r, e) || Is(e, r) || (r.state.pasteIncoming = +new Date, n.fastPoll())
        })), he(i, "cut", o), he(i, "copy", o), he(e.scroller, "paste", (function (t) {
          if (!Cn(e, t) && !me(r, t)) {
            if (!i.dispatchEvent) return r.state.pasteIncoming = +new Date, void n.focus();
            var o = new Event("paste");
            o.clipboardData = t.clipboardData, i.dispatchEvent(o)
          }
        })), he(e.lineSpace, "selectstart", (function (t) {
          Cn(e, t) || we(t)
        })), he(i, "compositionstart", (function () {
          var e = r.getCursor("from");
          n.composing && n.composing.range.clear(), n.composing = {
            start: e,
            range: r.markText(e, r.getCursor("to"), {
              className: "CodeMirror-composing"
            })
          }
        })), he(i, "compositionend", (function () {
          n.composing && (n.poll(), n.composing.range.clear(), n.composing = null)
        }))
      }, Gs.prototype.createField = function (e) {
        this.wrapper = Fs(), this.textarea = this.wrapper.firstChild
      }, Gs.prototype.prepareSelection = function () {
        var e = this.cm,
          t = e.display,
          n = e.doc,
          r = yr(e);
        if (e.options.moveInputWithCursor) {
          var i = qn(e, n.sel.primary().head, "div"),
            o = t.wrapper.getBoundingClientRect(),
            s = t.lineDiv.getBoundingClientRect();
          r.teTop = Math.max(0, Math.min(t.wrapper.clientHeight - 10, i.top + s.top - o.top)), r.teLeft = Math.max(0, Math.min(t.wrapper.clientWidth - 10, i.left + s.left - o.left))
        }
        return r
      }, Gs.prototype.showSelection = function (e) {
        var t = this.cm.display;
        D(t.cursorDiv, e.cursors), D(t.selectionDiv, e.selection), null != e.teTop && (this.wrapper.style.top = e.teTop + "px", this.wrapper.style.left = e.teLeft + "px")
      }, Gs.prototype.reset = function (e) {
        if (!this.contextMenuPending && !this.composing) {
          var t = this.cm;
          if (t.somethingSelected()) {
            this.prevInput = "";
            var n = t.getSelection();
            this.textarea.value = n, t.state.focused && L(this.textarea), s && a >= 9 && (this.hasSelection = n)
          } else e || (this.prevInput = this.textarea.value = "", s && a >= 9 && (this.hasSelection = null))
        }
      }, Gs.prototype.getField = function () {
        return this.textarea
      }, Gs.prototype.supportsTouch = function () {
        return !1
      }, Gs.prototype.focus = function () {
        if ("nocursor" != this.cm.options.readOnly && (!y || P() != this.textarea)) try {
          this.textarea.focus()
        } catch (e) {}
      }, Gs.prototype.blur = function () {
        this.textarea.blur()
      }, Gs.prototype.resetPosition = function () {
        this.wrapper.style.top = this.wrapper.style.left = 0
      }, Gs.prototype.receivedFocus = function () {
        this.slowPoll()
      }, Gs.prototype.slowPoll = function () {
        var e = this;
        this.pollingFast || this.polling.set(this.cm.options.pollInterval, (function () {
          e.poll(), e.cm.state.focused && e.slowPoll()
        }))
      }, Gs.prototype.fastPoll = function () {
        var e = !1,
          t = this;
        t.pollingFast = !0, t.polling.set(20, (function n() {
          t.poll() || e ? (t.pollingFast = !1, t.slowPoll()) : (e = !0, t.polling.set(60, n))
        }))
      }, Gs.prototype.poll = function () {
        var e = this,
          t = this.cm,
          n = this.textarea,
          r = this.prevInput;
        if (this.contextMenuPending || !t.state.focused || Pe(n) && !r && !this.composing || t.isReadOnly() || t.options.disableInput || t.state.keySeq) return !1;
        var i = n.value;
        if (i == r && !t.somethingSelected()) return !1;
        if (s && a >= 9 && this.hasSelection === i || v && /[\uf700-\uf7ff]/.test(i)) return t.display.input.reset(), !1;
        if (t.doc.sel == t.display.selForContextMenu) {
          var o = i.charCodeAt(0);
          if (8203 != o || r || (r = "​"), 8666 == o) return this.reset(), this.cm.execCommand("undo")
        }
        for (var l = 0, c = Math.min(r.length, i.length); l < c && r.charCodeAt(l) == i.charCodeAt(l);) ++l;
        return Jr(t, (function () {
          Ps(t, i.slice(l), r.length - l, null, e.composing ? "*compose" : null), i.length > 1e3 || i.indexOf("\n") > -1 ? n.value = e.prevInput = "" : e.prevInput = i, e.composing && (e.composing.range.clear(), e.composing.range = t.markText(e.composing.start, t.getCursor("to"), {
            className: "CodeMirror-composing"
          }))
        })), !0
      }, Gs.prototype.ensurePolled = function () {
        this.pollingFast && this.poll() && (this.pollingFast = !1)
      }, Gs.prototype.onKeyPress = function () {
        s && a >= 9 && (this.hasSelection = null), this.fastPoll()
      }, Gs.prototype.onContextMenu = function (e) {
        var t = this,
          n = t.cm,
          r = n.display,
          i = t.textarea;
        t.contextMenuPending && t.contextMenuPending();
        var o = cr(n, e),
          c = r.scroller.scrollTop;
        if (o && !h) {
          n.options.resetSelectionOnContextMenu && -1 == n.doc.sel.contains(o) && ei(n, Ji)(n.doc, xi(o), W);
          var u, p = i.style.cssText,
            d = t.wrapper.style.cssText,
            f = t.wrapper.offsetParent.getBoundingClientRect();
          if (t.wrapper.style.cssText = "position: static", i.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e.clientY - f.top - 5) + "px; left: " + (e.clientX - f.left - 5) + "px;\n      z-index: 1000; background: " + (s ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);", l && (u = window.scrollY), r.input.focus(), l && window.scrollTo(null, u), r.input.reset(), n.somethingSelected() || (i.value = t.prevInput = " "), t.contextMenuPending = y, r.selForContextMenu = n.doc.sel, clearTimeout(r.detectingSelectAll), s && a >= 9 && g(), E) {
            Ce(e);
            var m = function () {
              de(window, "mouseup", m), setTimeout(y, 20)
            };
            he(window, "mouseup", m)
          } else setTimeout(y, 50)
        }

        function g() {
          if (null != i.selectionStart) {
            var e = n.somethingSelected(),
              o = "​" + (e ? i.value : "");
            i.value = "⇚", i.value = o, t.prevInput = e ? "" : "​", i.selectionStart = 1, i.selectionEnd = o.length, r.selForContextMenu = n.doc.sel
          }
        }

        function y() {
          if (t.contextMenuPending == y && (t.contextMenuPending = !1, t.wrapper.style.cssText = d, i.style.cssText = p, s && a < 9 && r.scrollbars.setScrollTop(r.scroller.scrollTop = c), null != i.selectionStart)) {
            (!s || s && a < 9) && g();
            var e = 0,
              o = function () {
                r.selForContextMenu == n.doc.sel && 0 == i.selectionStart && i.selectionEnd > 0 && "​" == t.prevInput ? ei(n, ao)(n) : e++ < 10 ? r.detectingSelectAll = setTimeout(o, 500) : (r.selForContextMenu = null, r.input.reset())
              };
            r.detectingSelectAll = setTimeout(o, 200)
          }
        }
      }, Gs.prototype.readOnlyChanged = function (e) {
        e || this.reset(), this.textarea.disabled = "nocursor" == e
      }, Gs.prototype.setUneditable = function () {}, Gs.prototype.needsContentAttribute = !1,
      function (e) {
        var t = e.optionHandlers;

        function n(n, r, i, o) {
          e.defaults[n] = r, i && (t[n] = o ? function (e, t, n) {
            n != Cs && i(e, t, n)
          } : i)
        }
        e.defineOption = n, e.Init = Cs, n("value", "", (function (e, t) {
          return e.setValue(t)
        }), !0), n("mode", null, (function (e, t) {
          e.doc.modeOption = t, Ai(e)
        }), !0), n("indentUnit", 2, Ai, !0), n("indentWithTabs", !1), n("smartIndent", !0), n("tabSize", 4, (function (e) {
          Mi(e), zn(e), hr(e)
        }), !0), n("lineSeparator", null, (function (e, t) {
          if (e.doc.lineSep = t, t) {
            var n = [],
              r = e.doc.first;
            e.doc.iter((function (e) {
              for (var i = 0;;) {
                var o = e.text.indexOf(t, i);
                if (-1 == o) break;
                i = o + t.length, n.push(et(r, o))
              }
              r++
            }));
            for (var i = n.length - 1; i >= 0; i--) mo(e.doc, t, n[i], et(n[i].line, n[i].ch + t.length))
          }
        })), n("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff\ufff9-\ufffc]/g, (function (e, t, n) {
          e.state.specialChars = new RegExp(t.source + (t.test("\t") ? "" : "|\t"), "g"), n != Cs && e.refresh()
        })), n("specialCharPlaceholder", Xt, (function (e) {
          return e.refresh()
        }), !0), n("electricChars", !0), n("inputStyle", y ? "contenteditable" : "textarea", (function () {
          throw new Error("inputStyle can not (yet) be changed in a running editor")
        }), !0), n("spellcheck", !1, (function (e, t) {
          return e.getInputField().spellcheck = t
        }), !0), n("autocorrect", !1, (function (e, t) {
          return e.getInputField().autocorrect = t
        }), !0), n("autocapitalize", !1, (function (e, t) {
          return e.getInputField().autocapitalize = t
        }), !0), n("rtlMoveVisually", !b), n("wholeLineUpdateBefore", !0), n("theme", "default", (function (e) {
          Ss(e), mi(e)
        }), !0), n("keyMap", "default", (function (e, t, n) {
          var r = Qo(t),
            i = n != Cs && Qo(n);
          i && i.detach && i.detach(e, r), r.attach && r.attach(e, i || null)
        })), n("extraKeys", null), n("configureMouse", null), n("lineWrapping", !1, Ts, !0), n("gutters", [], (function (e, t) {
          e.display.gutterSpecs = di(t, e.options.lineNumbers), mi(e)
        }), !0), n("fixedGutter", !0, (function (e, t) {
          e.display.gutters.style.left = t ? sr(e.display) + "px" : "0", e.refresh()
        }), !0), n("coverGutterNextToScrollbar", !1, (function (e) {
          return Ur(e)
        }), !0), n("scrollbarStyle", "native", (function (e) {
          jr(e), Ur(e), e.display.scrollbars.setScrollTop(e.doc.scrollTop), e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)
        }), !0), n("lineNumbers", !1, (function (e, t) {
          e.display.gutterSpecs = di(e.options.gutters, t), mi(e)
        }), !0), n("firstLineNumber", 1, mi, !0), n("lineNumberFormatter", (function (e) {
          return e
        }), mi, !0), n("showCursorWhenSelecting", !1, gr, !0), n("resetSelectionOnContextMenu", !0), n("lineWiseCopyCut", !0), n("pasteLinesPerSelection", !0), n("selectionsMayTouch", !1), n("readOnly", !1, (function (e, t) {
          "nocursor" == t && (xr(e), e.display.input.blur()), e.display.input.readOnlyChanged(t)
        })), n("disableInput", !1, (function (e, t) {
          t || e.display.input.reset()
        }), !0), n("dragDrop", !0, xs), n("allowDropFileTypes", null), n("cursorBlinkRate", 530), n("cursorScrollMargin", 0), n("cursorHeight", 1, gr, !0), n("singleCursorHeightPerLine", !0, gr, !0), n("workTime", 100), n("workDelay", 100), n("flattenSpans", !0, Mi, !0), n("addModeClass", !1, Mi, !0), n("pollInterval", 100), n("undoDepth", 200, (function (e, t) {
          return e.doc.history.undoDepth = t
        })), n("historyEventDelay", 1250), n("viewportMargin", 10, (function (e) {
          return e.refresh()
        }), !0), n("maxHighlightLength", 1e4, Mi, !0), n("moveInputWithCursor", !0, (function (e, t) {
          t || e.display.input.resetPosition()
        })), n("tabindex", null, (function (e, t) {
          return e.display.input.getField().tabIndex = t || ""
        })), n("autofocus", null), n("direction", "ltr", (function (e, t) {
          return e.doc.setDirection(t)
        }), !0), n("phrases", null)
      }(Rs),
      function (e) {
        var t = e.optionHandlers,
          n = e.helpers = {};
        e.prototype = {
          constructor: e,
          focus: function () {
            window.focus(), this.display.input.focus()
          },
          setOption: function (e, n) {
            var r = this.options,
              i = r[e];
            r[e] == n && "mode" != e || (r[e] = n, t.hasOwnProperty(e) && ei(this, t[e])(this, n, i), fe(this, "optionChange", this, e))
          },
          getOption: function (e) {
            return this.options[e]
          },
          getDoc: function () {
            return this.doc
          },
          addKeyMap: function (e, t) {
            this.state.keyMaps[t ? "push" : "unshift"](Qo(e))
          },
          removeKeyMap: function (e) {
            for (var t = this.state.keyMaps, n = 0; n < t.length; ++n)
              if (t[n] == e || t[n].name == e) return t.splice(n, 1), !0
          },
          addOverlay: ti((function (t, n) {
            var r = t.token ? t : e.getMode(this.options, t);
            if (r.startState) throw new Error("Overlays may not be stateful.");
            ! function (e, t, n) {
              for (var r = 0, i = n(t); r < e.length && n(e[r]) <= i;) r++;
              e.splice(r, 0, t)
            }(this.state.overlays, {
              mode: r,
              modeSpec: t,
              opaque: n && n.opaque,
              priority: n && n.priority || 0
            }, (function (e) {
              return e.priority
            })), this.state.modeGen++, hr(this)
          })),
          removeOverlay: ti((function (e) {
            for (var t = this.state.overlays, n = 0; n < t.length; ++n) {
              var r = t[n].modeSpec;
              if (r == e || "string" == typeof e && r.name == e) return t.splice(n, 1), this.state.modeGen++, void hr(this)
            }
          })),
          indentLine: ti((function (e, t, n) {
            "string" != typeof t && "number" != typeof t && (t = null == t ? this.options.smartIndent ? "smart" : "prev" : t ? "add" : "subtract"), Xe(this.doc, e) && _s(this, e, t, n)
          })),
          indentSelection: ti((function (e) {
            for (var t = this.doc.sel.ranges, n = -1, r = 0; r < t.length; r++) {
              var i = t[r];
              if (i.empty()) i.head.line > n && (_s(this, i.head.line, e, !0), n = i.head.line, r == this.doc.sel.primIndex && Mr(this));
              else {
                var o = i.from(),
                  s = i.to(),
                  a = Math.max(n, o.line);
                n = Math.min(this.lastLine(), s.line - (s.ch ? 0 : 1)) + 1;
                for (var l = a; l < n; ++l) _s(this, l, e);
                var c = this.doc.sel.ranges;
                0 == o.ch && t.length == c.length && c[r].from().ch > 0 && Qi(this.doc, r, new Ei(o, c[r].to()), W)
              }
            }
          })),
          getTokenAt: function (e, t) {
            return vt(this, e, t)
          },
          getLineTokens: function (e, t) {
            return vt(this, et(e), t, !0)
          },
          getTokenTypeAt: function (e) {
            e = at(this.doc, e);
            var t, n = pt(this, $e(this.doc, e.line)),
              r = 0,
              i = (n.length - 1) / 2,
              o = e.ch;
            if (0 == o) t = n[2];
            else
              for (;;) {
                var s = r + i >> 1;
                if ((s ? n[2 * s - 1] : 0) >= o) i = s;
                else {
                  if (!(n[2 * s + 1] < o)) {
                    t = n[2 * s + 2];
                    break
                  }
                  r = s + 1
                }
              }
            var a = t ? t.indexOf("overlay ") : -1;
            return a < 0 ? t : 0 == a ? null : t.slice(0, a - 1)
          },
          getModeAt: function (t) {
            var n = this.doc.mode;
            return n.innerMode ? e.innerMode(n, this.getTokenAt(t).state).mode : n
          },
          getHelper: function (e, t) {
            return this.getHelpers(e, t)[0]
          },
          getHelpers: function (e, t) {
            var r = [];
            if (!n.hasOwnProperty(t)) return r;
            var i = n[t],
              o = this.getModeAt(e);
            if ("string" == typeof o[t]) i[o[t]] && r.push(i[o[t]]);
            else if (o[t])
              for (var s = 0; s < o[t].length; s++) {
                var a = i[o[t][s]];
                a && r.push(a)
              } else o.helperType && i[o.helperType] ? r.push(i[o.helperType]) : i[o.name] && r.push(i[o.name]);
            for (var l = 0; l < i._global.length; l++) {
              var c = i._global[l];
              c.pred(o, this) && -1 == z(r, c.val) && r.push(c.val)
            }
            return r
          },
          getStateAfter: function (e, t) {
            var n = this.doc;
            return dt(this, (e = st(n, null == e ? n.first + n.size - 1 : e)) + 1, t).state
          },
          cursorCoords: function (e, t) {
            var n = this.doc.sel.primary();
            return qn(this, null == e ? n.head : "object" == typeof e ? at(this.doc, e) : e ? n.from() : n.to(), t || "page")
          },
          charCoords: function (e, t) {
            return $n(this, at(this.doc, e), t || "page")
          },
          coordsChar: function (e, t) {
            return Qn(this, (e = Gn(this, e, t || "page")).left, e.top)
          },
          lineAtHeight: function (e, t) {
            return e = Gn(this, {
              top: e,
              left: 0
            }, t || "page").top, Ze(this.doc, e + this.display.viewOffset)
          },
          heightAtLine: function (e, t, n) {
            var r, i = !1;
            if ("number" == typeof e) {
              var o = this.doc.first + this.doc.size - 1;
              e < this.doc.first ? e = this.doc.first : e > o && (e = o, i = !0), r = $e(this.doc, e)
            } else r = e;
            return jn(this, r, {
              top: 0,
              left: 0
            }, t || "page", n || i).top + (i ? this.doc.height - Vt(r) : 0)
          },
          defaultTextHeight: function () {
            return rr(this.display)
          },
          defaultCharWidth: function () {
            return ir(this.display)
          },
          getViewport: function () {
            return {
              from: this.display.viewFrom,
              to: this.display.viewTo
            }
          },
          addWidget: function (e, t, n, r, i) {
            var o, s, a, l = this.display,
              c = (e = qn(this, at(this.doc, e))).bottom,
              u = e.left;
            if (t.style.position = "absolute", t.setAttribute("cm-ignore-events", "true"), this.display.input.setUneditable(t), l.sizer.appendChild(t), "over" == r) c = e.top;
            else if ("above" == r || "near" == r) {
              var h = Math.max(l.wrapper.clientHeight, this.doc.height),
                p = Math.max(l.sizer.clientWidth, l.lineSpace.clientWidth);
              ("above" == r || e.bottom + t.offsetHeight > h) && e.top > t.offsetHeight ? c = e.top - t.offsetHeight : e.bottom + t.offsetHeight <= h && (c = e.bottom), u + t.offsetWidth > p && (u = p - t.offsetWidth)
            }
            t.style.top = c + "px", t.style.left = t.style.right = "", "right" == i ? (u = l.sizer.clientWidth - t.offsetWidth, t.style.right = "0px") : ("left" == i ? u = 0 : "middle" == i && (u = (l.sizer.clientWidth - t.offsetWidth) / 2), t.style.left = u + "px"), n && (o = this, s = {
              left: u,
              top: c,
              right: u + t.offsetWidth,
              bottom: c + t.offsetHeight
            }, null != (a = _r(o, s)).scrollTop && Lr(o, a.scrollTop), null != a.scrollLeft && Fr(o, a.scrollLeft))
          },
          triggerOnKeyDown: ti(us),
          triggerOnKeyPress: ti(ps),
          triggerOnKeyUp: hs,
          triggerOnMouseDown: ti(gs),
          execCommand: function (e) {
            if (ts.hasOwnProperty(e)) return ts[e].call(null, this)
          },
          triggerElectric: ti((function (e) {
            Os(this, e)
          })),
          findPosH: function (e, t, n, r) {
            var i = 1;
            t < 0 && (i = -1, t = -t);
            for (var o = at(this.doc, e), s = 0; s < t && !(o = Bs(this.doc, o, i, n, r)).hitSide; ++s);
            return o
          },
          moveH: ti((function (e, t) {
            var n = this;
            this.extendSelectionsBy((function (r) {
              return n.display.shift || n.doc.extend || r.empty() ? Bs(n.doc, r.head, e, t, n.options.rtlMoveVisually) : e < 0 ? r.from() : r.to()
            }), j)
          })),
          deleteH: ti((function (e, t) {
            var n = this.doc.sel,
              r = this.doc;
            n.somethingSelected() ? r.replaceSelection("", null, "+delete") : Zo(this, (function (n) {
              var i = Bs(r, n.head, e, t, !1);
              return e < 0 ? {
                from: i,
                to: n.head
              } : {
                from: n.head,
                to: i
              }
            }))
          })),
          findPosV: function (e, t, n, r) {
            var i = 1,
              o = r;
            t < 0 && (i = -1, t = -t);
            for (var s = at(this.doc, e), a = 0; a < t; ++a) {
              var l = qn(this, s, "div");
              if (null == o ? o = l.left : l.left = o, (s = Hs(this, l, i, n)).hitSide) break
            }
            return s
          },
          moveV: ti((function (e, t) {
            var n = this,
              r = this.doc,
              i = [],
              o = !this.display.shift && !r.extend && r.sel.somethingSelected();
            if (r.extendSelectionsBy((function (s) {
                if (o) return e < 0 ? s.from() : s.to();
                var a = qn(n, s.head, "div");
                null != s.goalColumn && (a.left = s.goalColumn), i.push(a.left);
                var l = Hs(n, a, e, t);
                return "page" == t && s == r.sel.primary() && Ar(n, $n(n, l, "div").top - a.top), l
              }), j), i.length)
              for (var s = 0; s < r.sel.ranges.length; s++) r.sel.ranges[s].goalColumn = i[s]
          })),
          findWordAt: function (e) {
            var t = $e(this.doc, e.line).text,
              n = e.ch,
              r = e.ch;
            if (t) {
              var i = this.getHelper(e, "wordChars");
              "before" != e.sticky && r != t.length || !n ? ++r : --n;
              for (var o = t.charAt(n), s = ee(o, i) ? function (e) {
                  return ee(e, i)
                } : /\s/.test(o) ? function (e) {
                  return /\s/.test(e)
                } : function (e) {
                  return !/\s/.test(e) && !ee(e)
                }; n > 0 && s(t.charAt(n - 1));) --n;
              for (; r < t.length && s(t.charAt(r));) ++r
            }
            return new Ei(et(e.line, n), et(e.line, r))
          },
          toggleOverwrite: function (e) {
            null != e && e == this.state.overwrite || ((this.state.overwrite = !this.state.overwrite) ? I(this.display.cursorDiv, "CodeMirror-overwrite") : T(this.display.cursorDiv, "CodeMirror-overwrite"), fe(this, "overwriteToggle", this, this.state.overwrite))
          },
          hasFocus: function () {
            return this.display.input.getField() == P()
          },
          isReadOnly: function () {
            return !(!this.options.readOnly && !this.doc.cantEdit)
          },
          scrollTo: ti((function (e, t) {
            Pr(this, e, t)
          })),
          getScrollInfo: function () {
            var e = this.display.scroller;
            return {
              left: e.scrollLeft,
              top: e.scrollTop,
              height: e.scrollHeight - Tn(this) - this.display.barHeight,
              width: e.scrollWidth - Tn(this) - this.display.barWidth,
              clientHeight: Dn(this),
              clientWidth: Rn(this)
            }
          },
          scrollIntoView: ti((function (e, t) {
            null == e ? (e = {
              from: this.doc.sel.primary().head,
              to: null
            }, null == t && (t = this.options.cursorScrollMargin)) : "number" == typeof e ? e = {
              from: et(e, 0),
              to: null
            } : null == e.from && (e = {
              from: e,
              to: null
            }), e.to || (e.to = e.from), e.margin = t || 0, null != e.from.line ? function (e, t) {
              Ir(e), e.curOp.scrollToPos = t
            }(this, e) : Or(this, e.from, e.to, e.margin)
          })),
          setSize: ti((function (e, t) {
            var n = this,
              r = function (e) {
                return "number" == typeof e || /^\d+$/.test(String(e)) ? e + "px" : e
              };
            null != e && (this.display.wrapper.style.width = r(e)), null != t && (this.display.wrapper.style.height = r(t)), this.options.lineWrapping && Hn(this);
            var i = this.display.viewFrom;
            this.doc.iter(i, this.display.viewTo, (function (e) {
              if (e.widgets)
                for (var t = 0; t < e.widgets.length; t++)
                  if (e.widgets[t].noHScroll) {
                    pr(n, i, "widget");
                    break
                  }++ i
            })), this.curOp.forceUpdate = !0, fe(this, "refresh", this)
          })),
          operation: function (e) {
            return Jr(this, e)
          },
          startOperation: function () {
            return $r(this)
          },
          endOperation: function () {
            return qr(this)
          },
          refresh: ti((function () {
            var e = this.display.cachedTextHeight;
            hr(this), this.curOp.forceUpdate = !0, zn(this), Pr(this, this.doc.scrollLeft, this.doc.scrollTop), ci(this.display), (null == e || Math.abs(e - rr(this.display)) > .5) && lr(this), fe(this, "refresh", this)
          })),
          swapDoc: ti((function (e) {
            var t = this.doc;
            return t.cm = null, this.state.selectingText && this.state.selectingText(), Li(this, e), zn(this), this.display.input.reset(), Pr(this, e.scrollLeft, e.scrollTop), this.curOp.forceScroll = !0, ln(this, "swapDoc", this, t), t
          })),
          phrase: function (e) {
            var t = this.options.phrases;
            return t && Object.prototype.hasOwnProperty.call(t, e) ? t[e] : e
          },
          getInputField: function () {
            return this.display.input.getField()
          },
          getWrapperElement: function () {
            return this.display.wrapper
          },
          getScrollerElement: function () {
            return this.display.scroller
          },
          getGutterElement: function () {
            return this.display.gutters
          }
        }, ve(e), e.registerHelper = function (t, r, i) {
          n.hasOwnProperty(t) || (n[t] = e[t] = {
            _global: []
          }), n[t][r] = i
        }, e.registerGlobalHelper = function (t, r, i, o) {
          e.registerHelper(t, r, o), n[t]._global.push({
            pred: i,
            val: o
          })
        }
      }(Rs);
    var $s = "iter insert remove copy getEditor constructor".split(" ");
    for (var qs in Mo.prototype) Mo.prototype.hasOwnProperty(qs) && z($s, qs) < 0 && (Rs.prototype[qs] = function (e) {
      return function () {
        return e.apply(this.doc, arguments)
      }
    }(Mo.prototype[qs]));
    return ve(Mo), Rs.inputStyles = {
        textarea: Gs,
        contenteditable: zs
      }, Rs.defineMode = function (e) {
        Rs.defaults.mode || "null" == e || (Rs.defaults.mode = e), Fe.apply(this, arguments)
      }, Rs.defineMIME = function (e, t) {
        Ne[e] = t
      }, Rs.defineMode("null", (function () {
        return {
          token: function (e) {
            return e.skipToEnd()
          }
        }
      })), Rs.defineMIME("text/plain", "null"), Rs.defineExtension = function (e, t) {
        Rs.prototype[e] = t
      }, Rs.defineDocExtension = function (e, t) {
        Mo.prototype[e] = t
      }, Rs.fromTextArea = function (e, t) {
        if ((t = t ? F(t) : {}).value = e.value, !t.tabindex && e.tabIndex && (t.tabindex = e.tabIndex), !t.placeholder && e.placeholder && (t.placeholder = e.placeholder), null == t.autofocus) {
          var n = P();
          t.autofocus = n == e || null != e.getAttribute("autofocus") && n == document.body
        }

        function r() {
          e.value = a.getValue()
        }
        var i;
        if (e.form && (he(e.form, "submit", r), !t.leaveSubmitMethodAlone)) {
          var o = e.form;
          i = o.submit;
          try {
            var s = o.submit = function () {
              r(), o.submit = i, o.submit(), o.submit = s
            }
          } catch (e) {}
        }
        t.finishInit = function (n) {
          n.save = r, n.getTextArea = function () {
            return e
          }, n.toTextArea = function () {
            n.toTextArea = isNaN, r(), e.parentNode.removeChild(n.getWrapperElement()), e.style.display = "", e.form && (de(e.form, "submit", r), t.leaveSubmitMethodAlone || "function" != typeof e.form.submit || (e.form.submit = i))
          }
        }, e.style.display = "none";
        var a = Rs((function (t) {
          return e.parentNode.insertBefore(t, e.nextSibling)
        }), t);
        return a
      },
      function (e) {
        e.off = de, e.on = he, e.wheelEventPixels = bi, e.Doc = Mo, e.splitLines = Me, e.countColumn = B, e.findColumn = G, e.isWordChar = J, e.Pass = U, e.signal = fe, e.Line = $t, e.changeEnd = Ti, e.scrollbarModel = Vr, e.Pos = et, e.cmpPos = tt, e.modes = Le, e.mimeModes = Ne, e.resolveMode = Be, e.getMode = He, e.modeExtensions = ze, e.extendMode = Ue, e.copyState = We, e.startState = je, e.innerMode = Ve, e.commands = ts, e.keyMap = Vo, e.keyName = Yo, e.isModifierKey = qo, e.lookupKey = $o, e.normalizeKeyMap = Go, e.StringStream = Ge, e.SharedTextMarker = Ro, e.TextMarker = xo, e.LineWidget = Co, e.e_preventDefault = we, e.e_stopPropagation = be, e.e_stop = Ce, e.addClass = I, e.contains = M, e.rmClass = T, e.keyNames = Ho
      }(Rs), Rs.version = "5.49.2", Rs
  }()
}, function (e, t) {
  e.exports = require("os")
}, function (e, t, n) {
  "use strict";
  t.fromCallback = function (e) {
    return Object.defineProperty((function () {
      if ("function" != typeof arguments[arguments.length - 1]) return new Promise((t, n) => {
        arguments[arguments.length] = (e, r) => {
          if (e) return n(e);
          t(r)
        }, arguments.length++, e.apply(this, arguments)
      });
      e.apply(this, arguments)
    }), "name", {
      value: e.name
    })
  }, t.fromPromise = function (e) {
    return Object.defineProperty((function () {
      const t = arguments[arguments.length - 1];
      if ("function" != typeof t) return e.apply(this, arguments);
      e.apply(this, arguments).then(e => t(null, e), t)
    }), "name", {
      value: e.name
    })
  }
}, function (e, t, n) {
  "use strict";
  const r = (0, n(16).fromCallback)(n(172)),
    i = n(173);
  e.exports = {
    mkdirs: r,
    mkdirsSync: i,
    mkdirp: r,
    mkdirpSync: i,
    ensureDir: r,
    ensureDirSync: i
  }
}, function (e, t, n) {
  "use strict";
  ! function e() {
    if ("undefined" != typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" == typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE) {
      0;
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)
      } catch (e) {
        console.error(e)
      }
    }
  }(), e.exports = n(149)
}, function (e, t, n) {
  "use strict";
  t.__esModule = !0;
  var r, i = n(54),
    o = (r = i) && r.__esModule ? r : {
      default: r
    };
  t.default = o.default || function (e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
    }
    return e
  }
}, function (e, t) {
  var n = e.exports = {
    version: "2.5.1"
  };
  "number" == typeof __e && (__e = n)
}, function (e, t, n) {
  "use strict";
  const r = n(16).fromPromise,
    i = n(95);
  e.exports = {
    pathExists: r((function (e) {
      return i.access(e).then(() => !0).catch(() => !1)
    })),
    pathExistsSync: i.existsSync
  }
}, function (e, t) {
  var n = e.exports = "undefined" != typeof window && window.Math == Math ? window : "undefined" != typeof self && self.Math == Math ? self : Function("return this")();
  "number" == typeof __g && (__g = n)
}, function (e, t, n) {
  "use strict";
  t.__esModule = !0, t.default = function (e, t) {
    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
  }
}, function (e, t, n) {
  "use strict";
  t.__esModule = !0;
  var r, i = n(243),
    o = (r = i) && r.__esModule ? r : {
      default: r
    };
  t.default = function () {
    function e(e, t) {
      for (var n = 0; n < t.length; n++) {
        var r = t[n];
        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), (0, o.default)(e, r.key, r)
      }
    }
    return function (t, n, r) {
      return n && e(t.prototype, n), r && e(t, r), t
    }
  }()
}, function (e, t, n) {
  var r = n(22),
    i = n(20),
    o = n(105),
    s = n(29),
    a = function (e, t, n) {
      var l, c, u, h = e & a.F,
        p = e & a.G,
        d = e & a.S,
        f = e & a.P,
        m = e & a.B,
        g = e & a.W,
        y = p ? i : i[t] || (i[t] = {}),
        v = y.prototype,
        w = p ? r : d ? r[t] : (r[t] || {}).prototype;
      for (l in p && (n = t), n)(c = !h && w && void 0 !== w[l]) && l in y || (u = c ? w[l] : n[l], y[l] = p && "function" != typeof w[l] ? n[l] : m && c ? o(u, r) : g && w[l] == u ? function (e) {
        var t = function (t, n, r) {
          if (this instanceof e) {
            switch (arguments.length) {
              case 0:
                return new e;
              case 1:
                return new e(t);
              case 2:
                return new e(t, n)
            }
            return new e(t, n, r)
          }
          return e.apply(this, arguments)
        };
        return t.prototype = e.prototype, t
      }(u) : f && "function" == typeof u ? o(Function.call, u) : u, f && ((y.virtual || (y.virtual = {}))[l] = u, e & a.R && v && !v[l] && s(v, l, u)))
    };
  a.F = 1, a.G = 2, a.S = 4, a.P = 8, a.B = 16, a.W = 32, a.U = 64, a.R = 128, e.exports = a
}, function (e, t, n) {
  var r = n(37),
    i = n(106),
    o = n(64),
    s = Object.defineProperty;
  t.f = n(27) ? Object.defineProperty : function (e, t, n) {
    if (r(e), t = o(t, !0), r(n), i) try {
      return s(e, t, n)
    } catch (e) {}
    if ("get" in n || "set" in n) throw TypeError("Accessors not supported!");
    return "value" in n && (e[t] = n.value), e
  }
}, function (e, t, n) {
  e.exports = !n(30)((function () {
    return 7 != Object.defineProperty({}, "a", {
      get: function () {
        return 7
      }
    }).a
  }))
}, function (e, t) {
  var n = {}.hasOwnProperty;
  e.exports = function (e, t) {
    return n.call(e, t)
  }
}, function (e, t, n) {
  var r = n(26),
    i = n(46);
  e.exports = n(27) ? function (e, t, n) {
    return r.f(e, t, i(1, n))
  } : function (e, t, n) {
    return e[t] = n, e
  }
}, function (e, t) {
  e.exports = function (e) {
    try {
      return !!e()
    } catch (e) {
      return !0
    }
  }
}, function (e, t, n) {
  var r = n(109),
    i = n(65);
  e.exports = function (e) {
    return r(i(e))
  }
}, function (e, t, n) {
  var r = n(68)("wks"),
    i = n(47),
    o = n(22).Symbol,
    s = "function" == typeof o;
  (e.exports = function (e) {
    return r[e] || (r[e] = s && o[e] || (s ? o : i)("Symbol." + e))
  }).store = r
}, function (e, t, n) {
  var r = n(43),
    i = n(36),
    o = n(223);

  function s(e, t) {
    if (!e) throw new Error("expected readStream");
    if (!e.readable) throw new Error("readStream must be readable");
    var n = new a(t);
    return e.pipe(n), n
  }

  function a(e) {
    r.Transform.call(this, e), e = e || {}, this._readableState.objectMode = !0, this._lineBuffer = [], this._keepEmptyLines = e.keepEmptyLines || !1, this._lastChunkEndedWithCR = !1;
    var t = this;
    this.on("pipe", (function (e) {
      t.encoding || e instanceof r.Readable && (t.encoding = e._readableState.encoding)
    }))
  }
  e.exports = function (t, n) {
    return e.exports.createStream(t, n)
  }, e.exports.createStream = function (e, t) {
    return e ? s(e, t) : new a(t)
  }, e.exports.createLineStream = function (e) {
    return console.log("WARNING: byline#createLineStream is deprecated and will be removed soon"), s(e)
  }, e.exports.LineStream = a, i.inherits(a, r.Transform), a.prototype._transform = function (e, t, n) {
    t = t || "utf8", Buffer.isBuffer(e) && ("buffer" == t ? (e = e.toString(), t = "utf8") : e = e.toString(t)), this._chunkEncoding = t;
    var r = e.split(/\r\n|[\n\v\f\r\x85\u2028\u2029]/g);
    this._lastChunkEndedWithCR && "\n" == e[0] && r.shift(), this._lineBuffer.length > 0 && (this._lineBuffer[this._lineBuffer.length - 1] += r[0], r.shift()), this._lastChunkEndedWithCR = "\r" == e[e.length - 1], this._lineBuffer = this._lineBuffer.concat(r), this._pushBuffer(t, 1, n)
  }, a.prototype._pushBuffer = function (e, t, n) {
    for (; this._lineBuffer.length > t;) {
      var r = this._lineBuffer.shift();
      if ((this._keepEmptyLines || r.length > 0) && !this.push(this._reencode(r, e))) {
        var i = this;
        return void o.setImmediate((function () {
          i._pushBuffer(e, t, n)
        }))
      }
    }
    n()
  }, a.prototype._flush = function (e) {
    this._pushBuffer(this._chunkEncoding, 0, e)
  }, a.prototype._reencode = function (e, t) {
    return this.encoding && this.encoding != t ? new Buffer(e, t).toString(this.encoding) : this.encoding ? e : new Buffer(e, t)
  }
}, , function (e, t) {
  t.getArg = function (e, t, n) {
    if (t in e) return e[t];
    if (3 === arguments.length) return n;
    throw new Error('"' + t + '" is a required argument.')
  };
  var n = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/,
    r = /^data:.+\,.+$/;

  function i(e) {
    var t = e.match(n);
    return t ? {
      scheme: t[1],
      auth: t[2],
      host: t[3],
      port: t[4],
      path: t[5]
    } : null
  }

  function o(e) {
    var t = "";
    return e.scheme && (t += e.scheme + ":"), t += "//", e.auth && (t += e.auth + "@"), e.host && (t += e.host), e.port && (t += ":" + e.port), e.path && (t += e.path), t
  }

  function s(e) {
    var n = e,
      r = i(e);
    if (r) {
      if (!r.path) return e;
      n = r.path
    }
    for (var s, a = t.isAbsolute(n), l = n.split(/\/+/), c = 0, u = l.length - 1; u >= 0; u--) "." === (s = l[u]) ? l.splice(u, 1) : ".." === s ? c++ : c > 0 && ("" === s ? (l.splice(u + 1, c), c = 0) : (l.splice(u, 2), c--));
    return "" === (n = l.join("/")) && (n = a ? "/" : "."), r ? (r.path = n, o(r)) : n
  }
  t.urlParse = i, t.urlGenerate = o, t.normalize = s, t.join = function (e, t) {
    "" === e && (e = "."), "" === t && (t = ".");
    var n = i(t),
      a = i(e);
    if (a && (e = a.path || "/"), n && !n.scheme) return a && (n.scheme = a.scheme), o(n);
    if (n || t.match(r)) return t;
    if (a && !a.host && !a.path) return a.host = t, o(a);
    var l = "/" === t.charAt(0) ? t : s(e.replace(/\/+$/, "") + "/" + t);
    return a ? (a.path = l, o(a)) : l
  }, t.isAbsolute = function (e) {
    return "/" === e.charAt(0) || !!e.match(n)
  }, t.relative = function (e, t) {
    "" === e && (e = "."), e = e.replace(/\/$/, "");
    for (var n = 0; 0 !== t.indexOf(e + "/");) {
      var r = e.lastIndexOf("/");
      if (r < 0) return t;
      if ((e = e.slice(0, r)).match(/^([^\/]+:\/)?\/*$/)) return t;
      ++n
    }
    return Array(n + 1).join("../") + t.substr(e.length + 1)
  };
  var a = !("__proto__" in Object.create(null));

  function l(e) {
    return e
  }

  function c(e) {
    if (!e) return !1;
    var t = e.length;
    if (t < 9) return !1;
    if (95 !== e.charCodeAt(t - 1) || 95 !== e.charCodeAt(t - 2) || 111 !== e.charCodeAt(t - 3) || 116 !== e.charCodeAt(t - 4) || 111 !== e.charCodeAt(t - 5) || 114 !== e.charCodeAt(t - 6) || 112 !== e.charCodeAt(t - 7) || 95 !== e.charCodeAt(t - 8) || 95 !== e.charCodeAt(t - 9)) return !1;
    for (var n = t - 10; n >= 0; n--)
      if (36 !== e.charCodeAt(n)) return !1;
    return !0
  }

  function u(e, t) {
    return e === t ? 0 : e > t ? 1 : -1
  }
  t.toSetString = a ? l : function (e) {
    return c(e) ? "$" + e : e
  }, t.fromSetString = a ? l : function (e) {
    return c(e) ? e.slice(1) : e
  }, t.compareByOriginalPositions = function (e, t, n) {
    var r = e.source - t.source;
    return 0 !== r || 0 !== (r = e.originalLine - t.originalLine) || 0 !== (r = e.originalColumn - t.originalColumn) || n || 0 !== (r = e.generatedColumn - t.generatedColumn) || 0 !== (r = e.generatedLine - t.generatedLine) ? r : e.name - t.name
  }, t.compareByGeneratedPositionsDeflated = function (e, t, n) {
    var r = e.generatedLine - t.generatedLine;
    return 0 !== r || 0 !== (r = e.generatedColumn - t.generatedColumn) || n || 0 !== (r = e.source - t.source) || 0 !== (r = e.originalLine - t.originalLine) || 0 !== (r = e.originalColumn - t.originalColumn) ? r : e.name - t.name
  }, t.compareByGeneratedPositionsInflated = function (e, t) {
    var n = e.generatedLine - t.generatedLine;
    return 0 !== n || 0 !== (n = e.generatedColumn - t.generatedColumn) || 0 !== (n = u(e.source, t.source)) || 0 !== (n = e.originalLine - t.originalLine) || 0 !== (n = e.originalColumn - t.originalColumn) ? n : u(e.name, t.name)
  }
}, function (e, t) {
  e.exports = require("util")
}, function (e, t, n) {
  var r = n(38);
  e.exports = function (e) {
    if (!r(e)) throw TypeError(e + " is not an object!");
    return e
  }
}, function (e, t) {
  e.exports = function (e) {
    return "object" == typeof e ? null !== e : "function" == typeof e
  }
}, function (e, t, n) {
  var r = n(108),
    i = n(69);
  e.exports = Object.keys || function (e) {
    return r(e, i)
  }
}, function (e, t, n) {
  "use strict";
  n.r(t), n.d(t, "start", (function () {
    return o
  })), n.d(t, "stop", (function () {
    return s
  })), n.d(t, "measure", (function () {
    return a
  }));
  let r = !1,
    i = 0;

  function o() {
    r = !0
  }

  function s() {
    r = !1
  }
  async function a(e, t) {
    const n = ++i,
      o = performance && performance.now ? performance.now() : null;
    ! function (e, t) {
      if (!r) return;
      const n = `${e}::${t}`;
      performance.mark(n)
    }(n, e);
    try {
      return await t()
    } finally {
      if (o) {
        const t = performance.now() - o;
        if (t > 1e3) {
          const n = (t / 1e3).toFixed(3);
          log.info(`Executing ${e} (took ${n}s)`)
        }
      }! function (e, t) {
        if (!r) return;
        const n = `${e}::${t}`,
          i = t;
        performance.measure(i, n), performance.clearMarks(n), performance.clearMeasures(i)
      }(n, e)
    }
  }
}, function (e, t, n) {
  "use strict";
  t.__esModule = !0;
  var r, i = n(113),
    o = (r = i) && r.__esModule ? r : {
      default: r
    };
  t.default = function (e, t) {
    if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return !t || "object" !== (void 0 === t ? "undefined" : (0, o.default)(t)) && "function" != typeof t ? e : t
  }
}, function (e, t) {
  e.exports = function (e) {
    return e.webpackPolyfill || (e.deprecate = function () {}, e.paths = [], e.children || (e.children = []), Object.defineProperty(e, "loaded", {
      enumerable: !0,
      get: function () {
        return e.l
      }
    }), Object.defineProperty(e, "id", {
      enumerable: !0,
      get: function () {
        return e.i
      }
    }), e.webpackPolyfill = 1), e
  }
}, function (e, t) {
  e.exports = require("stream")
}, function (e, t) {
  e.exports = require("assert")
}, function (e, t, n) {
  "use strict";
  const r = n(16).fromCallback,
    i = n(176);
  e.exports = {
    remove: r(i),
    removeSync: i.sync
  }
}, function (e, t) {
  e.exports = function (e, t) {
    return {
      enumerable: !(1 & e),
      configurable: !(2 & e),
      writable: !(4 & e),
      value: t
    }
  }
}, function (e, t) {
  var n = 0,
    r = Math.random();
  e.exports = function (e) {
    return "Symbol(".concat(void 0 === e ? "" : e, ")_", (++n + r).toString(36))
  }
}, function (e, t) {
  t.f = {}.propertyIsEnumerable
}, function (e, t, n) {
  var r = n(65);
  e.exports = function (e) {
    return Object(r(e))
  }
}, function (e, t) {
  e.exports = function (e) {
    return e && e.__esModule ? e : {
      default: e
    }
  }
}, function (e, t) {
  (function () {
    var e, n, r, i, o, s, a, l, c, u, h, p, d, f, m, g;
    t.score = function (e, t, r) {
      var i, s, a;
      return i = r.preparedQuery, r.allowErrors || o(e, i.core_lw, i.core_up) ? (a = e.toLowerCase(), s = n(e, a, i), Math.ceil(s)) : 0
    }, t.isMatch = o = function (e, t, n) {
      var r, i, o, s, a, l, c;
      if (o = e.length, s = t.length, !o || s > o) return !1;
      for (r = -1, i = -1; ++i < s;) {
        for (a = t.charCodeAt(i), l = n.charCodeAt(i); ++r < o && (c = e.charCodeAt(r)) !== a && c !== l;);
        if (r === o) return !1
      }
      return !0
    }, t.computeScore = n = function (e, t, n) {
      var r, i, o, s, a, f, m, y, v, w, b, S, C, E, k, x, T, R, D, _, A, M, P, I;
      if (k = n.query, x = n.query_lw, w = e.length, C = k.length, i = (r = c(e, t, k, x)).score, r.count === C) return p(C, w, i, r.pos);
      if ((E = t.indexOf(x)) > -1) return d(e, t, k, x, E, C, w);
      for (_ = new Array(C), a = new Array(C), I = g(C, w), S = b = Math.ceil(.75 * C) + 5, m = !0, v = -1; ++v < C;) _[v] = 0, a[v] = 0;
      for (y = -1; ++y < w;)
        if (!(M = t[y]).charCodeAt(0) in n.charCodes) {
          if (m) {
            for (v = -1; ++v < C;) a[v] = 0;
            m = !1
          }
        } else
          for (R = 0, D = 0, s = 0, T = !0, m = !0, v = -1; ++v < C;) {
            if ((A = _[v]) > R && (R = A), f = 0, x[v] === M)
              if (P = l(y, e, t), f = s > 0 ? s : h(e, t, k, x, y, v, P), (o = D + u(y, v, P, i, f)) > R) R = o, S = b;
              else {
                if (T && --S <= 0) return Math.max(R, _[C - 1]) * I;
                T = !1
              } D = A, s = a[v], a[v] = f, _[v] = R
          }
      return (R = _[C - 1]) * I
    }, t.isWordStart = l = function (e, t, n) {
      var r, i;
      return 0 === e || (r = t[e], i = t[e - 1], s(i) || r !== n[e] && i === n[e - 1])
    }, t.isWordEnd = a = function (e, t, n, r) {
      var i, o;
      return e === r - 1 || (i = t[e], o = t[e + 1], s(o) || i === n[e] && o !== n[e + 1])
    }, s = function (e) {
      return " " === e || "." === e || "-" === e || "_" === e || "/" === e || "\\" === e
    }, m = function (e) {
      var t;
      return e < 20 ? 100 + (t = 20 - e) * t : Math.max(120 - e, 0)
    }, t.scoreSize = g = function (e, t) {
      return 150 / (150 + Math.abs(t - e))
    }, p = function (e, t, n, r) {
      return 2 * e * (150 * n + m(r)) * g(e, t)
    }, t.scorePattern = f = function (e, t, n, r, i) {
      var o, s;
      return s = e, o = 6, n === e && (o += 2), r && (o += 3), i && (o += 1), e === t && (r && (s += n === t ? 2 : 1), i && (o += 1)), n + s * (s + o)
    }, t.scoreCharacter = u = function (e, t, n, r, i) {
      var o;
      return o = m(e), n ? o + 150 * ((r > i ? r : i) + 10) : o + 150 * i
    }, t.scoreConsecutives = h = function (e, t, n, r, i, o, s) {
      var l, c, u, h, p, d, m;
      for (l = (u = (c = e.length) - i) < (p = (h = n.length) - o) ? u : p, d = 0, m = 0, n[o] === e[i] && d++; ++m < l && r[++o] === t[++i];) n[o] === e[i] && d++;
      return m < l && i--, 1 === m ? 1 + 2 * d : f(m, h, d, s, a(i, e, t, c))
    }, t.scoreExactMatch = d = function (e, t, n, r, i, o, s) {
      var c, u, h, d, m;
      for ((m = l(i, e, t)) || (h = t.indexOf(r, i + 1)) > -1 && (m = l(h, e, t)) && (i = h), u = -1, d = 0; ++u < o;) n[i + u] === e[u] && d++;
      return c = a(i + o - 1, e, t, s), p(o, s, f(o, o, d, m, c), i)
    }, r = new(e = function (e, t, n) {
      this.score = e, this.pos = t, this.count = n
    })(0, .1, 0), t.scoreAcronyms = c = function (t, n, o, a) {
      var c, u, h, p, d, m, g, y, v, w, b;
      if (d = t.length, m = o.length, !(d > 1 && m > 1)) return r;
      for (c = 0, w = 0, b = 0, y = 0, h = -1, p = -1; ++p < m;) {
        if (g = a[p], s(g)) {
          if ((h = n.indexOf(g, h + 1)) > -1) {
            w++;
            continue
          }
          break
        }
        for (; ++h < d;)
          if (g === n[h] && l(h, t, n)) {
            o[p] === t[h] && y++, b += h, c++;
            break
          } if (h === d) break
      }
      return c < 2 ? r : (u = c === m && i(t, n, o, c), v = f(c, m, y, !0, u), new e(v, b / c, c + w))
    }, i = function (e, t, n, r) {
      var i, o, s;
      if (i = 0, (s = e.length) > 12 * n.length) return !1;
      for (o = -1; ++o < s;)
        if (l(o, e, t) && ++i > r) return !1;
      return !0
    }
  }).call(this)
}, function (e, t) {
  e.exports = require("crypto")
}, function (e, t, n) {
  "use strict";
  n(193);
  const r = async e => {
    throw new Error("macOS only")
  };
  e.exports = r, e.exports.default = r, e.exports.sync = e => {
    throw new Error("macOS only")
  }
}, function (e, t, n) {
  e.exports = {
    default: n(234),
    __esModule: !0
  }
}, function (e, t, n) {
  e.exports = {
    default: n(241),
    __esModule: !0
  }
}, function (e, t, n) {
  "use strict";
  t.__esModule = !0;
  var r = s(n(267)),
    i = s(n(271)),
    o = s(n(113));

  function s(e) {
    return e && e.__esModule ? e : {
      default: e
    }
  }
  t.default = function (e, t) {
    if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + (void 0 === t ? "undefined" : (0, o.default)(t)));
    e.prototype = (0, i.default)(t && t.prototype, {
      constructor: {
        value: e,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }), t && (r.default ? (0, r.default)(e, t) : e.__proto__ = t)
  }
}, function (e, t, n) {
  var r = n(222);

  function i(e, t) {
    if (!e || e.length <= 0) throw new Error(t + " is required.")
  }
  e.exports = {
    getPassword: function (e, t) {
      return i(e, "Service"), i(t, "Account"), r.getPassword(e, t)
    },
    setPassword: function (e, t, n) {
      return i(e, "Service"), i(t, "Account"), i(n, "Password"), r.setPassword(e, t, n)
    },
    deletePassword: function (e, t) {
      return i(e, "Service"), i(t, "Account"), r.deletePassword(e, t)
    },
    findPassword: function (e) {
      return i(e, "Service"), r.findPassword(e)
    },
    findCredentials: function (e) {
      return i(e, "Service"), r.findCredentials(e)
    }
  }
}, function (e, t, n) {
  const r = n(7),
    {
      spawn: i,
      spawnSync: o
    } = n(8),
    s = (n(62), n(297)),
    a = e.exports;

  function l(e, t) {
    return n => t(0 === n ? null : new Error(e + " failed with exit status " + n))
  }
  a.testMode = !1, Object.assign(a, {
    symlink(e, t, n) {
      s.spawnAsAdmin("cmd", ["/c", "mklink", "/j", t, e], a.testMode, l("mklink", n))
    },
    unlink(e, t) {
      r.stat(e, (n, r) => {
        if (n) return t(n);
        r.isDirectory() ? s.spawnAsAdmin("cmd", ["/c", "rmdir", "/s", "/q", e], a.testMode, l("rmdir", t)) : s.spawnAsAdmin("cmd", ["/c", "del", "/f", "/q", e], a.testMode, l("del", t))
      })
    },
    makeTree(e, t) {
      s.spawnAsAdmin("cmd", ["/c", "mkdir", e], a.testMode, l("mkdir", t))
    },
    recursiveCopy(e, t, n) {
      s.spawnAsAdmin("cmd", ["/c", 298, e, t], a.testMode, l("robocopy", n))
    }
  })
}, function (e, t, n) {
  "use strict";
  /*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  */
  var r = Object.getOwnPropertySymbols,
    i = Object.prototype.hasOwnProperty,
    o = Object.prototype.propertyIsEnumerable;

  function s(e) {
    if (null == e) throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(e)
  }
  e.exports = function () {
    try {
      if (!Object.assign) return !1;
      var e = new String("abc");
      if (e[5] = "de", "5" === Object.getOwnPropertyNames(e)[0]) return !1;
      for (var t = {}, n = 0; n < 10; n++) t["_" + String.fromCharCode(n)] = n;
      if ("0123456789" !== Object.getOwnPropertyNames(t).map((function (e) {
          return t[e]
        })).join("")) return !1;
      var r = {};
      return "abcdefghijklmnopqrst".split("").forEach((function (e) {
        r[e] = e
      })), "abcdefghijklmnopqrst" === Object.keys(Object.assign({}, r)).join("")
    } catch (e) {
      return !1
    }
  }() ? Object.assign : function (e, t) {
    for (var n, a, l = s(e), c = 1; c < arguments.length; c++) {
      for (var u in n = Object(arguments[c])) i.call(n, u) && (l[u] = n[u]);
      if (r) {
        a = r(n);
        for (var h = 0; h < a.length; h++) o.call(n, a[h]) && (l[a[h]] = n[a[h]])
      }
    }
    return l
  }
}, function (e, t) {
  (function () {
    e.exports = function () {
      function e(e) {
        this.disposalAction = e
      }
      return e.prototype.disposed = !1, e.isDisposable = function (e) {
        return "function" == typeof (null != e ? e.dispose : void 0)
      }, e.prototype.dispose = function () {
        this.disposed || (this.disposed = !0, "function" == typeof this.disposalAction && this.disposalAction(), this.disposalAction = null)
      }, e
    }()
  }).call(this)
}, function (e, t, n) {
  "use strict";
  const r = n(16).fromCallback,
    i = n(184);
  e.exports = {
    readJson: r(i.readFile),
    readJsonSync: i.readFileSync,
    writeJson: r(i.writeFile),
    writeJsonSync: i.writeFileSync
  }
}, function (e, t) {
  e.exports = require("events")
}, function (e, t, n) {
  e.exports = n(232)()
}, function (e, t, n) {
  var r = n(38);
  e.exports = function (e, t) {
    if (!r(e)) return e;
    var n, i;
    if (t && "function" == typeof (n = e.toString) && !r(i = n.call(e))) return i;
    if ("function" == typeof (n = e.valueOf) && !r(i = n.call(e))) return i;
    if (!t && "function" == typeof (n = e.toString) && !r(i = n.call(e))) return i;
    throw TypeError("Can't convert object to primitive value")
  }
}, function (e, t) {
  e.exports = function (e) {
    if (null == e) throw TypeError("Can't call method on  " + e);
    return e
  }
}, function (e, t) {
  var n = Math.ceil,
    r = Math.floor;
  e.exports = function (e) {
    return isNaN(e = +e) ? 0 : (e > 0 ? r : n)(e)
  }
}, function (e, t, n) {
  var r = n(68)("keys"),
    i = n(47);
  e.exports = function (e) {
    return r[e] || (r[e] = i(e))
  }
}, function (e, t, n) {
  var r = n(22),
    i = r["__core-js_shared__"] || (r["__core-js_shared__"] = {});
  e.exports = function (e) {
    return i[e] || (i[e] = {})
  }
}, function (e, t) {
  e.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")
}, function (e, t) {
  t.f = Object.getOwnPropertySymbols
}, function (e, t) {
  e.exports = !0
}, function (e, t) {
  e.exports = {}
}, function (e, t, n) {
  var r = n(37),
    i = n(251),
    o = n(69),
    s = n(67)("IE_PROTO"),
    a = function () {},
    l = function () {
      var e, t = n(107)("iframe"),
        r = o.length;
      for (t.style.display = "none", n(252).appendChild(t), t.src = "javascript:", (e = t.contentWindow.document).open(), e.write("<script>document.F=Object<\/script>"), e.close(), l = e.F; r--;) delete l.prototype[o[r]];
      return l()
    };
  e.exports = Object.create || function (e, t) {
    var n;
    return null !== e ? (a.prototype = r(e), n = new a, a.prototype = null, n[s] = e) : n = l(), void 0 === t ? n : i(n, t)
  }
}, function (e, t, n) {
  var r = n(26).f,
    i = n(28),
    o = n(32)("toStringTag");
  e.exports = function (e, t, n) {
    e && !i(e = n ? e : e.prototype, o) && r(e, o, {
      configurable: !0,
      value: t
    })
  }
}, function (e, t, n) {
  t.f = n(32)
}, function (e, t, n) {
  var r = n(22),
    i = n(20),
    o = n(71),
    s = n(75),
    a = n(26).f;
  e.exports = function (e) {
    var t = i.Symbol || (i.Symbol = o ? {} : r.Symbol || {});
    "_" == e.charAt(0) || e in t || a(t, e, {
      value: s.f(e)
    })
  }
}, function (e, t, n) {
  e.exports = n(274)()
}, function (e, t, n) {
  "use strict";
  t.__esModule = !0, t.default = void 0;
  var r = !("undefined" == typeof window || !window.document || !window.document.createElement);
  t.default = r, e.exports = t.default
}, function (e, t, n) {
  (function () {
    var e, r, i, o, s, a, l;
    l = n(51), o = l.isMatch, e = l.computeScore, a = l.scoreSize, t.score = function (t, n, r) {
      var i, a, l;
      return i = r.preparedQuery, r.allowErrors || o(t, i.core_lw, i.core_up) ? (l = t.toLowerCase(), a = e(t, l, i), a = s(t, l, a, r), Math.ceil(a)) : 0
    }, s = function (t, n, o, s) {
      var l, c, u, h, p, d, f, m, g, y;
      if (0 === o) return 0;
      for (g = s.preparedQuery, y = s.useExtensionBonus, m = s.pathSeparator, p = t.length - 1; t[p] === m;) p--;
      if (f = p - (u = t.lastIndexOf(m, p)), d = 1, y && (o *= d += i(n, g.ext, u, p, 2)), -1 === u) return o;
      for (h = g.depth; u > -1 && h-- > 0;) u = t.lastIndexOf(m, u - 1);
      return c = -1 === u ? o : d * e(t.slice(u + 1, p + 1), n.slice(u + 1, p + 1), g), (l = 10 / (20 + r(t, p + 1, m))) * c + (1 - l) * o * a(0, 2.5 * f)
    }, t.countDir = r = function (e, t, n) {
      var r, i;
      if (t < 1) return 0;
      for (r = 0, i = -1; ++i < t && e[i] === n;);
      for (; ++i < t;)
        if (e[i] === n)
          for (r++; ++i < t && e[i] === n;);
      return r
    }, t.getExtension = function (e) {
      var t;
      return (t = e.lastIndexOf(".")) < 0 ? "" : e.substr(t + 1)
    }, i = function (e, t, n, r, o) {
      var s, a, l, c;
      if (!t.length) return 0;
      if (!((c = e.lastIndexOf(".", r)) > n)) return 0;
      for ((s = r - c) < (l = t.length) && (l = s, s = t.length), c++, a = -1; ++a < l && e[c + a] === t[a];);
      return 0 === a && o > 0 ? .9 * i(e, t, n, c - 2, o - 1) : a / s
    }
  }).call(this)
}, function (e, t, n) {
  e.exports = n(288)()
}, function (e, t, n) {
  var r = n(88),
    i = n(89);
  e.exports = function (e, t, n) {
    var o = t && n || 0;
    "string" == typeof e && (t = "binary" == e ? new Array(16) : null, e = null);
    var s = (e = e || {}).random || (e.rng || r)();
    if (s[6] = 15 & s[6] | 64, s[8] = 63 & s[8] | 128, t)
      for (var a = 0; a < 16; ++a) t[o + a] = s[a];
    return t || i(s)
  }
}, function (e, t, n) {
  "use strict";
  const r = n(228),
    i = n(229),
    o = n(230),
    s = new WeakMap,
    a = (...e) => {
      if (0 === e.length) return "__defaultKey";
      if (1 === e.length) {
        const [t] = e;
        if (null == t || "function" != typeof t && "object" != typeof t) return t
      }
      return JSON.stringify(e)
    },
    l = (e, t) => {
      "number" == typeof (t = Object.assign({
        cacheKey: a,
        cache: new Map,
        cachePromiseRejection: !1
      }, t)).maxAge && o(t.cache);
      const {
        cache: n
      } = t;
      t.maxAge = t.maxAge || 0;
      const l = function (...r) {
        const o = t.cacheKey(...r);
        if (n.has(o)) return n.get(o).data;
        const s = e.call(this, ...r);
        return ((e, r) => {
          n.set(e, {
            data: r,
            maxAge: Date.now() + t.maxAge
          })
        })(o, s), i(s) && !1 === t.cachePromiseRejection && s.catch(() => n.delete(o)), s
      };
      try {
        r(l, e)
      } catch (e) {}
      return s.set(l, t.cache), l
    };
  e.exports = l, e.exports.default = l, e.exports.clear = e => {
    const t = s.get(e);
    t && "function" == typeof t.clear && t.clear()
  }
}, function (e, t, n) {
  e.exports = {
    default: n(278),
    __esModule: !0
  }
}, function (e, t, n) {
  (function () {
    var t, r, i, o, s, a, l, c;
    i = n(280), o = n(281), c = n(51), a = n(79), t = n(118), l = null, r = "win32" === ("undefined" != typeof process && null !== process ? "win32" : void 0) ? "\\" : "/", e.exports = {
      filter: function (e, t, n) {
        return null == n && (n = {}), (null != t ? t.length : void 0) && (null != e ? e.length : void 0) ? (n = s(n, t), i(e, t, n)) : []
      },
      score: function (e, t, n) {
        return null == n && (n = {}), (null != e ? e.length : void 0) && (null != t ? t.length : void 0) ? (n = s(n, t)).usePathScoring ? a.score(e, t, n) : c.score(e, t, n) : 0
      },
      match: function (e, t, n) {
        var r;
        return null == n && (n = {}), e && t ? e === t ? function () {
          r = [];
          for (var t = 0, n = e.length; 0 <= n ? t < n : t > n; 0 <= n ? t++ : t--) r.push(t);
          return r
        }.apply(this) : (n = s(n, t), o.match(e, t, n)) : []
      },
      wrap: function (e, t, n) {
        return null == n && (n = {}), e && t ? (n = s(n, t), o.wrap(e, t, n)) : []
      },
      prepareQuery: function (e, t) {
        return null == t && (t = {}), (t = s(t, e)).preparedQuery
      }
    }, s = function (e, n) {
      return null == e.allowErrors && (e.allowErrors = !1), null == e.usePathScoring && (e.usePathScoring = !0), null == e.useExtensionBonus && (e.useExtensionBonus = !1), null == e.pathSeparator && (e.pathSeparator = r), null == e.optCharRegEx && (e.optCharRegEx = null), null == e.wrap && (e.wrap = null), null == e.preparedQuery && (e.preparedQuery = l && l.query === n ? l : l = new t(n, e)), e
    }
  }).call(this)
}, function (e, t, n) {
  var r = n(86),
    i = n(35),
    o = n(87).ArraySet,
    s = n(142).MappingList;

  function a(e) {
    e || (e = {}), this._file = i.getArg(e, "file", null), this._sourceRoot = i.getArg(e, "sourceRoot", null), this._skipValidation = i.getArg(e, "skipValidation", !1), this._sources = new o, this._names = new o, this._mappings = new s, this._sourcesContents = null
  }
  a.prototype._version = 3, a.fromSourceMap = function (e) {
    var t = e.sourceRoot,
      n = new a({
        file: e.file,
        sourceRoot: t
      });
    return e.eachMapping((function (e) {
      var r = {
        generated: {
          line: e.generatedLine,
          column: e.generatedColumn
        }
      };
      null != e.source && (r.source = e.source, null != t && (r.source = i.relative(t, r.source)), r.original = {
        line: e.originalLine,
        column: e.originalColumn
      }, null != e.name && (r.name = e.name)), n.addMapping(r)
    })), e.sources.forEach((function (t) {
      var r = e.sourceContentFor(t);
      null != r && n.setSourceContent(t, r)
    })), n
  }, a.prototype.addMapping = function (e) {
    var t = i.getArg(e, "generated"),
      n = i.getArg(e, "original", null),
      r = i.getArg(e, "source", null),
      o = i.getArg(e, "name", null);
    this._skipValidation || this._validateMapping(t, n, r, o), null != r && (r = String(r), this._sources.has(r) || this._sources.add(r)), null != o && (o = String(o), this._names.has(o) || this._names.add(o)), this._mappings.add({
      generatedLine: t.line,
      generatedColumn: t.column,
      originalLine: null != n && n.line,
      originalColumn: null != n && n.column,
      source: r,
      name: o
    })
  }, a.prototype.setSourceContent = function (e, t) {
    var n = e;
    null != this._sourceRoot && (n = i.relative(this._sourceRoot, n)), null != t ? (this._sourcesContents || (this._sourcesContents = Object.create(null)), this._sourcesContents[i.toSetString(n)] = t) : this._sourcesContents && (delete this._sourcesContents[i.toSetString(n)], 0 === Object.keys(this._sourcesContents).length && (this._sourcesContents = null))
  }, a.prototype.applySourceMap = function (e, t, n) {
    var r = t;
    if (null == t) {
      if (null == e.file) throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map\'s "file" property. Both were omitted.');
      r = e.file
    }
    var s = this._sourceRoot;
    null != s && (r = i.relative(s, r));
    var a = new o,
      l = new o;
    this._mappings.unsortedForEach((function (t) {
      if (t.source === r && null != t.originalLine) {
        var o = e.originalPositionFor({
          line: t.originalLine,
          column: t.originalColumn
        });
        null != o.source && (t.source = o.source, null != n && (t.source = i.join(n, t.source)), null != s && (t.source = i.relative(s, t.source)), t.originalLine = o.line, t.originalColumn = o.column, null != o.name && (t.name = o.name))
      }
      var c = t.source;
      null == c || a.has(c) || a.add(c);
      var u = t.name;
      null == u || l.has(u) || l.add(u)
    }), this), this._sources = a, this._names = l, e.sources.forEach((function (t) {
      var r = e.sourceContentFor(t);
      null != r && (null != n && (t = i.join(n, t)), null != s && (t = i.relative(s, t)), this.setSourceContent(t, r))
    }), this)
  }, a.prototype._validateMapping = function (e, t, n, r) {
    if (t && "number" != typeof t.line && "number" != typeof t.column) throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");
    if ((!(e && "line" in e && "column" in e && e.line > 0 && e.column >= 0) || t || n || r) && !(e && "line" in e && "column" in e && t && "line" in t && "column" in t && e.line > 0 && e.column >= 0 && t.line > 0 && t.column >= 0 && n)) throw new Error("Invalid mapping: " + JSON.stringify({
      generated: e,
      source: n,
      original: t,
      name: r
    }))
  }, a.prototype._serializeMappings = function () {
    for (var e, t, n, o, s = 0, a = 1, l = 0, c = 0, u = 0, h = 0, p = "", d = this._mappings.toArray(), f = 0, m = d.length; f < m; f++) {
      if (e = "", (t = d[f]).generatedLine !== a)
        for (s = 0; t.generatedLine !== a;) e += ";", a++;
      else if (f > 0) {
        if (!i.compareByGeneratedPositionsInflated(t, d[f - 1])) continue;
        e += ","
      }
      e += r.encode(t.generatedColumn - s), s = t.generatedColumn, null != t.source && (o = this._sources.indexOf(t.source), e += r.encode(o - h), h = o, e += r.encode(t.originalLine - 1 - c), c = t.originalLine - 1, e += r.encode(t.originalColumn - l), l = t.originalColumn, null != t.name && (n = this._names.indexOf(t.name), e += r.encode(n - u), u = n)), p += e
    }
    return p
  }, a.prototype._generateSourcesContent = function (e, t) {
    return e.map((function (e) {
      if (!this._sourcesContents) return null;
      null != t && (e = i.relative(t, e));
      var n = i.toSetString(e);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, n) ? this._sourcesContents[n] : null
    }), this)
  }, a.prototype.toJSON = function () {
    var e = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    return null != this._file && (e.file = this._file), null != this._sourceRoot && (e.sourceRoot = this._sourceRoot), this._sourcesContents && (e.sourcesContent = this._generateSourcesContent(e.sources, e.sourceRoot)), e
  }, a.prototype.toString = function () {
    return JSON.stringify(this.toJSON())
  }, t.SourceMapGenerator = a
}, function (e, t, n) {
  var r = n(141);
  t.encode = function (e) {
    var t, n = "",
      i = function (e) {
        return e < 0 ? 1 + (-e << 1) : 0 + (e << 1)
      }(e);
    do {
      t = 31 & i, (i >>>= 5) > 0 && (t |= 32), n += r.encode(t)
    } while (i > 0);
    return n
  }, t.decode = function (e, t, n) {
    var i, o, s, a, l = e.length,
      c = 0,
      u = 0;
    do {
      if (t >= l) throw new Error("Expected more digits in base 64 VLQ value.");
      if (-1 === (o = r.decode(e.charCodeAt(t++)))) throw new Error("Invalid base64 digit: " + e.charAt(t - 1));
      i = !!(32 & o), c += (o &= 31) << u, u += 5
    } while (i);
    n.value = (a = (s = c) >> 1, 1 == (1 & s) ? -a : a), n.rest = t
  }
}, function (e, t, n) {
  var r = n(35),
    i = Object.prototype.hasOwnProperty,
    o = "undefined" != typeof Map;

  function s() {
    this._array = [], this._set = o ? new Map : Object.create(null)
  }
  s.fromArray = function (e, t) {
    for (var n = new s, r = 0, i = e.length; r < i; r++) n.add(e[r], t);
    return n
  }, s.prototype.size = function () {
    return o ? this._set.size : Object.getOwnPropertyNames(this._set).length
  }, s.prototype.add = function (e, t) {
    var n = o ? e : r.toSetString(e),
      s = o ? this.has(e) : i.call(this._set, n),
      a = this._array.length;
    s && !t || this._array.push(e), s || (o ? this._set.set(e, a) : this._set[n] = a)
  }, s.prototype.has = function (e) {
    if (o) return this._set.has(e);
    var t = r.toSetString(e);
    return i.call(this._set, t)
  }, s.prototype.indexOf = function (e) {
    if (o) {
      var t = this._set.get(e);
      if (t >= 0) return t
    } else {
      var n = r.toSetString(e);
      if (i.call(this._set, n)) return this._set[n]
    }
    throw new Error('"' + e + '" is not in the set.')
  }, s.prototype.at = function (e) {
    if (e >= 0 && e < this._array.length) return this._array[e];
    throw new Error("No element indexed by " + e)
  }, s.prototype.toArray = function () {
    return this._array.slice()
  }, t.ArraySet = s
}, function (e, t) {
  var n, r = global.crypto || global.msCrypto;
  if (r && r.getRandomValues) {
    var i = new Uint8Array(16);
    n = function () {
      return r.getRandomValues(i), i
    }
  }
  if (!n) {
    var o = new Array(16);
    n = function () {
      for (var e, t = 0; t < 16; t++) 0 == (3 & t) && (e = 4294967296 * Math.random()), o[t] = e >>> ((3 & t) << 3) & 255;
      return o
    }
  }
  e.exports = n
}, function (e, t) {
  for (var n = [], r = 0; r < 256; ++r) n[r] = (r + 256).toString(16).substr(1);
  e.exports = function (e, t) {
    var r = t || 0,
      i = n;
    return i[e[r++]] + i[e[r++]] + i[e[r++]] + i[e[r++]] + "-" + i[e[r++]] + i[e[r++]] + "-" + i[e[r++]] + i[e[r++]] + "-" + i[e[r++]] + i[e[r++]] + "-" + i[e[r++]] + i[e[r++]] + i[e[r++]] + i[e[r++]] + i[e[r++]] + i[e[r++]]
  }
}, function (e, t, n) {
  "use strict";
  e.exports = y;
  var r, i = n(157),
    o = n(36),
    s = n(159),
    a = (r = "function" == typeof Symbol ? function (e) {
      return Symbol.for(e)
    } : function (e) {
      return "_" + e
    })("max"),
    l = r("length"),
    c = r("lengthCalculator"),
    u = r("allowStale"),
    h = r("maxAge"),
    p = r("dispose"),
    d = r("noDisposeOnSet"),
    f = r("lruList"),
    m = r("cache");

  function g() {
    return 1
  }

  function y(e) {
    if (!(this instanceof y)) return new y(e);
    "number" == typeof e && (e = {
      max: e
    }), e || (e = {});
    var t = this[a] = e.max;
    (!t || "number" != typeof t || t <= 0) && (this[a] = 1 / 0);
    var n = e.length || g;
    "function" != typeof n && (n = g), this[c] = n, this[u] = e.stale || !1, this[h] = e.maxAge || 0, this[p] = e.dispose, this[d] = e.noDisposeOnSet || !1, this.reset()
  }

  function v(e, t, n, r) {
    var i = n.value;
    b(e, i) && (C(e, n), e[u] || (i = void 0)), i && t.call(r, i.value, i.key, e)
  }

  function w(e, t, n) {
    var r = e[m].get(t);
    if (r) {
      var i = r.value;
      b(e, i) ? (C(e, r), e[u] || (i = void 0)) : n && e[f].unshiftNode(r), i && (i = i.value)
    }
    return i
  }

  function b(e, t) {
    if (!t || !t.maxAge && !e[h]) return !1;
    var n = Date.now() - t.now;
    return t.maxAge ? n > t.maxAge : e[h] && n > e[h]
  }

  function S(e) {
    if (e[l] > e[a])
      for (var t = e[f].tail; e[l] > e[a] && null !== t;) {
        var n = t.prev;
        C(e, t), t = n
      }
  }

  function C(e, t) {
    if (t) {
      var n = t.value;
      e[p] && e[p](n.key, n.value), e[l] -= n.length, e[m].delete(n.key), e[f].removeNode(t)
    }
  }

  function E(e, t, n, r, i) {
    this.key = e, this.value = t, this.length = n, this.now = r, this.maxAge = i || 0
  }
  Object.defineProperty(y.prototype, "max", {
    set: function (e) {
      (!e || "number" != typeof e || e <= 0) && (e = 1 / 0), this[a] = e, S(this)
    },
    get: function () {
      return this[a]
    },
    enumerable: !0
  }), Object.defineProperty(y.prototype, "allowStale", {
    set: function (e) {
      this[u] = !!e
    },
    get: function () {
      return this[u]
    },
    enumerable: !0
  }), Object.defineProperty(y.prototype, "maxAge", {
    set: function (e) {
      (!e || "number" != typeof e || e < 0) && (e = 0), this[h] = e, S(this)
    },
    get: function () {
      return this[h]
    },
    enumerable: !0
  }), Object.defineProperty(y.prototype, "lengthCalculator", {
    set: function (e) {
      "function" != typeof e && (e = g), e !== this[c] && (this[c] = e, this[l] = 0, this[f].forEach((function (e) {
        e.length = this[c](e.value, e.key), this[l] += e.length
      }), this)), S(this)
    },
    get: function () {
      return this[c]
    },
    enumerable: !0
  }), Object.defineProperty(y.prototype, "length", {
    get: function () {
      return this[l]
    },
    enumerable: !0
  }), Object.defineProperty(y.prototype, "itemCount", {
    get: function () {
      return this[f].length
    },
    enumerable: !0
  }), y.prototype.rforEach = function (e, t) {
    t = t || this;
    for (var n = this[f].tail; null !== n;) {
      var r = n.prev;
      v(this, e, n, t), n = r
    }
  }, y.prototype.forEach = function (e, t) {
    t = t || this;
    for (var n = this[f].head; null !== n;) {
      var r = n.next;
      v(this, e, n, t), n = r
    }
  }, y.prototype.keys = function () {
    return this[f].toArray().map((function (e) {
      return e.key
    }), this)
  }, y.prototype.values = function () {
    return this[f].toArray().map((function (e) {
      return e.value
    }), this)
  }, y.prototype.reset = function () {
    this[p] && this[f] && this[f].length && this[f].forEach((function (e) {
      this[p](e.key, e.value)
    }), this), this[m] = new i, this[f] = new s, this[l] = 0
  }, y.prototype.dump = function () {
    return this[f].map((function (e) {
      if (!b(this, e)) return {
        k: e.key,
        v: e.value,
        e: e.now + (e.maxAge || 0)
      }
    }), this).toArray().filter((function (e) {
      return e
    }))
  }, y.prototype.dumpLru = function () {
    return this[f]
  }, y.prototype.inspect = function (e, t) {
    var n = "LRUCache {",
      r = !1;
    this[u] && (n += "\n  allowStale: true", r = !0);
    var i = this[a];
    i && i !== 1 / 0 && (r && (n += ","), n += "\n  max: " + o.inspect(i, t), r = !0);
    var s = this[h];
    s && (r && (n += ","), n += "\n  maxAge: " + o.inspect(s, t), r = !0);
    var p = this[c];
    p && p !== g && (r && (n += ","), n += "\n  length: " + o.inspect(this[l], t), r = !0);
    var d = !1;
    return this[f].forEach((function (e) {
      d ? n += ",\n  " : (r && (n += ",\n"), d = !0, n += "\n  ");
      var i = o.inspect(e.key).split("\n").join("\n  "),
        a = {
          value: e.value
        };
      e.maxAge !== s && (a.maxAge = e.maxAge), p !== g && (a.length = e.length), b(this, e) && (a.stale = !0), a = o.inspect(a, t).split("\n").join("\n  "), n += i + " => " + a
    })), (d || r) && (n += "\n"), n += "}"
  }, y.prototype.set = function (e, t, n) {
    var r = (n = n || this[h]) ? Date.now() : 0,
      i = this[c](t, e);
    if (this[m].has(e)) {
      if (i > this[a]) return C(this, this[m].get(e)), !1;
      var o = this[m].get(e).value;
      return this[p] && (this[d] || this[p](e, o.value)), o.now = r, o.maxAge = n, o.value = t, this[l] += i - o.length, o.length = i, this.get(e), S(this), !0
    }
    var s = new E(e, t, i, r, n);
    return s.length > this[a] ? (this[p] && this[p](e, t), !1) : (this[l] += s.length, this[f].unshift(s), this[m].set(e, this[f].head), S(this), !0)
  }, y.prototype.has = function (e) {
    return !!this[m].has(e) && !b(this, this[m].get(e).value)
  }, y.prototype.get = function (e) {
    return w(this, e, !0)
  }, y.prototype.peek = function (e) {
    return w(this, e, !1)
  }, y.prototype.pop = function () {
    var e = this[f].tail;
    return e ? (C(this, e), e.value) : null
  }, y.prototype.del = function (e) {
    C(this, this[m].get(e))
  }, y.prototype.load = function (e) {
    this.reset();
    for (var t = Date.now(), n = e.length - 1; n >= 0; n--) {
      var r = e[n],
        i = r.e || 0;
      if (0 === i) this.set(r.k, r.v);
      else {
        var o = i - t;
        o > 0 && this.set(r.k, r.v, o)
      }
    }
  }, y.prototype.prune = function () {
    var e = this;
    this[m].forEach((function (t, n) {
      w(e, n, !1)
    }))
  }
}, function (e, t, n) {
  var r;
  n(7);

  function i(e, t, n) {
    if ("function" == typeof t && (n = t, t = {}), !n) {
      if ("function" != typeof Promise) throw new TypeError("callback not provided");
      return new Promise((function (n, r) {
        i(e, t || {}, (function (e, t) {
          e ? r(e) : n(t)
        }))
      }))
    }
    r(e, t || {}, (function (e, r) {
      e && ("EACCES" === e.code || t && t.ignoreErrors) && (e = null, r = !1), n(e, r)
    }))
  }
  r = n(162), e.exports = i, i.sync = function (e, t) {
    try {
      return r.sync(e, t || {})
    } catch (e) {
      if (t && t.ignoreErrors || "EACCES" === e.code) return !1;
      throw e
    }
  }
}, function (e, t, n) {
  "use strict";
  e.exports = function (e) {
    var t = "string" == typeof e ? "\n" : "\n".charCodeAt(),
      n = "string" == typeof e ? "\r" : "\r".charCodeAt();
    return e[e.length - 1] === t && (e = e.slice(0, e.length - 1)), e[e.length - 1] === n && (e = e.slice(0, e.length - 1)), e
  }
}, function (e, t, n) {
  "use strict";
  e.exports = function (e) {
    var t = (e = e || {}).env || process.env;
    return "win32" !== (e.platform || "win32") ? "PATH" : Object.keys(t).filter((function (e) {
      return "PATH" === e.toUpperCase()
    }))[0] || "Path"
  }
}, function (e, t, n) {
  "use strict";
  var r = e.exports = function (e) {
    return null !== e && "object" == typeof e && "function" == typeof e.pipe
  };
  r.writable = function (e) {
    return r(e) && !1 !== e.writable && "function" == typeof e._write && "object" == typeof e._writableState
  }, r.readable = function (e) {
    return r(e) && !1 !== e.readable && "function" == typeof e._read && "object" == typeof e._readableState
  }, r.duplex = function (e) {
    return r.writable(e) && r.readable(e)
  }, r.transform = function (e) {
    return r.duplex(e) && "function" == typeof e._transform && "object" == typeof e._transformState
  }
}, function (e, t, n) {
  "use strict";
  const r = n(16).fromCallback,
    i = n(13),
    o = ["access", "appendFile", "chmod", "chown", "close", "copyFile", "fchmod", "fchown", "fdatasync", "fstat", "fsync", "ftruncate", "futimes", "lchown", "lchmod", "link", "lstat", "mkdir", "mkdtemp", "open", "readFile", "readdir", "readlink", "realpath", "rename", "rmdir", "stat", "symlink", "truncate", "unlink", "utimes", "writeFile"].filter(e => "function" == typeof i[e]);
  Object.keys(i).forEach(e => {
    "promises" !== e && (t[e] = i[e])
  }), o.forEach(e => {
    t[e] = r(i[e])
  }), t.exists = function (e, t) {
    return "function" == typeof t ? i.exists(e, t) : new Promise(t => i.exists(e, t))
  }, t.read = function (e, t, n, r, o, s) {
    return "function" == typeof s ? i.read(e, t, n, r, o, s) : new Promise((s, a) => {
      i.read(e, t, n, r, o, (e, t, n) => {
        if (e) return a(e);
        s({
          bytesRead: t,
          buffer: n
        })
      })
    })
  }, t.write = function (e, t, ...n) {
    return "function" == typeof n[n.length - 1] ? i.write(e, t, ...n) : new Promise((r, o) => {
      i.write(e, t, ...n, (e, t, n) => {
        if (e) return o(e);
        r({
          bytesWritten: t,
          buffer: n
        })
      })
    })
  }
}, function (e, t) {
  e.exports = require("constants")
}, function (e, t, n) {
  "use strict";
  e.exports = {
    copySync: n(171)
  }
}, function (e, t, n) {
  "use strict";
  const r = n(1);

  function i(e) {
    return (e = r.normalize(r.resolve(e)).split(r.sep)).length > 0 ? e[0] : null
  }
  const o = /[<>:"|?*]/;
  e.exports = {
    getRootPath: i,
    invalidWin32Path: function (e) {
      const t = i(e);
      return e = e.replace(t, ""), o.test(e)
    }
  }
}, function (e, t, n) {
  "use strict";
  const r = n(13),
    i = n(15),
    o = n(1);
  e.exports = {
    hasMillisRes: function (e) {
      let t = o.join("millis-test" + Date.now().toString() + Math.random().toString().slice(2));
      t = o.join(i.tmpdir(), t);
      const n = new Date(1435410243862);
      r.writeFile(t, "https://github.com/jprichardson/node-fs-extra/pull/141", i => {
        if (i) return e(i);
        r.open(t, "r+", (i, o) => {
          if (i) return e(i);
          r.futimes(o, n, n, n => {
            if (n) return e(n);
            r.close(o, n => {
              if (n) return e(n);
              r.stat(t, (t, n) => {
                if (t) return e(t);
                e(null, n.mtime > 1435410243e3)
              })
            })
          })
        })
      })
    },
    hasMillisResSync: function () {
      let e = o.join("millis-test-sync" + Date.now().toString() + Math.random().toString().slice(2));
      e = o.join(i.tmpdir(), e);
      const t = new Date(1435410243862);
      r.writeFileSync(e, "https://github.com/jprichardson/node-fs-extra/pull/141");
      const n = r.openSync(e, "r+");
      return r.futimesSync(n, t, t), r.closeSync(n), r.statSync(e).mtime > 1435410243e3
    },
    timeRemoveMillis: function (e) {
      if ("number" == typeof e) return 1e3 * Math.floor(e / 1e3);
      if (e instanceof Date) return new Date(1e3 * Math.floor(e.getTime() / 1e3));
      throw new Error("fs-extra: timeRemoveMillis() unknown parameter type")
    },
    utimesMillis: function (e, t, n, i) {
      r.open(e, "r+", (e, o) => {
        if (e) return i(e);
        r.futimes(o, t, n, e => {
          r.close(o, t => {
            i && i(e || t)
          })
        })
      })
    },
    utimesMillisSync: function (e, t, n) {
      const i = r.openSync(e, "r+");
      return r.futimesSync(i, t, n), r.closeSync(i)
    }
  }
}, function (e, t, n) {
  "use strict";
  e.exports = function (e) {
    if ("function" == typeof Buffer.allocUnsafe) try {
      return Buffer.allocUnsafe(e)
    } catch (t) {
      return new Buffer(e)
    }
    return new Buffer(e)
  }
}, function (e, t, n) {
  "use strict";
  const r = n(16).fromCallback;
  e.exports = {
    copy: r(n(174))
  }
}, function (e, t, n) {
  "use strict";
  var r = n(7);
  e.exports = function (e) {
    if (null === e || "object" != typeof e) return e;
    if (e instanceof Object) var t = {
      __proto__: e.__proto__
    };
    else t = Object.create(null);
    return Object.getOwnPropertyNames(e).forEach((function (n) {
      Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(e, n))
    })), t
  }(r)
}, function (e, t, n) {
  var r = n(210);

  function i(e) {
    var t = function () {
      return t.called ? t.value : (t.called = !0, t.value = e.apply(this, arguments))
    };
    return t.called = !1, t
  }

  function o(e) {
    var t = function () {
        if (t.called) throw new Error(t.onceError);
        return t.called = !0, t.value = e.apply(this, arguments)
      },
      n = e.name || "Function wrapped with `once`";
    return t.onceError = n + " shouldn't be called more than once", t.called = !1, t
  }
  e.exports = r(i), e.exports.strict = r(o), i.proto = i((function () {
    Object.defineProperty(Function.prototype, "once", {
      value: function () {
        return i(this)
      },
      configurable: !0
    }), Object.defineProperty(Function.prototype, "onceStrict", {
      value: function () {
        return o(this)
      },
      configurable: !0
    })
  }))
}, function (e, t, n) {
  "use strict";
  var r;
  Object.defineProperty(t, "__esModule", {
      value: !0
    }),
    function (e) {
      e[e.SSHKeyAuditUnverified = 0] = "SSHKeyAuditUnverified", e[e.SSHAuthenticationFailed = 1] = "SSHAuthenticationFailed", e[e.SSHPermissionDenied = 2] = "SSHPermissionDenied", e[e.HTTPSAuthenticationFailed = 3] = "HTTPSAuthenticationFailed", e[e.RemoteDisconnection = 4] = "RemoteDisconnection", e[e.HostDown = 5] = "HostDown", e[e.RebaseConflicts = 6] = "RebaseConflicts", e[e.MergeConflicts = 7] = "MergeConflicts", e[e.HTTPSRepositoryNotFound = 8] = "HTTPSRepositoryNotFound", e[e.SSHRepositoryNotFound = 9] = "SSHRepositoryNotFound", e[e.PushNotFastForward = 10] = "PushNotFastForward", e[e.BranchDeletionFailed = 11] = "BranchDeletionFailed", e[e.DefaultBranchDeletionFailed = 12] = "DefaultBranchDeletionFailed", e[e.RevertConflicts = 13] = "RevertConflicts", e[e.EmptyRebasePatch = 14] = "EmptyRebasePatch", e[e.NoMatchingRemoteBranch = 15] = "NoMatchingRemoteBranch", e[e.NoExistingRemoteBranch = 16] = "NoExistingRemoteBranch", e[e.NothingToCommit = 17] = "NothingToCommit", e[e.NoSubmoduleMapping = 18] = "NoSubmoduleMapping", e[e.SubmoduleRepositoryDoesNotExist = 19] = "SubmoduleRepositoryDoesNotExist", e[e.InvalidSubmoduleSHA = 20] = "InvalidSubmoduleSHA", e[e.LocalPermissionDenied = 21] = "LocalPermissionDenied", e[e.InvalidMerge = 22] = "InvalidMerge", e[e.InvalidRebase = 23] = "InvalidRebase", e[e.NonFastForwardMergeIntoEmptyHead = 24] = "NonFastForwardMergeIntoEmptyHead", e[e.PatchDoesNotApply = 25] = "PatchDoesNotApply", e[e.BranchAlreadyExists = 26] = "BranchAlreadyExists", e[e.BadRevision = 27] = "BadRevision", e[e.NotAGitRepository = 28] = "NotAGitRepository", e[e.CannotMergeUnrelatedHistories = 29] = "CannotMergeUnrelatedHistories", e[e.LFSAttributeDoesNotMatch = 30] = "LFSAttributeDoesNotMatch", e[e.BranchRenameFailed = 31] = "BranchRenameFailed", e[e.PathDoesNotExist = 32] = "PathDoesNotExist", e[e.InvalidObjectName = 33] = "InvalidObjectName", e[e.OutsideRepository = 34] = "OutsideRepository", e[e.LockFileAlreadyExists = 35] = "LockFileAlreadyExists", e[e.NoMergeToAbort = 36] = "NoMergeToAbort", e[e.LocalChangesOverwritten = 37] = "LocalChangesOverwritten", e[e.UnresolvedConflicts = 38] = "UnresolvedConflicts", e[e.PushWithFileSizeExceedingLimit = 39] = "PushWithFileSizeExceedingLimit", e[e.HexBranchNameRejected = 40] = "HexBranchNameRejected", e[e.ForcePushRejected = 41] = "ForcePushRejected", e[e.InvalidRefLength = 42] = "InvalidRefLength", e[e.ProtectedBranchRequiresReview = 43] = "ProtectedBranchRequiresReview", e[e.ProtectedBranchForcePush = 44] = "ProtectedBranchForcePush", e[e.ProtectedBranchDeleteRejected = 45] = "ProtectedBranchDeleteRejected", e[e.ProtectedBranchRequiredStatus = 46] = "ProtectedBranchRequiredStatus", e[e.PushWithPrivateEmail = 47] = "PushWithPrivateEmail", e[e.ConfigLockFileAlreadyExists = 48] = "ConfigLockFileAlreadyExists", e[e.RemoteAlreadyExists = 49] = "RemoteAlreadyExists", e[e.TagAlreadyExists = 50] = "TagAlreadyExists", e[e.MergeWithLocalChanges = 51] = "MergeWithLocalChanges", e[e.RebaseWithLocalChanges = 52] = "RebaseWithLocalChanges"
    }(r = t.GitError || (t.GitError = {})), t.GitErrorRegexes = {
      "ERROR: ([\\s\\S]+?)\\n+\\[EPOLICYKEYAGE\\]\\n+fatal: Could not read from remote repository.": r.SSHKeyAuditUnverified,
      "fatal: Authentication failed for 'https://": r.HTTPSAuthenticationFailed,
      "fatal: Authentication failed": r.SSHAuthenticationFailed,
      "fatal: Could not read from remote repository.": r.SSHPermissionDenied,
      "The requested URL returned error: 403": r.HTTPSAuthenticationFailed,
      "fatal: The remote end hung up unexpectedly": r.RemoteDisconnection,
      "fatal: unable to access '(.+)': Failed to connect to (.+): Host is down": r.HostDown,
      "Cloning into '(.+)'...\nfatal: unable to access '(.+)': Could not resolve host: (.+)": r.HostDown,
      "Resolve all conflicts manually, mark them as resolved with": r.RebaseConflicts,
      "(Merge conflict|Automatic merge failed; fix conflicts and then commit the result)": r.MergeConflicts,
      "fatal: repository '(.+)' not found": r.HTTPSRepositoryNotFound,
      "ERROR: Repository not found": r.SSHRepositoryNotFound,
      "\\((non-fast-forward|fetch first)\\)\nerror: failed to push some refs to '.*'": r.PushNotFastForward,
      "error: unable to delete '(.+)': remote ref does not exist": r.BranchDeletionFailed,
      "\\[remote rejected\\] (.+) \\(deletion of the current branch prohibited\\)": r.DefaultBranchDeletionFailed,
      "error: could not revert .*\nhint: after resolving the conflicts, mark the corrected paths\nhint: with 'git add <paths>' or 'git rm <paths>'\nhint: and commit the result with 'git commit'": r.RevertConflicts,
      "Applying: .*\nNo changes - did you forget to use 'git add'\\?\nIf there is nothing left to stage, chances are that something else\n.*": r.EmptyRebasePatch,
      "There are no candidates for (rebasing|merging) among the refs that you just fetched.\nGenerally this means that you provided a wildcard refspec which had no\nmatches on the remote end.": r.NoMatchingRemoteBranch,
      "Your configuration specifies to merge with the ref '(.+)'\nfrom the remote, but no such ref was fetched.": r.NoExistingRemoteBranch,
      "nothing to commit": r.NothingToCommit,
      "No submodule mapping found in .gitmodules for path '(.+)'": r.NoSubmoduleMapping,
      "fatal: repository '(.+)' does not exist\nfatal: clone of '.+' into submodule path '(.+)' failed": r.SubmoduleRepositoryDoesNotExist,
      "Fetched in submodule path '(.+)', but it did not contain (.+). Direct fetching of that commit failed.": r.InvalidSubmoduleSHA,
      "fatal: could not create work tree dir '(.+)'.*: Permission denied": r.LocalPermissionDenied,
      "merge: (.+) - not something we can merge": r.InvalidMerge,
      "invalid upstream (.+)": r.InvalidRebase,
      "fatal: Non-fast-forward commit does not make sense into an empty head": r.NonFastForwardMergeIntoEmptyHead,
      "error: (.+): (patch does not apply|already exists in working directory)": r.PatchDoesNotApply,
      "fatal: A branch named '(.+)' already exists.": r.BranchAlreadyExists,
      "fatal: bad revision '(.*)'": r.BadRevision,
      "fatal: [Nn]ot a git repository \\(or any of the parent directories\\): (.*)": r.NotAGitRepository,
      "fatal: refusing to merge unrelated histories": r.CannotMergeUnrelatedHistories,
      "The .+ attribute should be .+ but is .+": r.LFSAttributeDoesNotMatch,
      "fatal: Branch rename failed": r.BranchRenameFailed,
      "fatal: path '(.+)' does not exist .+": r.PathDoesNotExist,
      "fatal: invalid object name '(.+)'.": r.InvalidObjectName,
      "fatal: .+: '(.+)' is outside repository": r.OutsideRepository,
      "Another git process seems to be running in this repository, e.g.": r.LockFileAlreadyExists,
      "fatal: There is no merge to abort": r.NoMergeToAbort,
      "error: (?:Your local changes to the following|The following untracked working tree) files would be overwritten by checkout:": r.LocalChangesOverwritten,
      "You must edit all merge conflicts and then\nmark them as resolved using git add": r.UnresolvedConflicts,
      "error: GH001: ": r.PushWithFileSizeExceedingLimit,
      "error: GH002: ": r.HexBranchNameRejected,
      "error: GH003: Sorry, force-pushing to (.+) is not allowed.": r.ForcePushRejected,
      "error: GH005: Sorry, refs longer than (.+) bytes are not allowed": r.InvalidRefLength,
      "error: GH006: Protected branch update failed for (.+)\nremote: error: At least one approved review is required": r.ProtectedBranchRequiresReview,
      "error: GH006: Protected branch update failed for (.+)\nremote: error: Cannot force-push to a protected branch": r.ProtectedBranchForcePush,
      "error: GH006: Protected branch update failed for (.+)\nremote: error: Cannot delete a protected branch": r.ProtectedBranchDeleteRejected,
      'error: GH006: Protected branch update failed for (.+).\nremote: error: Required status check "(.+)" is expected': r.ProtectedBranchRequiredStatus,
      "error: GH007: Your push would publish a private email address.": r.PushWithPrivateEmail,
      "error: could not lock config file (.+): File exists": r.ConfigLockFileAlreadyExists,
      "fatal: remote (.+) already exists.": r.RemoteAlreadyExists,
      "fatal: tag '(.+)' already exists": r.TagAlreadyExists,
      "error: Your local changes to the following files would be overwritten by merge:\n": r.MergeWithLocalChanges,
      "error: cannot (pull with rebase|rebase): You have unstaged changes\\.\n\\s*error: [Pp]lease commit or stash them\\.": r.RebaseWithLocalChanges
    }, t.GitNotFoundErrorCode = "git-not-found-error", t.RepositoryDoesNotExistErrorCode = "repository-does-not-exist-error"
}, function (e, t, n) {
  var r = n(236);
  e.exports = function (e, t, n) {
    if (r(e), void 0 === t) return e;
    switch (n) {
      case 1:
        return function (n) {
          return e.call(t, n)
        };
      case 2:
        return function (n, r) {
          return e.call(t, n, r)
        };
      case 3:
        return function (n, r, i) {
          return e.call(t, n, r, i)
        }
    }
    return function () {
      return e.apply(t, arguments)
    }
  }
}, function (e, t, n) {
  e.exports = !n(27) && !n(30)((function () {
    return 7 != Object.defineProperty(n(107)("div"), "a", {
      get: function () {
        return 7
      }
    }).a
  }))
}, function (e, t, n) {
  var r = n(38),
    i = n(22).document,
    o = r(i) && r(i.createElement);
  e.exports = function (e) {
    return o ? i.createElement(e) : {}
  }
}, function (e, t, n) {
  var r = n(28),
    i = n(31),
    o = n(238)(!1),
    s = n(67)("IE_PROTO");
  e.exports = function (e, t) {
    var n, a = i(e),
      l = 0,
      c = [];
    for (n in a) n != s && r(a, n) && c.push(n);
    for (; t.length > l;) r(a, n = t[l++]) && (~o(c, n) || c.push(n));
    return c
  }
}, function (e, t, n) {
  var r = n(110);
  e.exports = Object("z").propertyIsEnumerable(0) ? Object : function (e) {
    return "String" == r(e) ? e.split("") : Object(e)
  }
}, function (e, t) {
  var n = {}.toString;
  e.exports = function (e) {
    return n.call(e).slice(8, -1)
  }
}, function (e, t, n) {
  var r = n(28),
    i = n(49),
    o = n(67)("IE_PROTO"),
    s = Object.prototype;
  e.exports = Object.getPrototypeOf || function (e) {
    return e = i(e), r(e, o) ? e[o] : "function" == typeof e.constructor && e instanceof e.constructor ? e.constructor.prototype : e instanceof Object ? s : null
  }
}, function (e, t, n) {
  var r = n(25),
    i = n(20),
    o = n(30);
  e.exports = function (e, t) {
    var n = (i.Object || {})[e] || Object[e],
      s = {};
    s[e] = t(n), r(r.S + r.F * o((function () {
      n(1)
    })), "Object", s)
  }
}, function (e, t, n) {
  "use strict";
  t.__esModule = !0;
  var r = s(n(246)),
    i = s(n(257)),
    o = "function" == typeof i.default && "symbol" == typeof r.default ? function (e) {
      return typeof e
    } : function (e) {
      return e && "function" == typeof i.default && e.constructor === i.default && e !== i.default.prototype ? "symbol" : typeof e
    };

  function s(e) {
    return e && e.__esModule ? e : {
      default: e
    }
  }
  t.default = "function" == typeof i.default && "symbol" === o(r.default) ? function (e) {
    return void 0 === e ? "undefined" : o(e)
  } : function (e) {
    return e && "function" == typeof i.default && e.constructor === i.default && e !== i.default.prototype ? "symbol" : void 0 === e ? "undefined" : o(e)
  }
}, function (e, t, n) {
  "use strict";
  var r = n(71),
    i = n(25),
    o = n(115),
    s = n(29),
    a = n(28),
    l = n(72),
    c = n(250),
    u = n(74),
    h = n(111),
    p = n(32)("iterator"),
    d = !([].keys && "next" in [].keys()),
    f = function () {
      return this
    };
  e.exports = function (e, t, n, m, g, y, v) {
    c(n, t, m);
    var w, b, S, C = function (e) {
        if (!d && e in T) return T[e];
        switch (e) {
          case "keys":
          case "values":
            return function () {
              return new n(this, e)
            }
        }
        return function () {
          return new n(this, e)
        }
      },
      E = t + " Iterator",
      k = "values" == g,
      x = !1,
      T = e.prototype,
      R = T[p] || T["@@iterator"] || g && T[g],
      D = R || C(g),
      _ = g ? k ? C("entries") : D : void 0,
      A = "Array" == t && T.entries || R;
    if (A && (S = h(A.call(new e))) !== Object.prototype && S.next && (u(S, E, !0), r || a(S, p) || s(S, p, f)), k && R && "values" !== R.name && (x = !0, D = function () {
        return R.call(this)
      }), r && !v || !d && !x && T[p] || s(T, p, D), l[t] = D, l[E] = f, g)
      if (w = {
          values: k ? D : C("values"),
          keys: y ? D : C("keys"),
          entries: _
        }, v)
        for (b in w) b in T || o(T, b, w[b]);
      else i(i.P + i.F * (d || x), t, w);
    return w
  }
}, function (e, t, n) {
  e.exports = n(29)
}, function (e, t, n) {
  var r = n(108),
    i = n(69).concat("length", "prototype");
  t.f = Object.getOwnPropertyNames || function (e) {
    return r(e, i)
  }
}, function (e, t, n) {
  var r = n(48),
    i = n(46),
    o = n(31),
    s = n(64),
    a = n(28),
    l = n(106),
    c = Object.getOwnPropertyDescriptor;
  t.f = n(27) ? c : function (e, t) {
    if (e = o(e), t = s(t, !0), l) try {
      return c(e, t)
    } catch (e) {}
    if (a(e, t)) return i(!r.f.call(e, t), e[t])
  }
}, function (e, t, n) {
  (function () {
    var t, r, i, o, s, a, l;
    l = n(79), r = l.countDir, o = l.getExtension, e.exports = function (e, n) {
      var s, l, c;
      if (s = (c = null != n ? n : {}).optCharRegEx, l = c.pathSeparator, !e || !e.length) return null;
      this.query = e, this.query_lw = e.toLowerCase(), this.core = t(e, s), this.core_lw = this.core.toLowerCase(), this.core_up = a(this.core), this.depth = r(e, e.length, l), this.ext = o(this.query_lw), this.charCodes = i(this.query_lw)
    }, s = /[ _\-:\/\\]/g, t = function (e, t) {
      return null == t && (t = s), e.replace(t, "")
    }, a = function (e) {
      var t, n, r;
      for (t = "", n = 0, r = e.length; n < r; n++) t += e[n].toUpperCase()[0];
      return t
    }, i = function (e) {
      var t, n, r;
      for (r = e.length, n = -1, t = []; ++n < r;) t[e.charCodeAt(n)] = !0;
      return t
    }
  }).call(this)
}, function (e, t, n) {
  "use strict";
  var r = n(50);
  t.__esModule = !0, t.default = void 0;
  var i, o = r(n(78)),
    s = "clearTimeout",
    a = function (e) {
      var t = (new Date).getTime(),
        n = Math.max(0, 16 - (t - c)),
        r = setTimeout(e, n);
      return c = t, r
    },
    l = function (e, t) {
      return e + (e ? t[0].toUpperCase() + t.substr(1) : t) + "AnimationFrame"
    };
  o.default && ["", "webkit", "moz", "o", "ms"].some((function (e) {
    var t = l(e, "request");
    if (t in window) return s = l(e, "cancel"), a = function (e) {
      return window[t](e)
    }
  }));
  var c = (new Date).getTime();
  (i = function (e) {
    return a(e)
  }).cancel = function (e) {
    window[s] && "function" == typeof window[s] && window[s](e)
  };
  var u = i;
  t.default = u, e.exports = t.default
}, function (e, t, n) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.nameShape = void 0, t.transitionTimeout = function (e) {
    var t = "transition" + e + "Timeout",
      n = "transition" + e;
    return function (e) {
      if (e[n]) {
        if (null == e[t]) return new Error(t + " wasn't supplied to CSSTransitionGroup: this can cause unreliable animations and won't be supported in a future version of React. See https://fb.me/react-animation-transition-group-timeout for more information.");
        if ("number" != typeof e[t]) return new Error(t + " must be a number (in milliseconds)")
      }
      return null
    }
  };
  var r, i = n(80),
    o = (r = i) && r.__esModule ? r : {
      default: r
    };
  t.nameShape = o.default.oneOfType([o.default.string, o.default.shape({
    enter: o.default.string,
    leave: o.default.string,
    active: o.default.string,
    height: o.default.string
  }), o.default.shape({
    enter: o.default.string,
    enterActive: o.default.string,
    leave: o.default.string,
    leaveActive: o.default.string,
    appear: o.default.string,
    appearActive: o.default.string,
    height: o.default.string,
    heightActive: o.default.string
  })])
}, function (e, t, n) {
  "use strict";
  const r = n(1);
  e.exports = function (e) {
    if ("string" != typeof e || e.length <= 7 || "file://" !== e.substring(0, 7)) throw new TypeError("must pass in a file:// URI to convert to a file path");
    const t = decodeURI(e.substring(7)),
      n = t.indexOf("/");
    let i = t.substring(0, n),
      o = t.substring(n + 1);
    return "localhost" === i && (i = ""), i && (i = r.sep + r.sep + i), o = o.replace(/^(.+)\|/, "$1:"), "\\" === r.sep && (o = o.replace(/\//g, "\\")), /^.+:/.test(o) || (o = r.sep + o), i + o
  }
}, function (e, t, n) {
  var r, i = n(140).SourceMapConsumer,
    o = n(1);
  try {
    (r = n(7)).existsSync && r.readFileSync || (r = null)
  } catch (e) {}
  var s = !1,
    a = !1,
    l = !1,
    c = "auto",
    u = {},
    h = {},
    p = /^data:application\/json[^,]+base64,/,
    d = [],
    f = [];

  function m() {
    return "browser" === c || "node" !== c && ("undefined" != typeof window && "function" == typeof XMLHttpRequest && !(window.require && window.module && window.process && "renderer" === window.process.type))
  }

  function g(e) {
    return function (t) {
      for (var n = 0; n < e.length; n++) {
        var r = e[n](t);
        if (r) return r
      }
      return null
    }
  }
  var y = g(d);

  function v(e, t) {
    if (!e) return t;
    var n = o.dirname(e),
      r = /^\w+:\/\/[^\/]*/.exec(n),
      i = r ? r[0] : "";
    return i + o.resolve(n.slice(i.length), t)
  }
  d.push((function (e) {
    if ((e = e.trim()) in u) return u[e];
    var t = null;
    if (r) {
      if (r.existsSync(e)) try {
        t = r.readFileSync(e, "utf8")
      } catch (e) {
        t = ""
      }
    } else {
      var n = new XMLHttpRequest;
      n.open("GET", e, !1), n.send(null);
      t = null;
      4 === n.readyState && 200 === n.status && (t = n.responseText)
    }
    return u[e] = t
  }));
  var w = g(f);

  function b(e) {
    var t = h[e.source];
    if (!t) {
      var n = w(e.source);
      n ? (t = h[e.source] = {
        url: n.url,
        map: new i(n.map)
      }).map.sourcesContent && t.map.sources.forEach((function (e, n) {
        var r = t.map.sourcesContent[n];
        if (r) {
          var i = v(t.url, e);
          u[i] = r
        }
      })) : t = h[e.source] = {
        url: null,
        map: null
      }
    }
    if (t && t.map) {
      var r = t.map.originalPositionFor(e);
      if (null !== r.source) return r.source = v(t.url, r.source), r
    }
    return e
  }

  function S() {
    var e, t = "";
    if (this.isNative()) t = "native";
    else {
      !(e = this.getScriptNameOrSourceURL()) && this.isEval() && (t = this.getEvalOrigin(), t += ", "), t += e || "<anonymous>";
      var n = this.getLineNumber();
      if (null != n) {
        t += ":" + n;
        var r = this.getColumnNumber();
        r && (t += ":" + r)
      }
    }
    var i = "",
      o = this.getFunctionName(),
      s = !0,
      a = this.isConstructor();
    if (!(this.isToplevel() || a)) {
      var l = this.getTypeName();
      "[object Object]" === l && (l = "null");
      var c = this.getMethodName();
      o ? (l && 0 != o.indexOf(l) && (i += l + "."), i += o, c && o.indexOf("." + c) != o.length - c.length - 1 && (i += " [as " + c + "]")) : i += l + "." + (c || "<anonymous>")
    } else a ? i += "new " + (o || "<anonymous>") : o ? i += o : (i += t, s = !1);
    return s && (i += " (" + t + ")"), i
  }

  function C(e) {
    var t = {};
    return Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((function (n) {
      t[n] = /^(?:is|get)/.test(n) ? function () {
        return e[n].call(e)
      } : e[n]
    })), t.toString = S, t
  }

  function E(e) {
    if (e.isNative()) return e;
    var t = e.getFileName() || e.getScriptNameOrSourceURL();
    if (t) {
      var n = e.getLineNumber(),
        r = e.getColumnNumber() - 1;
      1 === n && r > 62 && !m() && !e.isEval() && (r -= 62);
      var i = b({
        source: t,
        line: n,
        column: r
      });
      return (e = C(e)).getFileName = function () {
        return i.source
      }, e.getLineNumber = function () {
        return i.line
      }, e.getColumnNumber = function () {
        return i.column + 1
      }, e.getScriptNameOrSourceURL = function () {
        return i.source
      }, e
    }
    var o = e.isEval() && e.getEvalOrigin();
    return o ? (o = function e(t) {
      var n = /^eval at ([^(]+) \((.+):(\d+):(\d+)\)$/.exec(t);
      if (n) {
        var r = b({
          source: n[2],
          line: +n[3],
          column: n[4] - 1
        });
        return "eval at " + n[1] + " (" + r.source + ":" + r.line + ":" + (r.column + 1) + ")"
      }
      return (n = /^eval at ([^(]+) \((.+)\)$/.exec(t)) ? "eval at " + n[1] + " (" + e(n[2]) + ")" : t
    }(o), (e = C(e)).getEvalOrigin = function () {
      return o
    }, e) : e
  }

  function k(e, t) {
    return l && (u = {}, h = {}), e + t.map((function (e) {
      return "\n    at " + E(e)
    })).join("")
  }

  function x(e) {
    var t = /\n    at [^(]+ \((.*):(\d+):(\d+)\)/.exec(e.stack);
    if (t) {
      var n = t[1],
        i = +t[2],
        o = +t[3],
        s = u[n];
      if (!s && r && r.existsSync(n)) try {
        s = r.readFileSync(n, "utf8")
      } catch (e) {
        s = ""
      }
      if (s) {
        var a = s.split(/(?:\r\n|\r|\n)/)[i - 1];
        if (a) return n + ":" + i + "\n" + a + "\n" + new Array(o).join(" ") + "^"
      }
    }
    return null
  }

  function T(e) {
    var t = x(e);
    t && (console.error(), console.error(t)), console.error(e.stack), process.exit(1)
  }
  f.push((function (e) {
    var t, n = function (e) {
      var t;
      if (m()) try {
        var n = new XMLHttpRequest;
        n.open("GET", e, !1), n.send(null), t = 4 === n.readyState ? n.responseText : null;
        var r = n.getResponseHeader("SourceMap") || n.getResponseHeader("X-SourceMap");
        if (r) return r
      } catch (e) {}
      t = y(e);
      for (var i, o, s = /(?:\/\/[@#][ \t]+sourceMappingURL=([^\s'"]+?)[ \t]*$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^\*]+?)[ \t]*(?:\*\/)[ \t]*$)/gm; o = s.exec(t);) i = o;
      return i ? i[1] : null
    }(e);
    if (!n) return null;
    if (p.test(n)) {
      var r = n.slice(n.indexOf(",") + 1);
      t = new Buffer(r, "base64").toString(), n = e
    } else n = v(e, n), t = y(n);
    return t ? {
      url: n,
      map: t
    } : null
  })), t.wrapCallSite = E, t.getErrorSource = x, t.mapSourcePosition = b, t.retrieveSourceMap = w, t.install = function (e) {
    if ((e = e || {}).environment && (c = e.environment, -1 === ["node", "browser", "auto"].indexOf(c))) throw new Error("environment " + c + " was unknown. Available options are {auto, browser, node}");
    if (e.retrieveFile && (e.overrideRetrieveFile && (d.length = 0), d.unshift(e.retrieveFile)), e.retrieveSourceMap && (e.overrideRetrieveSourceMap && (f.length = 0), f.unshift(e.retrieveSourceMap)), e.hookRequire && !m()) {
      var t;
      try {
        t = n(147)
      } catch (e) {}
      var r = t.prototype._compile;
      r.__sourceMapSupport || (t.prototype._compile = function (e, t) {
        return u[t] = e, h[t] = void 0, r.call(this, e, t)
      }, t.prototype._compile.__sourceMapSupport = !0)
    }
    var i;
    (l || (l = "emptyCacheBetweenOperations" in e && e.emptyCacheBetweenOperations), s || (s = !0, Error.prepareStackTrace = k), a) || (!("handleUncaughtExceptions" in e) || e.handleUncaughtExceptions) && "object" == typeof process && null !== process && "function" == typeof process.on && (a = !0, i = process.emit, process.emit = function (e) {
      if ("uncaughtException" === e) {
        var t = arguments[1] && arguments[1].stack,
          n = this.listeners(e).length > 0;
        if (t && !n) return T(arguments[1])
      }
      return i.apply(this, arguments)
    })
  }
}, function (e, t, n) {
  "use strict";
  const r = n(15),
    i = n(154),
    o = n(165);

  function s() {
    const e = process.env;
    return e.SUDO_USER || e.C9_USER || e.LOGNAME || e.USER || e.LNAME || e.USERNAME
  }

  function a(e) {
    return e.replace(/^.*\\/, "")
  }

  function l() {}
  e.exports = o(() => {
    if (r.userInfo) return Promise.resolve(r.userInfo().username);
    const e = s();
    return e ? Promise.resolve(e) : i("whoami").then(e => a(e.stdout)).catch(l)
  }), e.exports.sync = o(() => {
    if (r.userInfo) return r.userInfo().username;
    const e = s();
    if (e) return e;
    try {
      return a(i.sync("whoami").stdout)
    } catch (e) {}
  })
}, function (e, t, n) {
  var r, i, o;
  i = [], void 0 === (o = "function" == typeof (r = function () {
    var e = /^v?(?:\d+)(\.(?:[x*]|\d+)(\.(?:[x*]|\d+)(\.(?:[x*]|\d+))?(?:-[\da-z\-]+(?:\.[\da-z\-]+)*)?(?:\+[\da-z\-]+(?:\.[\da-z\-]+)*)?)?)?$/i;

    function t(e) {
      var t, n, r = e.replace(/^v/, "").replace(/\+.*$/, ""),
        i = (n = "-", -1 === (t = r).indexOf(n) ? t.length : t.indexOf(n)),
        o = r.substring(0, i).split(".");
      return o.push(r.substring(i + 1)), o
    }

    function n(e) {
      return isNaN(Number(e)) ? e : Number(e)
    }

    function r(t) {
      if ("string" != typeof t) throw new TypeError("Invalid argument expected string");
      if (!e.test(t)) throw new Error("Invalid argument not valid semver ('" + t + "' received)")
    }

    function i(e, i) {
      [e, i].forEach(r);
      for (var o = t(e), s = t(i), a = 0; a < Math.max(o.length - 1, s.length - 1); a++) {
        var l = parseInt(o[a] || 0, 10),
          c = parseInt(s[a] || 0, 10);
        if (l > c) return 1;
        if (c > l) return -1
      }
      var u = o[o.length - 1],
        h = s[s.length - 1];
      if (u && h) {
        var p = u.split(".").map(n),
          d = h.split(".").map(n);
        for (a = 0; a < Math.max(p.length, d.length); a++) {
          if (void 0 === p[a] || "string" == typeof d[a] && "number" == typeof p[a]) return -1;
          if (void 0 === d[a] || "string" == typeof p[a] && "number" == typeof d[a]) return 1;
          if (p[a] > d[a]) return 1;
          if (d[a] > p[a]) return -1
        }
      } else if (u || h) return u ? -1 : 1;
      return 0
    }
    var o = [">", ">=", "=", "<", "<="],
      s = {
        ">": [1],
        ">=": [0, 1],
        "=": [0],
        "<=": [-1, 0],
        "<": [-1]
      };
    return i.validate = function (t) {
      return "string" == typeof t && e.test(t)
    }, i.compare = function (e, t, n) {
      ! function (e) {
        if ("string" != typeof e) throw new TypeError("Invalid operator type, expected string but got " + typeof e);
        if (-1 === o.indexOf(e)) throw new TypeError("Invalid operator, expected one of " + o.join("|"))
      }(n);
      var r = i(e, t);
      return s[n].indexOf(r) > -1
    }, i
  }) ? r.apply(t, i) : r) || (e.exports = o)
}, function (e, t) {
  e.exports = require("querystring")
}, function (e, t, n) {
  "use strict";

  function r(e) {
    if (this._capacity = o(e), this._length = 0, this._front = 0, i(e)) {
      for (var t = e.length, n = 0; n < t; ++n) this[n] = e[n];
      this._length = t
    }
  }
  r.prototype.toArray = function () {
    for (var e = this._length, t = new Array(e), n = this._front, r = this._capacity, i = 0; i < e; ++i) t[i] = this[n + i & r - 1];
    return t
  }, r.prototype.push = function (e) {
    var t = arguments.length,
      n = this._length;
    if (t > 1) {
      var r = this._capacity;
      if (n + t > r) {
        for (var i = 0; i < t; ++i) {
          this._checkCapacity(n + 1), this[o = this._front + n & this._capacity - 1] = arguments[i], n++, this._length = n
        }
        return n
      }
      for (var o = this._front, i = 0; i < t; ++i) this[o + n & r - 1] = arguments[i], o++;
      return this._length = n + t, n + t
    }
    return 0 === t ? n : (this._checkCapacity(n + 1), this[i = this._front + n & this._capacity - 1] = e, this._length = n + 1, n + 1)
  }, r.prototype.pop = function () {
    var e = this._length;
    if (0 !== e) {
      var t = this._front + e - 1 & this._capacity - 1,
        n = this[t];
      return this[t] = void 0, this._length = e - 1, n
    }
  }, r.prototype.shift = function () {
    var e = this._length;
    if (0 !== e) {
      var t = this._front,
        n = this[t];
      return this[t] = void 0, this._front = t + 1 & this._capacity - 1, this._length = e - 1, n
    }
  }, r.prototype.unshift = function (e) {
    var t = this._length,
      n = arguments.length;
    if (n > 1) {
      if (t + n > (i = this._capacity)) {
        for (var r = n - 1; r >= 0; r--) {
          this._checkCapacity(t + 1);
          var i = this._capacity;
          this[s = (this._front - 1 & i - 1 ^ i) - i] = arguments[r], t++, this._length = t, this._front = s
        }
        return t
      }
      var o = this._front;
      for (r = n - 1; r >= 0; r--) {
        var s;
        this[s = (o - 1 & i - 1 ^ i) - i] = arguments[r], o = s
      }
      return this._front = o, this._length = t + n, t + n
    }
    if (0 === n) return t;
    this._checkCapacity(t + 1);
    i = this._capacity;
    return this[r = (this._front - 1 & i - 1 ^ i) - i] = e, this._length = t + 1, this._front = r, t + 1
  }, r.prototype.peekBack = function () {
    var e = this._length;
    if (0 !== e) return this[this._front + e - 1 & this._capacity - 1]
  }, r.prototype.peekFront = function () {
    if (0 !== this._length) return this[this._front]
  }, r.prototype.get = function (e) {
    var t = e;
    if (t === (0 | t)) {
      var n = this._length;
      if (t < 0 && (t += n), !(t < 0 || t >= n)) return this[this._front + t & this._capacity - 1]
    }
  }, r.prototype.isEmpty = function () {
    return 0 === this._length
  }, r.prototype.clear = function () {
    for (var e = this._length, t = this._front, n = this._capacity, r = 0; r < e; ++r) this[t + r & n - 1] = void 0;
    this._length = 0, this._front = 0
  }, r.prototype.toString = function () {
    return this.toArray().toString()
  }, r.prototype.valueOf = r.prototype.toString, r.prototype.removeFront = r.prototype.shift, r.prototype.removeBack = r.prototype.pop, r.prototype.insertFront = r.prototype.unshift, r.prototype.insertBack = r.prototype.push, r.prototype.enqueue = r.prototype.push, r.prototype.dequeue = r.prototype.shift, r.prototype.toJSON = r.prototype.toArray, Object.defineProperty(r.prototype, "length", {
    get: function () {
      return this._length
    },
    set: function () {
      throw new RangeError("")
    }
  }), r.prototype._checkCapacity = function (e) {
    this._capacity < e && this._resizeTo(o(1.5 * this._capacity + 16))
  }, r.prototype._resizeTo = function (e) {
    var t = this._capacity;
    this._capacity = e;
    var n = this._front,
      r = this._length;
    n + r > t && function (e, t, n, r, i) {
      for (var o = 0; o < i; ++o) n[o + r] = e[o + t], e[o + t] = void 0
    }(this, 0, this, t, n + r & t - 1)
  };
  var i = Array.isArray;

  function o(e) {
    if ("number" != typeof e) {
      if (!i(e)) return 16;
      e = e.length
    }
    return t = Math.min(Math.max(16, e), 1073741824), t >>>= 0, t -= 1, t |= t >> 1, t |= t >> 2, t |= t >> 4, t |= t >> 8, 1 + (t |= t >> 16);
    var t
  }
  e.exports = r
}, function (e, t, n) {
  var r = n(224),
    i = n(81),
    o = i;
  o.v1 = r, o.v4 = i, e.exports = o
}, function (e, t, n) {
  var r = n(225),
    i = n(62).EventEmitter;

  function o(e) {
    if (!(this instanceof o)) return new o(e);
    i.call(this), e = e || {}, this.concurrency = e.concurrency || 1 / 0, this.timeout = e.timeout || 0, this.autostart = e.autostart || !1, this.results = e.results || null, this.pending = 0, this.session = 0, this.running = !1, this.jobs = [], this.timers = {}
  }
  e.exports = o, e.exports.default = o, r(o, i);
  ["pop", "shift", "indexOf", "lastIndexOf"].forEach((function (e) {
    o.prototype[e] = function () {
      return Array.prototype[e].apply(this.jobs, arguments)
    }
  })), o.prototype.slice = function (e, t) {
    return this.jobs = this.jobs.slice(e, t), this
  }, o.prototype.reverse = function () {
    return this.jobs.reverse(), this
  };

  function s() {
    for (var e in this.timers) {
      var t = this.timers[e];
      delete this.timers[e], clearTimeout(t)
    }
  }

  function a(e) {
    var t = this;

    function n(e) {
      t.end(e)
    }
    this.on("error", n), this.on("end", (function r(i) {
      t.removeListener("error", n), t.removeListener("end", r), e(i, this.results)
    }))
  }

  function l(e) {
    this.session++, this.running = !1, this.emit("end", e)
  } ["push", "unshift", "splice"].forEach((function (e) {
    o.prototype[e] = function () {
      var t = Array.prototype[e].apply(this.jobs, arguments);
      return this.autostart && this.start(), t
    }
  })), Object.defineProperty(o.prototype, "length", {
    get: function () {
      return this.pending + this.jobs.length
    }
  }), o.prototype.start = function (e) {
    if (e && a.call(this, e), this.running = !0, !(this.pending >= this.concurrency))
      if (0 !== this.jobs.length) {
        var t = this,
          n = this.jobs.shift(),
          r = !0,
          i = this.session,
          o = null,
          s = !1,
          c = null;
        this.timeout && (o = setTimeout((function () {
          s = !0, t.listeners("timeout").length > 0 ? t.emit("timeout", h, n) : h()
        }), this.timeout), this.timers[o] = o), this.results && (c = this.results.length, this.results[c] = null), this.pending++;
        var u = n(h);
        u && u.then && "function" == typeof u.then && u.then((function (e) {
          return h(null, e)
        })).catch((function (e) {
          return h(e || !0)
        })), this.running && this.jobs.length > 0 && this.start()
      } else 0 === this.pending && l.call(this);

    function h(e, a) {
      r && t.session === i && (r = !1, t.pending--, null !== o && (delete t.timers[o], clearTimeout(o)), e ? t.emit("error", e, n) : !1 === s && (null !== c && (t.results[c] = Array.prototype.slice.call(arguments, 1)), t.emit("success", a, n)), t.session === i && (0 === t.pending && 0 === t.jobs.length ? l.call(t) : t.running && t.start()))
    }
  }, o.prototype.stop = function () {
    this.running = !1
  }, o.prototype.end = function (e) {
    s.call(this), this.jobs.length = 0, this.pending = 0, l.call(this, e)
  }
}, function (e, t, n) {
  "use strict";
  const r = n(1);
  e.exports = (e, t) => {
    if ("string" != typeof e) throw new TypeError("Expected a string, got " + typeof e);
    let n = e;
    return (t = Object.assign({
      resolve: !0
    }, t)).resolve && (n = r.resolve(e)), n = n.replace(/\\/g, "/"), "/" !== n[0] && (n = "/" + n), encodeURI("file://" + n).replace(/[?#]/g, encodeURIComponent)
  }
}, function (e, t, n) {
  var r = Array.prototype.slice,
    i = n(226),
    o = n(227),
    s = e.exports = function (e, t, n) {
      return n || (n = {}), e === t || (e instanceof Date && t instanceof Date ? e.getTime() === t.getTime() : !e || !t || "object" != typeof e && "object" != typeof t ? n.strict ? e === t : e == t : function (e, t, n) {
        var c, u;
        if (a(e) || a(t)) return !1;
        if (e.prototype !== t.prototype) return !1;
        if (o(e)) return !!o(t) && (e = r.call(e), t = r.call(t), s(e, t, n));
        if (l(e)) {
          if (!l(t)) return !1;
          if (e.length !== t.length) return !1;
          for (c = 0; c < e.length; c++)
            if (e[c] !== t[c]) return !1;
          return !0
        }
        try {
          var h = i(e),
            p = i(t)
        } catch (e) {
          return !1
        }
        if (h.length != p.length) return !1;
        for (h.sort(), p.sort(), c = h.length - 1; c >= 0; c--)
          if (h[c] != p[c]) return !1;
        for (c = h.length - 1; c >= 0; c--)
          if (u = h[c], !s(e[u], t[u], n)) return !1;
        return typeof e == typeof t
      }(e, t, n))
    };

  function a(e) {
    return null == e
  }

  function l(e) {
    return !(!e || "object" != typeof e || "number" != typeof e.length) && ("function" == typeof e.copy && "function" == typeof e.slice && !(e.length > 0 && "number" != typeof e[0]))
  }
}, function (e, t, n) {
  "use strict";
  var r = n(50);
  t.__esModule = !0, t.default = function (e) {
    if ((!i && 0 !== i || e) && o.default) {
      var t = document.createElement("div");
      t.style.position = "absolute", t.style.top = "-9999px", t.style.width = "50px", t.style.height = "50px", t.style.overflow = "scroll", document.body.appendChild(t), i = t.offsetWidth - t.clientWidth, document.body.removeChild(t)
    }
    return i
  };
  var i, o = r(n(78));
  e.exports = t.default
}, function (e, t, n) {
  "use strict";
  t.__esModule = !0, t.default = function (e, t) {
    var n = {};
    for (var r in e) t.indexOf(r) >= 0 || Object.prototype.hasOwnProperty.call(e, r) && (n[r] = e[r]);
    return n
  }
}, function (e, t, n) {
  ! function () {
    var t = ["direction", "boxSizing", "width", "height", "overflowX", "overflowY", "borderTopWidth", "borderRightWidth", "borderBottomWidth", "borderLeftWidth", "borderStyle", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "fontStyle", "fontVariant", "fontWeight", "fontStretch", "fontSize", "fontSizeAdjust", "lineHeight", "fontFamily", "textAlign", "textTransform", "textIndent", "textDecoration", "letterSpacing", "wordSpacing", "tabSize", "MozTabSize"],
      n = "undefined" != typeof window,
      r = n && null != window.mozInnerScreenX;

    function i(e, i, o) {
      if (!n) throw new Error("textarea-caret-position#getCaretCoordinates should only be called in a browser");
      var s = o && o.debug || !1;
      if (s) {
        var a = document.querySelector("#input-textarea-caret-position-mirror-div");
        a && a.parentNode.removeChild(a)
      }
      var l = document.createElement("div");
      l.id = "input-textarea-caret-position-mirror-div", document.body.appendChild(l);
      var c = l.style,
        u = window.getComputedStyle ? getComputedStyle(e) : e.currentStyle;
      c.whiteSpace = "pre-wrap", "INPUT" !== e.nodeName && (c.wordWrap = "break-word"), c.position = "absolute", s || (c.visibility = "hidden"), t.forEach((function (e) {
        c[e] = u[e]
      })), r ? e.scrollHeight > parseInt(u.height) && (c.overflowY = "scroll") : c.overflow = "hidden", l.textContent = e.value.substring(0, i), "INPUT" === e.nodeName && (l.textContent = l.textContent.replace(/\s/g, " "));
      var h = document.createElement("span");
      h.textContent = e.value.substring(i) || ".", l.appendChild(h);
      var p = {
        top: h.offsetTop + parseInt(u.borderTopWidth),
        left: h.offsetLeft + parseInt(u.borderLeftWidth)
      };
      return s ? h.style.backgroundColor = "#aaa" : document.body.removeChild(l), p
    }
    void 0 !== e.exports ? e.exports = i : n && (window.getCaretCoordinates = i)
  }()
}, function (e, t, n) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.default = void 0;
  var r, i, o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
      return typeof e
    } : function (e) {
      return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    },
    s = Object.assign || function (e) {
      for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t];
        for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
      }
      return e
    },
    a = d(n(0)),
    l = n(18),
    c = (d(n(80)), d(n(290))),
    u = d(n(291)),
    h = d(n(119)),
    p = d(n(292));
  n(120);

  function d(e) {
    return e && e.__esModule ? e : {
      default: e
    }
  }

  function f(e, t) {
    for (var n = Object.getOwnPropertyNames(t), r = 0; r < n.length; r++) {
      var i = n[r],
        o = Object.getOwnPropertyDescriptor(t, i);
      o && o.configurable && void 0 === e[i] && Object.defineProperty(e, i, o)
    }
    return e
  }
  var m = a.default.createFactory(p.default),
    g = (i = r = function (e) {
      function t(n, r) {
        ! function (e, t) {
          if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
        }(this, t);
        var i = function (e, t) {
          if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return !t || "object" != typeof t && "function" != typeof t ? e : t
        }(this, e.call(this, n, r));
        return i.handleDoneAppearing = function (e) {
          delete i.transitioningKeys[e], e !== i.state.currentKey && i.performLeave(e)
        }, i.performLeave = function (e) {
          i.transitioningKeys[e] = !0, i.childRefs[e].componentWillLeave(i.handleDoneLeaving.bind(i, e)), i.state.currentChild && (0, l.findDOMNode)(i.childRefs[i.state.currentKey]) || i.enqueueHeightTransition()
        }, i.performHeightTransition = function () {
          if (!i.unmounted) {
            var e = i.state,
              t = e.currentChild ? (0, l.findDOMNode)(i.childRefs[e.currentKey]) : null;
            i.setState({
              height: t ? t.offsetHeight : 0,
              width: i.props.changeWidth ? t ? t.offsetWidth : 0 : null
            })
          }
          i.rafHandle = null
        }, i.childRefs = Object.create(null), i.state = {
          currentKey: "1",
          currentChild: i.props.children ? a.default.Children.only(i.props.children) : void 0,
          prevChildren: {},
          height: null,
          width: null
        }, i
      }
      return function (e, t) {
        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
        e.prototype = Object.create(t && t.prototype, {
          constructor: {
            value: e,
            enumerable: !1,
            writable: !0,
            configurable: !0
          }
        }), t && (Object.setPrototypeOf, f(e, t))
      }(t, e), t.prototype.componentWillMount = function () {
        this.shouldEnterCurrent = !1, this.keysToLeave = [], this.transitioningKeys = {}
      }, t.prototype.componentDidMount = function () {
        this.props.transitionAppear && this.state.currentChild && this.performAppear(this.state.currentKey)
      }, t.prototype.componentWillUnmount = function () {
        this.unmounted = !0
      }, t.prototype.componentWillReceiveProps = function (e) {
        var t = e.children ? a.default.Children.only(e.children) : void 0,
          n = this.state.currentChild;
        if (n && t && t.key === n.key && !this.state.nextChild) return this.setState({
          currentChild: t
        });
        var r = this.state,
          i = r.currentKey,
          o = r.prevChildren,
          c = {
            currentKey: String(Number(i) + 1),
            currentChild: t,
            height: 0,
            width: this.props.changeWidth ? 0 : null
          };
        if (t && (this.shouldEnterCurrent = !0), n) {
          var u, h = (0, l.findDOMNode)(this.childRefs[i]);
          c.height = h ? h.offsetHeight : 0, c.width = this.props.changeWidth ? h ? h.offsetWidth : 0 : null, c.prevChildren = s({}, o, ((u = {})[i] = n, u)), this.transitioningKeys[i] || this.keysToLeave.push(i)
        }
        this.setState(c)
      }, t.prototype.componentDidUpdate = function () {
        this.shouldEnterCurrent && (this.shouldEnterCurrent = !1, (0, l.findDOMNode)(this.childRefs[this.state.currentKey]) && this.performEnter(this.state.currentKey));
        var e = this.keysToLeave;
        this.keysToLeave = [], e.forEach(this.performLeave)
      }, t.prototype.performAppear = function (e) {
        this.transitioningKeys[e] = !0, this.childRefs[e].componentWillAppear(this.handleDoneAppearing.bind(this, e))
      }, t.prototype.performEnter = function (e) {
        this.transitioningKeys[e] = !0, this.childRefs[e].componentWillEnter(this.handleDoneEntering.bind(this, e)), this.enqueueHeightTransition()
      }, t.prototype.handleDoneEntering = function (e) {
        delete this.transitioningKeys[e], e === this.state.currentKey ? this.setState({
          height: null
        }) : this.performLeave(e)
      }, t.prototype.handleDoneLeaving = function (e) {
        delete this.transitioningKeys[e];
        var t = {
          prevChildren: s({}, this.state.prevChildren)
        };
        delete t.prevChildren[e], delete this.childRefs[e], this.state.currentChild && (0, l.findDOMNode)(this.childRefs[this.state.currentKey]) || (t.height = null), this.setState(t)
      }, t.prototype.enqueueHeightTransition = function () {
        this.rafHandle || (this.rafHandle = (0, h.default)(this.performHeightTransition))
      }, t.prototype.wrapChild = function (e, t) {
        var n = this.props.transitionName;
        return "object" === (void 0 === n ? "undefined" : o(n)) && null !== n && delete(n = s({}, n)).height, m(s({
          name: n,
          appear: this.props.transitionAppear,
          enter: this.props.transitionEnter,
          leave: this.props.transitionLeave,
          appearTimeout: this.props.transitionAppearTimeout,
          enterTimeout: this.props.transitionEnterTimeout,
          leaveTimeout: this.props.transitionLeaveTimeout
        }, t), e)
      }, t.prototype.storeChildRef = function (e, t) {
        var n = this,
          r = "string" != typeof e.ref;
        return (0, u.default)(r, "string refs are not supported on children of ReactCSSTransitionReplace and will be ignored. Please use a callback ref instead: https://facebook.github.io/react/docs/refs-and-the-dom.html#the-ref-callback-attribute"), (0, c.default)(r ? e.ref : null, (function (e) {
          n.childRefs[t] = e
        }))
      }, t.prototype.render = function () {
        var e = this,
          t = this.state,
          n = t.currentKey,
          r = t.currentChild,
          i = t.prevChildren,
          o = t.height,
          l = t.width,
          c = [],
          u = this.props,
          h = u.overflowHidden,
          p = u.transitionName,
          d = u.component,
          f = u.childComponent,
          m = u.notifyLeaving,
          g = (u.transitionAppear, u.transitionEnter, u.transitionLeave, u.changeWidth, u.transitionAppearTimeout, u.transitionEnterTimeout, u.transitionLeaveTimeout, function (e, t) {
            var n = {};
            for (var r in e) t.indexOf(r) >= 0 || Object.prototype.hasOwnProperty.call(e, r) && (n[r] = e[r]);
            return n
          }(u, ["overflowHidden", "transitionName", "component", "childComponent", "notifyLeaving", "transitionAppear", "transitionEnter", "transitionLeave", "changeWidth", "transitionAppearTimeout", "transitionEnterTimeout", "transitionLeaveTimeout"])),
          y = this.shouldEnterCurrent || this.keysToLeave.length || Object.keys(this.transitioningKeys).length;
        if (g.style = s({}, g.style), y && (g.style.position = "relative", h && (g.style.overflow = "hidden")), null !== o) {
          var v = "string" == typeof p ? p + "-height" : p && p.height || "";
          g.className = String(g.className || "") + " " + String(v), g.style.height = o
        }
        null !== l && (g.style.width = l);
        var w = {
          position: "absolute",
          top: 0,
          left: 0,
          right: 0,
          bottom: 0,
          userSelect: "none"
        };
        return Object.keys(i).forEach((function (t) {
          var n = i[t];
          c.push(a.default.createElement(f, {
            key: t,
            style: w
          }, e.wrapChild(m && "string" != typeof n.type ? a.default.cloneElement(n, {
            isLeaving: !0
          }) : n, {
            ref: e.storeChildRef(n, t)
          })))
        })), r && c.push(a.default.createElement(f, {
          key: n,
          style: this.transitioningKeys[n] ? w : y ? {
            position: "relative"
          } : null
        }, this.wrapChild(r, {
          ref: this.storeChildRef(r, n)
        }))), a.default.createElement(d, g, c)
      }, t
    }(a.default.Component), r.displayName = "ReactCSSTransitionReplace", r.defaultProps = {
      transitionAppear: !1,
      transitionEnter: !0,
      transitionLeave: !0,
      overflowHidden: !0,
      changeWidth: !1,
      notifyLeaving: !1,
      component: "div",
      childComponent: "span"
    }, i);
  t.default = g, e.exports = t.default
}, function (e, t, n) {
  "use strict";
  const r = n(15).homedir();
  e.exports = e => {
    if ("string" != typeof e) throw new TypeError("Expected a string, got " + typeof e);
    return r ? e.replace(/^~($|\/|\\)/, r + "$1") : e
  }
}, function (e, t, n) {
  "use strict";
  const r = n(299),
    i = e => {
      if (e < 1) throw new TypeError("Expected `concurrency` to be a number from 1 and up");
      const t = [];
      let n = 0;
      const i = () => {
          n--, t.length > 0 && t.shift()()
        },
        o = (e, t, ...o) => {
          n++;
          const s = r(e, ...o);
          t(s), s.then(i, i)
        },
        s = (r, ...i) => new Promise(s => ((r, i, ...s) => {
          n < e ? o(r, i, ...s) : t.push(o.bind(null, r, i, ...s))
        })(r, s, ...i));
      return Object.defineProperties(s, {
        activeCount: {
          get: () => n
        },
        pendingCount: {
          get: () => t.length
        }
      }), s
    };
  e.exports = i, e.exports.default = i
}, function (e, t, n) {
  "use strict";
  class r {
    constructor(e = {}) {
      if (!(e.maxSize && e.maxSize > 0)) throw new TypeError("`maxSize` must be a number greater than 0");
      this.maxSize = e.maxSize, this.cache = new Map, this.oldCache = new Map, this._size = 0
    }
    _set(e, t) {
      this.cache.set(e, t), this._size++, this._size >= this.maxSize && (this._size = 0, this.oldCache = this.cache, this.cache = new Map)
    }
    get(e) {
      if (this.cache.has(e)) return this.cache.get(e);
      if (this.oldCache.has(e)) {
        const t = this.oldCache.get(e);
        return this._set(e, t), t
      }
    }
    set(e, t) {
      return this.cache.has(e) ? this.cache.set(e, t) : this._set(e, t), this
    }
    has(e) {
      return this.cache.has(e) || this.oldCache.has(e)
    }
    peek(e) {
      return this.cache.has(e) ? this.cache.get(e) : this.oldCache.has(e) ? this.oldCache.get(e) : void 0
    }
    delete(e) {
      const t = this.cache.delete(e);
      return t && this._size--, this.oldCache.delete(e) || t
    }
    clear() {
      this.cache.clear(), this.oldCache.clear(), this._size = 0
    }* keys() {
      for (const [e] of this) yield e
    }* values() {
      for (const [, e] of this) yield e
    }*[Symbol.iterator]() {
      for (const e of this.cache) yield e;
      for (const e of this.oldCache) {
        const [t] = e;
        this.cache.has(t) || (yield e)
      }
    }
    get size() {
      let e = 0;
      for (const t of this.oldCache.keys()) this.cache.has(t) || e++;
      return this._size + e
    }
  }
  e.exports = r, e.exports.default = r
}, function (e, t, n) {
  var r, i, o, s, a;
  /*! Moment Duration Format v2.2.2
   *  https://github.com/jsmreese/moment-duration-format
   *  Date: 2018-02-16
   *
   *  Duration format plugin function for the Moment.js library
   *  http://momentjs.com/
   *
   *  Copyright 2018 John Madhavan-Reese
   *  Released under the MIT license
   */
  s = this, a = function (e) {
    var t = !1,
      n = !1,
      r = !1,
      i = !1,
      o = "escape years months weeks days hours minutes seconds milliseconds general".split(" "),
      s = [{
        type: "seconds",
        targets: [{
          type: "minutes",
          value: 60
        }, {
          type: "hours",
          value: 3600
        }, {
          type: "days",
          value: 86400
        }, {
          type: "weeks",
          value: 604800
        }, {
          type: "months",
          value: 2678400
        }, {
          type: "years",
          value: 31536e3
        }]
      }, {
        type: "minutes",
        targets: [{
          type: "hours",
          value: 60
        }, {
          type: "days",
          value: 1440
        }, {
          type: "weeks",
          value: 10080
        }, {
          type: "months",
          value: 44640
        }, {
          type: "years",
          value: 525600
        }]
      }, {
        type: "hours",
        targets: [{
          type: "days",
          value: 24
        }, {
          type: "weeks",
          value: 168
        }, {
          type: "months",
          value: 744
        }, {
          type: "years",
          value: 8760
        }]
      }, {
        type: "days",
        targets: [{
          type: "weeks",
          value: 7
        }, {
          type: "months",
          value: 31
        }, {
          type: "years",
          value: 365
        }]
      }, {
        type: "months",
        targets: [{
          type: "years",
          value: 12
        }]
      }];

    function a(e, t) {
      return !(t.length > e.length) && -1 !== e.indexOf(t)
    }

    function l(e) {
      for (var t = ""; e;) t += "0", e -= 1;
      return t
    }

    function c(e, t) {
      var n = e + "+" + v(T(t).sort(), (function (e) {
        return e + ":" + t[e]
      })).join(",");
      return c.cache[n] || (c.cache[n] = Intl.NumberFormat(e, t)), c.cache[n]
    }

    function u(e, t, o) {
      var s, a, h, p = t.useToLocaleString,
        d = t.useGrouping,
        f = d && t.grouping.slice(),
        m = t.maximumSignificantDigits,
        g = t.minimumIntegerDigits || 1,
        y = t.fractionDigits || 0,
        v = t.groupingSeparator,
        w = t.decimalSeparator;
      if (p && o) {
        var b, S = {
          minimumIntegerDigits: g,
          useGrouping: d
        };
        return y && (S.maximumFractionDigits = y, S.minimumFractionDigits = y), m && e > 0 && (S.maximumSignificantDigits = m), r ? (i || ((b = x({}, t)).useGrouping = !1, b.decimalSeparator = ".", e = parseFloat(u(e, b), 10)), c(o, S).format(e)) : (n || ((b = x({}, t)).useGrouping = !1, b.decimalSeparator = ".", e = parseFloat(u(e, b), 10)), e.toLocaleString(o, S))
      }
      var C = (m ? e.toPrecision(m + 1) : e.toFixed(y + 1)).split("e");
      h = C[1] || "", a = (C = C[0].split("."))[1] || "";
      var E = (s = C[0] || "").length,
        k = a.length,
        T = E + k,
        R = s + a;
      (m && T === m + 1 || !m && k === y + 1) && ((R = function (e) {
        for (var t = e.split("").reverse(), n = 0, r = !0; r && n < t.length;) n ? "9" === t[n] ? t[n] = "0" : (t[n] = (parseInt(t[n], 10) + 1).toString(), r = !1) : (parseInt(t[n], 10) < 5 && (r = !1), t[n] = "0"), n += 1;
        return r && t.push("1"), t.reverse().join("")
      }(R)).length === T + 1 && (E += 1), k && (R = R.slice(0, -1)), s = R.slice(0, E), a = R.slice(E)), m && (a = a.replace(/0*$/, ""));
      var D = parseInt(h, 10);
      D > 0 ? a.length <= D ? (s += a += l(D - a.length), a = "") : (s += a.slice(0, D), a = a.slice(D)) : D < 0 && (a = l(Math.abs(D) - s.length) + s + a, s = "0"), m || ((a = a.slice(0, y)).length < y && (a += l(y - a.length)), s.length < g && (s = l(g - s.length) + s));
      var _, A = "";
      if (d)
        for (C = s; C.length;) f.length && (_ = f.shift()), A && (A = v + A), A = C.slice(-_) + A, C = C.slice(0, -_);
      else A = s;
      return a && (A = A + w + a), A
    }

    function h(e, t) {
      return e.label.length > t.label.length ? -1 : e.label.length < t.label.length ? 1 : 0
    }

    function p(e, t) {
      var n = [];
      return y(T(t), (function (r) {
        if ("_durationLabels" === r.slice(0, 15)) {
          var i = r.slice(15).toLowerCase();
          y(T(t[r]), (function (o) {
            o.slice(0, 1) === e && n.push({
              type: i,
              key: o,
              label: t[r][o]
            })
          }))
        }
      })), n
    }
    c.cache = {};
    var d = {
      durationLabelsStandard: {
        S: "millisecond",
        SS: "milliseconds",
        s: "second",
        ss: "seconds",
        m: "minute",
        mm: "minutes",
        h: "hour",
        hh: "hours",
        d: "day",
        dd: "days",
        w: "week",
        ww: "weeks",
        M: "month",
        MM: "months",
        y: "year",
        yy: "years"
      },
      durationLabelsShort: {
        S: "msec",
        SS: "msecs",
        s: "sec",
        ss: "secs",
        m: "min",
        mm: "mins",
        h: "hr",
        hh: "hrs",
        d: "dy",
        dd: "dys",
        w: "wk",
        ww: "wks",
        M: "mo",
        MM: "mos",
        y: "yr",
        yy: "yrs"
      },
      durationTimeTemplates: {
        HMS: "h:mm:ss",
        HM: "h:mm",
        MS: "m:ss"
      },
      durationLabelTypes: [{
        type: "standard",
        string: "__"
      }, {
        type: "short",
        string: "_"
      }],
      durationPluralKey: function (e, t, n) {
        return 1 === t && null === n ? e : e + e
      }
    };

    function f(e) {
      return "[object Array]" === Object.prototype.toString.call(e)
    }

    function m(e) {
      return "[object Object]" === Object.prototype.toString.call(e)
    }

    function g(e, t) {
      var n, r = 0,
        i = e && e.length || 0;
      for ("function" != typeof t && (n = t, t = function (e) {
          return e === n
        }); r < i;) {
        if (t(e[r])) return e[r];
        r += 1
      }
    }

    function y(e, t) {
      var n = 0,
        r = e.length;
      if (e && r)
        for (; n < r;) {
          if (!1 === t(e[n], n)) return;
          n += 1
        }
    }

    function v(e, t) {
      var n = 0,
        r = e.length,
        i = [];
      if (!e || !r) return i;
      for (; n < r;) i[n] = t(e[n], n), n += 1;
      return i
    }

    function w(e, t) {
      return v(e, (function (e) {
        return e[t]
      }))
    }

    function b(e) {
      var t = [];
      return y(e, (function (e) {
        e && t.push(e)
      })), t
    }

    function S(e) {
      var t = [];
      return y(e, (function (e) {
        g(t, e) || t.push(e)
      })), t
    }

    function C(e, t) {
      var n = [];
      return y(e, (function (e) {
        y(t, (function (t) {
          e === t && n.push(e)
        }))
      })), S(n)
    }

    function E(e, t) {
      var n = [];
      return y(e, (function (r, i) {
        if (!t(r)) return n = e.slice(i), !1
      })), n
    }

    function k(e, t) {
      return E(e.slice().reverse(), t).reverse()
    }

    function x(e, t) {
      for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n]);
      return e
    }

    function T(e) {
      var t = [];
      for (var n in e) e.hasOwnProperty(n) && t.push(n);
      return t
    }

    function R(e, t) {
      var n = 0,
        r = e.length;
      if (!e || !r) return !1;
      for (; n < r;) {
        if (!0 === t(e[n], n)) return !0;
        n += 1
      }
      return !1
    }

    function D(e) {
      var t = [];
      return y(e, (function (e) {
        t = t.concat(e)
      })), t
    }

    function _(e) {
      return "3.6" === e(3.55, "en", {
        useGrouping: !1,
        minimumIntegerDigits: 1,
        minimumFractionDigits: 1,
        maximumFractionDigits: 1
      })
    }

    function A(e) {
      var t = !0;
      return !!((t = (t = (t = t && "1" === e(1, "en", {
        minimumIntegerDigits: 1
      })) && "01" === e(1, "en", {
        minimumIntegerDigits: 2
      })) && "001" === e(1, "en", {
        minimumIntegerDigits: 3
      })) && (t = (t = (t = (t = t && "100" === e(99.99, "en", {
        maximumFractionDigits: 0,
        minimumFractionDigits: 0
      })) && "100.0" === e(99.99, "en", {
        maximumFractionDigits: 1,
        minimumFractionDigits: 1
      })) && "99.99" === e(99.99, "en", {
        maximumFractionDigits: 2,
        minimumFractionDigits: 2
      })) && "99.990" === e(99.99, "en", {
        maximumFractionDigits: 3,
        minimumFractionDigits: 3
      })) && (t = (t = (t = (t = (t = t && "100" === e(99.99, "en", {
        maximumSignificantDigits: 1
      })) && "100" === e(99.99, "en", {
        maximumSignificantDigits: 2
      })) && "100" === e(99.99, "en", {
        maximumSignificantDigits: 3
      })) && "99.99" === e(99.99, "en", {
        maximumSignificantDigits: 4
      })) && "99.99" === e(99.99, "en", {
        maximumSignificantDigits: 5
      })) && (t = (t = t && "1,000" === e(1e3, "en", {
        useGrouping: !0
      })) && "1000" === e(1e3, "en", {
        useGrouping: !1
      })))
    }

    function M() {
      var e, t = [].slice.call(arguments),
        n = {};
      if (y(t, (function (t, r) {
          if (!r) {
            if (!f(t)) throw "Expected array as the first argument to durationsFormat.";
            e = t
          }
          "string" != typeof t && "function" != typeof t ? "number" != typeof t ? m(t) && x(n, t) : n.precision = t : n.template = t
        })), !e || !e.length) return [];
      n.returnMomentTypes = !0;
      var r = v(e, (function (e) {
          return e.format(n)
        })),
        i = C(o, S(w(D(r), "type"))),
        s = n.largest;
      return s && (i = i.slice(0, s)), n.returnMomentTypes = !1, n.outputTypes = i, v(e, (function (e) {
        return e.format(n)
      }))
    }

    function P() {
      var n = [].slice.call(arguments),
        i = x({}, this.format.defaults),
        l = this.asMilliseconds(),
        c = this.asMonths();
      "function" == typeof this.isValid && !1 === this.isValid() && (l = 0, c = 0);
      var D = l < 0,
        _ = e.duration(Math.abs(l), "milliseconds"),
        A = e.duration(Math.abs(c), "months");
      y(n, (function (e) {
        "string" != typeof e && "function" != typeof e ? "number" != typeof e ? m(e) && x(i, e) : i.precision = e : i.template = e
      }));
      var M = {
          years: "y",
          months: "M",
          weeks: "w",
          days: "d",
          hours: "h",
          minutes: "m",
          seconds: "s",
          milliseconds: "S"
        },
        P = {
          escape: /\[(.+?)\]/,
          years: /\*?[Yy]+/,
          months: /\*?M+/,
          weeks: /\*?[Ww]+/,
          days: /\*?[Dd]+/,
          hours: /\*?[Hh]+/,
          minutes: /\*?m+/,
          seconds: /\*?s+/,
          milliseconds: /\*?S+/,
          general: /.+?/
        };
      i.types = o;
      var I = function (e) {
          return g(o, (function (t) {
            return P[t].test(e)
          }))
        },
        O = new RegExp(v(o, (function (e) {
          return P[e].source
        })).join("|"), "g");
      i.duration = this;
      var L = "function" == typeof i.template ? i.template.apply(i) : i.template,
        N = i.outputTypes,
        F = i.returnMomentTypes,
        B = i.largest,
        H = [];
      N || (f(i.stopTrim) && (i.stopTrim = i.stopTrim.join("")), i.stopTrim && y(i.stopTrim.match(O), (function (e) {
        var t = I(e);
        "escape" !== t && "general" !== t && H.push(t)
      })));
      var z = e.localeData();
      z || (z = {}), y(T(d), (function (e) {
        "function" != typeof d[e] ? z["_" + e] || (z["_" + e] = d[e]) : z[e] || (z[e] = d[e])
      })), y(T(z._durationTimeTemplates), (function (e) {
        L = L.replace("_" + e + "_", z._durationTimeTemplates[e])
      }));
      var U = i.userLocale || e.locale(),
        W = i.useLeftUnits,
        V = i.usePlural,
        j = i.precision,
        G = i.forceLength,
        $ = i.useGrouping,
        q = i.trunc,
        K = i.useSignificantDigits && j > 0,
        Y = K ? i.precision : 0,
        Q = Y,
        Z = i.minValue,
        X = !1,
        J = i.maxValue,
        ee = !1,
        te = i.useToLocaleString,
        ne = i.groupingSeparator,
        re = i.decimalSeparator,
        ie = i.grouping;
      te = te && (t || r);
      var oe = i.trim;
      f(oe) && (oe = oe.join(" ")), null === oe && (B || J || K) && (oe = "all"), null !== oe && !0 !== oe && "left" !== oe && "right" !== oe || (oe = "large"), !1 === oe && (oe = "");
      var se = function (e) {
          return e.test(oe)
        },
        ae = /large/,
        le = /small/,
        ce = /both/,
        ue = /mid/,
        he = /^all|[^sm]all/,
        pe = /final/,
        de = B > 0 || R([ae, ce, he], se),
        fe = R([le, ce, he], se),
        me = R([ue, he], se),
        ge = R([pe, he], se),
        ye = v(L.match(O), (function (e, t) {
          var n = I(e);
          return "*" === e.slice(0, 1) && (e = e.slice(1), "escape" !== n && "general" !== n && H.push(n)), {
            index: t,
            length: e.length,
            text: "",
            token: "escape" === n ? e.replace(P.escape, "$1") : e,
            type: "escape" === n || "general" === n ? null : n
          }
        })),
        ve = {
          index: 0,
          length: 0,
          token: "",
          text: "",
          type: null
        },
        we = [];
      W && ye.reverse(), y(ye, (function (e) {
        if (e.type) return (ve.type || ve.text) && we.push(ve), void(ve = e);
        W ? ve.text = e.token + ve.text : ve.text += e.token
      })), (ve.type || ve.text) && we.push(ve), W && we.reverse();
      var be = C(o, S(b(w(we, "type"))));
      if (!be.length) return w(we, "text").join("");
      be = v(be, (function (e, t) {
        var n, r = t + 1 === be.length,
          o = !t;
        n = "years" === e || "months" === e ? A.as(e) : _.as(e);
        var s = Math.floor(n),
          a = n - s,
          l = g(we, (function (t) {
            return e === t.type
          }));
        return o && J && n > J && (ee = !0), r && Z && Math.abs(i.duration.as(e)) < Z && (X = !0), o && null === G && l.length > 1 && (G = !0), _.subtract(s, e), A.subtract(s, e), {
          rawValue: n,
          wholeValue: s,
          decimalValue: r ? a : 0,
          isSmallest: r,
          isLargest: o,
          type: e,
          tokenLength: l.length
        }
      }));
      var Se = q ? Math.floor : Math.round,
        Ce = function (e, t) {
          var n = Math.pow(10, t);
          return Se(e * n) / n
        },
        Ee = !1,
        ke = !1,
        xe = function (e, t) {
          var n = {
            useGrouping: $,
            groupingSeparator: ne,
            decimalSeparator: re,
            grouping: ie,
            useToLocaleString: te
          };
          return K && (Y <= 0 ? (e.rawValue = 0, e.wholeValue = 0, e.decimalValue = 0) : (n.maximumSignificantDigits = Y, e.significantDigits = Y)), ee && !ke && (e.isLargest ? (e.wholeValue = J, e.decimalValue = 0) : (e.wholeValue = 0, e.decimalValue = 0)), X && !ke && (e.isSmallest ? (e.wholeValue = Z, e.decimalValue = 0) : (e.wholeValue = 0, e.decimalValue = 0)), e.isSmallest || e.significantDigits && e.significantDigits - e.wholeValue.toString().length <= 0 ? j < 0 ? e.value = Ce(e.wholeValue, j) : 0 === j ? e.value = Se(e.wholeValue + e.decimalValue) : K ? (e.value = q ? Ce(e.rawValue, Y - e.wholeValue.toString().length) : e.rawValue, e.wholeValue && (Y -= e.wholeValue.toString().length)) : (n.fractionDigits = j, e.value = q ? e.wholeValue + Ce(e.decimalValue, j) : e.wholeValue + e.decimalValue) : K && e.wholeValue ? (e.value = Math.round(Ce(e.wholeValue, e.significantDigits - e.wholeValue.toString().length)), Y -= e.wholeValue.toString().length) : e.value = e.wholeValue, e.tokenLength > 1 && (G || Ee) && (n.minimumIntegerDigits = e.tokenLength, ke && n.maximumSignificantDigits < e.tokenLength && delete n.maximumSignificantDigits), !Ee && (e.value > 0 || "" === oe || g(H, e.type) || g(N, e.type)) && (Ee = !0), e.formattedValue = u(e.value, n, U), n.useGrouping = !1, n.decimalSeparator = ".", e.formattedValueEn = u(e.value, n, "en"), 2 === e.tokenLength && "milliseconds" === e.type && (e.formattedValueMS = u(e.value, {
            minimumIntegerDigits: 3,
            useGrouping: !1
          }, "en").slice(0, 2)), e
        };
      if ((be = b(be = v(be, xe))).length > 1) {
        var Te = function (e) {
            return g(be, (function (t) {
              return t.type === e
            }))
          },
          Re = function (e) {
            var t = Te(e.type);
            t && y(e.targets, (function (e) {
              var n = Te(e.type);
              n && parseInt(t.formattedValueEn, 10) === e.value && (t.rawValue = 0, t.wholeValue = 0, t.decimalValue = 0, n.rawValue += 1, n.wholeValue += 1, n.decimalValue = 0, n.formattedValueEn = n.wholeValue.toString(), ke = !0)
            }))
          };
        y(s, Re)
      }
      return ke && (Ee = !1, Y = Q, be = b(be = v(be, xe))), !N || ee && !i.trim ? (de && (be = E(be, (function (e) {
        return !e.isSmallest && !e.wholeValue && !g(H, e.type)
      }))), B && be.length && (be = be.slice(0, B)), fe && be.length > 1 && (be = k(be, (function (e) {
        return !e.wholeValue && !g(H, e.type) && !e.isLargest
      }))), me && (be = b(be = v(be, (function (e, t) {
        return t > 0 && t < be.length - 1 && !e.wholeValue ? null : e
      })))), !ge || 1 !== be.length || be[0].wholeValue || !q && be[0].isSmallest && be[0].rawValue < Z || (be = [])) : be = b(be = v(be, (function (e) {
        return g(N, (function (t) {
          return e.type === t
        })) ? e : null
      }))), F ? be : (y(we, (function (e) {
        var t = M[e.type],
          n = g(be, (function (t) {
            return t.type === e.type
          }));
        if (t && n) {
          var r = n.formattedValueEn.split(".");
          r[0] = parseInt(r[0], 10), r[1] ? r[1] = parseFloat("0." + r[1], 10) : r[1] = null;
          var i = z.durationPluralKey(t, r[0], r[1]),
            o = p(t, z),
            s = !1,
            l = {};
          y(z._durationLabelTypes, (function (t) {
            var n = g(o, (function (e) {
              return e.type === t.type && e.key === i
            }));
            n && (l[n.type] = n.label, a(e.text, t.string) && (e.text = e.text.replace(t.string, n.label), s = !0))
          })), V && !s && (o.sort(h), y(o, (function (t) {
            return l[t.type] === t.label ? !a(e.text, t.label) && void 0 : a(e.text, t.label) ? (e.text = e.text.replace(t.label, l[t.type]), !1) : void 0
          })))
        }
      })), (we = v(we, (function (e) {
        if (!e.type) return e.text;
        var t = g(be, (function (t) {
          return t.type === e.type
        }));
        if (!t) return "";
        var n = "";
        return W && (n += e.text), (D && ee || !D && X) && (n += "< ", ee = !1, X = !1), (D && X || !D && ee) && (n += "> ", ee = !1, X = !1), D && (t.value > 0 || "" === oe || g(H, t.type) || g(N, t.type)) && (n += "-", D = !1), "milliseconds" === e.type && t.formattedValueMS ? n += t.formattedValueMS : n += t.formattedValue, W || (n += e.text), n
      }))).join("").replace(/(,| |:|\.)*$/, "").replace(/^(,| |:|\.)*/, ""))
    }

    function I() {
      var e = this.duration,
        t = function (t) {
          return e._data[t]
        },
        n = g(this.types, t),
        r = function (e, t) {
          for (var n = e.length; n -= 1;)
            if (t(e[n])) return e[n]
        }(this.types, t);
      switch (n) {
        case "milliseconds":
          return "S __";
        case "seconds":
        case "minutes":
          return "*_MS_";
        case "hours":
          return "_HMS_";
        case "days":
          if (n === r) return "d __";
        case "weeks":
          return n === r ? "w __" : (null === this.trim && (this.trim = "both"), "w __, d __, h __");
        case "months":
          if (n === r) return "M __";
        case "years":
          return n === r ? "y __" : (null === this.trim && (this.trim = "both"), "y __, M __, d __");
        default:
          return null === this.trim && (this.trim = "both"), "y __, d __, h __, m __, s __"
      }
    }

    function O(e) {
      if (!e) throw "Moment Duration Format init cannot find moment instance.";
      e.duration.format = M, e.duration.fn.format = P, e.duration.fn.format.defaults = {
        trim: null,
        stopTrim: null,
        largest: null,
        maxValue: null,
        minValue: null,
        precision: 0,
        trunc: !1,
        forceLength: null,
        userLocale: null,
        usePlural: !0,
        useLeftUnits: !1,
        useGrouping: !0,
        useSignificantDigits: !1,
        template: I,
        useToLocaleString: !0,
        groupingSeparator: ",",
        decimalSeparator: ".",
        grouping: [3]
      }, e.updateLocale("en", d)
    }
    var L = function (e, t, n) {
      return e.toLocaleString(t, n)
    };
    t = function () {
      try {
        (0).toLocaleString("i")
      } catch (e) {
        return "RangeError" === e.name
      }
      return !1
    }() && A(L), n = t && _(L);
    var N = function (e, t, n) {
      if ("undefined" != typeof window && window && window.Intl && window.Intl.NumberFormat) return window.Intl.NumberFormat(t, n).format(e)
    };
    return r = A(N), i = r && _(N), O(e), O
  }, i = [n(12)], void 0 === (o = "function" == typeof (r = a) ? r.apply(t, i) : r) || (e.exports = o), s && (s.momentDurationFormatSetup = s.moment ? a(s.moment) : a)
}, , function (e, t, n) {
  t.SourceMapGenerator = n(85).SourceMapGenerator, t.SourceMapConsumer = n(143).SourceMapConsumer, t.SourceNode = n(146).SourceNode
}, function (e, t) {
  var n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
  t.encode = function (e) {
    if (0 <= e && e < n.length) return n[e];
    throw new TypeError("Must be between 0 and 63: " + e)
  }, t.decode = function (e) {
    return 65 <= e && e <= 90 ? e - 65 : 97 <= e && e <= 122 ? e - 97 + 26 : 48 <= e && e <= 57 ? e - 48 + 52 : 43 == e ? 62 : 47 == e ? 63 : -1
  }
}, function (e, t, n) {
  var r = n(35);

  function i() {
    this._array = [], this._sorted = !0, this._last = {
      generatedLine: -1,
      generatedColumn: 0
    }
  }
  i.prototype.unsortedForEach = function (e, t) {
    this._array.forEach(e, t)
  }, i.prototype.add = function (e) {
    var t, n, i, o, s, a;
    t = this._last, n = e, i = t.generatedLine, o = n.generatedLine, s = t.generatedColumn, a = n.generatedColumn, o > i || o == i && a >= s || r.compareByGeneratedPositionsInflated(t, n) <= 0 ? (this._last = e, this._array.push(e)) : (this._sorted = !1, this._array.push(e))
  }, i.prototype.toArray = function () {
    return this._sorted || (this._array.sort(r.compareByGeneratedPositionsInflated), this._sorted = !0), this._array
  }, t.MappingList = i
}, function (e, t, n) {
  var r = n(35),
    i = n(144),
    o = n(87).ArraySet,
    s = n(86),
    a = n(145).quickSort;

  function l(e) {
    var t = e;
    return "string" == typeof e && (t = JSON.parse(e.replace(/^\)\]\}'/, ""))), null != t.sections ? new h(t) : new c(t)
  }

  function c(e) {
    var t = e;
    "string" == typeof e && (t = JSON.parse(e.replace(/^\)\]\}'/, "")));
    var n = r.getArg(t, "version"),
      i = r.getArg(t, "sources"),
      s = r.getArg(t, "names", []),
      a = r.getArg(t, "sourceRoot", null),
      l = r.getArg(t, "sourcesContent", null),
      c = r.getArg(t, "mappings"),
      u = r.getArg(t, "file", null);
    if (n != this._version) throw new Error("Unsupported version: " + n);
    i = i.map(String).map(r.normalize).map((function (e) {
      return a && r.isAbsolute(a) && r.isAbsolute(e) ? r.relative(a, e) : e
    })), this._names = o.fromArray(s.map(String), !0), this._sources = o.fromArray(i, !0), this.sourceRoot = a, this.sourcesContent = l, this._mappings = c, this.file = u
  }

  function u() {
    this.generatedLine = 0, this.generatedColumn = 0, this.source = null, this.originalLine = null, this.originalColumn = null, this.name = null
  }

  function h(e) {
    var t = e;
    "string" == typeof e && (t = JSON.parse(e.replace(/^\)\]\}'/, "")));
    var n = r.getArg(t, "version"),
      i = r.getArg(t, "sections");
    if (n != this._version) throw new Error("Unsupported version: " + n);
    this._sources = new o, this._names = new o;
    var s = {
      line: -1,
      column: 0
    };
    this._sections = i.map((function (e) {
      if (e.url) throw new Error("Support for url field in sections not implemented.");
      var t = r.getArg(e, "offset"),
        n = r.getArg(t, "line"),
        i = r.getArg(t, "column");
      if (n < s.line || n === s.line && i < s.column) throw new Error("Section offsets must be ordered and non-overlapping.");
      return s = t, {
        generatedOffset: {
          generatedLine: n + 1,
          generatedColumn: i + 1
        },
        consumer: new l(r.getArg(e, "map"))
      }
    }))
  }
  l.fromSourceMap = function (e) {
    return c.fromSourceMap(e)
  }, l.prototype._version = 3, l.prototype.__generatedMappings = null, Object.defineProperty(l.prototype, "_generatedMappings", {
    get: function () {
      return this.__generatedMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__generatedMappings
    }
  }), l.prototype.__originalMappings = null, Object.defineProperty(l.prototype, "_originalMappings", {
    get: function () {
      return this.__originalMappings || this._parseMappings(this._mappings, this.sourceRoot), this.__originalMappings
    }
  }), l.prototype._charIsMappingSeparator = function (e, t) {
    var n = e.charAt(t);
    return ";" === n || "," === n
  }, l.prototype._parseMappings = function (e, t) {
    throw new Error("Subclasses must implement _parseMappings")
  }, l.GENERATED_ORDER = 1, l.ORIGINAL_ORDER = 2, l.GREATEST_LOWER_BOUND = 1, l.LEAST_UPPER_BOUND = 2, l.prototype.eachMapping = function (e, t, n) {
    var i, o = t || null;
    switch (n || l.GENERATED_ORDER) {
      case l.GENERATED_ORDER:
        i = this._generatedMappings;
        break;
      case l.ORIGINAL_ORDER:
        i = this._originalMappings;
        break;
      default:
        throw new Error("Unknown order of iteration.")
    }
    var s = this.sourceRoot;
    i.map((function (e) {
      var t = null === e.source ? null : this._sources.at(e.source);
      return null != t && null != s && (t = r.join(s, t)), {
        source: t,
        generatedLine: e.generatedLine,
        generatedColumn: e.generatedColumn,
        originalLine: e.originalLine,
        originalColumn: e.originalColumn,
        name: null === e.name ? null : this._names.at(e.name)
      }
    }), this).forEach(e, o)
  }, l.prototype.allGeneratedPositionsFor = function (e) {
    var t = r.getArg(e, "line"),
      n = {
        source: r.getArg(e, "source"),
        originalLine: t,
        originalColumn: r.getArg(e, "column", 0)
      };
    if (null != this.sourceRoot && (n.source = r.relative(this.sourceRoot, n.source)), !this._sources.has(n.source)) return [];
    n.source = this._sources.indexOf(n.source);
    var o = [],
      s = this._findMapping(n, this._originalMappings, "originalLine", "originalColumn", r.compareByOriginalPositions, i.LEAST_UPPER_BOUND);
    if (s >= 0) {
      var a = this._originalMappings[s];
      if (void 0 === e.column)
        for (var l = a.originalLine; a && a.originalLine === l;) o.push({
          line: r.getArg(a, "generatedLine", null),
          column: r.getArg(a, "generatedColumn", null),
          lastColumn: r.getArg(a, "lastGeneratedColumn", null)
        }), a = this._originalMappings[++s];
      else
        for (var c = a.originalColumn; a && a.originalLine === t && a.originalColumn == c;) o.push({
          line: r.getArg(a, "generatedLine", null),
          column: r.getArg(a, "generatedColumn", null),
          lastColumn: r.getArg(a, "lastGeneratedColumn", null)
        }), a = this._originalMappings[++s]
    }
    return o
  }, t.SourceMapConsumer = l, c.prototype = Object.create(l.prototype), c.prototype.consumer = l, c.fromSourceMap = function (e) {
    var t = Object.create(c.prototype),
      n = t._names = o.fromArray(e._names.toArray(), !0),
      i = t._sources = o.fromArray(e._sources.toArray(), !0);
    t.sourceRoot = e._sourceRoot, t.sourcesContent = e._generateSourcesContent(t._sources.toArray(), t.sourceRoot), t.file = e._file;
    for (var s = e._mappings.toArray().slice(), l = t.__generatedMappings = [], h = t.__originalMappings = [], p = 0, d = s.length; p < d; p++) {
      var f = s[p],
        m = new u;
      m.generatedLine = f.generatedLine, m.generatedColumn = f.generatedColumn, f.source && (m.source = i.indexOf(f.source), m.originalLine = f.originalLine, m.originalColumn = f.originalColumn, f.name && (m.name = n.indexOf(f.name)), h.push(m)), l.push(m)
    }
    return a(t.__originalMappings, r.compareByOriginalPositions), t
  }, c.prototype._version = 3, Object.defineProperty(c.prototype, "sources", {
    get: function () {
      return this._sources.toArray().map((function (e) {
        return null != this.sourceRoot ? r.join(this.sourceRoot, e) : e
      }), this)
    }
  }), c.prototype._parseMappings = function (e, t) {
    for (var n, i, o, l, c, h = 1, p = 0, d = 0, f = 0, m = 0, g = 0, y = e.length, v = 0, w = {}, b = {}, S = [], C = []; v < y;)
      if (";" === e.charAt(v)) h++, v++, p = 0;
      else if ("," === e.charAt(v)) v++;
    else {
      for ((n = new u).generatedLine = h, l = v; l < y && !this._charIsMappingSeparator(e, l); l++);
      if (o = w[i = e.slice(v, l)]) v += i.length;
      else {
        for (o = []; v < l;) s.decode(e, v, b), c = b.value, v = b.rest, o.push(c);
        if (2 === o.length) throw new Error("Found a source, but no line and column");
        if (3 === o.length) throw new Error("Found a source and line, but no column");
        w[i] = o
      }
      n.generatedColumn = p + o[0], p = n.generatedColumn, o.length > 1 && (n.source = m + o[1], m += o[1], n.originalLine = d + o[2], d = n.originalLine, n.originalLine += 1, n.originalColumn = f + o[3], f = n.originalColumn, o.length > 4 && (n.name = g + o[4], g += o[4])), C.push(n), "number" == typeof n.originalLine && S.push(n)
    }
    a(C, r.compareByGeneratedPositionsDeflated), this.__generatedMappings = C, a(S, r.compareByOriginalPositions), this.__originalMappings = S
  }, c.prototype._findMapping = function (e, t, n, r, o, s) {
    if (e[n] <= 0) throw new TypeError("Line must be greater than or equal to 1, got " + e[n]);
    if (e[r] < 0) throw new TypeError("Column must be greater than or equal to 0, got " + e[r]);
    return i.search(e, t, o, s)
  }, c.prototype.computeColumnSpans = function () {
    for (var e = 0; e < this._generatedMappings.length; ++e) {
      var t = this._generatedMappings[e];
      if (e + 1 < this._generatedMappings.length) {
        var n = this._generatedMappings[e + 1];
        if (t.generatedLine === n.generatedLine) {
          t.lastGeneratedColumn = n.generatedColumn - 1;
          continue
        }
      }
      t.lastGeneratedColumn = 1 / 0
    }
  }, c.prototype.originalPositionFor = function (e) {
    var t = {
        generatedLine: r.getArg(e, "line"),
        generatedColumn: r.getArg(e, "column")
      },
      n = this._findMapping(t, this._generatedMappings, "generatedLine", "generatedColumn", r.compareByGeneratedPositionsDeflated, r.getArg(e, "bias", l.GREATEST_LOWER_BOUND));
    if (n >= 0) {
      var i = this._generatedMappings[n];
      if (i.generatedLine === t.generatedLine) {
        var o = r.getArg(i, "source", null);
        null !== o && (o = this._sources.at(o), null != this.sourceRoot && (o = r.join(this.sourceRoot, o)));
        var s = r.getArg(i, "name", null);
        return null !== s && (s = this._names.at(s)), {
          source: o,
          line: r.getArg(i, "originalLine", null),
          column: r.getArg(i, "originalColumn", null),
          name: s
        }
      }
    }
    return {
      source: null,
      line: null,
      column: null,
      name: null
    }
  }, c.prototype.hasContentsOfAllSources = function () {
    return !!this.sourcesContent && (this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some((function (e) {
      return null == e
    })))
  }, c.prototype.sourceContentFor = function (e, t) {
    if (!this.sourcesContent) return null;
    if (null != this.sourceRoot && (e = r.relative(this.sourceRoot, e)), this._sources.has(e)) return this.sourcesContent[this._sources.indexOf(e)];
    var n;
    if (null != this.sourceRoot && (n = r.urlParse(this.sourceRoot))) {
      var i = e.replace(/^file:\/\//, "");
      if ("file" == n.scheme && this._sources.has(i)) return this.sourcesContent[this._sources.indexOf(i)];
      if ((!n.path || "/" == n.path) && this._sources.has("/" + e)) return this.sourcesContent[this._sources.indexOf("/" + e)]
    }
    if (t) return null;
    throw new Error('"' + e + '" is not in the SourceMap.')
  }, c.prototype.generatedPositionFor = function (e) {
    var t = r.getArg(e, "source");
    if (null != this.sourceRoot && (t = r.relative(this.sourceRoot, t)), !this._sources.has(t)) return {
      line: null,
      column: null,
      lastColumn: null
    };
    var n = {
        source: t = this._sources.indexOf(t),
        originalLine: r.getArg(e, "line"),
        originalColumn: r.getArg(e, "column")
      },
      i = this._findMapping(n, this._originalMappings, "originalLine", "originalColumn", r.compareByOriginalPositions, r.getArg(e, "bias", l.GREATEST_LOWER_BOUND));
    if (i >= 0) {
      var o = this._originalMappings[i];
      if (o.source === n.source) return {
        line: r.getArg(o, "generatedLine", null),
        column: r.getArg(o, "generatedColumn", null),
        lastColumn: r.getArg(o, "lastGeneratedColumn", null)
      }
    }
    return {
      line: null,
      column: null,
      lastColumn: null
    }
  }, t.BasicSourceMapConsumer = c, h.prototype = Object.create(l.prototype), h.prototype.constructor = l, h.prototype._version = 3, Object.defineProperty(h.prototype, "sources", {
    get: function () {
      for (var e = [], t = 0; t < this._sections.length; t++)
        for (var n = 0; n < this._sections[t].consumer.sources.length; n++) e.push(this._sections[t].consumer.sources[n]);
      return e
    }
  }), h.prototype.originalPositionFor = function (e) {
    var t = {
        generatedLine: r.getArg(e, "line"),
        generatedColumn: r.getArg(e, "column")
      },
      n = i.search(t, this._sections, (function (e, t) {
        var n = e.generatedLine - t.generatedOffset.generatedLine;
        return n || e.generatedColumn - t.generatedOffset.generatedColumn
      })),
      o = this._sections[n];
    return o ? o.consumer.originalPositionFor({
      line: t.generatedLine - (o.generatedOffset.generatedLine - 1),
      column: t.generatedColumn - (o.generatedOffset.generatedLine === t.generatedLine ? o.generatedOffset.generatedColumn - 1 : 0),
      bias: e.bias
    }) : {
      source: null,
      line: null,
      column: null,
      name: null
    }
  }, h.prototype.hasContentsOfAllSources = function () {
    return this._sections.every((function (e) {
      return e.consumer.hasContentsOfAllSources()
    }))
  }, h.prototype.sourceContentFor = function (e, t) {
    for (var n = 0; n < this._sections.length; n++) {
      var r = this._sections[n].consumer.sourceContentFor(e, !0);
      if (r) return r
    }
    if (t) return null;
    throw new Error('"' + e + '" is not in the SourceMap.')
  }, h.prototype.generatedPositionFor = function (e) {
    for (var t = 0; t < this._sections.length; t++) {
      var n = this._sections[t];
      if (-1 !== n.consumer.sources.indexOf(r.getArg(e, "source"))) {
        var i = n.consumer.generatedPositionFor(e);
        if (i) return {
          line: i.line + (n.generatedOffset.generatedLine - 1),
          column: i.column + (n.generatedOffset.generatedLine === i.line ? n.generatedOffset.generatedColumn - 1 : 0)
        }
      }
    }
    return {
      line: null,
      column: null
    }
  }, h.prototype._parseMappings = function (e, t) {
    this.__generatedMappings = [], this.__originalMappings = [];
    for (var n = 0; n < this._sections.length; n++)
      for (var i = this._sections[n], o = i.consumer._generatedMappings, s = 0; s < o.length; s++) {
        var l = o[s],
          c = i.consumer._sources.at(l.source);
        null !== i.consumer.sourceRoot && (c = r.join(i.consumer.sourceRoot, c)), this._sources.add(c), c = this._sources.indexOf(c);
        var u = i.consumer._names.at(l.name);
        this._names.add(u), u = this._names.indexOf(u);
        var h = {
          source: c,
          generatedLine: l.generatedLine + (i.generatedOffset.generatedLine - 1),
          generatedColumn: l.generatedColumn + (i.generatedOffset.generatedLine === l.generatedLine ? i.generatedOffset.generatedColumn - 1 : 0),
          originalLine: l.originalLine,
          originalColumn: l.originalColumn,
          name: u
        };
        this.__generatedMappings.push(h), "number" == typeof h.originalLine && this.__originalMappings.push(h)
      }
    a(this.__generatedMappings, r.compareByGeneratedPositionsDeflated), a(this.__originalMappings, r.compareByOriginalPositions)
  }, t.IndexedSourceMapConsumer = h
}, function (e, t) {
  t.GREATEST_LOWER_BOUND = 1, t.LEAST_UPPER_BOUND = 2, t.search = function (e, n, r, i) {
    if (0 === n.length) return -1;
    var o = function e(n, r, i, o, s, a) {
      var l = Math.floor((r - n) / 2) + n,
        c = s(i, o[l], !0);
      return 0 === c ? l : c > 0 ? r - l > 1 ? e(l, r, i, o, s, a) : a == t.LEAST_UPPER_BOUND ? r < o.length ? r : -1 : l : l - n > 1 ? e(n, l, i, o, s, a) : a == t.LEAST_UPPER_BOUND ? l : n < 0 ? -1 : n
    }(-1, n.length, e, n, r, i || t.GREATEST_LOWER_BOUND);
    if (o < 0) return -1;
    for (; o - 1 >= 0 && 0 === r(n[o], n[o - 1], !0);) --o;
    return o
  }
}, function (e, t) {
  function n(e, t, n) {
    var r = e[t];
    e[t] = e[n], e[n] = r
  }

  function r(e, t, i, o) {
    if (i < o) {
      var s = i - 1;
      n(e, (u = i, h = o, Math.round(u + Math.random() * (h - u))), o);
      for (var a = e[o], l = i; l < o; l++) t(e[l], a) <= 0 && n(e, s += 1, l);
      n(e, s + 1, l);
      var c = s + 1;
      r(e, t, i, c - 1), r(e, t, c + 1, o)
    }
    var u, h
  }
  t.quickSort = function (e, t) {
    r(e, t, 0, e.length - 1)
  }
}, function (e, t, n) {
  var r = n(85).SourceMapGenerator,
    i = n(35),
    o = /(\r?\n)/,
    s = "$$$isSourceNode$$$";

  function a(e, t, n, r, i) {
    this.children = [], this.sourceContents = {}, this.line = null == e ? null : e, this.column = null == t ? null : t, this.source = null == n ? null : n, this.name = null == i ? null : i, this[s] = !0, null != r && this.add(r)
  }
  a.fromStringWithSourceMap = function (e, t, n) {
    var r = new a,
      s = e.split(o),
      l = 0,
      c = function () {
        return e() + (e() || "");

        function e() {
          return l < s.length ? s[l++] : void 0
        }
      },
      u = 1,
      h = 0,
      p = null;
    return t.eachMapping((function (e) {
      if (null !== p) {
        if (!(u < e.generatedLine)) {
          var t = (n = s[l]).substr(0, e.generatedColumn - h);
          return s[l] = n.substr(e.generatedColumn - h), h = e.generatedColumn, d(p, t), void(p = e)
        }
        d(p, c()), u++, h = 0
      }
      for (; u < e.generatedLine;) r.add(c()), u++;
      if (h < e.generatedColumn) {
        var n = s[l];
        r.add(n.substr(0, e.generatedColumn)), s[l] = n.substr(e.generatedColumn), h = e.generatedColumn
      }
      p = e
    }), this), l < s.length && (p && d(p, c()), r.add(s.splice(l).join(""))), t.sources.forEach((function (e) {
      var o = t.sourceContentFor(e);
      null != o && (null != n && (e = i.join(n, e)), r.setSourceContent(e, o))
    })), r;

    function d(e, t) {
      if (null === e || void 0 === e.source) r.add(t);
      else {
        var o = n ? i.join(n, e.source) : e.source;
        r.add(new a(e.originalLine, e.originalColumn, o, t, e.name))
      }
    }
  }, a.prototype.add = function (e) {
    if (Array.isArray(e)) e.forEach((function (e) {
      this.add(e)
    }), this);
    else {
      if (!e[s] && "string" != typeof e) throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + e);
      e && this.children.push(e)
    }
    return this
  }, a.prototype.prepend = function (e) {
    if (Array.isArray(e))
      for (var t = e.length - 1; t >= 0; t--) this.prepend(e[t]);
    else {
      if (!e[s] && "string" != typeof e) throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + e);
      this.children.unshift(e)
    }
    return this
  }, a.prototype.walk = function (e) {
    for (var t, n = 0, r = this.children.length; n < r; n++)(t = this.children[n])[s] ? t.walk(e) : "" !== t && e(t, {
      source: this.source,
      line: this.line,
      column: this.column,
      name: this.name
    })
  }, a.prototype.join = function (e) {
    var t, n, r = this.children.length;
    if (r > 0) {
      for (t = [], n = 0; n < r - 1; n++) t.push(this.children[n]), t.push(e);
      t.push(this.children[n]), this.children = t
    }
    return this
  }, a.prototype.replaceRight = function (e, t) {
    var n = this.children[this.children.length - 1];
    return n[s] ? n.replaceRight(e, t) : "string" == typeof n ? this.children[this.children.length - 1] = n.replace(e, t) : this.children.push("".replace(e, t)), this
  }, a.prototype.setSourceContent = function (e, t) {
    this.sourceContents[i.toSetString(e)] = t
  }, a.prototype.walkSourceContents = function (e) {
    for (var t = 0, n = this.children.length; t < n; t++) this.children[t][s] && this.children[t].walkSourceContents(e);
    var r = Object.keys(this.sourceContents);
    for (t = 0, n = r.length; t < n; t++) e(i.fromSetString(r[t]), this.sourceContents[r[t]])
  }, a.prototype.toString = function () {
    var e = "";
    return this.walk((function (t) {
      e += t
    })), e
  }, a.prototype.toStringWithSourceMap = function (e) {
    var t = {
        code: "",
        line: 1,
        column: 0
      },
      n = new r(e),
      i = !1,
      o = null,
      s = null,
      a = null,
      l = null;
    return this.walk((function (e, r) {
      t.code += e, null !== r.source && null !== r.line && null !== r.column ? (o === r.source && s === r.line && a === r.column && l === r.name || n.addMapping({
        source: r.source,
        original: {
          line: r.line,
          column: r.column
        },
        generated: {
          line: t.line,
          column: t.column
        },
        name: r.name
      }), o = r.source, s = r.line, a = r.column, l = r.name, i = !0) : i && (n.addMapping({
        generated: {
          line: t.line,
          column: t.column
        }
      }), o = null, i = !1);
      for (var c = 0, u = e.length; c < u; c++) 10 === e.charCodeAt(c) ? (t.line++, t.column = 0, c + 1 === u ? (o = null, i = !1) : i && n.addMapping({
        source: r.source,
        original: {
          line: r.line,
          column: r.column
        },
        generated: {
          line: t.line,
          column: t.column
        },
        name: r.name
      })) : t.column++
    })), this.walkSourceContents((function (e, t) {
      n.setSourceContent(e, t)
    })), {
      code: t.code,
      map: n
    }
  }, t.SourceNode = a
}, function (e, t) {
  e.exports = require("module")
}, function (e, t, n) {
  "use strict";
  /** @license React v16.8.4
   * react.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var r = n(59),
    i = "function" == typeof Symbol && Symbol.for,
    o = i ? Symbol.for("react.element") : 60103,
    s = i ? Symbol.for("react.portal") : 60106,
    a = i ? Symbol.for("react.fragment") : 60107,
    l = i ? Symbol.for("react.strict_mode") : 60108,
    c = i ? Symbol.for("react.profiler") : 60114,
    u = i ? Symbol.for("react.provider") : 60109,
    h = i ? Symbol.for("react.context") : 60110,
    p = i ? Symbol.for("react.concurrent_mode") : 60111,
    d = i ? Symbol.for("react.forward_ref") : 60112,
    f = i ? Symbol.for("react.suspense") : 60113,
    m = i ? Symbol.for("react.memo") : 60115,
    g = i ? Symbol.for("react.lazy") : 60116,
    y = "function" == typeof Symbol && Symbol.iterator;

  function v(e, t, n, r, i, o, s, a) {
    if (!e) {
      if (e = void 0, void 0 === t) e = Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var l = [n, r, i, o, s, a],
          c = 0;
        (e = Error(t.replace(/%s/g, (function () {
          return l[c++]
        })))).name = "Invariant Violation"
      }
      throw e.framesToPop = 1, e
    }
  }

  function w(e) {
    for (var t = arguments.length - 1, n = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, r = 0; r < t; r++) n += "&args[]=" + encodeURIComponent(arguments[r + 1]);
    v(!1, "Minified React error #" + e + "; visit %s for the full message or use the non-minified dev environment for full errors and additional helpful warnings. ", n)
  }
  var b = {
      isMounted: function () {
        return !1
      },
      enqueueForceUpdate: function () {},
      enqueueReplaceState: function () {},
      enqueueSetState: function () {}
    },
    S = {};

  function C(e, t, n) {
    this.props = e, this.context = t, this.refs = S, this.updater = n || b
  }

  function E() {}

  function k(e, t, n) {
    this.props = e, this.context = t, this.refs = S, this.updater = n || b
  }
  C.prototype.isReactComponent = {}, C.prototype.setState = function (e, t) {
    "object" != typeof e && "function" != typeof e && null != e && w("85"), this.updater.enqueueSetState(this, e, t, "setState")
  }, C.prototype.forceUpdate = function (e) {
    this.updater.enqueueForceUpdate(this, e, "forceUpdate")
  }, E.prototype = C.prototype;
  var x = k.prototype = new E;
  x.constructor = k, r(x, C.prototype), x.isPureReactComponent = !0;
  var T = {
      current: null
    },
    R = {
      current: null
    },
    D = Object.prototype.hasOwnProperty,
    _ = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    };

  function A(e, t, n) {
    var r = void 0,
      i = {},
      s = null,
      a = null;
    if (null != t)
      for (r in void 0 !== t.ref && (a = t.ref), void 0 !== t.key && (s = "" + t.key), t) D.call(t, r) && !_.hasOwnProperty(r) && (i[r] = t[r]);
    var l = arguments.length - 2;
    if (1 === l) i.children = n;
    else if (1 < l) {
      for (var c = Array(l), u = 0; u < l; u++) c[u] = arguments[u + 2];
      i.children = c
    }
    if (e && e.defaultProps)
      for (r in l = e.defaultProps) void 0 === i[r] && (i[r] = l[r]);
    return {
      $$typeof: o,
      type: e,
      key: s,
      ref: a,
      props: i,
      _owner: R.current
    }
  }

  function M(e) {
    return "object" == typeof e && null !== e && e.$$typeof === o
  }
  var P = /\/+/g,
    I = [];

  function O(e, t, n, r) {
    if (I.length) {
      var i = I.pop();
      return i.result = e, i.keyPrefix = t, i.func = n, i.context = r, i.count = 0, i
    }
    return {
      result: e,
      keyPrefix: t,
      func: n,
      context: r,
      count: 0
    }
  }

  function L(e) {
    e.result = null, e.keyPrefix = null, e.func = null, e.context = null, e.count = 0, 10 > I.length && I.push(e)
  }

  function N(e, t, n) {
    return null == e ? 0 : function e(t, n, r, i) {
      var a = typeof t;
      "undefined" !== a && "boolean" !== a || (t = null);
      var l = !1;
      if (null === t) l = !0;
      else switch (a) {
        case "string":
        case "number":
          l = !0;
          break;
        case "object":
          switch (t.$$typeof) {
            case o:
            case s:
              l = !0
          }
      }
      if (l) return r(i, t, "" === n ? "." + F(t, 0) : n), 1;
      if (l = 0, n = "" === n ? "." : n + ":", Array.isArray(t))
        for (var c = 0; c < t.length; c++) {
          var u = n + F(a = t[c], c);
          l += e(a, u, r, i)
        } else if (null === t || "object" != typeof t ? u = null : u = "function" == typeof (u = y && t[y] || t["@@iterator"]) ? u : null, "function" == typeof u)
          for (t = u.call(t), c = 0; !(a = t.next()).done;) l += e(a = a.value, u = n + F(a, c++), r, i);
        else "object" === a && w("31", "[object Object]" === (r = "" + t) ? "object with keys {" + Object.keys(t).join(", ") + "}" : r, "");
      return l
    }(e, "", t, n)
  }

  function F(e, t) {
    return "object" == typeof e && null !== e && null != e.key ? function (e) {
      var t = {
        "=": "=0",
        ":": "=2"
      };
      return "$" + ("" + e).replace(/[=:]/g, (function (e) {
        return t[e]
      }))
    }(e.key) : t.toString(36)
  }

  function B(e, t) {
    e.func.call(e.context, t, e.count++)
  }

  function H(e, t, n) {
    var r = e.result,
      i = e.keyPrefix;
    e = e.func.call(e.context, t, e.count++), Array.isArray(e) ? z(e, r, n, (function (e) {
      return e
    })) : null != e && (M(e) && (e = function (e, t) {
      return {
        $$typeof: o,
        type: e.type,
        key: t,
        ref: e.ref,
        props: e.props,
        _owner: e._owner
      }
    }(e, i + (!e.key || t && t.key === e.key ? "" : ("" + e.key).replace(P, "$&/") + "/") + n)), r.push(e))
  }

  function z(e, t, n, r, i) {
    var o = "";
    null != n && (o = ("" + n).replace(P, "$&/") + "/"), N(e, H, t = O(t, o, r, i)), L(t)
  }

  function U() {
    var e = T.current;
    return null === e && w("307"), e
  }
  var W = {
      Children: {
        map: function (e, t, n) {
          if (null == e) return e;
          var r = [];
          return z(e, r, null, t, n), r
        },
        forEach: function (e, t, n) {
          if (null == e) return e;
          N(e, B, t = O(null, null, t, n)), L(t)
        },
        count: function (e) {
          return N(e, (function () {
            return null
          }), null)
        },
        toArray: function (e) {
          var t = [];
          return z(e, t, null, (function (e) {
            return e
          })), t
        },
        only: function (e) {
          return M(e) || w("143"), e
        }
      },
      createRef: function () {
        return {
          current: null
        }
      },
      Component: C,
      PureComponent: k,
      createContext: function (e, t) {
        return void 0 === t && (t = null), (e = {
          $$typeof: h,
          _calculateChangedBits: t,
          _currentValue: e,
          _currentValue2: e,
          _threadCount: 0,
          Provider: null,
          Consumer: null
        }).Provider = {
          $$typeof: u,
          _context: e
        }, e.Consumer = e
      },
      forwardRef: function (e) {
        return {
          $$typeof: d,
          render: e
        }
      },
      lazy: function (e) {
        return {
          $$typeof: g,
          _ctor: e,
          _status: -1,
          _result: null
        }
      },
      memo: function (e, t) {
        return {
          $$typeof: m,
          type: e,
          compare: void 0 === t ? null : t
        }
      },
      useCallback: function (e, t) {
        return U().useCallback(e, t)
      },
      useContext: function (e, t) {
        return U().useContext(e, t)
      },
      useEffect: function (e, t) {
        return U().useEffect(e, t)
      },
      useImperativeHandle: function (e, t, n) {
        return U().useImperativeHandle(e, t, n)
      },
      useDebugValue: function () {},
      useLayoutEffect: function (e, t) {
        return U().useLayoutEffect(e, t)
      },
      useMemo: function (e, t) {
        return U().useMemo(e, t)
      },
      useReducer: function (e, t, n) {
        return U().useReducer(e, t, n)
      },
      useRef: function (e) {
        return U().useRef(e)
      },
      useState: function (e) {
        return U().useState(e)
      },
      Fragment: a,
      StrictMode: l,
      Suspense: f,
      createElement: A,
      cloneElement: function (e, t, n) {
        null == e && w("267", e);
        var i = void 0,
          s = r({}, e.props),
          a = e.key,
          l = e.ref,
          c = e._owner;
        if (null != t) {
          void 0 !== t.ref && (l = t.ref, c = R.current), void 0 !== t.key && (a = "" + t.key);
          var u = void 0;
          for (i in e.type && e.type.defaultProps && (u = e.type.defaultProps), t) D.call(t, i) && !_.hasOwnProperty(i) && (s[i] = void 0 === t[i] && void 0 !== u ? u[i] : t[i])
        }
        if (1 === (i = arguments.length - 2)) s.children = n;
        else if (1 < i) {
          u = Array(i);
          for (var h = 0; h < i; h++) u[h] = arguments[h + 2];
          s.children = u
        }
        return {
          $$typeof: o,
          type: e.type,
          key: a,
          ref: l,
          props: s,
          _owner: c
        }
      },
      createFactory: function (e) {
        var t = A.bind(null, e);
        return t.type = e, t
      },
      isValidElement: M,
      version: "16.8.4",
      unstable_ConcurrentMode: p,
      unstable_Profiler: c,
      __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
        ReactCurrentDispatcher: T,
        ReactCurrentOwner: R,
        assign: r
      }
    },
    V = {
      default: W
    },
    j = V && W || V;
  e.exports = j.default || j
}, function (e, t, n) {
  "use strict";
  /** @license React v16.8.4
   * react-dom.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var r = n(0),
    i = n(59),
    o = n(150);

  function s(e, t, n, r, i, o, s, a) {
    if (!e) {
      if (e = void 0, void 0 === t) e = Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var l = [n, r, i, o, s, a],
          c = 0;
        (e = Error(t.replace(/%s/g, (function () {
          return l[c++]
        })))).name = "Invariant Violation"
      }
      throw e.framesToPop = 1, e
    }
  }

  function a(e) {
    for (var t = arguments.length - 1, n = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, r = 0; r < t; r++) n += "&args[]=" + encodeURIComponent(arguments[r + 1]);
    s(!1, "Minified React error #" + e + "; visit %s for the full message or use the non-minified dev environment for full errors and additional helpful warnings. ", n)
  }

  function l(e, t, n, r, i, o, s, a, l) {
    var c = Array.prototype.slice.call(arguments, 3);
    try {
      t.apply(n, c)
    } catch (e) {
      this.onError(e)
    }
  }
  r || a("227");
  var c = !1,
    u = null,
    h = !1,
    p = null,
    d = {
      onError: function (e) {
        c = !0, u = e
      }
    };

  function f(e, t, n, r, i, o, s, a, h) {
    c = !1, u = null, l.apply(d, arguments)
  }
  var m = null,
    g = {};

  function y() {
    if (m)
      for (var e in g) {
        var t = g[e],
          n = m.indexOf(e);
        if (-1 < n || a("96", e), !w[n])
          for (var r in t.extractEvents || a("97", e), w[n] = t, n = t.eventTypes) {
            var i = void 0,
              o = n[r],
              s = t,
              l = r;
            b.hasOwnProperty(l) && a("99", l), b[l] = o;
            var c = o.phasedRegistrationNames;
            if (c) {
              for (i in c) c.hasOwnProperty(i) && v(c[i], s, l);
              i = !0
            } else o.registrationName ? (v(o.registrationName, s, l), i = !0) : i = !1;
            i || a("98", r, e)
          }
      }
  }

  function v(e, t, n) {
    S[e] && a("100", e), S[e] = t, C[e] = t.eventTypes[n].dependencies
  }
  var w = [],
    b = {},
    S = {},
    C = {},
    E = null,
    k = null,
    x = null;

  function T(e, t, n) {
    var r = e.type || "unknown-event";
    e.currentTarget = x(n),
      function (e, t, n, r, i, o, s, l, d) {
        if (f.apply(this, arguments), c) {
          if (c) {
            var m = u;
            c = !1, u = null
          } else a("198"), m = void 0;
          h || (h = !0, p = m)
        }
      }(r, t, void 0, e), e.currentTarget = null
  }

  function R(e, t) {
    return null == t && a("30"), null == e ? t : Array.isArray(e) ? Array.isArray(t) ? (e.push.apply(e, t), e) : (e.push(t), e) : Array.isArray(t) ? [e].concat(t) : [e, t]
  }

  function D(e, t, n) {
    Array.isArray(e) ? e.forEach(t, n) : e && t.call(n, e)
  }
  var _ = null;

  function A(e) {
    if (e) {
      var t = e._dispatchListeners,
        n = e._dispatchInstances;
      if (Array.isArray(t))
        for (var r = 0; r < t.length && !e.isPropagationStopped(); r++) T(e, t[r], n[r]);
      else t && T(e, t, n);
      e._dispatchListeners = null, e._dispatchInstances = null, e.isPersistent() || e.constructor.release(e)
    }
  }
  var M = {
    injectEventPluginOrder: function (e) {
      m && a("101"), m = Array.prototype.slice.call(e), y()
    },
    injectEventPluginsByName: function (e) {
      var t, n = !1;
      for (t in e)
        if (e.hasOwnProperty(t)) {
          var r = e[t];
          g.hasOwnProperty(t) && g[t] === r || (g[t] && a("102", t), g[t] = r, n = !0)
        } n && y()
    }
  };

  function P(e, t) {
    var n = e.stateNode;
    if (!n) return null;
    var r = E(n);
    if (!r) return null;
    n = r[t];
    e: switch (t) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
        (r = !r.disabled) || (r = !("button" === (e = e.type) || "input" === e || "select" === e || "textarea" === e)), e = !r;
        break e;
      default:
        e = !1
    }
    return e ? null : (n && "function" != typeof n && a("231", t, typeof n), n)
  }

  function I(e) {
    if (null !== e && (_ = R(_, e)), e = _, _ = null, e && (D(e, A), _ && a("95"), h)) throw e = p, h = !1, p = null, e
  }
  var O = Math.random().toString(36).slice(2),
    L = "__reactInternalInstance$" + O,
    N = "__reactEventHandlers$" + O;

  function F(e) {
    if (e[L]) return e[L];
    for (; !e[L];) {
      if (!e.parentNode) return null;
      e = e.parentNode
    }
    return 5 === (e = e[L]).tag || 6 === e.tag ? e : null
  }

  function B(e) {
    return !(e = e[L]) || 5 !== e.tag && 6 !== e.tag ? null : e
  }

  function H(e) {
    if (5 === e.tag || 6 === e.tag) return e.stateNode;
    a("33")
  }

  function z(e) {
    return e[N] || null
  }

  function U(e) {
    do {
      e = e.return
    } while (e && 5 !== e.tag);
    return e || null
  }

  function W(e, t, n) {
    (t = P(e, n.dispatchConfig.phasedRegistrationNames[t])) && (n._dispatchListeners = R(n._dispatchListeners, t), n._dispatchInstances = R(n._dispatchInstances, e))
  }

  function V(e) {
    if (e && e.dispatchConfig.phasedRegistrationNames) {
      for (var t = e._targetInst, n = []; t;) n.push(t), t = U(t);
      for (t = n.length; 0 < t--;) W(n[t], "captured", e);
      for (t = 0; t < n.length; t++) W(n[t], "bubbled", e)
    }
  }

  function j(e, t, n) {
    e && n && n.dispatchConfig.registrationName && (t = P(e, n.dispatchConfig.registrationName)) && (n._dispatchListeners = R(n._dispatchListeners, t), n._dispatchInstances = R(n._dispatchInstances, e))
  }

  function G(e) {
    e && e.dispatchConfig.registrationName && j(e._targetInst, null, e)
  }

  function $(e) {
    D(e, V)
  }
  var q = !("undefined" == typeof window || !window.document || !window.document.createElement);

  function K(e, t) {
    var n = {};
    return n[e.toLowerCase()] = t.toLowerCase(), n["Webkit" + e] = "webkit" + t, n["Moz" + e] = "moz" + t, n
  }
  var Y = {
      animationend: K("Animation", "AnimationEnd"),
      animationiteration: K("Animation", "AnimationIteration"),
      animationstart: K("Animation", "AnimationStart"),
      transitionend: K("Transition", "TransitionEnd")
    },
    Q = {},
    Z = {};

  function X(e) {
    if (Q[e]) return Q[e];
    if (!Y[e]) return e;
    var t, n = Y[e];
    for (t in n)
      if (n.hasOwnProperty(t) && t in Z) return Q[e] = n[t];
    return e
  }
  q && (Z = document.createElement("div").style, "AnimationEvent" in window || (delete Y.animationend.animation, delete Y.animationiteration.animation, delete Y.animationstart.animation), "TransitionEvent" in window || delete Y.transitionend.transition);
  var J = X("animationend"),
    ee = X("animationiteration"),
    te = X("animationstart"),
    ne = X("transitionend"),
    re = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),
    ie = null,
    oe = null,
    se = null;

  function ae() {
    if (se) return se;
    var e, t, n = oe,
      r = n.length,
      i = "value" in ie ? ie.value : ie.textContent,
      o = i.length;
    for (e = 0; e < r && n[e] === i[e]; e++);
    var s = r - e;
    for (t = 1; t <= s && n[r - t] === i[o - t]; t++);
    return se = i.slice(e, 1 < t ? 1 - t : void 0)
  }

  function le() {
    return !0
  }

  function ce() {
    return !1
  }

  function ue(e, t, n, r) {
    for (var i in this.dispatchConfig = e, this._targetInst = t, this.nativeEvent = n, e = this.constructor.Interface) e.hasOwnProperty(i) && ((t = e[i]) ? this[i] = t(n) : "target" === i ? this.target = r : this[i] = n[i]);
    return this.isDefaultPrevented = (null != n.defaultPrevented ? n.defaultPrevented : !1 === n.returnValue) ? le : ce, this.isPropagationStopped = ce, this
  }

  function he(e, t, n, r) {
    if (this.eventPool.length) {
      var i = this.eventPool.pop();
      return this.call(i, e, t, n, r), i
    }
    return new this(e, t, n, r)
  }

  function pe(e) {
    e instanceof this || a("279"), e.destructor(), 10 > this.eventPool.length && this.eventPool.push(e)
  }

  function de(e) {
    e.eventPool = [], e.getPooled = he, e.release = pe
  }
  i(ue.prototype, {
    preventDefault: function () {
      this.defaultPrevented = !0;
      var e = this.nativeEvent;
      e && (e.preventDefault ? e.preventDefault() : "unknown" != typeof e.returnValue && (e.returnValue = !1), this.isDefaultPrevented = le)
    },
    stopPropagation: function () {
      var e = this.nativeEvent;
      e && (e.stopPropagation ? e.stopPropagation() : "unknown" != typeof e.cancelBubble && (e.cancelBubble = !0), this.isPropagationStopped = le)
    },
    persist: function () {
      this.isPersistent = le
    },
    isPersistent: ce,
    destructor: function () {
      var e, t = this.constructor.Interface;
      for (e in t) this[e] = null;
      this.nativeEvent = this._targetInst = this.dispatchConfig = null, this.isPropagationStopped = this.isDefaultPrevented = ce, this._dispatchInstances = this._dispatchListeners = null
    }
  }), ue.Interface = {
    type: null,
    target: null,
    currentTarget: function () {
      return null
    },
    eventPhase: null,
    bubbles: null,
    cancelable: null,
    timeStamp: function (e) {
      return e.timeStamp || Date.now()
    },
    defaultPrevented: null,
    isTrusted: null
  }, ue.extend = function (e) {
    function t() {}

    function n() {
      return r.apply(this, arguments)
    }
    var r = this;
    t.prototype = r.prototype;
    var o = new t;
    return i(o, n.prototype), n.prototype = o, n.prototype.constructor = n, n.Interface = i({}, r.Interface, e), n.extend = r.extend, de(n), n
  }, de(ue);
  var fe = ue.extend({
      data: null
    }),
    me = ue.extend({
      data: null
    }),
    ge = [9, 13, 27, 32],
    ye = q && "CompositionEvent" in window,
    ve = null;
  q && "documentMode" in document && (ve = document.documentMode);
  var we = q && "TextEvent" in window && !ve,
    be = q && (!ye || ve && 8 < ve && 11 >= ve),
    Se = String.fromCharCode(32),
    Ce = {
      beforeInput: {
        phasedRegistrationNames: {
          bubbled: "onBeforeInput",
          captured: "onBeforeInputCapture"
        },
        dependencies: ["compositionend", "keypress", "textInput", "paste"]
      },
      compositionEnd: {
        phasedRegistrationNames: {
          bubbled: "onCompositionEnd",
          captured: "onCompositionEndCapture"
        },
        dependencies: "blur compositionend keydown keypress keyup mousedown".split(" ")
      },
      compositionStart: {
        phasedRegistrationNames: {
          bubbled: "onCompositionStart",
          captured: "onCompositionStartCapture"
        },
        dependencies: "blur compositionstart keydown keypress keyup mousedown".split(" ")
      },
      compositionUpdate: {
        phasedRegistrationNames: {
          bubbled: "onCompositionUpdate",
          captured: "onCompositionUpdateCapture"
        },
        dependencies: "blur compositionupdate keydown keypress keyup mousedown".split(" ")
      }
    },
    Ee = !1;

  function ke(e, t) {
    switch (e) {
      case "keyup":
        return -1 !== ge.indexOf(t.keyCode);
      case "keydown":
        return 229 !== t.keyCode;
      case "keypress":
      case "mousedown":
      case "blur":
        return !0;
      default:
        return !1
    }
  }

  function xe(e) {
    return "object" == typeof (e = e.detail) && "data" in e ? e.data : null
  }
  var Te = !1;
  var Re = {
      eventTypes: Ce,
      extractEvents: function (e, t, n, r) {
        var i = void 0,
          o = void 0;
        if (ye) e: {
          switch (e) {
            case "compositionstart":
              i = Ce.compositionStart;
              break e;
            case "compositionend":
              i = Ce.compositionEnd;
              break e;
            case "compositionupdate":
              i = Ce.compositionUpdate;
              break e
          }
          i = void 0
        }
        else Te ? ke(e, n) && (i = Ce.compositionEnd) : "keydown" === e && 229 === n.keyCode && (i = Ce.compositionStart);
        return i ? (be && "ko" !== n.locale && (Te || i !== Ce.compositionStart ? i === Ce.compositionEnd && Te && (o = ae()) : (oe = "value" in (ie = r) ? ie.value : ie.textContent, Te = !0)), i = fe.getPooled(i, t, n, r), o ? i.data = o : null !== (o = xe(n)) && (i.data = o), $(i), o = i) : o = null, (e = we ? function (e, t) {
          switch (e) {
            case "compositionend":
              return xe(t);
            case "keypress":
              return 32 !== t.which ? null : (Ee = !0, Se);
            case "textInput":
              return (e = t.data) === Se && Ee ? null : e;
            default:
              return null
          }
        }(e, n) : function (e, t) {
          if (Te) return "compositionend" === e || !ye && ke(e, t) ? (e = ae(), se = oe = ie = null, Te = !1, e) : null;
          switch (e) {
            case "paste":
              return null;
            case "keypress":
              if (!(t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) {
                if (t.char && 1 < t.char.length) return t.char;
                if (t.which) return String.fromCharCode(t.which)
              }
              return null;
            case "compositionend":
              return be && "ko" !== t.locale ? null : t.data;
            default:
              return null
          }
        }(e, n)) ? ((t = me.getPooled(Ce.beforeInput, t, n, r)).data = e, $(t)) : t = null, null === o ? t : null === t ? o : [o, t]
      }
    },
    De = null,
    _e = null,
    Ae = null;

  function Me(e) {
    if (e = k(e)) {
      "function" != typeof De && a("280");
      var t = E(e.stateNode);
      De(e.stateNode, e.type, t)
    }
  }

  function Pe(e) {
    _e ? Ae ? Ae.push(e) : Ae = [e] : _e = e
  }

  function Ie() {
    if (_e) {
      var e = _e,
        t = Ae;
      if (Ae = _e = null, Me(e), t)
        for (e = 0; e < t.length; e++) Me(t[e])
    }
  }

  function Oe(e, t) {
    return e(t)
  }

  function Le(e, t, n) {
    return e(t, n)
  }

  function Ne() {}
  var Fe = !1;

  function Be(e, t) {
    if (Fe) return e(t);
    Fe = !0;
    try {
      return Oe(e, t)
    } finally {
      Fe = !1, (null !== _e || null !== Ae) && (Ne(), Ie())
    }
  }
  var He = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
  };

  function ze(e) {
    var t = e && e.nodeName && e.nodeName.toLowerCase();
    return "input" === t ? !!He[e.type] : "textarea" === t
  }

  function Ue(e) {
    return (e = e.target || e.srcElement || window).correspondingUseElement && (e = e.correspondingUseElement), 3 === e.nodeType ? e.parentNode : e
  }

  function We(e) {
    if (!q) return !1;
    var t = (e = "on" + e) in document;
    return t || ((t = document.createElement("div")).setAttribute(e, "return;"), t = "function" == typeof t[e]), t
  }

  function Ve(e) {
    var t = e.type;
    return (e = e.nodeName) && "input" === e.toLowerCase() && ("checkbox" === t || "radio" === t)
  }

  function je(e) {
    e._valueTracker || (e._valueTracker = function (e) {
      var t = Ve(e) ? "checked" : "value",
        n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t),
        r = "" + e[t];
      if (!e.hasOwnProperty(t) && void 0 !== n && "function" == typeof n.get && "function" == typeof n.set) {
        var i = n.get,
          o = n.set;
        return Object.defineProperty(e, t, {
          configurable: !0,
          get: function () {
            return i.call(this)
          },
          set: function (e) {
            r = "" + e, o.call(this, e)
          }
        }), Object.defineProperty(e, t, {
          enumerable: n.enumerable
        }), {
          getValue: function () {
            return r
          },
          setValue: function (e) {
            r = "" + e
          },
          stopTracking: function () {
            e._valueTracker = null, delete e[t]
          }
        }
      }
    }(e))
  }

  function Ge(e) {
    if (!e) return !1;
    var t = e._valueTracker;
    if (!t) return !0;
    var n = t.getValue(),
      r = "";
    return e && (r = Ve(e) ? e.checked ? "true" : "false" : e.value), (e = r) !== n && (t.setValue(e), !0)
  }
  var $e = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  $e.hasOwnProperty("ReactCurrentDispatcher") || ($e.ReactCurrentDispatcher = {
    current: null
  });
  var qe = /^(.*)[\\\/]/,
    Ke = "function" == typeof Symbol && Symbol.for,
    Ye = Ke ? Symbol.for("react.element") : 60103,
    Qe = Ke ? Symbol.for("react.portal") : 60106,
    Ze = Ke ? Symbol.for("react.fragment") : 60107,
    Xe = Ke ? Symbol.for("react.strict_mode") : 60108,
    Je = Ke ? Symbol.for("react.profiler") : 60114,
    et = Ke ? Symbol.for("react.provider") : 60109,
    tt = Ke ? Symbol.for("react.context") : 60110,
    nt = Ke ? Symbol.for("react.concurrent_mode") : 60111,
    rt = Ke ? Symbol.for("react.forward_ref") : 60112,
    it = Ke ? Symbol.for("react.suspense") : 60113,
    ot = Ke ? Symbol.for("react.memo") : 60115,
    st = Ke ? Symbol.for("react.lazy") : 60116,
    at = "function" == typeof Symbol && Symbol.iterator;

  function lt(e) {
    return null === e || "object" != typeof e ? null : "function" == typeof (e = at && e[at] || e["@@iterator"]) ? e : null
  }

  function ct(e) {
    if (null == e) return null;
    if ("function" == typeof e) return e.displayName || e.name || null;
    if ("string" == typeof e) return e;
    switch (e) {
      case nt:
        return "ConcurrentMode";
      case Ze:
        return "Fragment";
      case Qe:
        return "Portal";
      case Je:
        return "Profiler";
      case Xe:
        return "StrictMode";
      case it:
        return "Suspense"
    }
    if ("object" == typeof e) switch (e.$$typeof) {
      case tt:
        return "Context.Consumer";
      case et:
        return "Context.Provider";
      case rt:
        var t = e.render;
        return t = t.displayName || t.name || "", e.displayName || ("" !== t ? "ForwardRef(" + t + ")" : "ForwardRef");
      case ot:
        return ct(e.type);
      case st:
        if (e = 1 === e._status ? e._result : null) return ct(e)
    }
    return null
  }

  function ut(e) {
    var t = "";
    do {
      e: switch (e.tag) {
        case 3:
        case 4:
        case 6:
        case 7:
        case 10:
        case 9:
          var n = "";
          break e;
        default:
          var r = e._debugOwner,
            i = e._debugSource,
            o = ct(e.type);
          n = null, r && (n = ct(r.type)), r = o, o = "", i ? o = " (at " + i.fileName.replace(qe, "") + ":" + i.lineNumber + ")" : n && (o = " (created by " + n + ")"), n = "\n    in " + (r || "Unknown") + o
      }
      t += n,
      e = e.return
    } while (e);
    return t
  }
  var ht = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
    pt = Object.prototype.hasOwnProperty,
    dt = {},
    ft = {};

  function mt(e, t, n, r, i) {
    this.acceptsBooleans = 2 === t || 3 === t || 4 === t, this.attributeName = r, this.attributeNamespace = i, this.mustUseProperty = n, this.propertyName = e, this.type = t
  }
  var gt = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach((function (e) {
    gt[e] = new mt(e, 0, !1, e, null)
  })), [
    ["acceptCharset", "accept-charset"],
    ["className", "class"],
    ["htmlFor", "for"],
    ["httpEquiv", "http-equiv"]
  ].forEach((function (e) {
    var t = e[0];
    gt[t] = new mt(t, 1, !1, e[1], null)
  })), ["contentEditable", "draggable", "spellCheck", "value"].forEach((function (e) {
    gt[e] = new mt(e, 2, !1, e.toLowerCase(), null)
  })), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach((function (e) {
    gt[e] = new mt(e, 2, !1, e, null)
  })), "allowFullScreen async autoFocus autoPlay controls default defer disabled formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach((function (e) {
    gt[e] = new mt(e, 3, !1, e.toLowerCase(), null)
  })), ["checked", "multiple", "muted", "selected"].forEach((function (e) {
    gt[e] = new mt(e, 3, !0, e, null)
  })), ["capture", "download"].forEach((function (e) {
    gt[e] = new mt(e, 4, !1, e, null)
  })), ["cols", "rows", "size", "span"].forEach((function (e) {
    gt[e] = new mt(e, 6, !1, e, null)
  })), ["rowSpan", "start"].forEach((function (e) {
    gt[e] = new mt(e, 5, !1, e.toLowerCase(), null)
  }));
  var yt = /[\-:]([a-z])/g;

  function vt(e) {
    return e[1].toUpperCase()
  }

  function wt(e, t, n, r) {
    var i = gt.hasOwnProperty(t) ? gt[t] : null;
    (null !== i ? 0 === i.type : !r && (2 < t.length && ("o" === t[0] || "O" === t[0]) && ("n" === t[1] || "N" === t[1]))) || (function (e, t, n, r) {
      if (null == t || function (e, t, n, r) {
          if (null !== n && 0 === n.type) return !1;
          switch (typeof t) {
            case "function":
            case "symbol":
              return !0;
            case "boolean":
              return !r && (null !== n ? !n.acceptsBooleans : "data-" !== (e = e.toLowerCase().slice(0, 5)) && "aria-" !== e);
            default:
              return !1
          }
        }(e, t, n, r)) return !0;
      if (r) return !1;
      if (null !== n) switch (n.type) {
        case 3:
          return !t;
        case 4:
          return !1 === t;
        case 5:
          return isNaN(t);
        case 6:
          return isNaN(t) || 1 > t
      }
      return !1
    }(t, n, i, r) && (n = null), r || null === i ? function (e) {
      return !!pt.call(ft, e) || !pt.call(dt, e) && (ht.test(e) ? ft[e] = !0 : (dt[e] = !0, !1))
    }(t) && (null === n ? e.removeAttribute(t) : e.setAttribute(t, "" + n)) : i.mustUseProperty ? e[i.propertyName] = null === n ? 3 !== i.type && "" : n : (t = i.attributeName, r = i.attributeNamespace, null === n ? e.removeAttribute(t) : (n = 3 === (i = i.type) || 4 === i && !0 === n ? "" : "" + n, r ? e.setAttributeNS(r, t, n) : e.setAttribute(t, n))))
  }

  function bt(e) {
    switch (typeof e) {
      case "boolean":
      case "number":
      case "object":
      case "string":
      case "undefined":
        return e;
      default:
        return ""
    }
  }

  function St(e, t) {
    var n = t.checked;
    return i({}, t, {
      defaultChecked: void 0,
      defaultValue: void 0,
      value: void 0,
      checked: null != n ? n : e._wrapperState.initialChecked
    })
  }

  function Ct(e, t) {
    var n = null == t.defaultValue ? "" : t.defaultValue,
      r = null != t.checked ? t.checked : t.defaultChecked;
    n = bt(null != t.value ? t.value : n), e._wrapperState = {
      initialChecked: r,
      initialValue: n,
      controlled: "checkbox" === t.type || "radio" === t.type ? null != t.checked : null != t.value
    }
  }

  function Et(e, t) {
    null != (t = t.checked) && wt(e, "checked", t, !1)
  }

  function kt(e, t) {
    Et(e, t);
    var n = bt(t.value),
      r = t.type;
    if (null != n) "number" === r ? (0 === n && "" === e.value || e.value != n) && (e.value = "" + n) : e.value !== "" + n && (e.value = "" + n);
    else if ("submit" === r || "reset" === r) return void e.removeAttribute("value");
    t.hasOwnProperty("value") ? Tt(e, t.type, n) : t.hasOwnProperty("defaultValue") && Tt(e, t.type, bt(t.defaultValue)), null == t.checked && null != t.defaultChecked && (e.defaultChecked = !!t.defaultChecked)
  }

  function xt(e, t, n) {
    if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) {
      var r = t.type;
      if (!("submit" !== r && "reset" !== r || void 0 !== t.value && null !== t.value)) return;
      t = "" + e._wrapperState.initialValue, n || t === e.value || (e.value = t), e.defaultValue = t
    }
    "" !== (n = e.name) && (e.name = ""), e.defaultChecked = !e.defaultChecked, e.defaultChecked = !!e._wrapperState.initialChecked, "" !== n && (e.name = n)
  }

  function Tt(e, t, n) {
    "number" === t && e.ownerDocument.activeElement === e || (null == n ? e.defaultValue = "" + e._wrapperState.initialValue : e.defaultValue !== "" + n && (e.defaultValue = "" + n))
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach((function (e) {
    var t = e.replace(yt, vt);
    gt[t] = new mt(t, 1, !1, e, null)
  })), "xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type".split(" ").forEach((function (e) {
    var t = e.replace(yt, vt);
    gt[t] = new mt(t, 1, !1, e, "http://www.w3.org/1999/xlink")
  })), ["xml:base", "xml:lang", "xml:space"].forEach((function (e) {
    var t = e.replace(yt, vt);
    gt[t] = new mt(t, 1, !1, e, "http://www.w3.org/XML/1998/namespace")
  })), ["tabIndex", "crossOrigin"].forEach((function (e) {
    gt[e] = new mt(e, 1, !1, e.toLowerCase(), null)
  }));
  var Rt = {
    change: {
      phasedRegistrationNames: {
        bubbled: "onChange",
        captured: "onChangeCapture"
      },
      dependencies: "blur change click focus input keydown keyup selectionchange".split(" ")
    }
  };

  function Dt(e, t, n) {
    return (e = ue.getPooled(Rt.change, e, t, n)).type = "change", Pe(n), $(e), e
  }
  var _t = null,
    At = null;

  function Mt(e) {
    I(e)
  }

  function Pt(e) {
    if (Ge(H(e))) return e
  }

  function It(e, t) {
    if ("change" === e) return t
  }
  var Ot = !1;

  function Lt() {
    _t && (_t.detachEvent("onpropertychange", Nt), At = _t = null)
  }

  function Nt(e) {
    "value" === e.propertyName && Pt(At) && Be(Mt, e = Dt(At, e, Ue(e)))
  }

  function Ft(e, t, n) {
    "focus" === e ? (Lt(), At = n, (_t = t).attachEvent("onpropertychange", Nt)) : "blur" === e && Lt()
  }

  function Bt(e) {
    if ("selectionchange" === e || "keyup" === e || "keydown" === e) return Pt(At)
  }

  function Ht(e, t) {
    if ("click" === e) return Pt(t)
  }

  function zt(e, t) {
    if ("input" === e || "change" === e) return Pt(t)
  }
  q && (Ot = We("input") && (!document.documentMode || 9 < document.documentMode));
  var Ut = {
      eventTypes: Rt,
      _isInputEventSupported: Ot,
      extractEvents: function (e, t, n, r) {
        var i = t ? H(t) : window,
          o = void 0,
          s = void 0,
          a = i.nodeName && i.nodeName.toLowerCase();
        if ("select" === a || "input" === a && "file" === i.type ? o = It : ze(i) ? Ot ? o = zt : (o = Bt, s = Ft) : (a = i.nodeName) && "input" === a.toLowerCase() && ("checkbox" === i.type || "radio" === i.type) && (o = Ht), o && (o = o(e, t))) return Dt(o, n, r);
        s && s(e, i, t), "blur" === e && (e = i._wrapperState) && e.controlled && "number" === i.type && Tt(i, "number", i.value)
      }
    },
    Wt = ue.extend({
      view: null,
      detail: null
    }),
    Vt = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey"
    };

  function jt(e) {
    var t = this.nativeEvent;
    return t.getModifierState ? t.getModifierState(e) : !!(e = Vt[e]) && !!t[e]
  }

  function Gt() {
    return jt
  }
  var $t = 0,
    qt = 0,
    Kt = !1,
    Yt = !1,
    Qt = Wt.extend({
      screenX: null,
      screenY: null,
      clientX: null,
      clientY: null,
      pageX: null,
      pageY: null,
      ctrlKey: null,
      shiftKey: null,
      altKey: null,
      metaKey: null,
      getModifierState: Gt,
      button: null,
      buttons: null,
      relatedTarget: function (e) {
        return e.relatedTarget || (e.fromElement === e.srcElement ? e.toElement : e.fromElement)
      },
      movementX: function (e) {
        if ("movementX" in e) return e.movementX;
        var t = $t;
        return $t = e.screenX, Kt ? "mousemove" === e.type ? e.screenX - t : 0 : (Kt = !0, 0)
      },
      movementY: function (e) {
        if ("movementY" in e) return e.movementY;
        var t = qt;
        return qt = e.screenY, Yt ? "mousemove" === e.type ? e.screenY - t : 0 : (Yt = !0, 0)
      }
    }),
    Zt = Qt.extend({
      pointerId: null,
      width: null,
      height: null,
      pressure: null,
      tangentialPressure: null,
      tiltX: null,
      tiltY: null,
      twist: null,
      pointerType: null,
      isPrimary: null
    }),
    Xt = {
      mouseEnter: {
        registrationName: "onMouseEnter",
        dependencies: ["mouseout", "mouseover"]
      },
      mouseLeave: {
        registrationName: "onMouseLeave",
        dependencies: ["mouseout", "mouseover"]
      },
      pointerEnter: {
        registrationName: "onPointerEnter",
        dependencies: ["pointerout", "pointerover"]
      },
      pointerLeave: {
        registrationName: "onPointerLeave",
        dependencies: ["pointerout", "pointerover"]
      }
    },
    Jt = {
      eventTypes: Xt,
      extractEvents: function (e, t, n, r) {
        var i = "mouseover" === e || "pointerover" === e,
          o = "mouseout" === e || "pointerout" === e;
        if (i && (n.relatedTarget || n.fromElement) || !o && !i) return null;
        if (i = r.window === r ? r : (i = r.ownerDocument) ? i.defaultView || i.parentWindow : window, o ? (o = t, t = (t = n.relatedTarget || n.toElement) ? F(t) : null) : o = null, o === t) return null;
        var s = void 0,
          a = void 0,
          l = void 0,
          c = void 0;
        "mouseout" === e || "mouseover" === e ? (s = Qt, a = Xt.mouseLeave, l = Xt.mouseEnter, c = "mouse") : "pointerout" !== e && "pointerover" !== e || (s = Zt, a = Xt.pointerLeave, l = Xt.pointerEnter, c = "pointer");
        var u = null == o ? i : H(o);
        if (i = null == t ? i : H(t), (e = s.getPooled(a, o, n, r)).type = c + "leave", e.target = u, e.relatedTarget = i, (n = s.getPooled(l, t, n, r)).type = c + "enter", n.target = i, n.relatedTarget = u, r = t, o && r) e: {
          for (i = r, c = 0, s = t = o; s; s = U(s)) c++;
          for (s = 0, l = i; l; l = U(l)) s++;
          for (; 0 < c - s;) t = U(t),
          c--;
          for (; 0 < s - c;) i = U(i),
          s--;
          for (; c--;) {
            if (t === i || t === i.alternate) break e;
            t = U(t), i = U(i)
          }
          t = null
        }
        else t = null;
        for (i = t, t = []; o && o !== i && (null === (c = o.alternate) || c !== i);) t.push(o), o = U(o);
        for (o = []; r && r !== i && (null === (c = r.alternate) || c !== i);) o.push(r), r = U(r);
        for (r = 0; r < t.length; r++) j(t[r], "bubbled", e);
        for (r = o.length; 0 < r--;) j(o[r], "captured", n);
        return [e, n]
      }
    };

  function en(e, t) {
    return e === t && (0 !== e || 1 / e == 1 / t) || e != e && t != t
  }
  var tn = Object.prototype.hasOwnProperty;

  function nn(e, t) {
    if (en(e, t)) return !0;
    if ("object" != typeof e || null === e || "object" != typeof t || null === t) return !1;
    var n = Object.keys(e),
      r = Object.keys(t);
    if (n.length !== r.length) return !1;
    for (r = 0; r < n.length; r++)
      if (!tn.call(t, n[r]) || !en(e[n[r]], t[n[r]])) return !1;
    return !0
  }

  function rn(e) {
    var t = e;
    if (e.alternate)
      for (; t.return;) t = t.return;
    else {
      if (0 != (2 & t.effectTag)) return 1;
      for (; t.return;)
        if (0 != (2 & (t = t.return).effectTag)) return 1
    }
    return 3 === t.tag ? 2 : 3
  }

  function on(e) {
    2 !== rn(e) && a("188")
  }

  function sn(e) {
    if (!(e = function (e) {
        var t = e.alternate;
        if (!t) return 3 === (t = rn(e)) && a("188"), 1 === t ? null : e;
        for (var n = e, r = t;;) {
          var i = n.return,
            o = i ? i.alternate : null;
          if (!i || !o) break;
          if (i.child === o.child) {
            for (var s = i.child; s;) {
              if (s === n) return on(i), e;
              if (s === r) return on(i), t;
              s = s.sibling
            }
            a("188")
          }
          if (n.return !== r.return) n = i, r = o;
          else {
            s = !1;
            for (var l = i.child; l;) {
              if (l === n) {
                s = !0, n = i, r = o;
                break
              }
              if (l === r) {
                s = !0, r = i, n = o;
                break
              }
              l = l.sibling
            }
            if (!s) {
              for (l = o.child; l;) {
                if (l === n) {
                  s = !0, n = o, r = i;
                  break
                }
                if (l === r) {
                  s = !0, r = o, n = i;
                  break
                }
                l = l.sibling
              }
              s || a("189")
            }
          }
          n.alternate !== r && a("190")
        }
        return 3 !== n.tag && a("188"), n.stateNode.current === n ? e : t
      }(e))) return null;
    for (var t = e;;) {
      if (5 === t.tag || 6 === t.tag) return t;
      if (t.child) t.child.return = t, t = t.child;
      else {
        if (t === e) break;
        for (; !t.sibling;) {
          if (!t.return || t.return === e) return null;
          t = t.return
        }
        t.sibling.return = t.return, t = t.sibling
      }
    }
    return null
  }
  var an = ue.extend({
      animationName: null,
      elapsedTime: null,
      pseudoElement: null
    }),
    ln = ue.extend({
      clipboardData: function (e) {
        return "clipboardData" in e ? e.clipboardData : window.clipboardData
      }
    }),
    cn = Wt.extend({
      relatedTarget: null
    });

  function un(e) {
    var t = e.keyCode;
    return "charCode" in e ? 0 === (e = e.charCode) && 13 === t && (e = 13) : e = t, 10 === e && (e = 13), 32 <= e || 13 === e ? e : 0
  }
  var hn = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    },
    pn = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    },
    dn = Wt.extend({
      key: function (e) {
        if (e.key) {
          var t = hn[e.key] || e.key;
          if ("Unidentified" !== t) return t
        }
        return "keypress" === e.type ? 13 === (e = un(e)) ? "Enter" : String.fromCharCode(e) : "keydown" === e.type || "keyup" === e.type ? pn[e.keyCode] || "Unidentified" : ""
      },
      location: null,
      ctrlKey: null,
      shiftKey: null,
      altKey: null,
      metaKey: null,
      repeat: null,
      locale: null,
      getModifierState: Gt,
      charCode: function (e) {
        return "keypress" === e.type ? un(e) : 0
      },
      keyCode: function (e) {
        return "keydown" === e.type || "keyup" === e.type ? e.keyCode : 0
      },
      which: function (e) {
        return "keypress" === e.type ? un(e) : "keydown" === e.type || "keyup" === e.type ? e.keyCode : 0
      }
    }),
    fn = Qt.extend({
      dataTransfer: null
    }),
    mn = Wt.extend({
      touches: null,
      targetTouches: null,
      changedTouches: null,
      altKey: null,
      metaKey: null,
      ctrlKey: null,
      shiftKey: null,
      getModifierState: Gt
    }),
    gn = ue.extend({
      propertyName: null,
      elapsedTime: null,
      pseudoElement: null
    }),
    yn = Qt.extend({
      deltaX: function (e) {
        return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0
      },
      deltaY: function (e) {
        return "deltaY" in e ? e.deltaY : "wheelDeltaY" in e ? -e.wheelDeltaY : "wheelDelta" in e ? -e.wheelDelta : 0
      },
      deltaZ: null,
      deltaMode: null
    }),
    vn = [
      ["abort", "abort"],
      [J, "animationEnd"],
      [ee, "animationIteration"],
      [te, "animationStart"],
      ["canplay", "canPlay"],
      ["canplaythrough", "canPlayThrough"],
      ["drag", "drag"],
      ["dragenter", "dragEnter"],
      ["dragexit", "dragExit"],
      ["dragleave", "dragLeave"],
      ["dragover", "dragOver"],
      ["durationchange", "durationChange"],
      ["emptied", "emptied"],
      ["encrypted", "encrypted"],
      ["ended", "ended"],
      ["error", "error"],
      ["gotpointercapture", "gotPointerCapture"],
      ["load", "load"],
      ["loadeddata", "loadedData"],
      ["loadedmetadata", "loadedMetadata"],
      ["loadstart", "loadStart"],
      ["lostpointercapture", "lostPointerCapture"],
      ["mousemove", "mouseMove"],
      ["mouseout", "mouseOut"],
      ["mouseover", "mouseOver"],
      ["playing", "playing"],
      ["pointermove", "pointerMove"],
      ["pointerout", "pointerOut"],
      ["pointerover", "pointerOver"],
      ["progress", "progress"],
      ["scroll", "scroll"],
      ["seeking", "seeking"],
      ["stalled", "stalled"],
      ["suspend", "suspend"],
      ["timeupdate", "timeUpdate"],
      ["toggle", "toggle"],
      ["touchmove", "touchMove"],
      [ne, "transitionEnd"],
      ["waiting", "waiting"],
      ["wheel", "wheel"]
    ],
    wn = {},
    bn = {};

  function Sn(e, t) {
    var n = e[0],
      r = "on" + ((e = e[1])[0].toUpperCase() + e.slice(1));
    t = {
      phasedRegistrationNames: {
        bubbled: r,
        captured: r + "Capture"
      },
      dependencies: [n],
      isInteractive: t
    }, wn[e] = t, bn[n] = t
  } [
    ["blur", "blur"],
    ["cancel", "cancel"],
    ["click", "click"],
    ["close", "close"],
    ["contextmenu", "contextMenu"],
    ["copy", "copy"],
    ["cut", "cut"],
    ["auxclick", "auxClick"],
    ["dblclick", "doubleClick"],
    ["dragend", "dragEnd"],
    ["dragstart", "dragStart"],
    ["drop", "drop"],
    ["focus", "focus"],
    ["input", "input"],
    ["invalid", "invalid"],
    ["keydown", "keyDown"],
    ["keypress", "keyPress"],
    ["keyup", "keyUp"],
    ["mousedown", "mouseDown"],
    ["mouseup", "mouseUp"],
    ["paste", "paste"],
    ["pause", "pause"],
    ["play", "play"],
    ["pointercancel", "pointerCancel"],
    ["pointerdown", "pointerDown"],
    ["pointerup", "pointerUp"],
    ["ratechange", "rateChange"],
    ["reset", "reset"],
    ["seeked", "seeked"],
    ["submit", "submit"],
    ["touchcancel", "touchCancel"],
    ["touchend", "touchEnd"],
    ["touchstart", "touchStart"],
    ["volumechange", "volumeChange"]
  ].forEach((function (e) {
    Sn(e, !0)
  })), vn.forEach((function (e) {
    Sn(e, !1)
  }));
  var Cn = {
      eventTypes: wn,
      isInteractiveTopLevelEventType: function (e) {
        return void 0 !== (e = bn[e]) && !0 === e.isInteractive
      },
      extractEvents: function (e, t, n, r) {
        var i = bn[e];
        if (!i) return null;
        switch (e) {
          case "keypress":
            if (0 === un(n)) return null;
          case "keydown":
          case "keyup":
            e = dn;
            break;
          case "blur":
          case "focus":
            e = cn;
            break;
          case "click":
            if (2 === n.button) return null;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            e = Qt;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            e = fn;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            e = mn;
            break;
          case J:
          case ee:
          case te:
            e = an;
            break;
          case ne:
            e = gn;
            break;
          case "scroll":
            e = Wt;
            break;
          case "wheel":
            e = yn;
            break;
          case "copy":
          case "cut":
          case "paste":
            e = ln;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            e = Zt;
            break;
          default:
            e = ue
        }
        return $(t = e.getPooled(i, t, n, r)), t
      }
    },
    En = Cn.isInteractiveTopLevelEventType,
    kn = [];

  function xn(e) {
    var t = e.targetInst,
      n = t;
    do {
      if (!n) {
        e.ancestors.push(n);
        break
      }
      var r;
      for (r = n; r.return;) r = r.return;
      if (!(r = 3 !== r.tag ? null : r.stateNode.containerInfo)) break;
      e.ancestors.push(n), n = F(r)
    } while (n);
    for (n = 0; n < e.ancestors.length; n++) {
      t = e.ancestors[n];
      var i = Ue(e.nativeEvent);
      r = e.topLevelType;
      for (var o = e.nativeEvent, s = null, a = 0; a < w.length; a++) {
        var l = w[a];
        l && (l = l.extractEvents(r, t, o, i)) && (s = R(s, l))
      }
      I(s)
    }
  }
  var Tn = !0;

  function Rn(e, t) {
    if (!t) return null;
    var n = (En(e) ? _n : An).bind(null, e);
    t.addEventListener(e, n, !1)
  }

  function Dn(e, t) {
    if (!t) return null;
    var n = (En(e) ? _n : An).bind(null, e);
    t.addEventListener(e, n, !0)
  }

  function _n(e, t) {
    Le(An, e, t)
  }

  function An(e, t) {
    if (Tn) {
      var n = Ue(t);
      if (null === (n = F(n)) || "number" != typeof n.tag || 2 === rn(n) || (n = null), kn.length) {
        var r = kn.pop();
        r.topLevelType = e, r.nativeEvent = t, r.targetInst = n, e = r
      } else e = {
        topLevelType: e,
        nativeEvent: t,
        targetInst: n,
        ancestors: []
      };
      try {
        Be(xn, e)
      } finally {
        e.topLevelType = null, e.nativeEvent = null, e.targetInst = null, e.ancestors.length = 0, 10 > kn.length && kn.push(e)
      }
    }
  }
  var Mn = {},
    Pn = 0,
    In = "_reactListenersID" + ("" + Math.random()).slice(2);

  function On(e) {
    return Object.prototype.hasOwnProperty.call(e, In) || (e[In] = Pn++, Mn[e[In]] = {}), Mn[e[In]]
  }

  function Ln(e) {
    if (void 0 === (e = e || ("undefined" != typeof document ? document : void 0))) return null;
    try {
      return e.activeElement || e.body
    } catch (t) {
      return e.body
    }
  }

  function Nn(e) {
    for (; e && e.firstChild;) e = e.firstChild;
    return e
  }

  function Fn(e, t) {
    var n, r = Nn(e);
    for (e = 0; r;) {
      if (3 === r.nodeType) {
        if (n = e + r.textContent.length, e <= t && n >= t) return {
          node: r,
          offset: t - e
        };
        e = n
      }
      e: {
        for (; r;) {
          if (r.nextSibling) {
            r = r.nextSibling;
            break e
          }
          r = r.parentNode
        }
        r = void 0
      }
      r = Nn(r)
    }
  }

  function Bn() {
    for (var e = window, t = Ln(); t instanceof e.HTMLIFrameElement;) {
      try {
        e = t.contentDocument.defaultView
      } catch (e) {
        break
      }
      t = Ln(e.document)
    }
    return t
  }

  function Hn(e) {
    var t = e && e.nodeName && e.nodeName.toLowerCase();
    return t && ("input" === t && ("text" === e.type || "search" === e.type || "tel" === e.type || "url" === e.type || "password" === e.type) || "textarea" === t || "true" === e.contentEditable)
  }

  function zn(e) {
    var t = Bn(),
      n = e.focusedElem,
      r = e.selectionRange;
    if (t !== n && n && n.ownerDocument && function e(t, n) {
        return !(!t || !n) && (t === n || (!t || 3 !== t.nodeType) && (n && 3 === n.nodeType ? e(t, n.parentNode) : "contains" in t ? t.contains(n) : !!t.compareDocumentPosition && !!(16 & t.compareDocumentPosition(n))))
      }(n.ownerDocument.documentElement, n)) {
      if (null !== r && Hn(n))
        if (t = r.start, void 0 === (e = r.end) && (e = t), "selectionStart" in n) n.selectionStart = t, n.selectionEnd = Math.min(e, n.value.length);
        else if ((e = (t = n.ownerDocument || document) && t.defaultView || window).getSelection) {
        e = e.getSelection();
        var i = n.textContent.length,
          o = Math.min(r.start, i);
        r = void 0 === r.end ? o : Math.min(r.end, i), !e.extend && o > r && (i = r, r = o, o = i), i = Fn(n, o);
        var s = Fn(n, r);
        i && s && (1 !== e.rangeCount || e.anchorNode !== i.node || e.anchorOffset !== i.offset || e.focusNode !== s.node || e.focusOffset !== s.offset) && ((t = t.createRange()).setStart(i.node, i.offset), e.removeAllRanges(), o > r ? (e.addRange(t), e.extend(s.node, s.offset)) : (t.setEnd(s.node, s.offset), e.addRange(t)))
      }
      for (t = [], e = n; e = e.parentNode;) 1 === e.nodeType && t.push({
        element: e,
        left: e.scrollLeft,
        top: e.scrollTop
      });
      for ("function" == typeof n.focus && n.focus(), n = 0; n < t.length; n++)(e = t[n]).element.scrollLeft = e.left, e.element.scrollTop = e.top
    }
  }
  var Un = q && "documentMode" in document && 11 >= document.documentMode,
    Wn = {
      select: {
        phasedRegistrationNames: {
          bubbled: "onSelect",
          captured: "onSelectCapture"
        },
        dependencies: "blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")
      }
    },
    Vn = null,
    jn = null,
    Gn = null,
    $n = !1;

  function qn(e, t) {
    var n = t.window === t ? t.document : 9 === t.nodeType ? t : t.ownerDocument;
    return $n || null == Vn || Vn !== Ln(n) ? null : ("selectionStart" in (n = Vn) && Hn(n) ? n = {
      start: n.selectionStart,
      end: n.selectionEnd
    } : n = {
      anchorNode: (n = (n.ownerDocument && n.ownerDocument.defaultView || window).getSelection()).anchorNode,
      anchorOffset: n.anchorOffset,
      focusNode: n.focusNode,
      focusOffset: n.focusOffset
    }, Gn && nn(Gn, n) ? null : (Gn = n, (e = ue.getPooled(Wn.select, jn, e, t)).type = "select", e.target = Vn, $(e), e))
  }
  var Kn = {
    eventTypes: Wn,
    extractEvents: function (e, t, n, r) {
      var i, o = r.window === r ? r.document : 9 === r.nodeType ? r : r.ownerDocument;
      if (!(i = !o)) {
        e: {
          o = On(o),
          i = C.onSelect;
          for (var s = 0; s < i.length; s++) {
            var a = i[s];
            if (!o.hasOwnProperty(a) || !o[a]) {
              o = !1;
              break e
            }
          }
          o = !0
        }
        i = !o
      }
      if (i) return null;
      switch (o = t ? H(t) : window, e) {
        case "focus":
          (ze(o) || "true" === o.contentEditable) && (Vn = o, jn = t, Gn = null);
          break;
        case "blur":
          Gn = jn = Vn = null;
          break;
        case "mousedown":
          $n = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          return $n = !1, qn(n, r);
        case "selectionchange":
          if (Un) break;
        case "keydown":
        case "keyup":
          return qn(n, r)
      }
      return null
    }
  };

  function Yn(e, t) {
    return e = i({
      children: void 0
    }, t), (t = function (e) {
      var t = "";
      return r.Children.forEach(e, (function (e) {
        null != e && (t += e)
      })), t
    }(t.children)) && (e.children = t), e
  }

  function Qn(e, t, n, r) {
    if (e = e.options, t) {
      t = {};
      for (var i = 0; i < n.length; i++) t["$" + n[i]] = !0;
      for (n = 0; n < e.length; n++) i = t.hasOwnProperty("$" + e[n].value), e[n].selected !== i && (e[n].selected = i), i && r && (e[n].defaultSelected = !0)
    } else {
      for (n = "" + bt(n), t = null, i = 0; i < e.length; i++) {
        if (e[i].value === n) return e[i].selected = !0, void(r && (e[i].defaultSelected = !0));
        null !== t || e[i].disabled || (t = e[i])
      }
      null !== t && (t.selected = !0)
    }
  }

  function Zn(e, t) {
    return null != t.dangerouslySetInnerHTML && a("91"), i({}, t, {
      value: void 0,
      defaultValue: void 0,
      children: "" + e._wrapperState.initialValue
    })
  }

  function Xn(e, t) {
    var n = t.value;
    null == n && (n = t.defaultValue, null != (t = t.children) && (null != n && a("92"), Array.isArray(t) && (1 >= t.length || a("93"), t = t[0]), n = t), null == n && (n = "")), e._wrapperState = {
      initialValue: bt(n)
    }
  }

  function Jn(e, t) {
    var n = bt(t.value),
      r = bt(t.defaultValue);
    null != n && ((n = "" + n) !== e.value && (e.value = n), null == t.defaultValue && e.defaultValue !== n && (e.defaultValue = n)), null != r && (e.defaultValue = "" + r)
  }

  function er(e) {
    var t = e.textContent;
    t === e._wrapperState.initialValue && (e.value = t)
  }
  M.injectEventPluginOrder("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" ")), E = z, k = B, x = H, M.injectEventPluginsByName({
    SimpleEventPlugin: Cn,
    EnterLeaveEventPlugin: Jt,
    ChangeEventPlugin: Ut,
    SelectEventPlugin: Kn,
    BeforeInputEventPlugin: Re
  });
  var tr = "http://www.w3.org/1999/xhtml",
    nr = "http://www.w3.org/2000/svg";

  function rr(e) {
    switch (e) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml"
    }
  }

  function ir(e, t) {
    return null == e || "http://www.w3.org/1999/xhtml" === e ? rr(t) : "http://www.w3.org/2000/svg" === e && "foreignObject" === t ? "http://www.w3.org/1999/xhtml" : e
  }
  var or = void 0,
    sr = function (e) {
      return "undefined" != typeof MSApp && MSApp.execUnsafeLocalFunction ? function (t, n, r, i) {
        MSApp.execUnsafeLocalFunction((function () {
          return e(t, n)
        }))
      } : e
    }((function (e, t) {
      if (e.namespaceURI !== nr || "innerHTML" in e) e.innerHTML = t;
      else {
        for ((or = or || document.createElement("div")).innerHTML = "<svg>" + t + "</svg>", t = or.firstChild; e.firstChild;) e.removeChild(e.firstChild);
        for (; t.firstChild;) e.appendChild(t.firstChild)
      }
    }));

  function ar(e, t) {
    if (t) {
      var n = e.firstChild;
      if (n && n === e.lastChild && 3 === n.nodeType) return void(n.nodeValue = t)
    }
    e.textContent = t
  }
  var lr = {
      animationIterationCount: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    },
    cr = ["Webkit", "ms", "Moz", "O"];

  function ur(e, t, n) {
    return null == t || "boolean" == typeof t || "" === t ? "" : n || "number" != typeof t || 0 === t || lr.hasOwnProperty(e) && lr[e] ? ("" + t).trim() : t + "px"
  }

  function hr(e, t) {
    for (var n in e = e.style, t)
      if (t.hasOwnProperty(n)) {
        var r = 0 === n.indexOf("--"),
          i = ur(n, t[n], r);
        "float" === n && (n = "cssFloat"), r ? e.setProperty(n, i) : e[n] = i
      }
  }
  Object.keys(lr).forEach((function (e) {
    cr.forEach((function (t) {
      t = t + e.charAt(0).toUpperCase() + e.substring(1), lr[t] = lr[e]
    }))
  }));
  var pr = i({
    menuitem: !0
  }, {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0
  });

  function dr(e, t) {
    t && (pr[e] && (null != t.children || null != t.dangerouslySetInnerHTML) && a("137", e, ""), null != t.dangerouslySetInnerHTML && (null != t.children && a("60"), "object" == typeof t.dangerouslySetInnerHTML && "__html" in t.dangerouslySetInnerHTML || a("61")), null != t.style && "object" != typeof t.style && a("62", ""))
  }

  function fr(e, t) {
    if (-1 === e.indexOf("-")) return "string" == typeof t.is;
    switch (e) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0
    }
  }

  function mr(e, t) {
    var n = On(e = 9 === e.nodeType || 11 === e.nodeType ? e : e.ownerDocument);
    t = C[t];
    for (var r = 0; r < t.length; r++) {
      var i = t[r];
      if (!n.hasOwnProperty(i) || !n[i]) {
        switch (i) {
          case "scroll":
            Dn("scroll", e);
            break;
          case "focus":
          case "blur":
            Dn("focus", e), Dn("blur", e), n.blur = !0, n.focus = !0;
            break;
          case "cancel":
          case "close":
            We(i) && Dn(i, e);
            break;
          case "invalid":
          case "submit":
          case "reset":
            break;
          default:
            -1 === re.indexOf(i) && Rn(i, e)
        }
        n[i] = !0
      }
    }
  }

  function gr() {}
  var yr = null,
    vr = null;

  function wr(e, t) {
    switch (e) {
      case "button":
      case "input":
      case "select":
      case "textarea":
        return !!t.autoFocus
    }
    return !1
  }

  function br(e, t) {
    return "textarea" === e || "option" === e || "noscript" === e || "string" == typeof t.children || "number" == typeof t.children || "object" == typeof t.dangerouslySetInnerHTML && null !== t.dangerouslySetInnerHTML && null != t.dangerouslySetInnerHTML.__html
  }
  var Sr = "function" == typeof setTimeout ? setTimeout : void 0,
    Cr = "function" == typeof clearTimeout ? clearTimeout : void 0,
    Er = o.unstable_scheduleCallback,
    kr = o.unstable_cancelCallback;

  function xr(e) {
    for (e = e.nextSibling; e && 1 !== e.nodeType && 3 !== e.nodeType;) e = e.nextSibling;
    return e
  }

  function Tr(e) {
    for (e = e.firstChild; e && 1 !== e.nodeType && 3 !== e.nodeType;) e = e.nextSibling;
    return e
  }
  new Set;
  var Rr = [],
    Dr = -1;

  function _r(e) {
    0 > Dr || (e.current = Rr[Dr], Rr[Dr] = null, Dr--)
  }

  function Ar(e, t) {
    Dr++, Rr[Dr] = e.current, e.current = t
  }
  var Mr = {},
    Pr = {
      current: Mr
    },
    Ir = {
      current: !1
    },
    Or = Mr;

  function Lr(e, t) {
    var n = e.type.contextTypes;
    if (!n) return Mr;
    var r = e.stateNode;
    if (r && r.__reactInternalMemoizedUnmaskedChildContext === t) return r.__reactInternalMemoizedMaskedChildContext;
    var i, o = {};
    for (i in n) o[i] = t[i];
    return r && ((e = e.stateNode).__reactInternalMemoizedUnmaskedChildContext = t, e.__reactInternalMemoizedMaskedChildContext = o), o
  }

  function Nr(e) {
    return null != (e = e.childContextTypes)
  }

  function Fr(e) {
    _r(Ir), _r(Pr)
  }

  function Br(e) {
    _r(Ir), _r(Pr)
  }

  function Hr(e, t, n) {
    Pr.current !== Mr && a("168"), Ar(Pr, t), Ar(Ir, n)
  }

  function zr(e, t, n) {
    var r = e.stateNode;
    if (e = t.childContextTypes, "function" != typeof r.getChildContext) return n;
    for (var o in r = r.getChildContext()) o in e || a("108", ct(t) || "Unknown", o);
    return i({}, n, r)
  }

  function Ur(e) {
    var t = e.stateNode;
    return t = t && t.__reactInternalMemoizedMergedChildContext || Mr, Or = Pr.current, Ar(Pr, t), Ar(Ir, Ir.current), !0
  }

  function Wr(e, t, n) {
    var r = e.stateNode;
    r || a("169"), n ? (t = zr(e, t, Or), r.__reactInternalMemoizedMergedChildContext = t, _r(Ir), _r(Pr), Ar(Pr, t)) : _r(Ir), Ar(Ir, n)
  }
  var Vr = null,
    jr = null;

  function Gr(e) {
    return function (t) {
      try {
        return e(t)
      } catch (e) {}
    }
  }

  function $r(e, t, n, r) {
    this.tag = e, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = t, this.contextDependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r, this.effectTag = 0, this.lastEffect = this.firstEffect = this.nextEffect = null, this.childExpirationTime = this.expirationTime = 0, this.alternate = null
  }

  function qr(e, t, n, r) {
    return new $r(e, t, n, r)
  }

  function Kr(e) {
    return !(!(e = e.prototype) || !e.isReactComponent)
  }

  function Yr(e, t) {
    var n = e.alternate;
    return null === n ? ((n = qr(e.tag, t, e.key, e.mode)).elementType = e.elementType, n.type = e.type, n.stateNode = e.stateNode, n.alternate = e, e.alternate = n) : (n.pendingProps = t, n.effectTag = 0, n.nextEffect = null, n.firstEffect = null, n.lastEffect = null), n.childExpirationTime = e.childExpirationTime, n.expirationTime = e.expirationTime, n.child = e.child, n.memoizedProps = e.memoizedProps, n.memoizedState = e.memoizedState, n.updateQueue = e.updateQueue, n.contextDependencies = e.contextDependencies, n.sibling = e.sibling, n.index = e.index, n.ref = e.ref, n
  }

  function Qr(e, t, n, r, i, o) {
    var s = 2;
    if (r = e, "function" == typeof e) Kr(e) && (s = 1);
    else if ("string" == typeof e) s = 5;
    else e: switch (e) {
      case Ze:
        return Zr(n.children, i, o, t);
      case nt:
        return Xr(n, 3 | i, o, t);
      case Xe:
        return Xr(n, 2 | i, o, t);
      case Je:
        return (e = qr(12, n, t, 4 | i)).elementType = Je, e.type = Je, e.expirationTime = o, e;
      case it:
        return (e = qr(13, n, t, i)).elementType = it, e.type = it, e.expirationTime = o, e;
      default:
        if ("object" == typeof e && null !== e) switch (e.$$typeof) {
          case et:
            s = 10;
            break e;
          case tt:
            s = 9;
            break e;
          case rt:
            s = 11;
            break e;
          case ot:
            s = 14;
            break e;
          case st:
            s = 16, r = null;
            break e
        }
        a("130", null == e ? e : typeof e, "")
    }
    return (t = qr(s, n, t, i)).elementType = e, t.type = r, t.expirationTime = o, t
  }

  function Zr(e, t, n, r) {
    return (e = qr(7, e, r, t)).expirationTime = n, e
  }

  function Xr(e, t, n, r) {
    return e = qr(8, e, r, t), t = 0 == (1 & t) ? Xe : nt, e.elementType = t, e.type = t, e.expirationTime = n, e
  }

  function Jr(e, t, n) {
    return (e = qr(6, e, null, t)).expirationTime = n, e
  }

  function ei(e, t, n) {
    return (t = qr(4, null !== e.children ? e.children : [], e.key, t)).expirationTime = n, t.stateNode = {
      containerInfo: e.containerInfo,
      pendingChildren: null,
      implementation: e.implementation
    }, t
  }

  function ti(e, t) {
    e.didError = !1;
    var n = e.earliestPendingTime;
    0 === n ? e.earliestPendingTime = e.latestPendingTime = t : n < t ? e.earliestPendingTime = t : e.latestPendingTime > t && (e.latestPendingTime = t), ii(t, e)
  }

  function ni(e, t) {
    e.didError = !1, e.latestPingedTime >= t && (e.latestPingedTime = 0);
    var n = e.earliestPendingTime,
      r = e.latestPendingTime;
    n === t ? e.earliestPendingTime = r === t ? e.latestPendingTime = 0 : r : r === t && (e.latestPendingTime = n), n = e.earliestSuspendedTime, r = e.latestSuspendedTime, 0 === n ? e.earliestSuspendedTime = e.latestSuspendedTime = t : n < t ? e.earliestSuspendedTime = t : r > t && (e.latestSuspendedTime = t), ii(t, e)
  }

  function ri(e, t) {
    var n = e.earliestPendingTime;
    return n > t && (t = n), (e = e.earliestSuspendedTime) > t && (t = e), t
  }

  function ii(e, t) {
    var n = t.earliestSuspendedTime,
      r = t.latestSuspendedTime,
      i = t.earliestPendingTime,
      o = t.latestPingedTime;
    0 === (i = 0 !== i ? i : o) && (0 === e || r < e) && (i = r), 0 !== (e = i) && n > e && (e = n), t.nextExpirationTimeToWorkOn = i, t.expirationTime = e
  }

  function oi(e, t) {
    if (e && e.defaultProps)
      for (var n in t = i({}, t), e = e.defaultProps) void 0 === t[n] && (t[n] = e[n]);
    return t
  }
  var si = (new r.Component).refs;

  function ai(e, t, n, r) {
    n = null == (n = n(r, t = e.memoizedState)) ? t : i({}, t, n), e.memoizedState = n, null !== (r = e.updateQueue) && 0 === e.expirationTime && (r.baseState = n)
  }
  var li = {
    isMounted: function (e) {
      return !!(e = e._reactInternalFiber) && 2 === rn(e)
    },
    enqueueSetState: function (e, t, n) {
      e = e._reactInternalFiber;
      var r = ga(),
        i = Wo(r = Us(r, e));
      i.payload = t, null != n && (i.callback = n), Ls(), jo(e, i), Gs(e, r)
    },
    enqueueReplaceState: function (e, t, n) {
      e = e._reactInternalFiber;
      var r = ga(),
        i = Wo(r = Us(r, e));
      i.tag = Fo, i.payload = t, null != n && (i.callback = n), Ls(), jo(e, i), Gs(e, r)
    },
    enqueueForceUpdate: function (e, t) {
      e = e._reactInternalFiber;
      var n = ga(),
        r = Wo(n = Us(n, e));
      r.tag = Bo, null != t && (r.callback = t), Ls(), jo(e, r), Gs(e, n)
    }
  };

  function ci(e, t, n, r, i, o, s) {
    return "function" == typeof (e = e.stateNode).shouldComponentUpdate ? e.shouldComponentUpdate(r, o, s) : !t.prototype || !t.prototype.isPureReactComponent || (!nn(n, r) || !nn(i, o))
  }

  function ui(e, t, n) {
    var r = !1,
      i = Mr,
      o = t.contextType;
    return "object" == typeof o && null !== o ? o = No(o) : (i = Nr(t) ? Or : Pr.current, o = (r = null != (r = t.contextTypes)) ? Lr(e, i) : Mr), t = new t(n, o), e.memoizedState = null !== t.state && void 0 !== t.state ? t.state : null, t.updater = li, e.stateNode = t, t._reactInternalFiber = e, r && ((e = e.stateNode).__reactInternalMemoizedUnmaskedChildContext = i, e.__reactInternalMemoizedMaskedChildContext = o), t
  }

  function hi(e, t, n, r) {
    e = t.state, "function" == typeof t.componentWillReceiveProps && t.componentWillReceiveProps(n, r), "function" == typeof t.UNSAFE_componentWillReceiveProps && t.UNSAFE_componentWillReceiveProps(n, r), t.state !== e && li.enqueueReplaceState(t, t.state, null)
  }

  function pi(e, t, n, r) {
    var i = e.stateNode;
    i.props = n, i.state = e.memoizedState, i.refs = si;
    var o = t.contextType;
    "object" == typeof o && null !== o ? i.context = No(o) : (o = Nr(t) ? Or : Pr.current, i.context = Lr(e, o)), null !== (o = e.updateQueue) && (Ko(e, o, n, i, r), i.state = e.memoizedState), "function" == typeof (o = t.getDerivedStateFromProps) && (ai(e, t, o, n), i.state = e.memoizedState), "function" == typeof t.getDerivedStateFromProps || "function" == typeof i.getSnapshotBeforeUpdate || "function" != typeof i.UNSAFE_componentWillMount && "function" != typeof i.componentWillMount || (t = i.state, "function" == typeof i.componentWillMount && i.componentWillMount(), "function" == typeof i.UNSAFE_componentWillMount && i.UNSAFE_componentWillMount(), t !== i.state && li.enqueueReplaceState(i, i.state, null), null !== (o = e.updateQueue) && (Ko(e, o, n, i, r), i.state = e.memoizedState)), "function" == typeof i.componentDidMount && (e.effectTag |= 4)
  }
  var di = Array.isArray;

  function fi(e, t, n) {
    if (null !== (e = n.ref) && "function" != typeof e && "object" != typeof e) {
      if (n._owner) {
        n = n._owner;
        var r = void 0;
        n && (1 !== n.tag && a("309"), r = n.stateNode), r || a("147", e);
        var i = "" + e;
        return null !== t && null !== t.ref && "function" == typeof t.ref && t.ref._stringRef === i ? t.ref : ((t = function (e) {
          var t = r.refs;
          t === si && (t = r.refs = {}), null === e ? delete t[i] : t[i] = e
        })._stringRef = i, t)
      }
      "string" != typeof e && a("284"), n._owner || a("290", e)
    }
    return e
  }

  function mi(e, t) {
    "textarea" !== e.type && a("31", "[object Object]" === Object.prototype.toString.call(t) ? "object with keys {" + Object.keys(t).join(", ") + "}" : t, "")
  }

  function gi(e) {
    function t(t, n) {
      if (e) {
        var r = t.lastEffect;
        null !== r ? (r.nextEffect = n, t.lastEffect = n) : t.firstEffect = t.lastEffect = n, n.nextEffect = null, n.effectTag = 8
      }
    }

    function n(n, r) {
      if (!e) return null;
      for (; null !== r;) t(n, r), r = r.sibling;
      return null
    }

    function r(e, t) {
      for (e = new Map; null !== t;) null !== t.key ? e.set(t.key, t) : e.set(t.index, t), t = t.sibling;
      return e
    }

    function i(e, t, n) {
      return (e = Yr(e, t)).index = 0, e.sibling = null, e
    }

    function o(t, n, r) {
      return t.index = r, e ? null !== (r = t.alternate) ? (r = r.index) < n ? (t.effectTag = 2, n) : r : (t.effectTag = 2, n) : n
    }

    function s(t) {
      return e && null === t.alternate && (t.effectTag = 2), t
    }

    function l(e, t, n, r) {
      return null === t || 6 !== t.tag ? ((t = Jr(n, e.mode, r)).return = e, t) : ((t = i(t, n)).return = e, t)
    }

    function c(e, t, n, r) {
      return null !== t && t.elementType === n.type ? ((r = i(t, n.props)).ref = fi(e, t, n), r.return = e, r) : ((r = Qr(n.type, n.key, n.props, null, e.mode, r)).ref = fi(e, t, n), r.return = e, r)
    }

    function u(e, t, n, r) {
      return null === t || 4 !== t.tag || t.stateNode.containerInfo !== n.containerInfo || t.stateNode.implementation !== n.implementation ? ((t = ei(n, e.mode, r)).return = e, t) : ((t = i(t, n.children || [])).return = e, t)
    }

    function h(e, t, n, r, o) {
      return null === t || 7 !== t.tag ? ((t = Zr(n, e.mode, r, o)).return = e, t) : ((t = i(t, n)).return = e, t)
    }

    function p(e, t, n) {
      if ("string" == typeof t || "number" == typeof t) return (t = Jr("" + t, e.mode, n)).return = e, t;
      if ("object" == typeof t && null !== t) {
        switch (t.$$typeof) {
          case Ye:
            return (n = Qr(t.type, t.key, t.props, null, e.mode, n)).ref = fi(e, null, t), n.return = e, n;
          case Qe:
            return (t = ei(t, e.mode, n)).return = e, t
        }
        if (di(t) || lt(t)) return (t = Zr(t, e.mode, n, null)).return = e, t;
        mi(e, t)
      }
      return null
    }

    function d(e, t, n, r) {
      var i = null !== t ? t.key : null;
      if ("string" == typeof n || "number" == typeof n) return null !== i ? null : l(e, t, "" + n, r);
      if ("object" == typeof n && null !== n) {
        switch (n.$$typeof) {
          case Ye:
            return n.key === i ? n.type === Ze ? h(e, t, n.props.children, r, i) : c(e, t, n, r) : null;
          case Qe:
            return n.key === i ? u(e, t, n, r) : null
        }
        if (di(n) || lt(n)) return null !== i ? null : h(e, t, n, r, null);
        mi(e, n)
      }
      return null
    }

    function f(e, t, n, r, i) {
      if ("string" == typeof r || "number" == typeof r) return l(t, e = e.get(n) || null, "" + r, i);
      if ("object" == typeof r && null !== r) {
        switch (r.$$typeof) {
          case Ye:
            return e = e.get(null === r.key ? n : r.key) || null, r.type === Ze ? h(t, e, r.props.children, i, r.key) : c(t, e, r, i);
          case Qe:
            return u(t, e = e.get(null === r.key ? n : r.key) || null, r, i)
        }
        if (di(r) || lt(r)) return h(t, e = e.get(n) || null, r, i, null);
        mi(t, r)
      }
      return null
    }

    function m(i, s, a, l) {
      for (var c = null, u = null, h = s, m = s = 0, g = null; null !== h && m < a.length; m++) {
        h.index > m ? (g = h, h = null) : g = h.sibling;
        var y = d(i, h, a[m], l);
        if (null === y) {
          null === h && (h = g);
          break
        }
        e && h && null === y.alternate && t(i, h), s = o(y, s, m), null === u ? c = y : u.sibling = y, u = y, h = g
      }
      if (m === a.length) return n(i, h), c;
      if (null === h) {
        for (; m < a.length; m++)(h = p(i, a[m], l)) && (s = o(h, s, m), null === u ? c = h : u.sibling = h, u = h);
        return c
      }
      for (h = r(i, h); m < a.length; m++)(g = f(h, i, m, a[m], l)) && (e && null !== g.alternate && h.delete(null === g.key ? m : g.key), s = o(g, s, m), null === u ? c = g : u.sibling = g, u = g);
      return e && h.forEach((function (e) {
        return t(i, e)
      })), c
    }

    function g(i, s, l, c) {
      var u = lt(l);
      "function" != typeof u && a("150"), null == (l = u.call(l)) && a("151");
      for (var h = u = null, m = s, g = s = 0, y = null, v = l.next(); null !== m && !v.done; g++, v = l.next()) {
        m.index > g ? (y = m, m = null) : y = m.sibling;
        var w = d(i, m, v.value, c);
        if (null === w) {
          m || (m = y);
          break
        }
        e && m && null === w.alternate && t(i, m), s = o(w, s, g), null === h ? u = w : h.sibling = w, h = w, m = y
      }
      if (v.done) return n(i, m), u;
      if (null === m) {
        for (; !v.done; g++, v = l.next()) null !== (v = p(i, v.value, c)) && (s = o(v, s, g), null === h ? u = v : h.sibling = v, h = v);
        return u
      }
      for (m = r(i, m); !v.done; g++, v = l.next()) null !== (v = f(m, i, g, v.value, c)) && (e && null !== v.alternate && m.delete(null === v.key ? g : v.key), s = o(v, s, g), null === h ? u = v : h.sibling = v, h = v);
      return e && m.forEach((function (e) {
        return t(i, e)
      })), u
    }
    return function (e, r, o, l) {
      var c = "object" == typeof o && null !== o && o.type === Ze && null === o.key;
      c && (o = o.props.children);
      var u = "object" == typeof o && null !== o;
      if (u) switch (o.$$typeof) {
        case Ye:
          e: {
            for (u = o.key, c = r; null !== c;) {
              if (c.key === u) {
                if (7 === c.tag ? o.type === Ze : c.elementType === o.type) {
                  n(e, c.sibling), (r = i(c, o.type === Ze ? o.props.children : o.props)).ref = fi(e, c, o), r.return = e, e = r;
                  break e
                }
                n(e, c);
                break
              }
              t(e, c), c = c.sibling
            }
            o.type === Ze ? ((r = Zr(o.props.children, e.mode, l, o.key)).return = e, e = r) : ((l = Qr(o.type, o.key, o.props, null, e.mode, l)).ref = fi(e, r, o), l.return = e, e = l)
          }
          return s(e);
        case Qe:
          e: {
            for (c = o.key; null !== r;) {
              if (r.key === c) {
                if (4 === r.tag && r.stateNode.containerInfo === o.containerInfo && r.stateNode.implementation === o.implementation) {
                  n(e, r.sibling), (r = i(r, o.children || [])).return = e, e = r;
                  break e
                }
                n(e, r);
                break
              }
              t(e, r), r = r.sibling
            }(r = ei(o, e.mode, l)).return = e,
            e = r
          }
          return s(e)
      }
      if ("string" == typeof o || "number" == typeof o) return o = "" + o, null !== r && 6 === r.tag ? (n(e, r.sibling), (r = i(r, o)).return = e, e = r) : (n(e, r), (r = Jr(o, e.mode, l)).return = e, e = r), s(e);
      if (di(o)) return m(e, r, o, l);
      if (lt(o)) return g(e, r, o, l);
      if (u && mi(e, o), void 0 === o && !c) switch (e.tag) {
        case 1:
        case 0:
          a("152", (l = e.type).displayName || l.name || "Component")
      }
      return n(e, r)
    }
  }
  var yi = gi(!0),
    vi = gi(!1),
    wi = {},
    bi = {
      current: wi
    },
    Si = {
      current: wi
    },
    Ci = {
      current: wi
    };

  function Ei(e) {
    return e === wi && a("174"), e
  }

  function ki(e, t) {
    Ar(Ci, t), Ar(Si, e), Ar(bi, wi);
    var n = t.nodeType;
    switch (n) {
      case 9:
      case 11:
        t = (t = t.documentElement) ? t.namespaceURI : ir(null, "");
        break;
      default:
        t = ir(t = (n = 8 === n ? t.parentNode : t).namespaceURI || null, n = n.tagName)
    }
    _r(bi), Ar(bi, t)
  }

  function xi(e) {
    _r(bi), _r(Si), _r(Ci)
  }

  function Ti(e) {
    Ei(Ci.current);
    var t = Ei(bi.current),
      n = ir(t, e.type);
    t !== n && (Ar(Si, e), Ar(bi, n))
  }

  function Ri(e) {
    Si.current === e && (_r(bi), _r(Si))
  }
  var Di = $e.ReactCurrentDispatcher,
    _i = 0,
    Ai = null,
    Mi = null,
    Pi = null,
    Ii = null,
    Oi = null,
    Li = null,
    Ni = 0,
    Fi = null,
    Bi = 0,
    Hi = !1,
    zi = null,
    Ui = 0;

  function Wi() {
    a("307")
  }

  function Vi(e, t) {
    if (null === t) return !1;
    for (var n = 0; n < t.length && n < e.length; n++)
      if (!en(e[n], t[n])) return !1;
    return !0
  }

  function ji(e, t, n, r, i, o) {
    if (_i = o, Ai = t, Pi = null !== e ? e.memoizedState : null, Di.current = null === Pi ? ro : io, t = n(r, i), Hi) {
      do {
        Hi = !1, Ui += 1, Pi = null !== e ? e.memoizedState : null, Li = Ii, Fi = Oi = Mi = null, Di.current = io, t = n(r, i)
      } while (Hi);
      zi = null, Ui = 0
    }
    return Di.current = no, (e = Ai).memoizedState = Ii, e.expirationTime = Ni, e.updateQueue = Fi, e.effectTag |= Bi, e = null !== Mi && null !== Mi.next, _i = 0, Li = Oi = Ii = Pi = Mi = Ai = null, Ni = 0, Fi = null, Bi = 0, e && a("300"), t
  }

  function Gi() {
    Di.current = no, _i = 0, Li = Oi = Ii = Pi = Mi = Ai = null, Ni = 0, Fi = null, Bi = 0, Hi = !1, zi = null, Ui = 0
  }

  function $i() {
    var e = {
      memoizedState: null,
      baseState: null,
      queue: null,
      baseUpdate: null,
      next: null
    };
    return null === Oi ? Ii = Oi = e : Oi = Oi.next = e, Oi
  }

  function qi() {
    if (null !== Li) Li = (Oi = Li).next, Pi = null !== (Mi = Pi) ? Mi.next : null;
    else {
      null === Pi && a("310");
      var e = {
        memoizedState: (Mi = Pi).memoizedState,
        baseState: Mi.baseState,
        queue: Mi.queue,
        baseUpdate: Mi.baseUpdate,
        next: null
      };
      Oi = null === Oi ? Ii = e : Oi.next = e, Pi = Mi.next
    }
    return Oi
  }

  function Ki(e, t) {
    return "function" == typeof t ? t(e) : t
  }

  function Yi(e) {
    var t = qi(),
      n = t.queue;
    if (null === n && a("311"), 0 < Ui) {
      var r = n.dispatch;
      if (null !== zi) {
        var i = zi.get(n);
        if (void 0 !== i) {
          zi.delete(n);
          var o = t.memoizedState;
          do {
            o = e(o, i.action), i = i.next
          } while (null !== i);
          return en(o, t.memoizedState) || (go = !0), t.memoizedState = o, t.baseUpdate === n.last && (t.baseState = o), n.eagerReducer = e, n.eagerState = o, [o, r]
        }
      }
      return [t.memoizedState, r]
    }
    r = n.last;
    var s = t.baseUpdate;
    if (o = t.baseState, null !== s ? (null !== r && (r.next = null), r = s.next) : r = null !== r ? r.next : null, null !== r) {
      var l = i = null,
        c = r,
        u = !1;
      do {
        var h = c.expirationTime;
        h < _i ? (u || (u = !0, l = s, i = o), h > Ni && (Ni = h)) : o = c.eagerReducer === e ? c.eagerState : e(o, c.action), s = c, c = c.next
      } while (null !== c && c !== r);
      u || (l = s, i = o), en(o, t.memoizedState) || (go = !0), t.memoizedState = o, t.baseUpdate = l, t.baseState = i, n.eagerReducer = e, n.eagerState = o
    }
    return [t.memoizedState, n.dispatch]
  }

  function Qi(e, t, n, r) {
    return e = {
      tag: e,
      create: t,
      destroy: n,
      deps: r,
      next: null
    }, null === Fi ? (Fi = {
      lastEffect: null
    }).lastEffect = e.next = e : null === (t = Fi.lastEffect) ? Fi.lastEffect = e.next = e : (n = t.next, t.next = e, e.next = n, Fi.lastEffect = e), e
  }

  function Zi(e, t, n, r) {
    var i = $i();
    Bi |= e, i.memoizedState = Qi(t, n, void 0, void 0 === r ? null : r)
  }

  function Xi(e, t, n, r) {
    var i = qi();
    r = void 0 === r ? null : r;
    var o = void 0;
    if (null !== Mi) {
      var s = Mi.memoizedState;
      if (o = s.destroy, null !== r && Vi(r, s.deps)) return void Qi(0, n, o, r)
    }
    Bi |= e, i.memoizedState = Qi(t, n, o, r)
  }

  function Ji(e, t) {
    return "function" == typeof t ? (e = e(), t(e), function () {
      t(null)
    }) : null != t ? (e = e(), t.current = e, function () {
      t.current = null
    }) : void 0
  }

  function eo() {}

  function to(e, t, n) {
    25 > Ui || a("301");
    var r = e.alternate;
    if (e === Ai || null !== r && r === Ai)
      if (Hi = !0, e = {
          expirationTime: _i,
          action: n,
          eagerReducer: null,
          eagerState: null,
          next: null
        }, null === zi && (zi = new Map), void 0 === (n = zi.get(t))) zi.set(t, e);
      else {
        for (t = n; null !== t.next;) t = t.next;
        t.next = e
      }
    else {
      Ls();
      var i = ga(),
        o = {
          expirationTime: i = Us(i, e),
          action: n,
          eagerReducer: null,
          eagerState: null,
          next: null
        },
        s = t.last;
      if (null === s) o.next = o;
      else {
        var l = s.next;
        null !== l && (o.next = l), s.next = o
      }
      if (t.last = o, 0 === e.expirationTime && (null === r || 0 === r.expirationTime) && null !== (r = t.eagerReducer)) try {
        var c = t.eagerState,
          u = r(c, n);
        if (o.eagerReducer = r, o.eagerState = u, en(u, c)) return
      } catch (e) {}
      Gs(e, i)
    }
  }
  var no = {
      readContext: No,
      useCallback: Wi,
      useContext: Wi,
      useEffect: Wi,
      useImperativeHandle: Wi,
      useLayoutEffect: Wi,
      useMemo: Wi,
      useReducer: Wi,
      useRef: Wi,
      useState: Wi,
      useDebugValue: Wi
    },
    ro = {
      readContext: No,
      useCallback: function (e, t) {
        return $i().memoizedState = [e, void 0 === t ? null : t], e
      },
      useContext: No,
      useEffect: function (e, t) {
        return Zi(516, 192, e, t)
      },
      useImperativeHandle: function (e, t, n) {
        return n = null != n ? n.concat([e]) : null, Zi(4, 36, Ji.bind(null, t, e), n)
      },
      useLayoutEffect: function (e, t) {
        return Zi(4, 36, e, t)
      },
      useMemo: function (e, t) {
        var n = $i();
        return t = void 0 === t ? null : t, e = e(), n.memoizedState = [e, t], e
      },
      useReducer: function (e, t, n) {
        var r = $i();
        return t = void 0 !== n ? n(t) : t, r.memoizedState = r.baseState = t, e = (e = r.queue = {
          last: null,
          dispatch: null,
          eagerReducer: e,
          eagerState: t
        }).dispatch = to.bind(null, Ai, e), [r.memoizedState, e]
      },
      useRef: function (e) {
        return e = {
          current: e
        }, $i().memoizedState = e
      },
      useState: function (e) {
        var t = $i();
        return "function" == typeof e && (e = e()), t.memoizedState = t.baseState = e, e = (e = t.queue = {
          last: null,
          dispatch: null,
          eagerReducer: Ki,
          eagerState: e
        }).dispatch = to.bind(null, Ai, e), [t.memoizedState, e]
      },
      useDebugValue: eo
    },
    io = {
      readContext: No,
      useCallback: function (e, t) {
        var n = qi();
        t = void 0 === t ? null : t;
        var r = n.memoizedState;
        return null !== r && null !== t && Vi(t, r[1]) ? r[0] : (n.memoizedState = [e, t], e)
      },
      useContext: No,
      useEffect: function (e, t) {
        return Xi(516, 192, e, t)
      },
      useImperativeHandle: function (e, t, n) {
        return n = null != n ? n.concat([e]) : null, Xi(4, 36, Ji.bind(null, t, e), n)
      },
      useLayoutEffect: function (e, t) {
        return Xi(4, 36, e, t)
      },
      useMemo: function (e, t) {
        var n = qi();
        t = void 0 === t ? null : t;
        var r = n.memoizedState;
        return null !== r && null !== t && Vi(t, r[1]) ? r[0] : (e = e(), n.memoizedState = [e, t], e)
      },
      useReducer: Yi,
      useRef: function () {
        return qi().memoizedState
      },
      useState: function (e) {
        return Yi(Ki)
      },
      useDebugValue: eo
    },
    oo = null,
    so = null,
    ao = !1;

  function lo(e, t) {
    var n = qr(5, null, null, 0);
    n.elementType = "DELETED", n.type = "DELETED", n.stateNode = t, n.return = e, n.effectTag = 8, null !== e.lastEffect ? (e.lastEffect.nextEffect = n, e.lastEffect = n) : e.firstEffect = e.lastEffect = n
  }

  function co(e, t) {
    switch (e.tag) {
      case 5:
        var n = e.type;
        return null !== (t = 1 !== t.nodeType || n.toLowerCase() !== t.nodeName.toLowerCase() ? null : t) && (e.stateNode = t, !0);
      case 6:
        return null !== (t = "" === e.pendingProps || 3 !== t.nodeType ? null : t) && (e.stateNode = t, !0);
      case 13:
      default:
        return !1
    }
  }

  function uo(e) {
    if (ao) {
      var t = so;
      if (t) {
        var n = t;
        if (!co(e, t)) {
          if (!(t = xr(n)) || !co(e, t)) return e.effectTag |= 2, ao = !1, void(oo = e);
          lo(oo, n)
        }
        oo = e, so = Tr(t)
      } else e.effectTag |= 2, ao = !1, oo = e
    }
  }

  function ho(e) {
    for (e = e.return; null !== e && 5 !== e.tag && 3 !== e.tag && 18 !== e.tag;) e = e.return;
    oo = e
  }

  function po(e) {
    if (e !== oo) return !1;
    if (!ao) return ho(e), ao = !0, !1;
    var t = e.type;
    if (5 !== e.tag || "head" !== t && "body" !== t && !br(t, e.memoizedProps))
      for (t = so; t;) lo(e, t), t = xr(t);
    return ho(e), so = oo ? xr(e.stateNode) : null, !0
  }

  function fo() {
    so = oo = null, ao = !1
  }
  var mo = $e.ReactCurrentOwner,
    go = !1;

  function yo(e, t, n, r) {
    t.child = null === e ? vi(t, null, n, r) : yi(t, e.child, n, r)
  }

  function vo(e, t, n, r, i) {
    n = n.render;
    var o = t.ref;
    return Lo(t, i), r = ji(e, t, n, r, o, i), null === e || go ? (t.effectTag |= 1, yo(e, t, r, i), t.child) : (t.updateQueue = e.updateQueue, t.effectTag &= -517, e.expirationTime <= i && (e.expirationTime = 0), Ro(e, t, i))
  }

  function wo(e, t, n, r, i, o) {
    if (null === e) {
      var s = n.type;
      return "function" != typeof s || Kr(s) || void 0 !== s.defaultProps || null !== n.compare || void 0 !== n.defaultProps ? ((e = Qr(n.type, null, r, null, t.mode, o)).ref = t.ref, e.return = t, t.child = e) : (t.tag = 15, t.type = s, bo(e, t, s, r, i, o))
    }
    return s = e.child, i < o && (i = s.memoizedProps, (n = null !== (n = n.compare) ? n : nn)(i, r) && e.ref === t.ref) ? Ro(e, t, o) : (t.effectTag |= 1, (e = Yr(s, r)).ref = t.ref, e.return = t, t.child = e)
  }

  function bo(e, t, n, r, i, o) {
    return null !== e && nn(e.memoizedProps, r) && e.ref === t.ref && (go = !1, i < o) ? Ro(e, t, o) : Co(e, t, n, r, o)
  }

  function So(e, t) {
    var n = t.ref;
    (null === e && null !== n || null !== e && e.ref !== n) && (t.effectTag |= 128)
  }

  function Co(e, t, n, r, i) {
    var o = Nr(n) ? Or : Pr.current;
    return o = Lr(t, o), Lo(t, i), n = ji(e, t, n, r, o, i), null === e || go ? (t.effectTag |= 1, yo(e, t, n, i), t.child) : (t.updateQueue = e.updateQueue, t.effectTag &= -517, e.expirationTime <= i && (e.expirationTime = 0), Ro(e, t, i))
  }

  function Eo(e, t, n, r, i) {
    if (Nr(n)) {
      var o = !0;
      Ur(t)
    } else o = !1;
    if (Lo(t, i), null === t.stateNode) null !== e && (e.alternate = null, t.alternate = null, t.effectTag |= 2), ui(t, n, r), pi(t, n, r, i), r = !0;
    else if (null === e) {
      var s = t.stateNode,
        a = t.memoizedProps;
      s.props = a;
      var l = s.context,
        c = n.contextType;
      "object" == typeof c && null !== c ? c = No(c) : c = Lr(t, c = Nr(n) ? Or : Pr.current);
      var u = n.getDerivedStateFromProps,
        h = "function" == typeof u || "function" == typeof s.getSnapshotBeforeUpdate;
      h || "function" != typeof s.UNSAFE_componentWillReceiveProps && "function" != typeof s.componentWillReceiveProps || (a !== r || l !== c) && hi(t, s, r, c), Ho = !1;
      var p = t.memoizedState;
      l = s.state = p;
      var d = t.updateQueue;
      null !== d && (Ko(t, d, r, s, i), l = t.memoizedState), a !== r || p !== l || Ir.current || Ho ? ("function" == typeof u && (ai(t, n, u, r), l = t.memoizedState), (a = Ho || ci(t, n, a, r, p, l, c)) ? (h || "function" != typeof s.UNSAFE_componentWillMount && "function" != typeof s.componentWillMount || ("function" == typeof s.componentWillMount && s.componentWillMount(), "function" == typeof s.UNSAFE_componentWillMount && s.UNSAFE_componentWillMount()), "function" == typeof s.componentDidMount && (t.effectTag |= 4)) : ("function" == typeof s.componentDidMount && (t.effectTag |= 4), t.memoizedProps = r, t.memoizedState = l), s.props = r, s.state = l, s.context = c, r = a) : ("function" == typeof s.componentDidMount && (t.effectTag |= 4), r = !1)
    } else s = t.stateNode, a = t.memoizedProps, s.props = t.type === t.elementType ? a : oi(t.type, a), l = s.context, "object" == typeof (c = n.contextType) && null !== c ? c = No(c) : c = Lr(t, c = Nr(n) ? Or : Pr.current), (h = "function" == typeof (u = n.getDerivedStateFromProps) || "function" == typeof s.getSnapshotBeforeUpdate) || "function" != typeof s.UNSAFE_componentWillReceiveProps && "function" != typeof s.componentWillReceiveProps || (a !== r || l !== c) && hi(t, s, r, c), Ho = !1, l = t.memoizedState, p = s.state = l, null !== (d = t.updateQueue) && (Ko(t, d, r, s, i), p = t.memoizedState), a !== r || l !== p || Ir.current || Ho ? ("function" == typeof u && (ai(t, n, u, r), p = t.memoizedState), (u = Ho || ci(t, n, a, r, l, p, c)) ? (h || "function" != typeof s.UNSAFE_componentWillUpdate && "function" != typeof s.componentWillUpdate || ("function" == typeof s.componentWillUpdate && s.componentWillUpdate(r, p, c), "function" == typeof s.UNSAFE_componentWillUpdate && s.UNSAFE_componentWillUpdate(r, p, c)), "function" == typeof s.componentDidUpdate && (t.effectTag |= 4), "function" == typeof s.getSnapshotBeforeUpdate && (t.effectTag |= 256)) : ("function" != typeof s.componentDidUpdate || a === e.memoizedProps && l === e.memoizedState || (t.effectTag |= 4), "function" != typeof s.getSnapshotBeforeUpdate || a === e.memoizedProps && l === e.memoizedState || (t.effectTag |= 256), t.memoizedProps = r, t.memoizedState = p), s.props = r, s.state = p, s.context = c, r = u) : ("function" != typeof s.componentDidUpdate || a === e.memoizedProps && l === e.memoizedState || (t.effectTag |= 4), "function" != typeof s.getSnapshotBeforeUpdate || a === e.memoizedProps && l === e.memoizedState || (t.effectTag |= 256), r = !1);
    return ko(e, t, n, r, o, i)
  }

  function ko(e, t, n, r, i, o) {
    So(e, t);
    var s = 0 != (64 & t.effectTag);
    if (!r && !s) return i && Wr(t, n, !1), Ro(e, t, o);
    r = t.stateNode, mo.current = t;
    var a = s && "function" != typeof n.getDerivedStateFromError ? null : r.render();
    return t.effectTag |= 1, null !== e && s ? (t.child = yi(t, e.child, null, o), t.child = yi(t, null, a, o)) : yo(e, t, a, o), t.memoizedState = r.state, i && Wr(t, n, !0), t.child
  }

  function xo(e) {
    var t = e.stateNode;
    t.pendingContext ? Hr(0, t.pendingContext, t.pendingContext !== t.context) : t.context && Hr(0, t.context, !1), ki(e, t.containerInfo)
  }

  function To(e, t, n) {
    var r = t.mode,
      i = t.pendingProps,
      o = t.memoizedState;
    if (0 == (64 & t.effectTag)) {
      o = null;
      var s = !1
    } else o = {
      timedOutAt: null !== o ? o.timedOutAt : 0
    }, s = !0, t.effectTag &= -65;
    if (null === e)
      if (s) {
        var a = i.fallback;
        e = Zr(null, r, 0, null), 0 == (1 & t.mode) && (e.child = null !== t.memoizedState ? t.child.child : t.child), r = Zr(a, r, n, null), e.sibling = r, (n = e).return = r.return = t
      } else n = r = vi(t, null, i.children, n);
    else null !== e.memoizedState ? (a = (r = e.child).sibling, s ? (n = i.fallback, i = Yr(r, r.pendingProps), 0 == (1 & t.mode) && ((s = null !== t.memoizedState ? t.child.child : t.child) !== r.child && (i.child = s)), r = i.sibling = Yr(a, n, a.expirationTime), n = i, i.childExpirationTime = 0, n.return = r.return = t) : n = r = yi(t, r.child, i.children, n)) : (a = e.child, s ? (s = i.fallback, (i = Zr(null, r, 0, null)).child = a, 0 == (1 & t.mode) && (i.child = null !== t.memoizedState ? t.child.child : t.child), (r = i.sibling = Zr(s, r, n, null)).effectTag |= 2, n = i, i.childExpirationTime = 0, n.return = r.return = t) : r = n = yi(t, a, i.children, n)), t.stateNode = e.stateNode;
    return t.memoizedState = o, t.child = n, r
  }

  function Ro(e, t, n) {
    if (null !== e && (t.contextDependencies = e.contextDependencies), t.childExpirationTime < n) return null;
    if (null !== e && t.child !== e.child && a("153"), null !== t.child) {
      for (n = Yr(e = t.child, e.pendingProps, e.expirationTime), t.child = n, n.return = t; null !== e.sibling;) e = e.sibling, (n = n.sibling = Yr(e, e.pendingProps, e.expirationTime)).return = t;
      n.sibling = null
    }
    return t.child
  }

  function Do(e, t, n) {
    var r = t.expirationTime;
    if (null !== e) {
      if (e.memoizedProps !== t.pendingProps || Ir.current) go = !0;
      else if (r < n) {
        switch (go = !1, t.tag) {
          case 3:
            xo(t), fo();
            break;
          case 5:
            Ti(t);
            break;
          case 1:
            Nr(t.type) && Ur(t);
            break;
          case 4:
            ki(t, t.stateNode.containerInfo);
            break;
          case 10:
            Io(t, t.memoizedProps.value);
            break;
          case 13:
            if (null !== t.memoizedState) return 0 !== (r = t.child.childExpirationTime) && r >= n ? To(e, t, n) : null !== (t = Ro(e, t, n)) ? t.sibling : null
        }
        return Ro(e, t, n)
      }
    } else go = !1;
    switch (t.expirationTime = 0, t.tag) {
      case 2:
        r = t.elementType, null !== e && (e.alternate = null, t.alternate = null, t.effectTag |= 2), e = t.pendingProps;
        var i = Lr(t, Pr.current);
        if (Lo(t, n), i = ji(null, t, r, e, i, n), t.effectTag |= 1, "object" == typeof i && null !== i && "function" == typeof i.render && void 0 === i.$$typeof) {
          if (t.tag = 1, Gi(), Nr(r)) {
            var o = !0;
            Ur(t)
          } else o = !1;
          t.memoizedState = null !== i.state && void 0 !== i.state ? i.state : null;
          var s = r.getDerivedStateFromProps;
          "function" == typeof s && ai(t, r, s, e), i.updater = li, t.stateNode = i, i._reactInternalFiber = t, pi(t, r, e, n), t = ko(null, t, r, !0, o, n)
        } else t.tag = 0, yo(null, t, i, n), t = t.child;
        return t;
      case 16:
        switch (i = t.elementType, null !== e && (e.alternate = null, t.alternate = null, t.effectTag |= 2), o = t.pendingProps, e = function (e) {
          var t = e._result;
          switch (e._status) {
            case 1:
              return t;
            case 2:
            case 0:
              throw t;
            default:
              switch (e._status = 0, (t = (t = e._ctor)()).then((function (t) {
                0 === e._status && (t = t.default, e._status = 1, e._result = t)
              }), (function (t) {
                0 === e._status && (e._status = 2, e._result = t)
              })), e._status) {
                case 1:
                  return e._result;
                case 2:
                  throw e._result
              }
              throw e._result = t, t
          }
        }(i), t.type = e, i = t.tag = function (e) {
          if ("function" == typeof e) return Kr(e) ? 1 : 0;
          if (null != e) {
            if ((e = e.$$typeof) === rt) return 11;
            if (e === ot) return 14
          }
          return 2
        }(e), o = oi(e, o), s = void 0, i) {
          case 0:
            s = Co(null, t, e, o, n);
            break;
          case 1:
            s = Eo(null, t, e, o, n);
            break;
          case 11:
            s = vo(null, t, e, o, n);
            break;
          case 14:
            s = wo(null, t, e, oi(e.type, o), r, n);
            break;
          default:
            a("306", e, "")
        }
        return s;
      case 0:
        return r = t.type, i = t.pendingProps, Co(e, t, r, i = t.elementType === r ? i : oi(r, i), n);
      case 1:
        return r = t.type, i = t.pendingProps, Eo(e, t, r, i = t.elementType === r ? i : oi(r, i), n);
      case 3:
        return xo(t), null === (r = t.updateQueue) && a("282"), i = null !== (i = t.memoizedState) ? i.element : null, Ko(t, r, t.pendingProps, null, n), (r = t.memoizedState.element) === i ? (fo(), t = Ro(e, t, n)) : (i = t.stateNode, (i = (null === e || null === e.child) && i.hydrate) && (so = Tr(t.stateNode.containerInfo), oo = t, i = ao = !0), i ? (t.effectTag |= 2, t.child = vi(t, null, r, n)) : (yo(e, t, r, n), fo()), t = t.child), t;
      case 5:
        return Ti(t), null === e && uo(t), r = t.type, i = t.pendingProps, o = null !== e ? e.memoizedProps : null, s = i.children, br(r, i) ? s = null : null !== o && br(r, o) && (t.effectTag |= 16), So(e, t), 1 !== n && 1 & t.mode && i.hidden ? (t.expirationTime = t.childExpirationTime = 1, t = null) : (yo(e, t, s, n), t = t.child), t;
      case 6:
        return null === e && uo(t), null;
      case 13:
        return To(e, t, n);
      case 4:
        return ki(t, t.stateNode.containerInfo), r = t.pendingProps, null === e ? t.child = yi(t, null, r, n) : yo(e, t, r, n), t.child;
      case 11:
        return r = t.type, i = t.pendingProps, vo(e, t, r, i = t.elementType === r ? i : oi(r, i), n);
      case 7:
        return yo(e, t, t.pendingProps, n), t.child;
      case 8:
      case 12:
        return yo(e, t, t.pendingProps.children, n), t.child;
      case 10:
        e: {
          if (r = t.type._context, i = t.pendingProps, s = t.memoizedProps, Io(t, o = i.value), null !== s) {
            var l = s.value;
            if (0 === (o = en(l, o) ? 0 : 0 | ("function" == typeof r._calculateChangedBits ? r._calculateChangedBits(l, o) : 1073741823))) {
              if (s.children === i.children && !Ir.current) {
                t = Ro(e, t, n);
                break e
              }
            } else
              for (null !== (l = t.child) && (l.return = t); null !== l;) {
                var c = l.contextDependencies;
                if (null !== c) {
                  s = l.child;
                  for (var u = c.first; null !== u;) {
                    if (u.context === r && 0 != (u.observedBits & o)) {
                      1 === l.tag && ((u = Wo(n)).tag = Bo, jo(l, u)), l.expirationTime < n && (l.expirationTime = n), null !== (u = l.alternate) && u.expirationTime < n && (u.expirationTime = n), u = n;
                      for (var h = l.return; null !== h;) {
                        var p = h.alternate;
                        if (h.childExpirationTime < u) h.childExpirationTime = u, null !== p && p.childExpirationTime < u && (p.childExpirationTime = u);
                        else {
                          if (!(null !== p && p.childExpirationTime < u)) break;
                          p.childExpirationTime = u
                        }
                        h = h.return
                      }
                      c.expirationTime < n && (c.expirationTime = n);
                      break
                    }
                    u = u.next
                  }
                } else s = 10 === l.tag && l.type === t.type ? null : l.child;
                if (null !== s) s.return = l;
                else
                  for (s = l; null !== s;) {
                    if (s === t) {
                      s = null;
                      break
                    }
                    if (null !== (l = s.sibling)) {
                      l.return = s.return, s = l;
                      break
                    }
                    s = s.return
                  }
                l = s
              }
          }
          yo(e, t, i.children, n),
          t = t.child
        }
        return t;
      case 9:
        return i = t.type, r = (o = t.pendingProps).children, Lo(t, n), r = r(i = No(i, o.unstable_observedBits)), t.effectTag |= 1, yo(e, t, r, n), t.child;
      case 14:
        return o = oi(i = t.type, t.pendingProps), wo(e, t, i, o = oi(i.type, o), r, n);
      case 15:
        return bo(e, t, t.type, t.pendingProps, r, n);
      case 17:
        return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : oi(r, i), null !== e && (e.alternate = null, t.alternate = null, t.effectTag |= 2), t.tag = 1, Nr(r) ? (e = !0, Ur(t)) : e = !1, Lo(t, n), ui(t, r, i), pi(t, r, i, n), ko(null, t, r, !0, e, n)
    }
    a("156")
  }
  var _o = {
      current: null
    },
    Ao = null,
    Mo = null,
    Po = null;

  function Io(e, t) {
    var n = e.type._context;
    Ar(_o, n._currentValue), n._currentValue = t
  }

  function Oo(e) {
    var t = _o.current;
    _r(_o), e.type._context._currentValue = t
  }

  function Lo(e, t) {
    Ao = e, Po = Mo = null;
    var n = e.contextDependencies;
    null !== n && n.expirationTime >= t && (go = !0), e.contextDependencies = null
  }

  function No(e, t) {
    return Po !== e && !1 !== t && 0 !== t && ("number" == typeof t && 1073741823 !== t || (Po = e, t = 1073741823), t = {
      context: e,
      observedBits: t,
      next: null
    }, null === Mo ? (null === Ao && a("308"), Mo = t, Ao.contextDependencies = {
      first: t,
      expirationTime: 0
    }) : Mo = Mo.next = t), e._currentValue
  }
  var Fo = 1,
    Bo = 2,
    Ho = !1;

  function zo(e) {
    return {
      baseState: e,
      firstUpdate: null,
      lastUpdate: null,
      firstCapturedUpdate: null,
      lastCapturedUpdate: null,
      firstEffect: null,
      lastEffect: null,
      firstCapturedEffect: null,
      lastCapturedEffect: null
    }
  }

  function Uo(e) {
    return {
      baseState: e.baseState,
      firstUpdate: e.firstUpdate,
      lastUpdate: e.lastUpdate,
      firstCapturedUpdate: null,
      lastCapturedUpdate: null,
      firstEffect: null,
      lastEffect: null,
      firstCapturedEffect: null,
      lastCapturedEffect: null
    }
  }

  function Wo(e) {
    return {
      expirationTime: e,
      tag: 0,
      payload: null,
      callback: null,
      next: null,
      nextEffect: null
    }
  }

  function Vo(e, t) {
    null === e.lastUpdate ? e.firstUpdate = e.lastUpdate = t : (e.lastUpdate.next = t, e.lastUpdate = t)
  }

  function jo(e, t) {
    var n = e.alternate;
    if (null === n) {
      var r = e.updateQueue,
        i = null;
      null === r && (r = e.updateQueue = zo(e.memoizedState))
    } else r = e.updateQueue, i = n.updateQueue, null === r ? null === i ? (r = e.updateQueue = zo(e.memoizedState), i = n.updateQueue = zo(n.memoizedState)) : r = e.updateQueue = Uo(i) : null === i && (i = n.updateQueue = Uo(r));
    null === i || r === i ? Vo(r, t) : null === r.lastUpdate || null === i.lastUpdate ? (Vo(r, t), Vo(i, t)) : (Vo(r, t), i.lastUpdate = t)
  }

  function Go(e, t) {
    var n = e.updateQueue;
    null === (n = null === n ? e.updateQueue = zo(e.memoizedState) : $o(e, n)).lastCapturedUpdate ? n.firstCapturedUpdate = n.lastCapturedUpdate = t : (n.lastCapturedUpdate.next = t, n.lastCapturedUpdate = t)
  }

  function $o(e, t) {
    var n = e.alternate;
    return null !== n && t === n.updateQueue && (t = e.updateQueue = Uo(t)), t
  }

  function qo(e, t, n, r, o, s) {
    switch (n.tag) {
      case Fo:
        return "function" == typeof (e = n.payload) ? e.call(s, r, o) : e;
      case 3:
        e.effectTag = -2049 & e.effectTag | 64;
      case 0:
        if (null == (o = "function" == typeof (e = n.payload) ? e.call(s, r, o) : e)) break;
        return i({}, r, o);
      case Bo:
        Ho = !0
    }
    return r
  }

  function Ko(e, t, n, r, i) {
    Ho = !1;
    for (var o = (t = $o(e, t)).baseState, s = null, a = 0, l = t.firstUpdate, c = o; null !== l;) {
      var u = l.expirationTime;
      u < i ? (null === s && (s = l, o = c), a < u && (a = u)) : (c = qo(e, 0, l, c, n, r), null !== l.callback && (e.effectTag |= 32, l.nextEffect = null, null === t.lastEffect ? t.firstEffect = t.lastEffect = l : (t.lastEffect.nextEffect = l, t.lastEffect = l))), l = l.next
    }
    for (u = null, l = t.firstCapturedUpdate; null !== l;) {
      var h = l.expirationTime;
      h < i ? (null === u && (u = l, null === s && (o = c)), a < h && (a = h)) : (c = qo(e, 0, l, c, n, r), null !== l.callback && (e.effectTag |= 32, l.nextEffect = null, null === t.lastCapturedEffect ? t.firstCapturedEffect = t.lastCapturedEffect = l : (t.lastCapturedEffect.nextEffect = l, t.lastCapturedEffect = l))), l = l.next
    }
    null === s && (t.lastUpdate = null), null === u ? t.lastCapturedUpdate = null : e.effectTag |= 32, null === s && null === u && (o = c), t.baseState = o, t.firstUpdate = s, t.firstCapturedUpdate = u, e.expirationTime = a, e.memoizedState = c
  }

  function Yo(e, t, n) {
    null !== t.firstCapturedUpdate && (null !== t.lastUpdate && (t.lastUpdate.next = t.firstCapturedUpdate, t.lastUpdate = t.lastCapturedUpdate), t.firstCapturedUpdate = t.lastCapturedUpdate = null), Qo(t.firstEffect, n), t.firstEffect = t.lastEffect = null, Qo(t.firstCapturedEffect, n), t.firstCapturedEffect = t.lastCapturedEffect = null
  }

  function Qo(e, t) {
    for (; null !== e;) {
      var n = e.callback;
      if (null !== n) {
        e.callback = null;
        var r = t;
        "function" != typeof n && a("191", n), n.call(r)
      }
      e = e.nextEffect
    }
  }

  function Zo(e, t) {
    return {
      value: e,
      source: t,
      stack: ut(t)
    }
  }

  function Xo(e) {
    e.effectTag |= 4
  }
  var Jo, es, ts;
  Jo = function (e, t) {
    for (var n = t.child; null !== n;) {
      if (5 === n.tag || 6 === n.tag) e.appendChild(n.stateNode);
      else if (4 !== n.tag && null !== n.child) {
        n.child.return = n, n = n.child;
        continue
      }
      if (n === t) break;
      for (; null === n.sibling;) {
        if (null === n.return || n.return === t) return;
        n = n.return
      }
      n.sibling.return = n.return, n = n.sibling
    }
  }, es = function (e, t, n, r, o) {
    var s = e.memoizedProps;
    if (s !== r) {
      var a = t.stateNode;
      switch (Ei(bi.current), e = null, n) {
        case "input":
          s = St(a, s), r = St(a, r), e = [];
          break;
        case "option":
          s = Yn(a, s), r = Yn(a, r), e = [];
          break;
        case "select":
          s = i({}, s, {
            value: void 0
          }), r = i({}, r, {
            value: void 0
          }), e = [];
          break;
        case "textarea":
          s = Zn(a, s), r = Zn(a, r), e = [];
          break;
        default:
          "function" != typeof s.onClick && "function" == typeof r.onClick && (a.onclick = gr)
      }
      dr(n, r), a = n = void 0;
      var l = null;
      for (n in s)
        if (!r.hasOwnProperty(n) && s.hasOwnProperty(n) && null != s[n])
          if ("style" === n) {
            var c = s[n];
            for (a in c) c.hasOwnProperty(a) && (l || (l = {}), l[a] = "")
          } else "dangerouslySetInnerHTML" !== n && "children" !== n && "suppressContentEditableWarning" !== n && "suppressHydrationWarning" !== n && "autoFocus" !== n && (S.hasOwnProperty(n) ? e || (e = []) : (e = e || []).push(n, null));
      for (n in r) {
        var u = r[n];
        if (c = null != s ? s[n] : void 0, r.hasOwnProperty(n) && u !== c && (null != u || null != c))
          if ("style" === n)
            if (c) {
              for (a in c) !c.hasOwnProperty(a) || u && u.hasOwnProperty(a) || (l || (l = {}), l[a] = "");
              for (a in u) u.hasOwnProperty(a) && c[a] !== u[a] && (l || (l = {}), l[a] = u[a])
            } else l || (e || (e = []), e.push(n, l)), l = u;
        else "dangerouslySetInnerHTML" === n ? (u = u ? u.__html : void 0, c = c ? c.__html : void 0, null != u && c !== u && (e = e || []).push(n, "" + u)) : "children" === n ? c === u || "string" != typeof u && "number" != typeof u || (e = e || []).push(n, "" + u) : "suppressContentEditableWarning" !== n && "suppressHydrationWarning" !== n && (S.hasOwnProperty(n) ? (null != u && mr(o, n), e || c === u || (e = [])) : (e = e || []).push(n, u))
      }
      l && (e = e || []).push("style", l), o = e, (t.updateQueue = o) && Xo(t)
    }
  }, ts = function (e, t, n, r) {
    n !== r && Xo(t)
  };
  var ns = "function" == typeof WeakSet ? WeakSet : Set;

  function rs(e, t) {
    var n = t.source,
      r = t.stack;
    null === r && null !== n && (r = ut(n)), null !== n && ct(n.type), t = t.value, null !== e && 1 === e.tag && ct(e.type);
    try {
      console.error(t)
    } catch (e) {
      setTimeout((function () {
        throw e
      }))
    }
  }

  function is(e) {
    var t = e.ref;
    if (null !== t)
      if ("function" == typeof t) try {
        t(null)
      } catch (t) {
        zs(e, t)
      } else t.current = null
  }

  function os(e, t, n) {
    if (null !== (n = null !== (n = n.updateQueue) ? n.lastEffect : null)) {
      var r = n = n.next;
      do {
        if (0 != (r.tag & e)) {
          var i = r.destroy;
          r.destroy = void 0, void 0 !== i && i()
        }
        0 != (r.tag & t) && (i = r.create, r.destroy = i()), r = r.next
      } while (r !== n)
    }
  }

  function ss(e) {
    switch ("function" == typeof jr && jr(e), e.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        var t = e.updateQueue;
        if (null !== t && null !== (t = t.lastEffect)) {
          var n = t = t.next;
          do {
            var r = n.destroy;
            if (void 0 !== r) {
              var i = e;
              try {
                r()
              } catch (e) {
                zs(i, e)
              }
            }
            n = n.next
          } while (n !== t)
        }
        break;
      case 1:
        if (is(e), "function" == typeof (t = e.stateNode).componentWillUnmount) try {
          t.props = e.memoizedProps, t.state = e.memoizedState, t.componentWillUnmount()
        } catch (t) {
          zs(e, t)
        }
        break;
      case 5:
        is(e);
        break;
      case 4:
        cs(e)
    }
  }

  function as(e) {
    return 5 === e.tag || 3 === e.tag || 4 === e.tag
  }

  function ls(e) {
    e: {
      for (var t = e.return; null !== t;) {
        if (as(t)) {
          var n = t;
          break e
        }
        t = t.return
      }
      a("160"),
      n = void 0
    }
    var r = t = void 0;
    switch (n.tag) {
      case 5:
        t = n.stateNode, r = !1;
        break;
      case 3:
      case 4:
        t = n.stateNode.containerInfo, r = !0;
        break;
      default:
        a("161")
    }
    16 & n.effectTag && (ar(t, ""), n.effectTag &= -17);e: t: for (n = e;;) {
      for (; null === n.sibling;) {
        if (null === n.return || as(n.return)) {
          n = null;
          break e
        }
        n = n.return
      }
      for (n.sibling.return = n.return, n = n.sibling; 5 !== n.tag && 6 !== n.tag && 18 !== n.tag;) {
        if (2 & n.effectTag) continue t;
        if (null === n.child || 4 === n.tag) continue t;
        n.child.return = n, n = n.child
      }
      if (!(2 & n.effectTag)) {
        n = n.stateNode;
        break e
      }
    }
    for (var i = e;;) {
      if (5 === i.tag || 6 === i.tag)
        if (n)
          if (r) {
            var o = t,
              s = i.stateNode,
              l = n;
            8 === o.nodeType ? o.parentNode.insertBefore(s, l) : o.insertBefore(s, l)
          } else t.insertBefore(i.stateNode, n);
      else r ? (s = t, l = i.stateNode, 8 === s.nodeType ? (o = s.parentNode).insertBefore(l, s) : (o = s).appendChild(l), null != (s = s._reactRootContainer) || null !== o.onclick || (o.onclick = gr)) : t.appendChild(i.stateNode);
      else if (4 !== i.tag && null !== i.child) {
        i.child.return = i, i = i.child;
        continue
      }
      if (i === e) break;
      for (; null === i.sibling;) {
        if (null === i.return || i.return === e) return;
        i = i.return
      }
      i.sibling.return = i.return, i = i.sibling
    }
  }

  function cs(e) {
    for (var t = e, n = !1, r = void 0, i = void 0;;) {
      if (!n) {
        n = t.return;
        e: for (;;) {
          switch (null === n && a("160"), n.tag) {
            case 5:
              r = n.stateNode, i = !1;
              break e;
            case 3:
            case 4:
              r = n.stateNode.containerInfo, i = !0;
              break e
          }
          n = n.return
        }
        n = !0
      }
      if (5 === t.tag || 6 === t.tag) {
        e: for (var o = t, s = o;;)
          if (ss(s), null !== s.child && 4 !== s.tag) s.child.return = s, s = s.child;
          else {
            if (s === o) break;
            for (; null === s.sibling;) {
              if (null === s.return || s.return === o) break e;
              s = s.return
            }
            s.sibling.return = s.return, s = s.sibling
          }i ? (o = r, s = t.stateNode, 8 === o.nodeType ? o.parentNode.removeChild(s) : o.removeChild(s)) : r.removeChild(t.stateNode)
      }
      else if (4 === t.tag) {
        if (null !== t.child) {
          r = t.stateNode.containerInfo, i = !0, t.child.return = t, t = t.child;
          continue
        }
      } else if (ss(t), null !== t.child) {
        t.child.return = t, t = t.child;
        continue
      }
      if (t === e) break;
      for (; null === t.sibling;) {
        if (null === t.return || t.return === e) return;
        4 === (t = t.return).tag && (n = !1)
      }
      t.sibling.return = t.return, t = t.sibling
    }
  }

  function us(e, t) {
    switch (t.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        os(4, 8, t);
        break;
      case 1:
        break;
      case 5:
        var n = t.stateNode;
        if (null != n) {
          var r = t.memoizedProps;
          e = null !== e ? e.memoizedProps : r;
          var i = t.type,
            o = t.updateQueue;
          t.updateQueue = null, null !== o && function (e, t, n, r, i) {
            e[N] = i, "input" === n && "radio" === i.type && null != i.name && Et(e, i), fr(n, r), r = fr(n, i);
            for (var o = 0; o < t.length; o += 2) {
              var s = t[o],
                a = t[o + 1];
              "style" === s ? hr(e, a) : "dangerouslySetInnerHTML" === s ? sr(e, a) : "children" === s ? ar(e, a) : wt(e, s, a, r)
            }
            switch (n) {
              case "input":
                kt(e, i);
                break;
              case "textarea":
                Jn(e, i);
                break;
              case "select":
                t = e._wrapperState.wasMultiple, e._wrapperState.wasMultiple = !!i.multiple, null != (n = i.value) ? Qn(e, !!i.multiple, n, !1) : t !== !!i.multiple && (null != i.defaultValue ? Qn(e, !!i.multiple, i.defaultValue, !0) : Qn(e, !!i.multiple, i.multiple ? [] : "", !1))
            }
          }(n, o, i, e, r)
        }
        break;
      case 6:
        null === t.stateNode && a("162"), t.stateNode.nodeValue = t.memoizedProps;
        break;
      case 3:
      case 12:
        break;
      case 13:
        if (n = t.memoizedState, r = void 0, e = t, null === n ? r = !1 : (r = !0, e = t.child, 0 === n.timedOutAt && (n.timedOutAt = ga())), null !== e && function (e, t) {
            for (var n = e;;) {
              if (5 === n.tag) {
                var r = n.stateNode;
                if (t) r.style.display = "none";
                else {
                  r = n.stateNode;
                  var i = n.memoizedProps.style;
                  i = null != i && i.hasOwnProperty("display") ? i.display : null, r.style.display = ur("display", i)
                }
              } else if (6 === n.tag) n.stateNode.nodeValue = t ? "" : n.memoizedProps;
              else {
                if (13 === n.tag && null !== n.memoizedState) {
                  (r = n.child.sibling).return = n, n = r;
                  continue
                }
                if (null !== n.child) {
                  n.child.return = n, n = n.child;
                  continue
                }
              }
              if (n === e) break;
              for (; null === n.sibling;) {
                if (null === n.return || n.return === e) return;
                n = n.return
              }
              n.sibling.return = n.return, n = n.sibling
            }
          }(e, r), null !== (n = t.updateQueue)) {
          t.updateQueue = null;
          var s = t.stateNode;
          null === s && (s = t.stateNode = new ns), n.forEach((function (e) {
            var n = Vs.bind(null, t, e);
            s.has(e) || (s.add(e), e.then(n, n))
          }))
        }
        break;
      case 17:
        break;
      default:
        a("163")
    }
  }
  var hs = "function" == typeof WeakMap ? WeakMap : Map;

  function ps(e, t, n) {
    (n = Wo(n)).tag = 3, n.payload = {
      element: null
    };
    var r = t.value;
    return n.callback = function () {
      Ta(r), rs(e, t)
    }, n
  }

  function ds(e, t, n) {
    (n = Wo(n)).tag = 3;
    var r = e.type.getDerivedStateFromError;
    if ("function" == typeof r) {
      var i = t.value;
      n.payload = function () {
        return r(i)
      }
    }
    var o = e.stateNode;
    return null !== o && "function" == typeof o.componentDidCatch && (n.callback = function () {
      "function" != typeof r && (null === _s ? _s = new Set([this]) : _s.add(this));
      var n = t.value,
        i = t.stack;
      rs(e, t), this.componentDidCatch(n, {
        componentStack: null !== i ? i : ""
      })
    }), n
  }

  function fs(e) {
    switch (e.tag) {
      case 1:
        Nr(e.type) && Fr();
        var t = e.effectTag;
        return 2048 & t ? (e.effectTag = -2049 & t | 64, e) : null;
      case 3:
        return xi(), Br(), 0 != (64 & (t = e.effectTag)) && a("285"), e.effectTag = -2049 & t | 64, e;
      case 5:
        return Ri(e), null;
      case 13:
        return 2048 & (t = e.effectTag) ? (e.effectTag = -2049 & t | 64, e) : null;
      case 18:
        return null;
      case 4:
        return xi(), null;
      case 10:
        return Oo(e), null;
      default:
        return null
    }
  }
  var ms = $e.ReactCurrentDispatcher,
    gs = $e.ReactCurrentOwner,
    ys = 1073741822,
    vs = !1,
    ws = null,
    bs = null,
    Ss = 0,
    Cs = -1,
    Es = !1,
    ks = null,
    xs = !1,
    Ts = null,
    Rs = null,
    Ds = null,
    _s = null;

  function As() {
    if (null !== ws)
      for (var e = ws.return; null !== e;) {
        var t = e;
        switch (t.tag) {
          case 1:
            var n = t.type.childContextTypes;
            null != n && Fr();
            break;
          case 3:
            xi(), Br();
            break;
          case 5:
            Ri(t);
            break;
          case 4:
            xi();
            break;
          case 10:
            Oo(t)
        }
        e = e.return
      }
    bs = null, Ss = 0, Cs = -1, Es = !1, ws = null
  }

  function Ms() {
    for (; null !== ks;) {
      var e = ks.effectTag;
      if (16 & e && ar(ks.stateNode, ""), 128 & e) {
        var t = ks.alternate;
        null !== t && (null !== (t = t.ref) && ("function" == typeof t ? t(null) : t.current = null))
      }
      switch (14 & e) {
        case 2:
          ls(ks), ks.effectTag &= -3;
          break;
        case 6:
          ls(ks), ks.effectTag &= -3, us(ks.alternate, ks);
          break;
        case 4:
          us(ks.alternate, ks);
          break;
        case 8:
          cs(e = ks), e.return = null, e.child = null, e.memoizedState = null, e.updateQueue = null, null !== (e = e.alternate) && (e.return = null, e.child = null, e.memoizedState = null, e.updateQueue = null)
      }
      ks = ks.nextEffect
    }
  }

  function Ps() {
    for (; null !== ks;) {
      if (256 & ks.effectTag) e: {
        var e = ks.alternate,
          t = ks;
        switch (t.tag) {
          case 0:
          case 11:
          case 15:
            os(2, 0, t);
            break e;
          case 1:
            if (256 & t.effectTag && null !== e) {
              var n = e.memoizedProps,
                r = e.memoizedState;
              t = (e = t.stateNode).getSnapshotBeforeUpdate(t.elementType === t.type ? n : oi(t.type, n), r), e.__reactInternalSnapshotBeforeUpdate = t
            }
            break e;
          case 3:
          case 5:
          case 6:
          case 4:
          case 17:
            break e;
          default:
            a("163")
        }
      }
      ks = ks.nextEffect
    }
  }

  function Is(e, t) {
    for (; null !== ks;) {
      var n = ks.effectTag;
      if (36 & n) {
        var r = ks.alternate,
          i = ks,
          o = t;
        switch (i.tag) {
          case 0:
          case 11:
          case 15:
            os(16, 32, i);
            break;
          case 1:
            var s = i.stateNode;
            if (4 & i.effectTag)
              if (null === r) s.componentDidMount();
              else {
                var l = i.elementType === i.type ? r.memoizedProps : oi(i.type, r.memoizedProps);
                s.componentDidUpdate(l, r.memoizedState, s.__reactInternalSnapshotBeforeUpdate)
              } null !== (r = i.updateQueue) && Yo(0, r, s);
            break;
          case 3:
            if (null !== (r = i.updateQueue)) {
              if (s = null, null !== i.child) switch (i.child.tag) {
                case 5:
                  s = i.child.stateNode;
                  break;
                case 1:
                  s = i.child.stateNode
              }
              Yo(0, r, s)
            }
            break;
          case 5:
            o = i.stateNode, null === r && 4 & i.effectTag && wr(i.type, i.memoizedProps) && o.focus();
            break;
          case 6:
          case 4:
          case 12:
          case 13:
          case 17:
            break;
          default:
            a("163")
        }
      }
      128 & n && (null !== (i = ks.ref) && (o = ks.stateNode, "function" == typeof i ? i(o) : i.current = o)), 512 & n && (Ts = e), ks = ks.nextEffect
    }
  }

  function Os(e, t) {
    Ds = Rs = Ts = null;
    var n = Zs;
    Zs = !0;
    do {
      if (512 & t.effectTag) {
        var r = !1,
          i = void 0;
        try {
          var o = t;
          os(128, 0, o), os(0, 64, o)
        } catch (e) {
          r = !0, i = e
        }
        r && zs(t, i)
      }
      t = t.nextEffect
    } while (null !== t);
    Zs = n, 0 !== (n = e.expirationTime) && ya(e, n), ra || Zs || Ca(1073741823, !1)
  }

  function Ls() {
    null !== Rs && kr(Rs), null !== Ds && Ds()
  }

  function Ns(e, t) {
    xs = vs = !0, e.current === t && a("177");
    var n = e.pendingCommitExpirationTime;
    0 === n && a("261"), e.pendingCommitExpirationTime = 0;
    var r = t.expirationTime,
      i = t.childExpirationTime;
    for (function (e, t) {
        if (e.didError = !1, 0 === t) e.earliestPendingTime = 0, e.latestPendingTime = 0, e.earliestSuspendedTime = 0, e.latestSuspendedTime = 0, e.latestPingedTime = 0;
        else {
          t < e.latestPingedTime && (e.latestPingedTime = 0);
          var n = e.latestPendingTime;
          0 !== n && (n > t ? e.earliestPendingTime = e.latestPendingTime = 0 : e.earliestPendingTime > t && (e.earliestPendingTime = e.latestPendingTime)), 0 === (n = e.earliestSuspendedTime) ? ti(e, t) : t < e.latestSuspendedTime ? (e.earliestSuspendedTime = 0, e.latestSuspendedTime = 0, e.latestPingedTime = 0, ti(e, t)) : t > n && ti(e, t)
        }
        ii(0, e)
      }(e, i > r ? i : r), gs.current = null, r = void 0, 1 < t.effectTag ? null !== t.lastEffect ? (t.lastEffect.nextEffect = t, r = t.firstEffect) : r = t : r = t.firstEffect, yr = Tn, vr = function () {
        var e = Bn();
        if (Hn(e)) {
          if ("selectionStart" in e) var t = {
            start: e.selectionStart,
            end: e.selectionEnd
          };
          else e: {
            var n = (t = (t = e.ownerDocument) && t.defaultView || window).getSelection && t.getSelection();
            if (n && 0 !== n.rangeCount) {
              t = n.anchorNode;
              var r = n.anchorOffset,
                i = n.focusNode;
              n = n.focusOffset;
              try {
                t.nodeType, i.nodeType
              } catch (e) {
                t = null;
                break e
              }
              var o = 0,
                s = -1,
                a = -1,
                l = 0,
                c = 0,
                u = e,
                h = null;
              t: for (;;) {
                for (var p; u !== t || 0 !== r && 3 !== u.nodeType || (s = o + r), u !== i || 0 !== n && 3 !== u.nodeType || (a = o + n), 3 === u.nodeType && (o += u.nodeValue.length), null !== (p = u.firstChild);) h = u, u = p;
                for (;;) {
                  if (u === e) break t;
                  if (h === t && ++l === r && (s = o), h === i && ++c === n && (a = o), null !== (p = u.nextSibling)) break;
                  h = (u = h).parentNode
                }
                u = p
              }
              t = -1 === s || -1 === a ? null : {
                start: s,
                end: a
              }
            } else t = null
          }
          t = t || {
            start: 0,
            end: 0
          }
        } else t = null;
        return {
          focusedElem: e,
          selectionRange: t
        }
      }(), Tn = !1, ks = r; null !== ks;) {
      i = !1;
      var s = void 0;
      try {
        Ps()
      } catch (e) {
        i = !0, s = e
      }
      i && (null === ks && a("178"), zs(ks, s), null !== ks && (ks = ks.nextEffect))
    }
    for (ks = r; null !== ks;) {
      i = !1, s = void 0;
      try {
        Ms()
      } catch (e) {
        i = !0, s = e
      }
      i && (null === ks && a("178"), zs(ks, s), null !== ks && (ks = ks.nextEffect))
    }
    for (zn(vr), vr = null, Tn = !!yr, yr = null, e.current = t, ks = r; null !== ks;) {
      i = !1, s = void 0;
      try {
        Is(e, n)
      } catch (e) {
        i = !0, s = e
      }
      i && (null === ks && a("178"), zs(ks, s), null !== ks && (ks = ks.nextEffect))
    }
    if (null !== r && null !== Ts) {
      var l = Os.bind(null, e, r);
      Rs = o.unstable_runWithPriority(o.unstable_NormalPriority, (function () {
        return Er(l)
      })), Ds = l
    }
    vs = xs = !1, "function" == typeof Vr && Vr(t.stateNode), n = t.expirationTime, 0 === (t = (t = t.childExpirationTime) > n ? t : n) && (_s = null),
      function (e, t) {
        e.expirationTime = t, e.finishedWork = null
      }(e, t)
  }

  function Fs(e) {
    for (;;) {
      var t = e.alternate,
        n = e.return,
        r = e.sibling;
      if (0 == (1024 & e.effectTag)) {
        ws = e;
        e: {
          var o = t,
            s = Ss,
            l = (t = e).pendingProps;
          switch (t.tag) {
            case 2:
            case 16:
              break;
            case 15:
            case 0:
              break;
            case 1:
              Nr(t.type) && Fr();
              break;
            case 3:
              xi(), Br(), (l = t.stateNode).pendingContext && (l.context = l.pendingContext, l.pendingContext = null), null !== o && null !== o.child || (po(t), t.effectTag &= -3);
              break;
            case 5:
              Ri(t);
              var c = Ei(Ci.current);
              if (s = t.type, null !== o && null != t.stateNode) es(o, t, s, l, c), o.ref !== t.ref && (t.effectTag |= 128);
              else if (l) {
                var u = Ei(bi.current);
                if (po(t)) {
                  o = (l = t).stateNode;
                  var h = l.type,
                    p = l.memoizedProps,
                    d = c;
                  switch (o[L] = l, o[N] = p, s = void 0, c = h) {
                    case "iframe":
                    case "object":
                      Rn("load", o);
                      break;
                    case "video":
                    case "audio":
                      for (h = 0; h < re.length; h++) Rn(re[h], o);
                      break;
                    case "source":
                      Rn("error", o);
                      break;
                    case "img":
                    case "image":
                    case "link":
                      Rn("error", o), Rn("load", o);
                      break;
                    case "form":
                      Rn("reset", o), Rn("submit", o);
                      break;
                    case "details":
                      Rn("toggle", o);
                      break;
                    case "input":
                      Ct(o, p), Rn("invalid", o), mr(d, "onChange");
                      break;
                    case "select":
                      o._wrapperState = {
                        wasMultiple: !!p.multiple
                      }, Rn("invalid", o), mr(d, "onChange");
                      break;
                    case "textarea":
                      Xn(o, p), Rn("invalid", o), mr(d, "onChange")
                  }
                  for (s in dr(c, p), h = null, p) p.hasOwnProperty(s) && (u = p[s], "children" === s ? "string" == typeof u ? o.textContent !== u && (h = ["children", u]) : "number" == typeof u && o.textContent !== "" + u && (h = ["children", "" + u]) : S.hasOwnProperty(s) && null != u && mr(d, s));
                  switch (c) {
                    case "input":
                      je(o), xt(o, p, !0);
                      break;
                    case "textarea":
                      je(o), er(o);
                      break;
                    case "select":
                    case "option":
                      break;
                    default:
                      "function" == typeof p.onClick && (o.onclick = gr)
                  }
                  s = h, l.updateQueue = s, (l = null !== s) && Xo(t)
                } else {
                  p = t, o = s, d = l, h = 9 === c.nodeType ? c : c.ownerDocument, u === tr && (u = rr(o)), u === tr ? "script" === o ? ((o = h.createElement("div")).innerHTML = "<script><\/script>", h = o.removeChild(o.firstChild)) : "string" == typeof d.is ? h = h.createElement(o, {
                    is: d.is
                  }) : (h = h.createElement(o), "select" === o && d.multiple && (h.multiple = !0)) : h = h.createElementNS(u, o), (o = h)[L] = p, o[N] = l, Jo(o, t), d = o;
                  var f = c,
                    m = fr(h = s, p = l);
                  switch (h) {
                    case "iframe":
                    case "object":
                      Rn("load", d), c = p;
                      break;
                    case "video":
                    case "audio":
                      for (c = 0; c < re.length; c++) Rn(re[c], d);
                      c = p;
                      break;
                    case "source":
                      Rn("error", d), c = p;
                      break;
                    case "img":
                    case "image":
                    case "link":
                      Rn("error", d), Rn("load", d), c = p;
                      break;
                    case "form":
                      Rn("reset", d), Rn("submit", d), c = p;
                      break;
                    case "details":
                      Rn("toggle", d), c = p;
                      break;
                    case "input":
                      Ct(d, p), c = St(d, p), Rn("invalid", d), mr(f, "onChange");
                      break;
                    case "option":
                      c = Yn(d, p);
                      break;
                    case "select":
                      d._wrapperState = {
                        wasMultiple: !!p.multiple
                      }, c = i({}, p, {
                        value: void 0
                      }), Rn("invalid", d), mr(f, "onChange");
                      break;
                    case "textarea":
                      Xn(d, p), c = Zn(d, p), Rn("invalid", d), mr(f, "onChange");
                      break;
                    default:
                      c = p
                  }
                  dr(h, c), u = void 0;
                  var g = h,
                    y = d,
                    v = c;
                  for (u in v)
                    if (v.hasOwnProperty(u)) {
                      var w = v[u];
                      "style" === u ? hr(y, w) : "dangerouslySetInnerHTML" === u ? null != (w = w ? w.__html : void 0) && sr(y, w) : "children" === u ? "string" == typeof w ? ("textarea" !== g || "" !== w) && ar(y, w) : "number" == typeof w && ar(y, "" + w) : "suppressContentEditableWarning" !== u && "suppressHydrationWarning" !== u && "autoFocus" !== u && (S.hasOwnProperty(u) ? null != w && mr(f, u) : null != w && wt(y, u, w, m))
                    } switch (h) {
                    case "input":
                      je(d), xt(d, p, !1);
                      break;
                    case "textarea":
                      je(d), er(d);
                      break;
                    case "option":
                      null != p.value && d.setAttribute("value", "" + bt(p.value));
                      break;
                    case "select":
                      (c = d).multiple = !!p.multiple, null != (d = p.value) ? Qn(c, !!p.multiple, d, !1) : null != p.defaultValue && Qn(c, !!p.multiple, p.defaultValue, !0);
                      break;
                    default:
                      "function" == typeof c.onClick && (d.onclick = gr)
                  }(l = wr(s, l)) && Xo(t), t.stateNode = o
                }
                null !== t.ref && (t.effectTag |= 128)
              } else null === t.stateNode && a("166");
              break;
            case 6:
              o && null != t.stateNode ? ts(0, t, o.memoizedProps, l) : ("string" != typeof l && (null === t.stateNode && a("166")), o = Ei(Ci.current), Ei(bi.current), po(t) ? (s = (l = t).stateNode, o = l.memoizedProps, s[L] = l, (l = s.nodeValue !== o) && Xo(t)) : (s = t, (l = (9 === o.nodeType ? o : o.ownerDocument).createTextNode(l))[L] = t, s.stateNode = l));
              break;
            case 11:
              break;
            case 13:
              if (l = t.memoizedState, 0 != (64 & t.effectTag)) {
                t.expirationTime = s, ws = t;
                break e
              }
              l = null !== l, s = null !== o && null !== o.memoizedState, null !== o && !l && s && (null !== (o = o.child.sibling) && (null !== (c = t.firstEffect) ? (t.firstEffect = o, o.nextEffect = c) : (t.firstEffect = t.lastEffect = o, o.nextEffect = null), o.effectTag = 8)), (l || s) && (t.effectTag |= 4);
              break;
            case 7:
            case 8:
            case 12:
              break;
            case 4:
              xi();
              break;
            case 10:
              Oo(t);
              break;
            case 9:
            case 14:
              break;
            case 17:
              Nr(t.type) && Fr();
              break;
            case 18:
              break;
            default:
              a("156")
          }
          ws = null
        }
        if (t = e, 1 === Ss || 1 !== t.childExpirationTime) {
          for (l = 0, s = t.child; null !== s;)(o = s.expirationTime) > l && (l = o), (c = s.childExpirationTime) > l && (l = c), s = s.sibling;
          t.childExpirationTime = l
        }
        if (null !== ws) return ws;
        null !== n && 0 == (1024 & n.effectTag) && (null === n.firstEffect && (n.firstEffect = e.firstEffect), null !== e.lastEffect && (null !== n.lastEffect && (n.lastEffect.nextEffect = e.firstEffect), n.lastEffect = e.lastEffect), 1 < e.effectTag && (null !== n.lastEffect ? n.lastEffect.nextEffect = e : n.firstEffect = e, n.lastEffect = e))
      } else {
        if (null !== (e = fs(e))) return e.effectTag &= 1023, e;
        null !== n && (n.firstEffect = n.lastEffect = null, n.effectTag |= 1024)
      }
      if (null !== r) return r;
      if (null === n) break;
      e = n
    }
    return null
  }

  function Bs(e) {
    var t = Do(e.alternate, e, Ss);
    return e.memoizedProps = e.pendingProps, null === t && (t = Fs(e)), gs.current = null, t
  }

  function Hs(e, t) {
    vs && a("243"), Ls(), vs = !0;
    var n = ms.current;
    ms.current = no;
    var r = e.nextExpirationTimeToWorkOn;
    r === Ss && e === bs && null !== ws || (As(), Ss = r, ws = Yr((bs = e).current, null), e.pendingCommitExpirationTime = 0);
    for (var i = !1;;) {
      try {
        if (t)
          for (; null !== ws && !ba();) ws = Bs(ws);
        else
          for (; null !== ws;) ws = Bs(ws)
      } catch (t) {
        if (Po = Mo = Ao = null, Gi(), null === ws) i = !0, Ta(t);
        else {
          null === ws && a("271");
          var o = ws,
            s = o.return;
          if (null !== s) {
            e: {
              var l = e,
                c = s,
                u = o,
                h = t;
              if (s = Ss, u.effectTag |= 1024, u.firstEffect = u.lastEffect = null, null !== h && "object" == typeof h && "function" == typeof h.then) {
                var p = h;
                h = c;
                var d = -1,
                  f = -1;
                do {
                  if (13 === h.tag) {
                    var m = h.alternate;
                    if (null !== m && null !== (m = m.memoizedState)) {
                      f = 10 * (1073741822 - m.timedOutAt);
                      break
                    }
                    "number" == typeof (m = h.pendingProps.maxDuration) && (0 >= m ? d = 0 : (-1 === d || m < d) && (d = m))
                  }
                  h = h.return
                } while (null !== h);
                h = c;
                do {
                  if ((m = 13 === h.tag) && (m = void 0 !== h.memoizedProps.fallback && null === h.memoizedState), m) {
                    if (null === (c = h.updateQueue) ? ((c = new Set).add(p), h.updateQueue = c) : c.add(p), 0 == (1 & h.mode)) {
                      h.effectTag |= 64, u.effectTag &= -1957, 1 === u.tag && (null === u.alternate ? u.tag = 17 : ((s = Wo(1073741823)).tag = Bo, jo(u, s))), u.expirationTime = 1073741823;
                      break e
                    }
                    c = s;
                    var g = (u = l).pingCache;
                    null === g ? (g = u.pingCache = new hs, m = new Set, g.set(p, m)) : void 0 === (m = g.get(p)) && (m = new Set, g.set(p, m)), m.has(c) || (m.add(c), u = Ws.bind(null, u, p, c), p.then(u, u)), -1 === d ? l = 1073741823 : (-1 === f && (f = 10 * (1073741822 - ri(l, s)) - 5e3), l = f + d), 0 <= l && Cs < l && (Cs = l), h.effectTag |= 2048, h.expirationTime = s;
                    break e
                  }
                  h = h.return
                } while (null !== h);
                h = Error((ct(u.type) || "A React component") + " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display." + ut(u))
              }
              Es = !0,
              h = Zo(h, u),
              l = c;do {
                switch (l.tag) {
                  case 3:
                    l.effectTag |= 2048, l.expirationTime = s, Go(l, s = ps(l, h, s));
                    break e;
                  case 1:
                    if (d = h, f = l.type, u = l.stateNode, 0 == (64 & l.effectTag) && ("function" == typeof f.getDerivedStateFromError || null !== u && "function" == typeof u.componentDidCatch && (null === _s || !_s.has(u)))) {
                      l.effectTag |= 2048, l.expirationTime = s, Go(l, s = ds(l, d, s));
                      break e
                    }
                }
                l = l.return
              } while (null !== l)
            }
            ws = Fs(o);
            continue
          }
          i = !0, Ta(t)
        }
      }
      break
    }
    if (vs = !1, ms.current = n, Po = Mo = Ao = null, Gi(), i) bs = null, e.finishedWork = null;
    else if (null !== ws) e.finishedWork = null;
    else {
      if (null === (n = e.current.alternate) && a("281"), bs = null, Es) {
        if (i = e.latestPendingTime, o = e.latestSuspendedTime, s = e.latestPingedTime, 0 !== i && i < r || 0 !== o && o < r || 0 !== s && s < r) return ni(e, r), void fa(e, n, r, e.expirationTime, -1);
        if (!e.didError && t) return e.didError = !0, r = e.nextExpirationTimeToWorkOn = r, t = e.expirationTime = 1073741823, void fa(e, n, r, t, -1)
      }
      t && -1 !== Cs ? (ni(e, r), (t = 10 * (1073741822 - ri(e, r))) < Cs && (Cs = t), t = 10 * (1073741822 - ga()), t = Cs - t, fa(e, n, r, e.expirationTime, 0 > t ? 0 : t)) : (e.pendingCommitExpirationTime = r, e.finishedWork = n)
    }
  }

  function zs(e, t) {
    for (var n = e.return; null !== n;) {
      switch (n.tag) {
        case 1:
          var r = n.stateNode;
          if ("function" == typeof n.type.getDerivedStateFromError || "function" == typeof r.componentDidCatch && (null === _s || !_s.has(r))) return jo(n, e = ds(n, e = Zo(t, e), 1073741823)), void Gs(n, 1073741823);
          break;
        case 3:
          return jo(n, e = ps(n, e = Zo(t, e), 1073741823)), void Gs(n, 1073741823)
      }
      n = n.return
    }
    3 === e.tag && (jo(e, n = ps(e, n = Zo(t, e), 1073741823)), Gs(e, 1073741823))
  }

  function Us(e, t) {
    var n = o.unstable_getCurrentPriorityLevel(),
      r = void 0;
    if (0 == (1 & t.mode)) r = 1073741823;
    else if (vs && !xs) r = Ss;
    else {
      switch (n) {
        case o.unstable_ImmediatePriority:
          r = 1073741823;
          break;
        case o.unstable_UserBlockingPriority:
          r = 1073741822 - 10 * (1 + ((1073741822 - e + 15) / 10 | 0));
          break;
        case o.unstable_NormalPriority:
          r = 1073741822 - 25 * (1 + ((1073741822 - e + 500) / 25 | 0));
          break;
        case o.unstable_LowPriority:
        case o.unstable_IdlePriority:
          r = 1;
          break;
        default:
          a("313")
      }
      null !== bs && r === Ss && --r
    }
    return n === o.unstable_UserBlockingPriority && (0 === ea || r < ea) && (ea = r), r
  }

  function Ws(e, t, n) {
    var r = e.pingCache;
    null !== r && r.delete(t), null !== bs && Ss === n ? bs = null : (t = e.earliestSuspendedTime, r = e.latestSuspendedTime, 0 !== t && n <= t && n >= r && (e.didError = !1, (0 === (t = e.latestPingedTime) || t > n) && (e.latestPingedTime = n), ii(n, e), 0 !== (n = e.expirationTime) && ya(e, n)))
  }

  function Vs(e, t) {
    var n = e.stateNode;
    null !== n && n.delete(t), null !== (e = js(e, t = Us(t = ga(), e))) && (ti(e, t), 0 !== (t = e.expirationTime) && ya(e, t))
  }

  function js(e, t) {
    e.expirationTime < t && (e.expirationTime = t);
    var n = e.alternate;
    null !== n && n.expirationTime < t && (n.expirationTime = t);
    var r = e.return,
      i = null;
    if (null === r && 3 === e.tag) i = e.stateNode;
    else
      for (; null !== r;) {
        if (n = r.alternate, r.childExpirationTime < t && (r.childExpirationTime = t), null !== n && n.childExpirationTime < t && (n.childExpirationTime = t), null === r.return && 3 === r.tag) {
          i = r.stateNode;
          break
        }
        r = r.return
      }
    return i
  }

  function Gs(e, t) {
    null !== (e = js(e, t)) && (!vs && 0 !== Ss && t > Ss && As(), ti(e, t), vs && !xs && bs === e || ya(e, e.expirationTime), ua > ca && (ua = 0, a("185")))
  }

  function $s(e, t, n, r, i) {
    return o.unstable_runWithPriority(o.unstable_ImmediatePriority, (function () {
      return e(t, n, r, i)
    }))
  }
  var qs = null,
    Ks = null,
    Ys = 0,
    Qs = void 0,
    Zs = !1,
    Xs = null,
    Js = 0,
    ea = 0,
    ta = !1,
    na = null,
    ra = !1,
    ia = !1,
    oa = null,
    sa = o.unstable_now(),
    aa = 1073741822 - (sa / 10 | 0),
    la = aa,
    ca = 50,
    ua = 0,
    ha = null;

  function pa() {
    aa = 1073741822 - ((o.unstable_now() - sa) / 10 | 0)
  }

  function da(e, t) {
    if (0 !== Ys) {
      if (t < Ys) return;
      null !== Qs && o.unstable_cancelCallback(Qs)
    }
    Ys = t, e = o.unstable_now() - sa, Qs = o.unstable_scheduleCallback(Sa, {
      timeout: 10 * (1073741822 - t) - e
    })
  }

  function fa(e, t, n, r, i) {
    e.expirationTime = r, 0 !== i || ba() ? 0 < i && (e.timeoutHandle = Sr(ma.bind(null, e, t, n), i)) : (e.pendingCommitExpirationTime = n, e.finishedWork = t)
  }

  function ma(e, t, n) {
    e.pendingCommitExpirationTime = n, e.finishedWork = t, pa(), la = aa, Ea(e, n)
  }

  function ga() {
    return Zs || (va(), 0 !== Js && 1 !== Js || (pa(), la = aa)), la
  }

  function ya(e, t) {
    null === e.nextScheduledRoot ? (e.expirationTime = t, null === Ks ? (qs = Ks = e, e.nextScheduledRoot = e) : (Ks = Ks.nextScheduledRoot = e).nextScheduledRoot = qs) : t > e.expirationTime && (e.expirationTime = t), Zs || (ra ? ia && (Xs = e, Js = 1073741823, ka(e, 1073741823, !1)) : 1073741823 === t ? Ca(1073741823, !1) : da(e, t))
  }

  function va() {
    var e = 0,
      t = null;
    if (null !== Ks)
      for (var n = Ks, r = qs; null !== r;) {
        var i = r.expirationTime;
        if (0 === i) {
          if ((null === n || null === Ks) && a("244"), r === r.nextScheduledRoot) {
            qs = Ks = r.nextScheduledRoot = null;
            break
          }
          if (r === qs) qs = i = r.nextScheduledRoot, Ks.nextScheduledRoot = i, r.nextScheduledRoot = null;
          else {
            if (r === Ks) {
              (Ks = n).nextScheduledRoot = qs, r.nextScheduledRoot = null;
              break
            }
            n.nextScheduledRoot = r.nextScheduledRoot, r.nextScheduledRoot = null
          }
          r = n.nextScheduledRoot
        } else {
          if (i > e && (e = i, t = r), r === Ks) break;
          if (1073741823 === e) break;
          n = r, r = r.nextScheduledRoot
        }
      }
    Xs = t, Js = e
  }
  var wa = !1;

  function ba() {
    return !!wa || !!o.unstable_shouldYield() && (wa = !0)
  }

  function Sa() {
    try {
      if (!ba() && null !== qs) {
        pa();
        var e = qs;
        do {
          var t = e.expirationTime;
          0 !== t && aa <= t && (e.nextExpirationTimeToWorkOn = aa), e = e.nextScheduledRoot
        } while (e !== qs)
      }
      Ca(0, !0)
    } finally {
      wa = !1
    }
  }

  function Ca(e, t) {
    if (va(), t)
      for (pa(), la = aa; null !== Xs && 0 !== Js && e <= Js && !(wa && aa > Js);) ka(Xs, Js, aa > Js), va(), pa(), la = aa;
    else
      for (; null !== Xs && 0 !== Js && e <= Js;) ka(Xs, Js, !1), va();
    if (t && (Ys = 0, Qs = null), 0 !== Js && da(Xs, Js), ua = 0, ha = null, null !== oa)
      for (e = oa, oa = null, t = 0; t < e.length; t++) {
        var n = e[t];
        try {
          n._onComplete()
        } catch (e) {
          ta || (ta = !0, na = e)
        }
      }
    if (ta) throw e = na, na = null, ta = !1, e
  }

  function Ea(e, t) {
    Zs && a("253"), Xs = e, Js = t, ka(e, t, !1), Ca(1073741823, !1)
  }

  function ka(e, t, n) {
    if (Zs && a("245"), Zs = !0, n) {
      var r = e.finishedWork;
      null !== r ? xa(e, r, t) : (e.finishedWork = null, -1 !== (r = e.timeoutHandle) && (e.timeoutHandle = -1, Cr(r)), Hs(e, n), null !== (r = e.finishedWork) && (ba() ? e.finishedWork = r : xa(e, r, t)))
    } else null !== (r = e.finishedWork) ? xa(e, r, t) : (e.finishedWork = null, -1 !== (r = e.timeoutHandle) && (e.timeoutHandle = -1, Cr(r)), Hs(e, n), null !== (r = e.finishedWork) && xa(e, r, t));
    Zs = !1
  }

  function xa(e, t, n) {
    var r = e.firstBatch;
    if (null !== r && r._expirationTime >= n && (null === oa ? oa = [r] : oa.push(r), r._defer)) return e.finishedWork = t, void(e.expirationTime = 0);
    e.finishedWork = null, e === ha ? ua++ : (ha = e, ua = 0), o.unstable_runWithPriority(o.unstable_ImmediatePriority, (function () {
      Ns(e, t)
    }))
  }

  function Ta(e) {
    null === Xs && a("246"), Xs.expirationTime = 0, ta || (ta = !0, na = e)
  }

  function Ra(e, t) {
    var n = ra;
    ra = !0;
    try {
      return e(t)
    } finally {
      (ra = n) || Zs || Ca(1073741823, !1)
    }
  }

  function Da(e, t) {
    if (ra && !ia) {
      ia = !0;
      try {
        return e(t)
      } finally {
        ia = !1
      }
    }
    return e(t)
  }

  function _a(e, t, n) {
    ra || Zs || 0 === ea || (Ca(ea, !1), ea = 0);
    var r = ra;
    ra = !0;
    try {
      return o.unstable_runWithPriority(o.unstable_UserBlockingPriority, (function () {
        return e(t, n)
      }))
    } finally {
      (ra = r) || Zs || Ca(1073741823, !1)
    }
  }

  function Aa(e, t, n, r, i) {
    var o = t.current;
    e: if (n) {
      t: {
        2 === rn(n = n._reactInternalFiber) && 1 === n.tag || a("170");
        var s = n;do {
          switch (s.tag) {
            case 3:
              s = s.stateNode.context;
              break t;
            case 1:
              if (Nr(s.type)) {
                s = s.stateNode.__reactInternalMemoizedMergedChildContext;
                break t
              }
          }
          s = s.return
        } while (null !== s);a("171"),
        s = void 0
      }
      if (1 === n.tag) {
        var l = n.type;
        if (Nr(l)) {
          n = zr(n, l, s);
          break e
        }
      }
      n = s
    }
    else n = Mr;
    return null === t.context ? t.context = n : t.pendingContext = n, t = i, (i = Wo(r)).payload = {
      element: e
    }, null !== (t = void 0 === t ? null : t) && (i.callback = t), Ls(), jo(o, i), Gs(o, r), r
  }

  function Ma(e, t, n, r) {
    var i = t.current;
    return Aa(e, t, n, i = Us(ga(), i), r)
  }

  function Pa(e) {
    if (!(e = e.current).child) return null;
    switch (e.child.tag) {
      case 5:
      default:
        return e.child.stateNode
    }
  }

  function Ia(e, t, n) {
    var r = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
    return {
      $$typeof: Qe,
      key: null == r ? null : "" + r,
      children: e,
      containerInfo: t,
      implementation: n
    }
  }

  function Oa(e) {
    var t = 1073741822 - 25 * (1 + ((1073741822 - ga() + 500) / 25 | 0));
    t >= ys && (t = ys - 1), this._expirationTime = ys = t, this._root = e, this._callbacks = this._next = null, this._hasChildren = this._didComplete = !1, this._children = null, this._defer = !0
  }

  function La() {
    this._callbacks = null, this._didCommit = !1, this._onCommit = this._onCommit.bind(this)
  }

  function Na(e, t, n) {
    e = {
      current: t = qr(3, null, null, t ? 3 : 0),
      containerInfo: e,
      pendingChildren: null,
      pingCache: null,
      earliestPendingTime: 0,
      latestPendingTime: 0,
      earliestSuspendedTime: 0,
      latestSuspendedTime: 0,
      latestPingedTime: 0,
      didError: !1,
      pendingCommitExpirationTime: 0,
      finishedWork: null,
      timeoutHandle: -1,
      context: null,
      pendingContext: null,
      hydrate: n,
      nextExpirationTimeToWorkOn: 0,
      expirationTime: 0,
      firstBatch: null,
      nextScheduledRoot: null
    }, this._internalRoot = t.stateNode = e
  }

  function Fa(e) {
    return !(!e || 1 !== e.nodeType && 9 !== e.nodeType && 11 !== e.nodeType && (8 !== e.nodeType || " react-mount-point-unstable " !== e.nodeValue))
  }

  function Ba(e, t, n, r, i) {
    var o = n._reactRootContainer;
    if (o) {
      if ("function" == typeof i) {
        var s = i;
        i = function () {
          var e = Pa(o._internalRoot);
          s.call(e)
        }
      }
      null != e ? o.legacy_renderSubtreeIntoContainer(e, t, i) : o.render(t, i)
    } else {
      if (o = n._reactRootContainer = function (e, t) {
          if (t || (t = !(!(t = e ? 9 === e.nodeType ? e.documentElement : e.firstChild : null) || 1 !== t.nodeType || !t.hasAttribute("data-reactroot"))), !t)
            for (var n; n = e.lastChild;) e.removeChild(n);
          return new Na(e, !1, t)
        }(n, r), "function" == typeof i) {
        var a = i;
        i = function () {
          var e = Pa(o._internalRoot);
          a.call(e)
        }
      }
      Da((function () {
        null != e ? o.legacy_renderSubtreeIntoContainer(e, t, i) : o.render(t, i)
      }))
    }
    return Pa(o._internalRoot)
  }

  function Ha(e, t) {
    var n = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
    return Fa(t) || a("200"), Ia(e, t, null, n)
  }
  De = function (e, t, n) {
    switch (t) {
      case "input":
        if (kt(e, n), t = n.name, "radio" === n.type && null != t) {
          for (n = e; n.parentNode;) n = n.parentNode;
          for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + t) + '][type="radio"]'), t = 0; t < n.length; t++) {
            var r = n[t];
            if (r !== e && r.form === e.form) {
              var i = z(r);
              i || a("90"), Ge(r), kt(r, i)
            }
          }
        }
        break;
      case "textarea":
        Jn(e, n);
        break;
      case "select":
        null != (t = n.value) && Qn(e, !!n.multiple, t, !1)
    }
  }, Oa.prototype.render = function (e) {
    this._defer || a("250"), this._hasChildren = !0, this._children = e;
    var t = this._root._internalRoot,
      n = this._expirationTime,
      r = new La;
    return Aa(e, t, null, n, r._onCommit), r
  }, Oa.prototype.then = function (e) {
    if (this._didComplete) e();
    else {
      var t = this._callbacks;
      null === t && (t = this._callbacks = []), t.push(e)
    }
  }, Oa.prototype.commit = function () {
    var e = this._root._internalRoot,
      t = e.firstBatch;
    if (this._defer && null !== t || a("251"), this._hasChildren) {
      var n = this._expirationTime;
      if (t !== this) {
        this._hasChildren && (n = this._expirationTime = t._expirationTime, this.render(this._children));
        for (var r = null, i = t; i !== this;) r = i, i = i._next;
        null === r && a("251"), r._next = i._next, this._next = t, e.firstBatch = this
      }
      this._defer = !1, Ea(e, n), t = this._next, this._next = null, null !== (t = e.firstBatch = t) && t._hasChildren && t.render(t._children)
    } else this._next = null, this._defer = !1
  }, Oa.prototype._onComplete = function () {
    if (!this._didComplete) {
      this._didComplete = !0;
      var e = this._callbacks;
      if (null !== e)
        for (var t = 0; t < e.length; t++)(0, e[t])()
    }
  }, La.prototype.then = function (e) {
    if (this._didCommit) e();
    else {
      var t = this._callbacks;
      null === t && (t = this._callbacks = []), t.push(e)
    }
  }, La.prototype._onCommit = function () {
    if (!this._didCommit) {
      this._didCommit = !0;
      var e = this._callbacks;
      if (null !== e)
        for (var t = 0; t < e.length; t++) {
          var n = e[t];
          "function" != typeof n && a("191", n), n()
        }
    }
  }, Na.prototype.render = function (e, t) {
    var n = this._internalRoot,
      r = new La;
    return null !== (t = void 0 === t ? null : t) && r.then(t), Ma(e, n, null, r._onCommit), r
  }, Na.prototype.unmount = function (e) {
    var t = this._internalRoot,
      n = new La;
    return null !== (e = void 0 === e ? null : e) && n.then(e), Ma(null, t, null, n._onCommit), n
  }, Na.prototype.legacy_renderSubtreeIntoContainer = function (e, t, n) {
    var r = this._internalRoot,
      i = new La;
    return null !== (n = void 0 === n ? null : n) && i.then(n), Ma(t, r, e, i._onCommit), i
  }, Na.prototype.createBatch = function () {
    var e = new Oa(this),
      t = e._expirationTime,
      n = this._internalRoot,
      r = n.firstBatch;
    if (null === r) n.firstBatch = e, e._next = null;
    else {
      for (n = null; null !== r && r._expirationTime >= t;) n = r, r = r._next;
      e._next = r, null !== n && (n._next = e)
    }
    return e
  }, Oe = Ra, Le = _a, Ne = function () {
    Zs || 0 === ea || (Ca(ea, !1), ea = 0)
  };
  var za, Ua, Wa = {
    createPortal: Ha,
    findDOMNode: function (e) {
      if (null == e) return null;
      if (1 === e.nodeType) return e;
      var t = e._reactInternalFiber;
      return void 0 === t && ("function" == typeof e.render ? a("188") : a("268", Object.keys(e))), e = null === (e = sn(t)) ? null : e.stateNode
    },
    hydrate: function (e, t, n) {
      return Fa(t) || a("200"), Ba(null, e, t, !0, n)
    },
    render: function (e, t, n) {
      return Fa(t) || a("200"), Ba(null, e, t, !1, n)
    },
    unstable_renderSubtreeIntoContainer: function (e, t, n, r) {
      return Fa(n) || a("200"), (null == e || void 0 === e._reactInternalFiber) && a("38"), Ba(e, t, n, !1, r)
    },
    unmountComponentAtNode: function (e) {
      return Fa(e) || a("40"), !!e._reactRootContainer && (Da((function () {
        Ba(null, null, e, !1, (function () {
          e._reactRootContainer = null
        }))
      })), !0)
    },
    unstable_createPortal: function () {
      return Ha.apply(void 0, arguments)
    },
    unstable_batchedUpdates: Ra,
    unstable_interactiveUpdates: _a,
    flushSync: function (e, t) {
      Zs && a("187");
      var n = ra;
      ra = !0;
      try {
        return $s(e, t)
      } finally {
        ra = n, Ca(1073741823, !1)
      }
    },
    unstable_createRoot: function (e, t) {
      return Fa(e) || a("299", "unstable_createRoot"), new Na(e, !0, null != t && !0 === t.hydrate)
    },
    unstable_flushControlled: function (e) {
      var t = ra;
      ra = !0;
      try {
        $s(e)
      } finally {
        (ra = t) || Zs || Ca(1073741823, !1)
      }
    },
    __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
      Events: [B, H, z, M.injectEventPluginsByName, b, $, function (e) {
        D(e, G)
      }, Pe, Ie, An, I]
    }
  };
  Ua = (za = {
      findFiberByHostInstance: F,
      bundleType: 0,
      version: "16.8.4",
      rendererPackageName: "react-dom"
    }).findFiberByHostInstance,
    function (e) {
      if ("undefined" == typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return !1;
      var t = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (t.isDisabled || !t.supportsFiber) return !0;
      try {
        var n = t.inject(e);
        Vr = Gr((function (e) {
          return t.onCommitFiberRoot(n, e)
        })), jr = Gr((function (e) {
          return t.onCommitFiberUnmount(n, e)
        }))
      } catch (e) {}
    }(i({}, za, {
      overrideProps: null,
      currentDispatcherRef: $e.ReactCurrentDispatcher,
      findHostInstanceByFiber: function (e) {
        return null === (e = sn(e)) ? null : e.stateNode
      },
      findFiberByHostInstance: function (e) {
        return Ua ? Ua(e) : null
      }
    }));
  var Va = {
      default: Wa
    },
    ja = Va && Wa || Va;
  e.exports = ja.default || ja
}, function (e, t, n) {
  "use strict";
  e.exports = n(151)
}, function (e, t, n) {
  "use strict";
  /** @license React v0.13.4
   * scheduler.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  var r = null,
    i = !1,
    o = 3,
    s = -1,
    a = -1,
    l = !1,
    c = !1;

  function u() {
    if (!l) {
      var e = r.expirationTime;
      c ? k() : c = !0, E(d, e)
    }
  }

  function h() {
    var e = r,
      t = r.next;
    if (r === t) r = null;
    else {
      var n = r.previous;
      r = n.next = t, t.previous = n
    }
    e.next = e.previous = null, n = e.callback, t = e.expirationTime, e = e.priorityLevel;
    var i = o,
      s = a;
    o = e, a = t;
    try {
      var l = n()
    } finally {
      o = i, a = s
    }
    if ("function" == typeof l)
      if (l = {
          callback: l,
          priorityLevel: e,
          expirationTime: t,
          next: null,
          previous: null
        }, null === r) r = l.next = l.previous = l;
      else {
        n = null, e = r;
        do {
          if (e.expirationTime >= t) {
            n = e;
            break
          }
          e = e.next
        } while (e !== r);
        null === n ? n = r : n === r && (r = l, u()), (t = n.previous).next = n.previous = l, l.next = n, l.previous = t
      }
  }

  function p() {
    if (-1 === s && null !== r && 1 === r.priorityLevel) {
      l = !0;
      try {
        do {
          h()
        } while (null !== r && 1 === r.priorityLevel)
      } finally {
        l = !1, null !== r ? u() : c = !1
      }
    }
  }

  function d(e) {
    l = !0;
    var n = i;
    i = e;
    try {
      if (e)
        for (; null !== r;) {
          var o = t.unstable_now();
          if (!(r.expirationTime <= o)) break;
          do {
            h()
          } while (null !== r && r.expirationTime <= o)
        } else if (null !== r)
          do {
            h()
          } while (null !== r && !x())
    } finally {
      l = !1, i = n, null !== r ? u() : c = !1, p()
    }
  }
  var f, m, g = Date,
    y = "function" == typeof setTimeout ? setTimeout : void 0,
    v = "function" == typeof clearTimeout ? clearTimeout : void 0,
    w = "function" == typeof requestAnimationFrame ? requestAnimationFrame : void 0,
    b = "function" == typeof cancelAnimationFrame ? cancelAnimationFrame : void 0;

  function S(e) {
    f = w((function (t) {
      v(m), e(t)
    })), m = y((function () {
      b(f), e(t.unstable_now())
    }), 100)
  }
  if ("object" == typeof performance && "function" == typeof performance.now) {
    var C = performance;
    t.unstable_now = function () {
      return C.now()
    }
  } else t.unstable_now = function () {
    return g.now()
  };
  var E, k, x, T = null;
  if ("undefined" != typeof window ? T = window : "undefined" != typeof global && (T = global), T && T._schedMock) {
    var R = T._schedMock;
    E = R[0], k = R[1], x = R[2], t.unstable_now = R[3]
  } else if ("undefined" == typeof window || "function" != typeof MessageChannel) {
    var D = null,
      _ = function (e) {
        if (null !== D) try {
          D(e)
        } finally {
          D = null
        }
      };
    E = function (e) {
      null !== D ? setTimeout(E, 0, e) : (D = e, setTimeout(_, 0, !1))
    }, k = function () {
      D = null
    }, x = function () {
      return !1
    }
  } else {
    "undefined" != typeof console && ("function" != typeof w && console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"), "function" != typeof b && console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));
    var A = null,
      M = !1,
      P = -1,
      I = !1,
      O = !1,
      L = 0,
      N = 33,
      F = 33;
    x = function () {
      return L <= t.unstable_now()
    };
    var B = new MessageChannel,
      H = B.port2;
    B.port1.onmessage = function () {
      M = !1;
      var e = A,
        n = P;
      A = null, P = -1;
      var r = t.unstable_now(),
        i = !1;
      if (0 >= L - r) {
        if (!(-1 !== n && n <= r)) return I || (I = !0, S(z)), A = e, void(P = n);
        i = !0
      }
      if (null !== e) {
        O = !0;
        try {
          e(i)
        } finally {
          O = !1
        }
      }
    };
    var z = function (e) {
      if (null !== A) {
        S(z);
        var t = e - L + F;
        t < F && N < F ? (8 > t && (t = 8), F = t < N ? N : t) : N = t, L = e + F, M || (M = !0, H.postMessage(void 0))
      } else I = !1
    };
    E = function (e, t) {
      A = e, P = t, O || 0 > t ? H.postMessage(void 0) : I || (I = !0, S(z))
    }, k = function () {
      A = null, M = !1, P = -1
    }
  }
  t.unstable_ImmediatePriority = 1, t.unstable_UserBlockingPriority = 2, t.unstable_NormalPriority = 3, t.unstable_IdlePriority = 5, t.unstable_LowPriority = 4, t.unstable_runWithPriority = function (e, n) {
    switch (e) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        e = 3
    }
    var r = o,
      i = s;
    o = e, s = t.unstable_now();
    try {
      return n()
    } finally {
      o = r, s = i, p()
    }
  }, t.unstable_next = function (e) {
    switch (o) {
      case 1:
      case 2:
      case 3:
        var n = 3;
        break;
      default:
        n = o
    }
    var r = o,
      i = s;
    o = n, s = t.unstable_now();
    try {
      return e()
    } finally {
      o = r, s = i, p()
    }
  }, t.unstable_scheduleCallback = function (e, n) {
    var i = -1 !== s ? s : t.unstable_now();
    if ("object" == typeof n && null !== n && "number" == typeof n.timeout) n = i + n.timeout;
    else switch (o) {
      case 1:
        n = i + -1;
        break;
      case 2:
        n = i + 250;
        break;
      case 5:
        n = i + 1073741823;
        break;
      case 4:
        n = i + 1e4;
        break;
      default:
        n = i + 5e3
    }
    if (e = {
        callback: e,
        priorityLevel: o,
        expirationTime: n,
        next: null,
        previous: null
      }, null === r) r = e.next = e.previous = e, u();
    else {
      i = null;
      var a = r;
      do {
        if (a.expirationTime > n) {
          i = a;
          break
        }
        a = a.next
      } while (a !== r);
      null === i ? i = r : i === r && (r = e, u()), (n = i.previous).next = i.previous = e, e.next = i, e.previous = n
    }
    return e
  }, t.unstable_cancelCallback = function (e) {
    var t = e.next;
    if (null !== t) {
      if (t === e) r = null;
      else {
        e === r && (r = t);
        var n = e.previous;
        n.next = t, t.previous = n
      }
      e.next = e.previous = null
    }
  }, t.unstable_wrapCallback = function (e) {
    var n = o;
    return function () {
      var r = o,
        i = s;
      o = n, s = t.unstable_now();
      try {
        return e.apply(this, arguments)
      } finally {
        o = r, s = i, p()
      }
    }
  }, t.unstable_getCurrentPriorityLevel = function () {
    return o
  }, t.unstable_shouldYield = function () {
    return !i && (null !== r && r.expirationTime < a || x())
  }, t.unstable_continueExecution = function () {
    null !== r && u()
  }, t.unstable_pauseExecution = function () {}, t.unstable_getFirstCallbackNode = function () {
    return r
  }
}, function (e, t, n) {
  (function () {
    var t;
    t = n(60), e.exports = function () {
      function e() {
        this.clear()
      }
      return e.exceptionHandlers = [], e.onEventHandlerException = function (e) {
        return 0 === this.exceptionHandlers.length && (this.dispatch = this.exceptionHandlingDispatch), this.exceptionHandlers.push(e), new t((n = this, function () {
          if (n.exceptionHandlers.splice(n.exceptionHandlers.indexOf(e), 1), 0 === n.exceptionHandlers.length) return n.dispatch = n.simpleDispatch
        }));
        var n
      }, e.simpleDispatch = function (e, t) {
        return e(t)
      }, e.exceptionHandlingDispatch = function (e, t) {
        var n, r, i, o, s, a;
        try {
          return e(t)
        } catch (e) {
          for (n = e, a = [], i = 0, o = (s = this.exceptionHandlers).length; i < o; i++) r = s[i], a.push(r(n));
          return a
        }
      }, e.dispatch = e.simpleDispatch, e.prototype.disposed = !1, e.prototype.clear = function () {
        return this.handlersByEventName = {}
      }, e.prototype.dispose = function () {
        return this.handlersByEventName = null, this.disposed = !0
      }, e.prototype.on = function (e, n, r) {
        var i;
        if (null == r && (r = !1), this.disposed) throw new Error("Emitter has been disposed");
        if ("function" != typeof n) throw new Error("Handler must be a function");
        return (i = this.handlersByEventName[e]) ? this.handlersByEventName[e] = r ? [n].concat(i) : i.concat(n) : this.handlersByEventName[e] = [n], new t(this.off.bind(this, e, n))
      }, e.prototype.once = function (e, t, n) {
        var r, i;
        return null == n && (n = !1), i = function (e) {
          return r.dispose(), t(e)
        }, r = this.on(e, i, n)
      }, e.prototype.preempt = function (e, t) {
        return this.on(e, t, !0)
      }, e.prototype.off = function (e, t) {
        var n, r, i, o, s;
        if (!this.disposed && (i = this.handlersByEventName[e])) {
          for (r = [], o = 0, s = i.length; o < s; o++)(n = i[o]) !== t && r.push(n);
          r.length > 0 ? this.handlersByEventName[e] = r : delete this.handlersByEventName[e]
        }
      }, e.prototype.emit = function (e, t) {
        var n, r, i, o, s;
        if (r = null != (s = this.handlersByEventName) ? s[e] : void 0)
          for (i = 0, o = r.length; i < o; i++) n = r[i], this.constructor.dispatch(n, t)
      }, e.prototype.emitAsync = function (e, t) {
        var n, r, i, o;
        return (r = null != (o = this.handlersByEventName) ? o[e] : void 0) ? (i = function () {
          var e, i, o;
          for (o = [], e = 0, i = r.length; e < i; e++) n = r[e], o.push(this.constructor.dispatch(n, t));
          return o
        }.call(this), Promise.all(i).then((function () {}))) : Promise.resolve()
      }, e.prototype.getEventNames = function () {
        return Object.keys(this.handlersByEventName)
      }, e.prototype.listenerCountForEventName = function (e) {
        var t, n;
        return null != (t = null != (n = this.handlersByEventName[e]) ? n.length : void 0) ? t : 0
      }, e.prototype.getTotalListenerCount = function () {
        var e, t, n, r, i;
        for (t = 0, n = 0, r = (i = Object.keys(this.handlersByEventName)).length; n < r; n++) e = i[n], t += this.handlersByEventName[e].length;
        return t
      }, e
    }()
  }).call(this)
}, function (e, t, n) {
  (function () {
    var t, r;
    t = null, e.exports = function () {
      function e() {
        var e, t, n;
        for (this.disposables = new Set, t = 0, n = arguments.length; t < n; t++) e = arguments[t], this.add(e)
      }
      return e.prototype.disposed = !1, e.prototype.dispose = function () {
        this.disposed || (this.disposed = !0, this.disposables.forEach((function (e) {
          return e.dispose()
        })), this.disposables = null)
      }, e.prototype.add = function () {
        var e, t, n;
        if (!this.disposed)
          for (t = 0, n = arguments.length; t < n; t += 1) r(e = arguments[t]), this.disposables.add(e)
      }, e.prototype.remove = function (e) {
        this.disposed || this.disposables.delete(e)
      }, e.prototype.delete = function (e) {
        this.remove(e)
      }, e.prototype.clear = function () {
        this.disposed || this.disposables.clear()
      }, e
    }(), r = function (e) {
      if (null == t && (t = n(60)), !t.isDisposable(e)) throw new TypeError("Arguments to CompositeDisposable.add must have a .dispose() method")
    }
  }).call(this)
}, function (e, t, n) {
  "use strict";
  var r = n(8),
    i = n(155),
    o = n(92),
    s = n(59),
    a = n(164),
    l = n(94),
    c = n(93)();

  function u(e, t, n) {
    var r;
    return n && !0 === n.__winShell ? (delete n.__winShell, r = {
      command: e,
      args: t,
      options: n,
      file: e,
      original: e
    }) : r = i._parse(e, t, n), (n = s({
      maxBuffer: 10485760,
      stripEof: !0,
      preferLocal: !0,
      encoding: "utf8"
    }, r.options)).preferLocal && (n.env = s({}, n.env || process.env), n.env[c] = a({
      cwd: n.cwd,
      path: n.env[c]
    })), {
      cmd: r.command,
      args: r.args,
      opts: n
    }
  }

  function h(e, t) {
    return e.stripEof && (t = o(t)), t
  }

  function p(e, t, n) {
    var r, i;
    return (n = s({}, n)).__winShell = !0, r = process.env.comspec || "cmd.exe", i = ["/s", "/c", '"' + t + '"'], n.windowsVerbatimArguments = !0, n.shell && (r = n.shell), e(r, i, n)
  }
  e.exports = function (e, t, n) {
    var o, s = new Promise((function (s, a) {
      var c = u(e, t, n);
      o = r.execFile(c.cmd, c.args, c.opts, (function (e, t, n) {
          if (e) return e.stdout = t, e.stderr = n, e.message += t, void a(e);
          s({
            stdout: h(c.opts, t),
            stderr: h(c.opts, n)
          })
        })), i._enoent.hookChildProcess(o, c),
        function (e, t) {
          var n = t.input;
          null != n && (l(n) ? n.pipe(e.stdin) : e.stdin.end(n))
        }(o, c.opts)
    }));
    return o.then = s.then.bind(s), o.catch = s.catch.bind(s), o
  }, e.exports.stdout = function () {
    return e.exports.apply(null, arguments).then((function (e) {
      return e.stdout
    }))
  }, e.exports.stderr = function () {
    return e.exports.apply(null, arguments).then((function (e) {
      return e.stderr
    }))
  }, e.exports.shell = function (t, n) {
    return p(e.exports, t, n)
  }, e.exports.spawn = function (e, t, n) {
    var o = u(e, t, n),
      s = r.spawn(o.cmd, o.args, o.opts);
    return i._enoent.hookChildProcess(s, o), s
  }, e.exports.sync = function (e, t, n) {
    var i = u(e, t, n);
    if (l(i.opts.input)) throw new TypeError("The `input` option cannot be a stream in sync mode");
    var s = r.spawnSync(i.cmd, i.args, i.opts);
    return i.opts.stripEof && (s.stdout = o(s.stdout), s.stderr = o(s.stderr)), s
  }, e.exports.shellSync = function (t, n) {
    return p(e.exports.sync, t, n)
  }
}, function (e, t, n) {
  "use strict";
  var r = n(8),
    i = n(156),
    o = n(163);

  function s(e, t, n) {
    var s, a;
    return s = i(e, t, n), a = r.spawn(s.command, s.args, s.options), o.hookChildProcess(a, s), a
  }
  e.exports = s, e.exports.spawn = s, e.exports._parse = i, e.exports._enoent = o
}, function (e, t, n) {
  "use strict";
  var r = n(7),
    i = n(90),
    o = n(160),
    s = new i({
      max: 50,
      maxAge: 3e4
    });

  function a(e, t) {
    return e = "" + e, e = t ? '"' + (e = (e = e.replace(/(\\*)"/g, '$1$1\\"')).replace(/(\\*)$/, "$1$1")) + '"' : e.replace(/([\(\)%!\^<>&|;,"'\s])/g, "^$1")
  }
  e.exports = function (e, t, n) {
    var i, l, c, u;
    return t && !Array.isArray(t) && (n = t, t = null), t = t ? t.slice(0) : [], n = n || {}, u = e, (i = (c = (c = o(e)) || o(e, !0)) && function (e) {
      var t, n, i, o;
      if (s.has(e)) return s.get(e);
      t = new Buffer(150);
      try {
        n = r.openSync(e, "r"), r.readSync(n, t, 0, 150, 0), r.closeSync(n)
      } catch (e) {}
      return (i = t.toString().trim().match(/#!(.+)/i)) && (o = i[1].replace(/\/usr\/bin\/env\s+/i, "")), s.set(e, o), o
    }(c)) && (t.unshift(c), e = i), l = "echo" !== e, t = ["/s", "/c", '"' + (e = function (e) {
      return /^[a-z0-9_-]+$/i.test(e) ? e : a(e, !0)
    }(e)) + ((t = t.map((function (e) {
      return a(e, l)
    }))).length ? " " + t.join(" ") : "") + '"'], e = process.env.comspec || "cmd.exe", n.windowsVerbatimArguments = !0, {
      command: e,
      args: t,
      options: n,
      file: c,
      original: u
    }
  }
}, function (e, t, n) {
  "pseudomap" === process.env.npm_package_name && "test" === process.env.npm_lifecycle_script && (process.env.TEST_PSEUDOMAP = "true"), "function" != typeof Map || process.env.TEST_PSEUDOMAP ? e.exports = n(158) : e.exports = Map
}, function (e, t) {
  var n = Object.prototype.hasOwnProperty;

  function r(e) {
    if (!(this instanceof r)) throw new TypeError("Constructor PseudoMap requires 'new'");
    if (this.clear(), e)
      if (e instanceof r || "function" == typeof Map && e instanceof Map) e.forEach((function (e, t) {
        this.set(t, e)
      }), this);
      else {
        if (!Array.isArray(e)) throw new TypeError("invalid argument");
        e.forEach((function (e) {
          this.set(e[0], e[1])
        }), this)
      }
  }

  function i(e, t) {
    return e === t || e != e && t != t
  }

  function o(e, t, n) {
    this.key = e, this.value = t, this._index = n
  }

  function s(e, t) {
    for (var r = 0, o = "_" + t, s = o; n.call(e, s); s = o + r++)
      if (i(e[s].key, t)) return e[s]
  }
  e.exports = r, r.prototype.forEach = function (e, t) {
    t = t || this, Object.keys(this._data).forEach((function (n) {
      "size" !== n && e.call(t, this._data[n].value, this._data[n].key)
    }), this)
  }, r.prototype.has = function (e) {
    return !!s(this._data, e)
  }, r.prototype.get = function (e) {
    var t = s(this._data, e);
    return t && t.value
  }, r.prototype.set = function (e, t) {
    ! function (e, t, r) {
      for (var s = 0, a = "_" + t, l = a; n.call(e, l); l = a + s++)
        if (i(e[l].key, t)) return void(e[l].value = r);
      e.size++, e[l] = new o(t, r, l)
    }(this._data, e, t)
  }, r.prototype.delete = function (e) {
    var t = s(this._data, e);
    t && (delete this._data[t._index], this._data.size--)
  }, r.prototype.clear = function () {
    var e = Object.create(null);
    e.size = 0, Object.defineProperty(this, "_data", {
      value: e,
      enumerable: !1,
      configurable: !0,
      writable: !1
    })
  }, Object.defineProperty(r.prototype, "size", {
    get: function () {
      return this._data.size
    },
    set: function (e) {},
    enumerable: !0,
    configurable: !0
  }), r.prototype.values = r.prototype.keys = r.prototype.entries = function () {
    throw new Error("iterators are not implemented in this version")
  }
}, function (e, t) {
  function n(e) {
    var t = this;
    if (t instanceof n || (t = new n), t.tail = null, t.head = null, t.length = 0, e && "function" == typeof e.forEach) e.forEach((function (e) {
      t.push(e)
    }));
    else if (arguments.length > 0)
      for (var r = 0, i = arguments.length; r < i; r++) t.push(arguments[r]);
    return t
  }

  function r(e, t) {
    e.tail = new o(t, e.tail, null, e), e.head || (e.head = e.tail), e.length++
  }

  function i(e, t) {
    e.head = new o(t, null, e.head, e), e.tail || (e.tail = e.head), e.length++
  }

  function o(e, t, n, r) {
    if (!(this instanceof o)) return new o(e, t, n, r);
    this.list = r, this.value = e, t ? (t.next = this, this.prev = t) : this.prev = null, n ? (n.prev = this, this.next = n) : this.next = null
  }
  e.exports = n, n.Node = o, n.create = n, n.prototype.removeNode = function (e) {
    if (e.list !== this) throw new Error("removing node which does not belong to this list");
    var t = e.next,
      n = e.prev;
    t && (t.prev = n), n && (n.next = t), e === this.head && (this.head = t), e === this.tail && (this.tail = n), e.list.length--, e.next = null, e.prev = null, e.list = null
  }, n.prototype.unshiftNode = function (e) {
    if (e !== this.head) {
      e.list && e.list.removeNode(e);
      var t = this.head;
      e.list = this, e.next = t, t && (t.prev = e), this.head = e, this.tail || (this.tail = e), this.length++
    }
  }, n.prototype.pushNode = function (e) {
    if (e !== this.tail) {
      e.list && e.list.removeNode(e);
      var t = this.tail;
      e.list = this, e.prev = t, t && (t.next = e), this.tail = e, this.head || (this.head = e), this.length++
    }
  }, n.prototype.push = function () {
    for (var e = 0, t = arguments.length; e < t; e++) r(this, arguments[e]);
    return this.length
  }, n.prototype.unshift = function () {
    for (var e = 0, t = arguments.length; e < t; e++) i(this, arguments[e]);
    return this.length
  }, n.prototype.pop = function () {
    if (this.tail) {
      var e = this.tail.value;
      return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, e
    }
  }, n.prototype.shift = function () {
    if (this.head) {
      var e = this.head.value;
      return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, e
    }
  }, n.prototype.forEach = function (e, t) {
    t = t || this;
    for (var n = this.head, r = 0; null !== n; r++) e.call(t, n.value, r, this), n = n.next
  }, n.prototype.forEachReverse = function (e, t) {
    t = t || this;
    for (var n = this.tail, r = this.length - 1; null !== n; r--) e.call(t, n.value, r, this), n = n.prev
  }, n.prototype.get = function (e) {
    for (var t = 0, n = this.head; null !== n && t < e; t++) n = n.next;
    if (t === e && null !== n) return n.value
  }, n.prototype.getReverse = function (e) {
    for (var t = 0, n = this.tail; null !== n && t < e; t++) n = n.prev;
    if (t === e && null !== n) return n.value
  }, n.prototype.map = function (e, t) {
    t = t || this;
    for (var r = new n, i = this.head; null !== i;) r.push(e.call(t, i.value, this)), i = i.next;
    return r
  }, n.prototype.mapReverse = function (e, t) {
    t = t || this;
    for (var r = new n, i = this.tail; null !== i;) r.push(e.call(t, i.value, this)), i = i.prev;
    return r
  }, n.prototype.reduce = function (e, t) {
    var n, r = this.head;
    if (arguments.length > 1) n = t;
    else {
      if (!this.head) throw new TypeError("Reduce of empty list with no initial value");
      r = this.head.next, n = this.head.value
    }
    for (var i = 0; null !== r; i++) n = e(n, r.value, i), r = r.next;
    return n
  }, n.prototype.reduceReverse = function (e, t) {
    var n, r = this.tail;
    if (arguments.length > 1) n = t;
    else {
      if (!this.tail) throw new TypeError("Reduce of empty list with no initial value");
      r = this.tail.prev, n = this.tail.value
    }
    for (var i = this.length - 1; null !== r; i--) n = e(n, r.value, i), r = r.prev;
    return n
  }, n.prototype.toArray = function () {
    for (var e = new Array(this.length), t = 0, n = this.head; null !== n; t++) e[t] = n.value, n = n.next;
    return e
  }, n.prototype.toArrayReverse = function () {
    for (var e = new Array(this.length), t = 0, n = this.tail; null !== n; t++) e[t] = n.value, n = n.prev;
    return e
  }, n.prototype.slice = function (e, t) {
    (t = t || this.length) < 0 && (t += this.length), (e = e || 0) < 0 && (e += this.length);
    var r = new n;
    if (t < e || t < 0) return r;
    e < 0 && (e = 0), t > this.length && (t = this.length);
    for (var i = 0, o = this.head; null !== o && i < e; i++) o = o.next;
    for (; null !== o && i < t; i++, o = o.next) r.push(o.value);
    return r
  }, n.prototype.sliceReverse = function (e, t) {
    (t = t || this.length) < 0 && (t += this.length), (e = e || 0) < 0 && (e += this.length);
    var r = new n;
    if (t < e || t < 0) return r;
    e < 0 && (e = 0), t > this.length && (t = this.length);
    for (var i = this.length, o = this.tail; null !== o && i > t; i--) o = o.prev;
    for (; null !== o && i > e; i--, o = o.prev) r.push(o.value);
    return r
  }, n.prototype.reverse = function () {
    for (var e = this.head, t = this.tail, n = e; null !== n; n = n.prev) {
      var r = n.prev;
      n.prev = n.next, n.next = r
    }
    return this.head = t, this.tail = e, this
  }
}, function (e, t, n) {
  "use strict";
  var r = n(1),
    i = n(161),
    o = new(n(90))({
      max: 50,
      maxAge: 3e4
    }),
    s = new RegExp(/[\/\\]/);
  e.exports = function (e, t) {
    var n;
    if (s.test(e) && (e = r.resolve(e)), t = !!t, n = o.get(e + "!" + t), o.has(e)) return o.get(e);
    try {
      n = t ? i.sync(e, {
        pathExt: r.delimiter + (process.env.PATHEXT || "")
      }) : i.sync(e)
    } catch (e) {}
    return o.set(e + "!" + t, n), n
  }
}, function (e, t, n) {
  e.exports = a, a.sync = function (e, t) {
    for (var n = s(e, t = t || {}), a = n.env, l = n.ext, c = n.extExe, u = [], h = 0, p = a.length; h < p; h++) {
      var d = a[h];
      '"' === d.charAt(0) && '"' === d.slice(-1) && (d = d.slice(1, -1));
      var f = r.join(d, e);
      !d && /^\.[\\\/]/.test(e) && (f = e.slice(0, 2) + f);
      for (var m = 0, g = l.length; m < g; m++) {
        var y = f + l[m];
        try {
          if (i.sync(y, {
              pathExt: c
            })) {
            if (!t.all) return y;
            u.push(y)
          }
        } catch (e) {}
      }
    }
    if (t.all && u.length) return u;
    if (t.nothrow) return null;
    throw o(e)
  };
  var r = n(1),
    i = n(91);

  function o(e) {
    var t = new Error("not found: " + e);
    return t.code = "ENOENT", t
  }

  function s(e, t) {
    var n = t.colon || ";",
      r = t.path || process.env.PATH || "",
      i = [""],
      o = "";
    return (r = r.split(n)).unshift(process.cwd()), i = (o = t.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM").split(n), -1 !== e.indexOf(".") && "" !== i[0] && i.unshift(""), (e.match(/\//) || e.match(/\\/)) && (r = [""]), {
      env: r,
      ext: i,
      extExe: o
    }
  }

  function a(e, t, n) {
    "function" == typeof t && (n = t, t = {});
    var a = s(e, t),
      l = a.env,
      c = a.ext,
      u = a.extExe,
      h = [];
    ! function s(a, p) {
      if (a === p) return t.all && h.length ? n(null, h) : n(o(e));
      var d = l[a];
      '"' === d.charAt(0) && '"' === d.slice(-1) && (d = d.slice(1, -1));
      var f = r.join(d, e);
      !d && /^\.[\\\/]/.test(e) && (f = e.slice(0, 2) + f),
        function e(r, o) {
          if (r === o) return s(a + 1, p);
          var l = c[r];
          i(f + l, {
            pathExt: u
          }, (function (i, s) {
            if (!i && s) {
              if (!t.all) return n(null, f + l);
              h.push(f + l)
            }
            return e(r + 1, o)
          }))
        }(0, c.length)
    }(0, l.length)
  }
}, function (e, t, n) {
  e.exports = o, o.sync = function (e, t) {
    return i(r.statSync(e), e, t)
  };
  var r = n(7);

  function i(e, t, n) {
    return !(!e.isSymbolicLink() && !e.isFile()) && function (e, t) {
      var n = void 0 !== t.pathExt ? t.pathExt : process.env.PATHEXT;
      if (!n) return !0;
      if (-1 !== (n = n.split(";")).indexOf("")) return !0;
      for (var r = 0; r < n.length; r++) {
        var i = n[r].toLowerCase();
        if (i && e.substr(-i.length).toLowerCase() === i) return !0
      }
      return !1
    }(t, n)
  }

  function o(e, t, n) {
    r.stat(e, (function (r, o) {
      n(r, !r && i(o, e, t))
    }))
  }
}, function (e, t, n) {
  "use strict";

  function r(e, t) {
    var n;
    return (n = new Error(t + " " + e + " ENOENT")).code = n.errno = "ENOENT", n.syscall = t + " " + e, n
  }

  function i(e, t, n) {
    return 1 !== e || t.file ? null : r(t.original, n)
  }
  e.exports.hookChildProcess = function (e, t) {
    var n;
    n = e.emit, e.emit = function (r, o) {
      var s;
      return "exit" === r && (s = i(o, t, "spawn")) ? n.call(e, "error", s) : n.apply(e, arguments)
    }
  }, e.exports.verifyENOENT = i, e.exports.notFoundError = r
}, function (e, t, n) {
  "use strict";
  var r = n(1),
    i = n(93);
  e.exports = function (e) {
    var t;
    e = e || {};
    for (var n = r.resolve(e.cwd || "."), o = []; t !== n;) o.push(r.join(n, "node_modules/.bin")), t = n, n = r.resolve(n, "..");
    return o.push(r.dirname(process.execPath)), o.concat(e.path || process.env[i()]).join(r.delimiter)
  }
}, function (e, t, n) {
  "use strict";
  e.exports = function (e, t) {
    var n = (t = t || {}).cacheKey || function (e) {
        return 1 === arguments.length && (null == e || "function" != typeof e && "object" != typeof e) ? e : JSON.stringify(arguments)
      },
      r = function () {
        var i = r.__cache__,
          o = n.apply(null, arguments);
        if (i.has(o)) {
          var s = i.get(o);
          if ("number" != typeof t.maxAge || Date.now() < s.maxAge) return s.data
        }
        var a = e.apply(null, arguments);
        return i.set(o, {
          data: a,
          maxAge: Date.now() + (t.maxAge || 0)
        }), a
      };
    return r.displayName = e.displayName || e.name, r.__cache__ = t.cache || new Map, r
  }
}, function (e, t, n) {
  var r;
  ! function (i, o) {
    "use strict";
    var s = "model",
      a = "name",
      l = "type",
      c = "vendor",
      u = "version",
      h = "mobile",
      p = "tablet",
      d = {
        extend: function (e, t) {
          var n = {};
          for (var r in e) t[r] && t[r].length % 2 == 0 ? n[r] = t[r].concat(e[r]) : n[r] = e[r];
          return n
        },
        has: function (e, t) {
          return "string" == typeof e && -1 !== t.toLowerCase().indexOf(e.toLowerCase())
        },
        lowerize: function (e) {
          return e.toLowerCase()
        },
        major: function (e) {
          return "string" == typeof e ? e.replace(/[^\d\.]/g, "").split(".")[0] : void 0
        },
        trim: function (e) {
          return e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "")
        }
      },
      f = {
        rgx: function (e, t) {
          for (var n, r, i, o, s, a, l = 0; l < t.length && !s;) {
            var c = t[l],
              u = t[l + 1];
            for (n = r = 0; n < c.length && !s;)
              if (s = c[n++].exec(e))
                for (i = 0; i < u.length; i++) a = s[++r], "object" == typeof (o = u[i]) && o.length > 0 ? 2 == o.length ? "function" == typeof o[1] ? this[o[0]] = o[1].call(this, a) : this[o[0]] = o[1] : 3 == o.length ? "function" != typeof o[1] || o[1].exec && o[1].test ? this[o[0]] = a ? a.replace(o[1], o[2]) : void 0 : this[o[0]] = a ? o[1].call(this, a, o[2]) : void 0 : 4 == o.length && (this[o[0]] = a ? o[3].call(this, a.replace(o[1], o[2])) : void 0) : this[o] = a || void 0;
            l += 2
          }
        },
        str: function (e, t) {
          for (var n in t)
            if ("object" == typeof t[n] && t[n].length > 0) {
              for (var r = 0; r < t[n].length; r++)
                if (d.has(t[n][r], e)) return "?" === n ? void 0 : n
            } else if (d.has(t[n], e)) return "?" === n ? void 0 : n;
          return e
        }
      },
      m = {
        browser: {
          oldsafari: {
            version: {
              "1.0": "/8",
              1.2: "/1",
              1.3: "/3",
              "2.0": "/412",
              "2.0.2": "/416",
              "2.0.3": "/417",
              "2.0.4": "/419",
              "?": "/"
            }
          }
        },
        device: {
          amazon: {
            model: {
              "Fire Phone": ["SD", "KF"]
            }
          },
          sprint: {
            model: {
              "Evo Shift 4G": "7373KT"
            },
            vendor: {
              HTC: "APA",
              Sprint: "Sprint"
            }
          }
        },
        os: {
          windows: {
            version: {
              ME: "4.90",
              "NT 3.11": "NT3.51",
              "NT 4.0": "NT4.0",
              2e3: "NT 5.0",
              XP: ["NT 5.1", "NT 5.2"],
              Vista: "NT 6.0",
              7: "NT 6.1",
              8: "NT 6.2",
              8.1: "NT 6.3",
              10: ["NT 6.4", "NT 10.0"],
              RT: "ARM"
            }
          }
        }
      },
      g = {
        browser: [
          [/(opera\smini)\/([\w\.-]+)/i, /(opera\s[mobiletab]+).+version\/([\w\.-]+)/i, /(opera).+version\/([\w\.]+)/i, /(opera)[\/\s]+([\w\.]+)/i],
          [a, u],
          [/(opios)[\/\s]+([\w\.]+)/i],
          [
            [a, "Opera Mini"], u
          ],
          [/\s(opr)\/([\w\.]+)/i],
          [
            [a, "Opera"], u
          ],
          [/(kindle)\/([\w\.]+)/i, /(lunascape|maxthon|netfront|jasmine|blazer)[\/\s]?([\w\.]+)*/i, /(avant\s|iemobile|slim|baidu)(?:browser)?[\/\s]?([\w\.]*)/i, /(?:ms|\()(ie)\s([\w\.]+)/i, /(rekonq)\/([\w\.]+)*/i, /(chromium|flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser)\/([\w\.-]+)/i],
          [a, u],
          [/(trident).+rv[:\s]([\w\.]+).+like\sgecko/i],
          [
            [a, "IE"], u
          ],
          [/(edge)\/((\d+)?[\w\.]+)/i],
          [a, u],
          [/(yabrowser)\/([\w\.]+)/i],
          [
            [a, "Yandex"], u
          ],
          [/(puffin)\/([\w\.]+)/i],
          [
            [a, "Puffin"], u
          ],
          [/((?:[\s\/])uc?\s?browser|(?:juc.+)ucweb)[\/\s]?([\w\.]+)/i],
          [
            [a, "UCBrowser"], u
          ],
          [/(comodo_dragon)\/([\w\.]+)/i],
          [
            [a, /_/g, " "], u
          ],
          [/(micromessenger)\/([\w\.]+)/i],
          [
            [a, "WeChat"], u
          ],
          [/(QQ)\/([\d\.]+)/i],
          [a, u],
          [/m?(qqbrowser)[\/\s]?([\w\.]+)/i],
          [a, u],
          [/xiaomi\/miuibrowser\/([\w\.]+)/i],
          [u, [a, "MIUI Browser"]],
          [/;fbav\/([\w\.]+);/i],
          [u, [a, "Facebook"]],
          [/(headlesschrome) ([\w\.]+)/i],
          [u, [a, "Chrome Headless"]],
          [/\swv\).+(chrome)\/([\w\.]+)/i],
          [
            [a, /(.+)/, "$1 WebView"], u
          ],
          [/((?:oculus|samsung)browser)\/([\w\.]+)/i],
          [
            [a, /(.+(?:g|us))(.+)/, "$1 $2"], u
          ],
          [/android.+version\/([\w\.]+)\s+(?:mobile\s?safari|safari)*/i],
          [u, [a, "Android Browser"]],
          [/(chrome|omniweb|arora|[tizenoka]{5}\s?browser)\/v?([\w\.]+)/i],
          [a, u],
          [/(dolfin)\/([\w\.]+)/i],
          [
            [a, "Dolphin"], u
          ],
          [/((?:android.+)crmo|crios)\/([\w\.]+)/i],
          [
            [a, "Chrome"], u
          ],
          [/(coast)\/([\w\.]+)/i],
          [
            [a, "Opera Coast"], u
          ],
          [/fxios\/([\w\.-]+)/i],
          [u, [a, "Firefox"]],
          [/version\/([\w\.]+).+?mobile\/\w+\s(safari)/i],
          [u, [a, "Mobile Safari"]],
          [/version\/([\w\.]+).+?(mobile\s?safari|safari)/i],
          [u, a],
          [/webkit.+?(mobile\s?safari|safari)(\/[\w\.]+)/i],
          [a, [u, f.str, m.browser.oldsafari.version]],
          [/(konqueror)\/([\w\.]+)/i, /(webkit|khtml)\/([\w\.]+)/i],
          [a, u],
          [/(navigator|netscape)\/([\w\.-]+)/i],
          [
            [a, "Netscape"], u
          ],
          [/(swiftfox)/i, /(icedragon|iceweasel|camino|chimera|fennec|maemo\sbrowser|minimo|conkeror)[\/\s]?([\w\.\+]+)/i, /(firefox|seamonkey|k-meleon|icecat|iceape|firebird|phoenix)\/([\w\.-]+)/i, /(mozilla)\/([\w\.]+).+rv\:.+gecko\/\d+/i, /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir)[\/\s]?([\w\.]+)/i, /(links)\s\(([\w\.]+)/i, /(gobrowser)\/?([\w\.]+)*/i, /(ice\s?browser)\/v?([\w\._]+)/i, /(mosaic)[\/\s]([\w\.]+)/i],
          [a, u]
        ],
        cpu: [
          [/(?:(amd|x(?:(?:86|64)[_-])?|wow|win)64)[;\)]/i],
          [
            ["architecture", "amd64"]
          ],
          [/(ia32(?=;))/i],
          [
            ["architecture", d.lowerize]
          ],
          [/((?:i[346]|x)86)[;\)]/i],
          [
            ["architecture", "ia32"]
          ],
          [/windows\s(ce|mobile);\sppc;/i],
          [
            ["architecture", "arm"]
          ],
          [/((?:ppc|powerpc)(?:64)?)(?:\smac|;|\))/i],
          [
            ["architecture", /ower/, "", d.lowerize]
          ],
          [/(sun4\w)[;\)]/i],
          [
            ["architecture", "sparc"]
          ],
          [/((?:avr32|ia64(?=;))|68k(?=\))|arm(?:64|(?=v\d+;))|(?=atmel\s)avr|(?:irix|mips|sparc)(?:64)?(?=;)|pa-risc)/i],
          [
            ["architecture", d.lowerize]
          ]
        ],
        device: [
          [/\((ipad|playbook);[\w\s\);-]+(rim|apple)/i],
          [s, c, [l, p]],
          [/applecoremedia\/[\w\.]+ \((ipad)/],
          [s, [c, "Apple"],
            [l, p]
          ],
          [/(apple\s{0,1}tv)/i],
          [
            [s, "Apple TV"],
            [c, "Apple"]
          ],
          [/(archos)\s(gamepad2?)/i, /(hp).+(touchpad)/i, /(hp).+(tablet)/i, /(kindle)\/([\w\.]+)/i, /\s(nook)[\w\s]+build\/(\w+)/i, /(dell)\s(strea[kpr\s\d]*[\dko])/i],
          [c, s, [l, p]],
          [/(kf[A-z]+)\sbuild\/[\w\.]+.*silk\//i],
          [s, [c, "Amazon"],
            [l, p]
          ],
          [/(sd|kf)[0349hijorstuw]+\sbuild\/[\w\.]+.*silk\//i],
          [
            [s, f.str, m.device.amazon.model],
            [c, "Amazon"],
            [l, h]
          ],
          [/\((ip[honed|\s\w*]+);.+(apple)/i],
          [s, c, [l, h]],
          [/\((ip[honed|\s\w*]+);/i],
          [s, [c, "Apple"],
            [l, h]
          ],
          [/(blackberry)[\s-]?(\w+)/i, /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[\s_-]?([\w-]+)*/i, /(hp)\s([\w\s]+\w)/i, /(asus)-?(\w+)/i],
          [c, s, [l, h]],
          [/\(bb10;\s(\w+)/i],
          [s, [c, "BlackBerry"],
            [l, h]
          ],
          [/android.+(transfo[prime\s]{4,10}\s\w+|eeepc|slider\s\w+|nexus 7|padfone)/i],
          [s, [c, "Asus"],
            [l, p]
          ],
          [/(sony)\s(tablet\s[ps])\sbuild\//i, /(sony)?(?:sgp.+)\sbuild\//i],
          [
            [c, "Sony"],
            [s, "Xperia Tablet"],
            [l, p]
          ],
          [/android.+\s([c-g]\d{4}|so[-l]\w+)\sbuild\//i],
          [s, [c, "Sony"],
            [l, h]
          ],
          [/\s(ouya)\s/i, /(nintendo)\s([wids3u]+)/i],
          [c, s, [l, "console"]],
          [/android.+;\s(shield)\sbuild/i],
          [s, [c, "Nvidia"],
            [l, "console"]
          ],
          [/(playstation\s[34portablevi]+)/i],
          [s, [c, "Sony"],
            [l, "console"]
          ],
          [/(sprint\s(\w+))/i],
          [
            [c, f.str, m.device.sprint.vendor],
            [s, f.str, m.device.sprint.model],
            [l, h]
          ],
          [/(lenovo)\s?(S(?:5000|6000)+(?:[-][\w+]))/i],
          [c, s, [l, p]],
          [/(htc)[;_\s-]+([\w\s]+(?=\))|\w+)*/i, /(zte)-(\w+)*/i, /(alcatel|geeksphone|lenovo|nexian|panasonic|(?=;\s)sony)[_\s-]?([\w-]+)*/i],
          [c, [s, /_/g, " "],
            [l, h]
          ],
          [/(nexus\s9)/i],
          [s, [c, "HTC"],
            [l, p]
          ],
          [/d\/huawei([\w\s-]+)[;\)]/i, /(nexus\s6p)/i],
          [s, [c, "Huawei"],
            [l, h]
          ],
          [/(microsoft);\s(lumia[\s\w]+)/i],
          [c, s, [l, h]],
          [/[\s\(;](xbox(?:\sone)?)[\s\);]/i],
          [s, [c, "Microsoft"],
            [l, "console"]
          ],
          [/(kin\.[onetw]{3})/i],
          [
            [s, /\./g, " "],
            [c, "Microsoft"],
            [l, h]
          ],
          [/\s(milestone|droid(?:[2-4x]|\s(?:bionic|x2|pro|razr))?(:?\s4g)?)[\w\s]+build\//i, /mot[\s-]?(\w+)*/i, /(XT\d{3,4}) build\//i, /(nexus\s6)/i],
          [s, [c, "Motorola"],
            [l, h]
          ],
          [/android.+\s(mz60\d|xoom[\s2]{0,2})\sbuild\//i],
          [s, [c, "Motorola"],
            [l, p]
          ],
          [/hbbtv\/\d+\.\d+\.\d+\s+\([\w\s]*;\s*(\w[^;]*);([^;]*)/i],
          [
            [c, d.trim],
            [s, d.trim],
            [l, "smarttv"]
          ],
          [/hbbtv.+maple;(\d+)/i],
          [
            [s, /^/, "SmartTV"],
            [c, "Samsung"],
            [l, "smarttv"]
          ],
          [/\(dtv[\);].+(aquos)/i],
          [s, [c, "Sharp"],
            [l, "smarttv"]
          ],
          [/android.+((sch-i[89]0\d|shw-m380s|gt-p\d{4}|gt-n\d+|sgh-t8[56]9|nexus 10))/i, /((SM-T\w+))/i],
          [
            [c, "Samsung"], s, [l, p]
          ],
          [/smart-tv.+(samsung)/i],
          [c, [l, "smarttv"], s],
          [/((s[cgp]h-\w+|gt-\w+|galaxy\snexus|sm-\w[\w\d]+))/i, /(sam[sung]*)[\s-]*(\w+-?[\w-]*)*/i, /sec-((sgh\w+))/i],
          [
            [c, "Samsung"], s, [l, h]
          ],
          [/sie-(\w+)*/i],
          [s, [c, "Siemens"],
            [l, h]
          ],
          [/(maemo|nokia).*(n900|lumia\s\d+)/i, /(nokia)[\s_-]?([\w-]+)*/i],
          [
            [c, "Nokia"], s, [l, h]
          ],
          [/android\s3\.[\s\w;-]{10}(a\d{3})/i],
          [s, [c, "Acer"],
            [l, p]
          ],
          [/android.+([vl]k\-?\d{3})\s+build/i],
          [s, [c, "LG"],
            [l, p]
          ],
          [/android\s3\.[\s\w;-]{10}(lg?)-([06cv9]{3,4})/i],
          [
            [c, "LG"], s, [l, p]
          ],
          [/(lg) netcast\.tv/i],
          [c, s, [l, "smarttv"]],
          [/(nexus\s[45])/i, /lg[e;\s\/-]+(\w+)*/i, /android.+lg(\-?[\d\w]+)\s+build/i],
          [s, [c, "LG"],
            [l, h]
          ],
          [/android.+(ideatab[a-z0-9\-\s]+)/i],
          [s, [c, "Lenovo"],
            [l, p]
          ],
          [/linux;.+((jolla));/i],
          [c, s, [l, h]],
          [/((pebble))app\/[\d\.]+\s/i],
          [c, s, [l, "wearable"]],
          [/android.+;\s(oppo)\s?([\w\s]+)\sbuild/i],
          [c, s, [l, h]],
          [/crkey/i],
          [
            [s, "Chromecast"],
            [c, "Google"]
          ],
          [/android.+;\s(glass)\s\d/i],
          [s, [c, "Google"],
            [l, "wearable"]
          ],
          [/android.+;\s(pixel c)\s/i],
          [s, [c, "Google"],
            [l, p]
          ],
          [/android.+;\s(pixel xl|pixel)\s/i],
          [s, [c, "Google"],
            [l, h]
          ],
          [/android.+(\w+)\s+build\/hm\1/i, /android.+(hm[\s\-_]*note?[\s_]*(?:\d\w)?)\s+build/i, /android.+(mi[\s\-_]*(?:one|one[\s_]plus|note lte)?[\s_]*(?:\d\w)?)\s+build/i],
          [
            [s, /_/g, " "],
            [c, "Xiaomi"],
            [l, h]
          ],
          [/android.+;\s(m[1-5]\snote)\sbuild/i],
          [s, [c, "Meizu"],
            [l, p]
          ],
          [/android.+a000(1)\s+build/i],
          [s, [c, "OnePlus"],
            [l, h]
          ],
          [/android.+[;\/]\s*(RCT[\d\w]+)\s+build/i],
          [s, [c, "RCA"],
            [l, p]
          ],
          [/android.+[;\/]\s*(Venue[\d\s]*)\s+build/i],
          [s, [c, "Dell"],
            [l, p]
          ],
          [/android.+[;\/]\s*(Q[T|M][\d\w]+)\s+build/i],
          [s, [c, "Verizon"],
            [l, p]
          ],
          [/android.+[;\/]\s+(Barnes[&\s]+Noble\s+|BN[RT])(V?.*)\s+build/i],
          [
            [c, "Barnes & Noble"], s, [l, p]
          ],
          [/android.+[;\/]\s+(TM\d{3}.*\b)\s+build/i],
          [s, [c, "NuVision"],
            [l, p]
          ],
          [/android.+[;\/]\s*(zte)?.+(k\d{2})\s+build/i],
          [
            [c, "ZTE"], s, [l, p]
          ],
          [/android.+[;\/]\s*(gen\d{3})\s+build.*49h/i],
          [s, [c, "Swiss"],
            [l, h]
          ],
          [/android.+[;\/]\s*(zur\d{3})\s+build/i],
          [s, [c, "Swiss"],
            [l, p]
          ],
          [/android.+[;\/]\s*((Zeki)?TB.*\b)\s+build/i],
          [s, [c, "Zeki"],
            [l, p]
          ],
          [/(android).+[;\/]\s+([YR]\d{2}x?.*)\s+build/i, /android.+[;\/]\s+(Dragon[\-\s]+Touch\s+|DT)(.+)\s+build/i],
          [
            [c, "Dragon Touch"], s, [l, p]
          ],
          [/android.+[;\/]\s*(NS-?.+)\s+build/i],
          [s, [c, "Insignia"],
            [l, p]
          ],
          [/android.+[;\/]\s*((NX|Next)-?.+)\s+build/i],
          [s, [c, "NextBook"],
            [l, p]
          ],
          [/android.+[;\/]\s*(Xtreme\_?)?(V(1[045]|2[015]|30|40|60|7[05]|90))\s+build/i],
          [
            [c, "Voice"], s, [l, h]
          ],
          [/android.+[;\/]\s*(LVTEL\-?)?(V1[12])\s+build/i],
          [
            [c, "LvTel"], s, [l, h]
          ],
          [/android.+[;\/]\s*(V(100MD|700NA|7011|917G).*\b)\s+build/i],
          [s, [c, "Envizen"],
            [l, p]
          ],
          [/android.+[;\/]\s*(Le[\s\-]+Pan)[\s\-]+(.*\b)\s+build/i],
          [c, s, [l, p]],
          [/android.+[;\/]\s*(Trio[\s\-]*.*)\s+build/i],
          [s, [c, "MachSpeed"],
            [l, p]
          ],
          [/android.+[;\/]\s*(Trinity)[\-\s]*(T\d{3})\s+build/i],
          [c, s, [l, p]],
          [/android.+[;\/]\s*TU_(1491)\s+build/i],
          [s, [c, "Rotor"],
            [l, p]
          ],
          [/android.+(KS(.+))\s+build/i],
          [s, [c, "Amazon"],
            [l, p]
          ],
          [/android.+(Gigaset)[\s\-]+(Q.+)\s+build/i],
          [c, s, [l, p]],
          [/\s(tablet|tab)[;\/]/i, /\s(mobile)(?:[;\/]|\ssafari)/i],
          [
            [l, d.lowerize], c, s
          ],
          [/(android.+)[;\/].+build/i],
          [s, [c, "Generic"]]
        ],
        engine: [
          [/windows.+\sedge\/([\w\.]+)/i],
          [u, [a, "EdgeHTML"]],
          [/(presto)\/([\w\.]+)/i, /(webkit|trident|netfront|netsurf|amaya|lynx|w3m)\/([\w\.]+)/i, /(khtml|tasman|links)[\/\s]\(?([\w\.]+)/i, /(icab)[\/\s]([23]\.[\d\.]+)/i],
          [a, u],
          [/rv\:([\w\.]+).*(gecko)/i],
          [u, a]
        ],
        os: [
          [/microsoft\s(windows)\s(vista|xp)/i],
          [a, u],
          [/(windows)\snt\s6\.2;\s(arm)/i, /(windows\sphone(?:\sos)*)[\s\/]?([\d\.\s]+\w)*/i, /(windows\smobile|windows)[\s\/]?([ntce\d\.\s]+\w)/i],
          [a, [u, f.str, m.os.windows.version]],
          [/(win(?=3|9|n)|win\s9x\s)([nt\d\.]+)/i],
          [
            [a, "Windows"],
            [u, f.str, m.os.windows.version]
          ],
          [/\((bb)(10);/i],
          [
            [a, "BlackBerry"], u
          ],
          [/(blackberry)\w*\/?([\w\.]+)*/i, /(tizen)[\/\s]([\w\.]+)/i, /(android|webos|palm\sos|qnx|bada|rim\stablet\sos|meego|contiki)[\/\s-]?([\w\.]+)*/i, /linux;.+(sailfish);/i],
          [a, u],
          [/(symbian\s?os|symbos|s60(?=;))[\/\s-]?([\w\.]+)*/i],
          [
            [a, "Symbian"], u
          ],
          [/\((series40);/i],
          [a],
          [/mozilla.+\(mobile;.+gecko.+firefox/i],
          [
            [a, "Firefox OS"], u
          ],
          [/(nintendo|playstation)\s([wids34portablevu]+)/i, /(mint)[\/\s\(]?(\w+)*/i, /(mageia|vectorlinux)[;\s]/i, /(joli|[kxln]?ubuntu|debian|[open]*suse|gentoo|(?=\s)arch|slackware|fedora|mandriva|centos|pclinuxos|redhat|zenwalk|linpus)[\/\s-]?(?!chrom)([\w\.-]+)*/i, /(hurd|linux)\s?([\w\.]+)*/i, /(gnu)\s?([\w\.]+)*/i],
          [a, u],
          [/(cros)\s[\w]+\s([\w\.]+\w)/i],
          [
            [a, "Chromium OS"], u
          ],
          [/(sunos)\s?([\w\.]+\d)*/i],
          [
            [a, "Solaris"], u
          ],
          [/\s([frentopc-]{0,4}bsd|dragonfly)\s?([\w\.]+)*/i],
          [a, u],
          [/(haiku)\s(\w+)/i],
          [a, u],
          [/cfnetwork\/.+darwin/i, /ip[honead]+(?:.*os\s([\w]+)*\slike\smac|;\sopera)/i],
          [
            [u, /_/g, "."],
            [a, "iOS"]
          ],
          [/(mac\sos\sx)\s?([\w\s\.]+\w)*/i, /(macintosh|mac(?=_powerpc)\s)/i],
          [
            [a, "Mac OS"],
            [u, /_/g, "."]
          ],
          [/((?:open)?solaris)[\/\s-]?([\w\.]+)*/i, /(aix)\s((\d)(?=\.|\)|\s)[\w\.]*)*/i, /(plan\s9|minix|beos|os\/2|amigaos|morphos|risc\sos|openvms)/i, /(unix)\s?([\w\.]+)*/i],
          [a, u]
        ]
      },
      y = function (e, t) {
        this[a] = e, this[u] = t
      },
      v = function (e) {
        this.architecture = e
      },
      w = function (e, t, n) {
        this[c] = e, this[s] = t, this[l] = n
      },
      b = y,
      S = y,
      C = function (e, t) {
        if ("object" == typeof e && (t = e, e = void 0), !(this instanceof C)) return new C(e, t).getResult();
        var n = e || (i && i.navigator && i.navigator.userAgent ? i.navigator.userAgent : ""),
          r = t ? d.extend(g, t) : g,
          o = new y,
          s = new v,
          a = new w,
          l = new b,
          c = new S;
        return this.getBrowser = function () {
          return f.rgx.call(o, n, r.browser), o.major = d.major(o.version), o
        }, this.getCPU = function () {
          return f.rgx.call(s, n, r.cpu), s
        }, this.getDevice = function () {
          return f.rgx.call(a, n, r.device), a
        }, this.getEngine = function () {
          return f.rgx.call(l, n, r.engine), l
        }, this.getOS = function () {
          return f.rgx.call(c, n, r.os), c
        }, this.getResult = function () {
          return {
            ua: this.getUA(),
            browser: this.getBrowser(),
            engine: this.getEngine(),
            os: this.getOS(),
            device: this.getDevice(),
            cpu: this.getCPU()
          }
        }, this.getUA = function () {
          return n
        }, this.setUA = function (e) {
          return n = e, o = new y, s = new v, a = new w, l = new b, c = new S, this
        }, this
      };
    C.VERSION = "0.7.14", C.BROWSER = {
      NAME: a,
      MAJOR: "major",
      VERSION: u
    }, C.CPU = {
      ARCHITECTURE: "architecture"
    }, C.DEVICE = {
      MODEL: s,
      VENDOR: c,
      TYPE: l,
      CONSOLE: "console",
      MOBILE: h,
      SMARTTV: "smarttv",
      TABLET: p,
      WEARABLE: "wearable",
      EMBEDDED: "embedded"
    }, C.ENGINE = {
      NAME: a,
      VERSION: u
    }, C.OS = {
      NAME: a,
      VERSION: u
    }, void 0 !== t ? (void 0 !== e && e.exports && (t = e.exports = C), t.UAParser = C) : n(167) ? void 0 === (r = function () {
      return C
    }.call(t, n, t, e)) || (e.exports = r) : i && (i.UAParser = C);
    var E = i && (i.jQuery || i.Zepto);
    if (void 0 !== E) {
      var k = new C;
      E.ua = k.getResult(), E.ua.get = function () {
        return k.getUA()
      }, E.ua.set = function (e) {
        k.setUA(e);
        var t = k.getResult();
        for (var n in t) E.ua[n] = t[n]
      }
    }
  }("object" == typeof window ? window : this)
}, function (e, t) {
  (function (t) {
    e.exports = t
  }).call(this, {})
}, function (e, t, n) {
  var r = n(96),
    i = process.cwd,
    o = null,
    s = process.env.GRACEFUL_FS_PLATFORM || "win32";
  process.cwd = function () {
    return o || (o = i.call(process)), o
  };
  try {
    process.cwd()
  } catch (e) {}
  var a = process.chdir;
  process.chdir = function (e) {
    o = null, a.call(process, e)
  }, e.exports = function (e) {
    r.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./) && function (e) {
      e.lchmod = function (t, n, i) {
        e.open(t, r.O_WRONLY | r.O_SYMLINK, n, (function (t, r) {
          t ? i && i(t) : e.fchmod(r, n, (function (t) {
            e.close(r, (function (e) {
              i && i(t || e)
            }))
          }))
        }))
      }, e.lchmodSync = function (t, n) {
        var i, o = e.openSync(t, r.O_WRONLY | r.O_SYMLINK, n),
          s = !0;
        try {
          i = e.fchmodSync(o, n), s = !1
        } finally {
          if (s) try {
            e.closeSync(o)
          } catch (e) {} else e.closeSync(o)
        }
        return i
      }
    }(e);
    e.lutimes || function (e) {
      r.hasOwnProperty("O_SYMLINK") ? (e.lutimes = function (t, n, i, o) {
        e.open(t, r.O_SYMLINK, (function (t, r) {
          t ? o && o(t) : e.futimes(r, n, i, (function (t) {
            e.close(r, (function (e) {
              o && o(t || e)
            }))
          }))
        }))
      }, e.lutimesSync = function (t, n, i) {
        var o, s = e.openSync(t, r.O_SYMLINK),
          a = !0;
        try {
          o = e.futimesSync(s, n, i), a = !1
        } finally {
          if (a) try {
            e.closeSync(s)
          } catch (e) {} else e.closeSync(s)
        }
        return o
      }) : (e.lutimes = function (e, t, n, r) {
        r && process.nextTick(r)
      }, e.lutimesSync = function () {})
    }(e);
    e.chown = o(e.chown), e.fchown = o(e.fchown), e.lchown = o(e.lchown), e.chmod = n(e.chmod), e.fchmod = n(e.fchmod), e.lchmod = n(e.lchmod), e.chownSync = a(e.chownSync), e.fchownSync = a(e.fchownSync), e.lchownSync = a(e.lchownSync), e.chmodSync = i(e.chmodSync), e.fchmodSync = i(e.fchmodSync), e.lchmodSync = i(e.lchmodSync), e.stat = l(e.stat), e.fstat = l(e.fstat), e.lstat = l(e.lstat), e.statSync = c(e.statSync), e.fstatSync = c(e.fstatSync), e.lstatSync = c(e.lstatSync), e.lchmod || (e.lchmod = function (e, t, n) {
      n && process.nextTick(n)
    }, e.lchmodSync = function () {});
    e.lchown || (e.lchown = function (e, t, n, r) {
      r && process.nextTick(r)
    }, e.lchownSync = function () {});
    "win32" === s && (e.rename = (t = e.rename, function (n, r, i) {
      var o = Date.now(),
        s = 0;
      t(n, r, (function a(l) {
        if (l && ("EACCES" === l.code || "EPERM" === l.code) && Date.now() - o < 6e4) return setTimeout((function () {
          e.stat(r, (function (e, o) {
            e && "ENOENT" === e.code ? t(n, r, a) : i(l)
          }))
        }), s), void(s < 100 && (s += 10));
        i && i(l)
      }))
    }));
    var t;

    function n(t) {
      return t ? function (n, r, i) {
        return t.call(e, n, r, (function (e) {
          u(e) && (e = null), i && i.apply(this, arguments)
        }))
      } : t
    }

    function i(t) {
      return t ? function (n, r) {
        try {
          return t.call(e, n, r)
        } catch (e) {
          if (!u(e)) throw e
        }
      } : t
    }

    function o(t) {
      return t ? function (n, r, i, o) {
        return t.call(e, n, r, i, (function (e) {
          u(e) && (e = null), o && o.apply(this, arguments)
        }))
      } : t
    }

    function a(t) {
      return t ? function (n, r, i) {
        try {
          return t.call(e, n, r, i)
        } catch (e) {
          if (!u(e)) throw e
        }
      } : t
    }

    function l(t) {
      return t ? function (n, r, i) {
        function o(e, t) {
          t && (t.uid < 0 && (t.uid += 4294967296), t.gid < 0 && (t.gid += 4294967296)), i && i.apply(this, arguments)
        }
        return "function" == typeof r && (i = r, r = null), r ? t.call(e, n, r, o) : t.call(e, n, o)
      } : t
    }

    function c(t) {
      return t ? function (n, r) {
        var i = r ? t.call(e, n, r) : t.call(e, n);
        return i.uid < 0 && (i.uid += 4294967296), i.gid < 0 && (i.gid += 4294967296), i
      } : t
    }

    function u(e) {
      return !e || ("ENOSYS" === e.code || !(process.getuid && 0 === process.getuid() || "EINVAL" !== e.code && "EPERM" !== e.code))
    }
    e.read = function (t) {
      function n(n, r, i, o, s, a) {
        var l;
        if (a && "function" == typeof a) {
          var c = 0;
          l = function (u, h, p) {
            if (u && "EAGAIN" === u.code && c < 10) return c++, t.call(e, n, r, i, o, s, l);
            a.apply(this, arguments)
          }
        }
        return t.call(e, n, r, i, o, s, l)
      }
      return n.__proto__ = t, n
    }(e.read), e.readSync = (h = e.readSync, function (t, n, r, i, o) {
      for (var s = 0;;) try {
        return h.call(e, t, n, r, i, o)
      } catch (e) {
        if ("EAGAIN" === e.code && s < 10) {
          s++;
          continue
        }
        throw e
      }
    });
    var h
  }
}, function (e, t, n) {
  var r = n(43).Stream;
  e.exports = function (e) {
    return {
      ReadStream: function t(n, i) {
        if (!(this instanceof t)) return new t(n, i);
        r.call(this);
        var o = this;
        this.path = n, this.fd = null, this.readable = !0, this.paused = !1, this.flags = "r", this.mode = 438, this.bufferSize = 65536, i = i || {};
        for (var s = Object.keys(i), a = 0, l = s.length; a < l; a++) {
          var c = s[a];
          this[c] = i[c]
        }
        this.encoding && this.setEncoding(this.encoding);
        if (void 0 !== this.start) {
          if ("number" != typeof this.start) throw TypeError("start must be a Number");
          if (void 0 === this.end) this.end = 1 / 0;
          else if ("number" != typeof this.end) throw TypeError("end must be a Number");
          if (this.start > this.end) throw new Error("start must be <= end");
          this.pos = this.start
        }
        if (null !== this.fd) return void process.nextTick((function () {
          o._read()
        }));
        e.open(this.path, this.flags, this.mode, (function (e, t) {
          if (e) return o.emit("error", e), void(o.readable = !1);
          o.fd = t, o.emit("open", t), o._read()
        }))
      },
      WriteStream: function t(n, i) {
        if (!(this instanceof t)) return new t(n, i);
        r.call(this), this.path = n, this.fd = null, this.writable = !0, this.flags = "w", this.encoding = "binary", this.mode = 438, this.bytesWritten = 0, i = i || {};
        for (var o = Object.keys(i), s = 0, a = o.length; s < a; s++) {
          var l = o[s];
          this[l] = i[l]
        }
        if (void 0 !== this.start) {
          if ("number" != typeof this.start) throw TypeError("start must be a Number");
          if (this.start < 0) throw new Error("start must be >= zero");
          this.pos = this.start
        }
        this.busy = !1, this._queue = [], null === this.fd && (this._open = e.open, this._queue.push([this._open, this.path, this.flags, this.mode, void 0]), this.flush())
      }
    }
  }
}, function (e, t, n) {
  "use strict";
  e.exports = function (e) {
    if (null === e || "object" != typeof e) return e;
    if (e instanceof Object) var t = {
      __proto__: e.__proto__
    };
    else t = Object.create(null);
    return Object.getOwnPropertyNames(e).forEach((function (n) {
      Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(e, n))
    })), t
  }
}, function (e, t, n) {
  "use strict";
  const r = n(13),
    i = n(1),
    o = n(17).mkdirsSync,
    s = n(99).utimesMillisSync,
    a = Symbol("notExist");

  function l(e, t, n, o) {
    if (!o.filter || o.filter(t, n)) return function (e, t, n, o) {
      const s = (o.dereference ? r.statSync : r.lstatSync)(t);
      if (s.isDirectory()) return function (e, t, n, i, o) {
        if (t === a) return function (e, t, n, i) {
          return r.mkdirSync(n), u(t, n, i), r.chmodSync(n, e.mode)
        }(e, n, i, o);
        if (t && !t.isDirectory()) throw new Error(`Cannot overwrite non-directory '${i}' with directory '${n}'.`);
        return u(n, i, o)
      }(s, e, t, n, o);
      if (s.isFile() || s.isCharacterDevice() || s.isBlockDevice()) return function (e, t, n, i, o) {
        return t === a ? c(e, n, i, o) : function (e, t, n, i) {
          if (i.overwrite) return r.unlinkSync(n), c(e, t, n, i);
          if (i.errorOnExist) throw new Error(`'${n}' already exists`)
        }(e, n, i, o)
      }(s, e, t, n, o);
      if (s.isSymbolicLink()) return function (e, t, n, o) {
        let s = r.readlinkSync(t);
        o.dereference && (s = i.resolve(process.cwd(), s));
        if (e === a) return r.symlinkSync(s, n); {
          let e;
          try {
            e = r.readlinkSync(n)
          } catch (e) {
            if ("EINVAL" === e.code || "UNKNOWN" === e.code) return r.symlinkSync(s, n);
            throw e
          }
          if (o.dereference && (e = i.resolve(process.cwd(), e)), h(s, e)) throw new Error(`Cannot copy '${s}' to a subdirectory of itself, '${e}'.`);
          if (r.statSync(n).isDirectory() && h(e, s)) throw new Error(`Cannot overwrite '${e}' with '${s}'.`);
          return function (e, t) {
            return r.unlinkSync(t), r.symlinkSync(e, t)
          }(s, n)
        }
      }(e, t, n, o)
    }(e, t, n, o)
  }

  function c(e, t, i, o) {
    return "function" == typeof r.copyFileSync ? (r.copyFileSync(t, i), r.chmodSync(i, e.mode), o.preserveTimestamps ? s(i, e.atime, e.mtime) : void 0) : function (e, t, i, o) {
      const s = n(100)(65536),
        a = r.openSync(t, "r"),
        l = r.openSync(i, "w", e.mode);
      let c = 0;
      for (; c < e.size;) {
        const e = r.readSync(a, s, 0, 65536, c);
        r.writeSync(l, s, 0, e), c += e
      }
      o.preserveTimestamps && r.futimesSync(l, e.atime, e.mtime);
      r.closeSync(a), r.closeSync(l)
    }(e, t, i, o)
  }

  function u(e, t, n) {
    r.readdirSync(e).forEach(r => function (e, t, n, r) {
      const o = i.join(t, e),
        s = i.join(n, e);
      return l(p(o, s), o, s, r)
    }(r, e, t, n))
  }

  function h(e, t) {
    const n = i.resolve(e).split(i.sep),
      r = i.resolve(t).split(i.sep);
    return n.reduce((e, t, n) => e && r[n] === t, !0)
  }

  function p(e, t) {
    const {
      srcStat: n,
      destStat: i
    } = function (e, t) {
      const n = r.statSync(e);
      let i;
      try {
        i = r.statSync(t)
      } catch (e) {
        if ("ENOENT" === e.code) return {
          srcStat: n,
          destStat: a
        };
        throw e
      }
      return {
        srcStat: n,
        destStat: i
      }
    }(e, t);
    if (i.ino && i.ino === n.ino) throw new Error("Source and destination must not be the same.");
    if (n.isDirectory() && h(e, t)) throw new Error(`Cannot copy '${e}' to a subdirectory of itself, '${t}'.`);
    return i
  }
  e.exports = function (e, t, n) {
    "function" == typeof n && (n = {
      filter: n
    }), (n = n || {}).clobber = !("clobber" in n) || !!n.clobber, n.overwrite = "overwrite" in n ? !!n.overwrite : n.clobber, n.preserveTimestamps && "ia32" === process.arch && console.warn("fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\n\n    see https://github.com/jprichardson/node-fs-extra/issues/269");
    const s = p(e, t);
    if (n.filter && !n.filter(e, t)) return;
    const a = i.dirname(t);
    return r.existsSync(a) || o(a), l(s, e, t, n)
  }
}, function (e, t, n) {
  "use strict";
  const r = n(13),
    i = n(1),
    o = n(98).invalidWin32Path,
    s = parseInt("0777", 8);
  e.exports = function e(t, n, a, l) {
    if ("function" == typeof n ? (a = n, n = {}) : n && "object" == typeof n || (n = {
        mode: n
      }), o(t)) {
      const e = new Error(t + " contains invalid WIN32 path characters.");
      return e.code = "EINVAL", a(e)
    }
    let c = n.mode;
    const u = n.fs || r;
    void 0 === c && (c = s & ~process.umask()), l || (l = null), a = a || function () {}, t = i.resolve(t), u.mkdir(t, c, r => {
      if (!r) return a(null, l = l || t);
      switch (r.code) {
        case "ENOENT":
          if (i.dirname(t) === t) return a(r);
          e(i.dirname(t), n, (r, i) => {
            r ? a(r, i) : e(t, n, a, i)
          });
          break;
        default:
          u.stat(t, (e, t) => {
            e || !t.isDirectory() ? a(r, l) : a(null, l)
          })
      }
    })
  }
}, function (e, t, n) {
  "use strict";
  const r = n(13),
    i = n(1),
    o = n(98).invalidWin32Path,
    s = parseInt("0777", 8);
  e.exports = function e(t, n, a) {
    n && "object" == typeof n || (n = {
      mode: n
    });
    let l = n.mode;
    const c = n.fs || r;
    if (o(t)) {
      const e = new Error(t + " contains invalid WIN32 path characters.");
      throw e.code = "EINVAL", e
    }
    void 0 === l && (l = s & ~process.umask()), a || (a = null), t = i.resolve(t);
    try {
      c.mkdirSync(t, l), a = a || t
    } catch (r) {
      if ("ENOENT" === r.code) {
        if (i.dirname(t) === t) throw r;
        a = e(i.dirname(t), n, a), e(t, n, a)
      } else {
        let e;
        try {
          e = c.statSync(t)
        } catch (e) {
          throw r
        }
        if (!e.isDirectory()) throw r
      }
    }
    return a
  }
}, function (e, t, n) {
  "use strict";
  const r = n(13),
    i = n(1),
    o = n(17).mkdirs,
    s = n(21).pathExists,
    a = n(99).utimesMillis,
    l = Symbol("notExist");

  function c(e, t, n, r, a) {
    const l = i.dirname(n);
    s(l, (i, s) => i ? a(i) : s ? h(e, t, n, r, a) : void o(l, i => i ? a(i) : h(e, t, n, r, a)))
  }

  function u(e, t, n, r, i, o) {
    Promise.resolve(i.filter(n, r)).then(s => s ? t ? e(t, n, r, i, o) : e(n, r, i, o) : o(), e => o(e))
  }

  function h(e, t, n, r, i) {
    return r.filter ? u(p, e, t, n, r, i) : p(e, t, n, r, i)
  }

  function p(e, t, n, o, s) {
    (o.dereference ? r.stat : r.lstat)(t, (a, c) => a ? s(a) : c.isDirectory() ? function (e, t, n, i, o, s) {
      if (t === l) return function (e, t, n, i, o) {
        r.mkdir(n, s => {
          if (s) return o(s);
          m(t, n, i, t => t ? o(t) : r.chmod(n, e.mode, o))
        })
      }(e, n, i, o, s);
      if (t && !t.isDirectory()) return s(new Error(`Cannot overwrite non-directory '${i}' with directory '${n}'.`));
      return m(n, i, o, s)
    }(c, e, t, n, o, s) : c.isFile() || c.isCharacterDevice() || c.isBlockDevice() ? function (e, t, n, i, o, s) {
      return t === l ? d(e, n, i, o, s) : function (e, t, n, i, o) {
        if (!i.overwrite) return i.errorOnExist ? o(new Error(`'${n}' already exists`)) : o();
        r.unlink(n, r => r ? o(r) : d(e, t, n, i, o))
      }(e, n, i, o, s)
    }(c, e, t, n, o, s) : c.isSymbolicLink() ? function (e, t, n, o, s) {
      r.readlink(t, (t, a) => t ? s(t) : (o.dereference && (a = i.resolve(process.cwd(), a)), e === l ? r.symlink(a, n, s) : void r.readlink(n, (t, l) => t ? "EINVAL" === t.code || "UNKNOWN" === t.code ? r.symlink(a, n, s) : s(t) : (o.dereference && (l = i.resolve(process.cwd(), l)), y(a, l) ? s(new Error(`Cannot copy '${a}' to a subdirectory of itself, '${l}'.`)) : e.isDirectory() && y(l, a) ? s(new Error(`Cannot overwrite '${l}' with '${a}'.`)) : function (e, t, n) {
        r.unlink(t, i => i ? n(i) : r.symlink(e, t, n))
      }(a, n, s)))))
    }(e, t, n, o, s) : void 0)
  }

  function d(e, t, n, i, o) {
    return "function" == typeof r.copyFile ? r.copyFile(t, n, t => t ? o(t) : f(e, n, i, o)) : function (e, t, n, i, o) {
      const s = r.createReadStream(t);
      s.on("error", e => o(e)).once("open", () => {
        const t = r.createWriteStream(n, {
          mode: e.mode
        });
        t.on("error", e => o(e)).on("open", () => s.pipe(t)).once("close", () => f(e, n, i, o))
      })
    }(e, t, n, i, o)
  }

  function f(e, t, n, i) {
    r.chmod(t, e.mode, r => r ? i(r) : n.preserveTimestamps ? a(t, e.atime, e.mtime, i) : i())
  }

  function m(e, t, n, i) {
    r.readdir(e, (r, o) => r ? i(r) : g(o, e, t, n, i))
  }

  function g(e, t, n, r, o) {
    const s = e.pop();
    return s ? function (e, t, n, r, o, s) {
      const a = i.join(n, t),
        l = i.join(r, t);
      v(a, l, (t, i) => {
        if (t) return s(t);
        h(i, a, l, o, t => t ? s(t) : g(e, n, r, o, s))
      })
    }(e, s, t, n, r, o) : o()
  }

  function y(e, t) {
    const n = i.resolve(e).split(i.sep),
      r = i.resolve(t).split(i.sep);
    return n.reduce((e, t, n) => e && r[n] === t, !0)
  }

  function v(e, t, n) {
    ! function (e, t, n) {
      r.stat(e, (e, i) => {
        if (e) return n(e);
        r.stat(t, (e, t) => e ? "ENOENT" === e.code ? n(null, {
          srcStat: i,
          destStat: l
        }) : n(e) : n(null, {
          srcStat: i,
          destStat: t
        }))
      })
    }(e, t, (r, i) => {
      if (r) return n(r);
      const {
        srcStat: o,
        destStat: s
      } = i;
      return s.ino && s.ino === o.ino ? n(new Error("Source and destination must not be the same.")) : o.isDirectory() && y(e, t) ? n(new Error(`Cannot copy '${e}' to a subdirectory of itself, '${t}'.`)) : n(null, s)
    })
  }
  e.exports = function (e, t, n, r) {
    "function" != typeof n || r ? "function" == typeof n && (n = {
      filter: n
    }) : (r = n, n = {}), r = r || function () {}, (n = n || {}).clobber = !("clobber" in n) || !!n.clobber, n.overwrite = "overwrite" in n ? !!n.overwrite : n.clobber, n.preserveTimestamps && "ia32" === process.arch && console.warn("fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\n\n    see https://github.com/jprichardson/node-fs-extra/issues/269"), v(e, t, (i, o) => i ? r(i) : n.filter ? u(c, o, e, t, n, r) : c(o, e, t, n, r))
  }
}, function (e, t, n) {
  "use strict";
  const r = n(16).fromCallback,
    i = n(7),
    o = n(1),
    s = n(17),
    a = n(45),
    l = r((function (e, t) {
      t = t || function () {}, i.readdir(e, (n, r) => {
        if (n) return s.mkdirs(e, t);
        r = r.map(t => o.join(e, t)),
          function e() {
            const n = r.pop();
            if (!n) return t();
            a.remove(n, n => {
              if (n) return t(n);
              e()
            })
          }()
      })
    }));

  function c(e) {
    let t;
    try {
      t = i.readdirSync(e)
    } catch (t) {
      return s.mkdirsSync(e)
    }
    t.forEach(t => {
      t = o.join(e, t), a.removeSync(t)
    })
  }
  e.exports = {
    emptyDirSync: c,
    emptydirSync: c,
    emptyDir: l,
    emptydir: l
  }
}, function (e, t, n) {
  "use strict";
  const r = n(13),
    i = n(1),
    o = n(44);

  function s(e) {
    ["unlink", "chmod", "stat", "lstat", "rmdir", "readdir"].forEach(t => {
      e[t] = e[t] || r[t], e[t += "Sync"] = e[t] || r[t]
    }), e.maxBusyTries = e.maxBusyTries || 3
  }

  function a(e, t, n) {
    let r = 0;
    "function" == typeof t && (n = t, t = {}), o(e, "rimraf: missing path"), o.strictEqual(typeof e, "string", "rimraf: path should be a string"), o.strictEqual(typeof n, "function", "rimraf: callback function required"), o(t, "rimraf: invalid options argument provided"), o.strictEqual(typeof t, "object", "rimraf: options should be object"), s(t), l(e, t, (function i(o) {
      if (o) {
        if (("EBUSY" === o.code || "ENOTEMPTY" === o.code || "EPERM" === o.code) && r < t.maxBusyTries) {
          r++;
          return setTimeout(() => l(e, t, i), 100 * r)
        }
        "ENOENT" === o.code && (o = null)
      }
      n(o)
    }))
  }

  function l(e, t, n) {
    o(e), o(t), o("function" == typeof n), t.lstat(e, (r, i) => r && "ENOENT" === r.code ? n(null) : r && "EPERM" === r.code ? c(e, t, r, n) : i && i.isDirectory() ? h(e, t, r, n) : void t.unlink(e, r => {
      if (r) {
        if ("ENOENT" === r.code) return n(null);
        if ("EPERM" === r.code) return c(e, t, r, n);
        if ("EISDIR" === r.code) return h(e, t, r, n)
      }
      return n(r)
    }))
  }

  function c(e, t, n, r) {
    o(e), o(t), o("function" == typeof r), n && o(n instanceof Error), t.chmod(e, 438, i => {
      i ? r("ENOENT" === i.code ? null : n) : t.stat(e, (i, o) => {
        i ? r("ENOENT" === i.code ? null : n) : o.isDirectory() ? h(e, t, n, r) : t.unlink(e, r)
      })
    })
  }

  function u(e, t, n) {
    let r;
    o(e), o(t), n && o(n instanceof Error);
    try {
      t.chmodSync(e, 438)
    } catch (e) {
      if ("ENOENT" === e.code) return;
      throw n
    }
    try {
      r = t.statSync(e)
    } catch (e) {
      if ("ENOENT" === e.code) return;
      throw n
    }
    r.isDirectory() ? d(e, t, n) : t.unlinkSync(e)
  }

  function h(e, t, n, r) {
    o(e), o(t), n && o(n instanceof Error), o("function" == typeof r), t.rmdir(e, s => {
      !s || "ENOTEMPTY" !== s.code && "EEXIST" !== s.code && "EPERM" !== s.code ? s && "ENOTDIR" === s.code ? r(n) : r(s) : function (e, t, n) {
        o(e), o(t), o("function" == typeof n), t.readdir(e, (r, o) => {
          if (r) return n(r);
          let s, l = o.length;
          if (0 === l) return t.rmdir(e, n);
          o.forEach(r => {
            a(i.join(e, r), t, r => {
              if (!s) return r ? n(s = r) : void(0 == --l && t.rmdir(e, n))
            })
          })
        })
      }(e, t, r)
    })
  }

  function p(e, t) {
    let n;
    s(t = t || {}), o(e, "rimraf: missing path"), o.strictEqual(typeof e, "string", "rimraf: path should be a string"), o(t, "rimraf: missing options"), o.strictEqual(typeof t, "object", "rimraf: options should be object");
    try {
      n = t.lstatSync(e)
    } catch (n) {
      if ("ENOENT" === n.code) return;
      "EPERM" === n.code && u(e, t, n)
    }
    try {
      n && n.isDirectory() ? d(e, t, null) : t.unlinkSync(e)
    } catch (n) {
      if ("ENOENT" === n.code) return;
      if ("EPERM" === n.code) return u(e, t, n);
      if ("EISDIR" !== n.code) throw n;
      d(e, t, n)
    }
  }

  function d(e, t, n) {
    o(e), o(t), n && o(n instanceof Error);
    try {
      t.rmdirSync(e)
    } catch (r) {
      if ("ENOTDIR" === r.code) throw n;
      if ("ENOTEMPTY" === r.code || "EEXIST" === r.code || "EPERM" === r.code) ! function (e, t) {
        o(e), o(t), t.readdirSync(e).forEach(n => p(i.join(e, n), t)); {
          const n = Date.now();
          do {
            try {
              return t.rmdirSync(e, t)
            } catch (e) {}
          } while (Date.now() - n < 500)
        }
      }(e, t);
      else if ("ENOENT" !== r.code) throw r
    }
  }
  e.exports = a, a.sync = p
}, function (e, t, n) {
  "use strict";
  const r = n(178),
    i = n(179),
    o = n(180);
  e.exports = {
    createFile: r.createFile,
    createFileSync: r.createFileSync,
    ensureFile: r.createFile,
    ensureFileSync: r.createFileSync,
    createLink: i.createLink,
    createLinkSync: i.createLinkSync,
    ensureLink: i.createLink,
    ensureLinkSync: i.createLinkSync,
    createSymlink: o.createSymlink,
    createSymlinkSync: o.createSymlinkSync,
    ensureSymlink: o.createSymlink,
    ensureSymlinkSync: o.createSymlinkSync
  }
}, function (e, t, n) {
  "use strict";
  const r = n(16).fromCallback,
    i = n(1),
    o = n(13),
    s = n(17),
    a = n(21).pathExists;
  e.exports = {
    createFile: r((function (e, t) {
      function n() {
        o.writeFile(e, "", e => {
          if (e) return t(e);
          t()
        })
      }
      o.stat(e, (r, o) => {
        if (!r && o.isFile()) return t();
        const l = i.dirname(e);
        a(l, (e, r) => e ? t(e) : r ? n() : void s.mkdirs(l, e => {
          if (e) return t(e);
          n()
        }))
      })
    })),
    createFileSync: function (e) {
      let t;
      try {
        t = o.statSync(e)
      } catch (e) {}
      if (t && t.isFile()) return;
      const n = i.dirname(e);
      o.existsSync(n) || s.mkdirsSync(n), o.writeFileSync(e, "")
    }
  }
}, function (e, t, n) {
  "use strict";
  const r = n(16).fromCallback,
    i = n(1),
    o = n(13),
    s = n(17),
    a = n(21).pathExists;
  e.exports = {
    createLink: r((function (e, t, n) {
      function r(e, t) {
        o.link(e, t, e => {
          if (e) return n(e);
          n(null)
        })
      }
      a(t, (l, c) => l ? n(l) : c ? n(null) : void o.lstat(e, o => {
        if (o) return o.message = o.message.replace("lstat", "ensureLink"), n(o);
        const l = i.dirname(t);
        a(l, (i, o) => i ? n(i) : o ? r(e, t) : void s.mkdirs(l, i => {
          if (i) return n(i);
          r(e, t)
        }))
      }))
    })),
    createLinkSync: function (e, t) {
      if (o.existsSync(t)) return;
      try {
        o.lstatSync(e)
      } catch (e) {
        throw e.message = e.message.replace("lstat", "ensureLink"), e
      }
      const n = i.dirname(t);
      return o.existsSync(n) || s.mkdirsSync(n), o.linkSync(e, t)
    }
  }
}, function (e, t, n) {
  "use strict";
  const r = n(16).fromCallback,
    i = n(1),
    o = n(13),
    s = n(17),
    a = s.mkdirs,
    l = s.mkdirsSync,
    c = n(181),
    u = c.symlinkPaths,
    h = c.symlinkPathsSync,
    p = n(182),
    d = p.symlinkType,
    f = p.symlinkTypeSync,
    m = n(21).pathExists;
  e.exports = {
    createSymlink: r((function (e, t, n, r) {
      r = "function" == typeof n ? n : r, n = "function" != typeof n && n, m(t, (s, l) => s ? r(s) : l ? r(null) : void u(e, t, (s, l) => {
        if (s) return r(s);
        e = l.toDst, d(l.toCwd, n, (n, s) => {
          if (n) return r(n);
          const l = i.dirname(t);
          m(l, (n, i) => n ? r(n) : i ? o.symlink(e, t, s, r) : void a(l, n => {
            if (n) return r(n);
            o.symlink(e, t, s, r)
          }))
        })
      }))
    })),
    createSymlinkSync: function (e, t, n) {
      if (o.existsSync(t)) return;
      const r = h(e, t);
      e = r.toDst, n = f(r.toCwd, n);
      const s = i.dirname(t);
      return o.existsSync(s) || l(s), o.symlinkSync(e, t, n)
    }
  }
}, function (e, t, n) {
  "use strict";
  const r = n(1),
    i = n(13),
    o = n(21).pathExists;
  e.exports = {
    symlinkPaths: function (e, t, n) {
      if (r.isAbsolute(e)) return i.lstat(e, t => t ? (t.message = t.message.replace("lstat", "ensureSymlink"), n(t)) : n(null, {
        toCwd: e,
        toDst: e
      })); {
        const s = r.dirname(t),
          a = r.join(s, e);
        return o(a, (t, o) => t ? n(t) : o ? n(null, {
          toCwd: a,
          toDst: e
        }) : i.lstat(e, t => t ? (t.message = t.message.replace("lstat", "ensureSymlink"), n(t)) : n(null, {
          toCwd: e,
          toDst: r.relative(s, e)
        })))
      }
    },
    symlinkPathsSync: function (e, t) {
      let n;
      if (r.isAbsolute(e)) {
        if (n = i.existsSync(e), !n) throw new Error("absolute srcpath does not exist");
        return {
          toCwd: e,
          toDst: e
        }
      } {
        const o = r.dirname(t),
          s = r.join(o, e);
        if (n = i.existsSync(s), n) return {
          toCwd: s,
          toDst: e
        };
        if (n = i.existsSync(e), !n) throw new Error("relative srcpath does not exist");
        return {
          toCwd: e,
          toDst: r.relative(o, e)
        }
      }
    }
  }
}, function (e, t, n) {
  "use strict";
  const r = n(13);
  e.exports = {
    symlinkType: function (e, t, n) {
      if (n = "function" == typeof t ? t : n, t = "function" != typeof t && t) return n(null, t);
      r.lstat(e, (e, r) => {
        if (e) return n(null, "file");
        t = r && r.isDirectory() ? "dir" : "file", n(null, t)
      })
    },
    symlinkTypeSync: function (e, t) {
      let n;
      if (t) return t;
      try {
        n = r.lstatSync(e)
      } catch (e) {
        return "file"
      }
      return n && n.isDirectory() ? "dir" : "file"
    }
  }
}, function (e, t, n) {
  "use strict";
  const r = n(16).fromCallback,
    i = n(61);
  i.outputJson = r(n(188)), i.outputJsonSync = n(189), i.outputJSON = i.outputJson, i.outputJSONSync = i.outputJsonSync, i.writeJSON = i.writeJson, i.writeJSONSync = i.writeJsonSync, i.readJSON = i.readJson, i.readJSONSync = i.readJsonSync, e.exports = i
}, function (e, t, n) {
  var r;
  try {
    r = n(185)
  } catch (e) {
    r = n(7)
  }

  function i(e, t) {
    var n, r = "\n";
    return "object" == typeof t && null !== t && (t.spaces && (n = t.spaces), t.EOL && (r = t.EOL)), JSON.stringify(e, t ? t.replacer : null, n).replace(/\n/g, r) + r
  }

  function o(e) {
    return Buffer.isBuffer(e) && (e = e.toString("utf8")), e = e.replace(/^\uFEFF/, "")
  }
  var s = {
    readFile: function (e, t, n) {
      null == n && (n = t, t = {}), "string" == typeof t && (t = {
        encoding: t
      });
      var i = (t = t || {}).fs || r,
        s = !0;
      "throws" in t && (s = t.throws), i.readFile(e, t, (function (r, i) {
        if (r) return n(r);
        var a;
        i = o(i);
        try {
          a = JSON.parse(i, t ? t.reviver : null)
        } catch (t) {
          return s ? (t.message = e + ": " + t.message, n(t)) : n(null, null)
        }
        n(null, a)
      }))
    },
    readFileSync: function (e, t) {
      "string" == typeof (t = t || {}) && (t = {
        encoding: t
      });
      var n = t.fs || r,
        i = !0;
      "throws" in t && (i = t.throws);
      try {
        var s = n.readFileSync(e, t);
        return s = o(s), JSON.parse(s, t.reviver)
      } catch (t) {
        if (i) throw t.message = e + ": " + t.message, t;
        return null
      }
    },
    writeFile: function (e, t, n, o) {
      null == o && (o = n, n = {});
      var s = (n = n || {}).fs || r,
        a = "";
      try {
        a = i(t, n)
      } catch (e) {
        return void(o && o(e, null))
      }
      s.writeFile(e, a, n, o)
    },
    writeFileSync: function (e, t, n) {
      var o = (n = n || {}).fs || r,
        s = i(t, n);
      return o.writeFileSync(e, s, n)
    }
  };
  e.exports = s
}, function (e, t, n) {
  var r = n(7),
    i = n(186),
    o = n(187),
    s = [],
    a = n(36);
  var l, c, u = function () {};

  function h(e) {
    i(e), e.gracefulify = h, e.FileReadStream = f, e.FileWriteStream = m, e.createReadStream = function (e, t) {
      return new f(e, t)
    }, e.createWriteStream = function (e, t) {
      return new m(e, t)
    };
    var t = e.readFile;
    e.readFile = function (e, n, r) {
      "function" == typeof n && (r = n, n = null);
      return function e(n, r, i) {
        return t(n, r, (function (t) {
          !t || "EMFILE" !== t.code && "ENFILE" !== t.code ? ("function" == typeof i && i.apply(this, arguments), d()) : p([e, [n, r, i]])
        }))
      }(e, n, r)
    };
    var n = e.writeFile;
    e.writeFile = function (e, t, r, i) {
      "function" == typeof r && (i = r, r = null);
      return function e(t, r, i, o) {
        return n(t, r, i, (function (n) {
          !n || "EMFILE" !== n.code && "ENFILE" !== n.code ? ("function" == typeof o && o.apply(this, arguments), d()) : p([e, [t, r, i, o]])
        }))
      }(e, t, r, i)
    };
    var r = e.appendFile;
    r && (e.appendFile = function (e, t, n, i) {
      "function" == typeof n && (i = n, n = null);
      return function e(t, n, i, o) {
        return r(t, n, i, (function (r) {
          !r || "EMFILE" !== r.code && "ENFILE" !== r.code ? ("function" == typeof o && o.apply(this, arguments), d()) : p([e, [t, n, i, o]])
        }))
      }(e, t, n, i)
    });
    var s = e.readdir;

    function a(t) {
      return s.apply(e, t)
    }
    if (e.readdir = function (e, t, n) {
        var r = [e];
        "function" != typeof t ? r.push(t) : n = t;
        return r.push((function (e, t) {
          t && t.sort && t.sort();
          !e || "EMFILE" !== e.code && "ENFILE" !== e.code ? ("function" == typeof n && n.apply(this, arguments), d()) : p([a, [r]])
        })), a(r)
      }, "v0.8" === process.version.substr(0, 4)) {
      var l = o(e);
      f = l.ReadStream, m = l.WriteStream
    }
    var c = e.ReadStream;
    f.prototype = Object.create(c.prototype), f.prototype.open = function () {
      var e = this;
      y(e.path, e.flags, e.mode, (function (t, n) {
        t ? (e.autoClose && e.destroy(), e.emit("error", t)) : (e.fd = n, e.emit("open", n), e.read())
      }))
    };
    var u = e.WriteStream;

    function f(e, t) {
      return this instanceof f ? (c.apply(this, arguments), this) : f.apply(Object.create(f.prototype), arguments)
    }

    function m(e, t) {
      return this instanceof m ? (u.apply(this, arguments), this) : m.apply(Object.create(m.prototype), arguments)
    }
    m.prototype = Object.create(u.prototype), m.prototype.open = function () {
      var e = this;
      y(e.path, e.flags, e.mode, (function (t, n) {
        t ? (e.destroy(), e.emit("error", t)) : (e.fd = n, e.emit("open", n))
      }))
    }, e.ReadStream = f, e.WriteStream = m;
    var g = e.open;

    function y(e, t, n, r) {
      return "function" == typeof n && (r = n, n = null),
        function e(t, n, r, i) {
          return g(t, n, r, (function (o, s) {
            !o || "EMFILE" !== o.code && "ENFILE" !== o.code ? ("function" == typeof i && i.apply(this, arguments), d()) : p([e, [t, n, r, i]])
          }))
        }(e, t, n, r)
    }
    return e.open = y, e
  }

  function p(e) {
    u("ENQUEUE", e[0].name, e[1]), s.push(e)
  }

  function d() {
    var e = s.shift();
    e && (u("RETRY", e[0].name, e[1]), e[0].apply(null, e[1]))
  }
  a.debuglog ? u = a.debuglog("gfs4") : /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") && (u = function () {
    var e = a.format.apply(a, arguments);
    e = "GFS4: " + e.split(/\n/).join("\nGFS4: "), console.error(e)
  }), /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") && process.on("exit", (function () {
    u(s), n(44).equal(s.length, 0)
  })), e.exports = h(n(102)), process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && (e.exports = h(r)), e.exports.close = r.close = (l = r.close, function (e, t) {
    return l.call(r, e, (function (e) {
      e || d(), "function" == typeof t && t.apply(this, arguments)
    }))
  }), e.exports.closeSync = r.closeSync = (c = r.closeSync, function (e) {
    var t = c.apply(r, arguments);
    return d(), t
  })
}, function (e, t, n) {
  var r = n(102),
    i = n(96),
    o = process.cwd,
    s = null,
    a = process.env.GRACEFUL_FS_PLATFORM || "win32";
  process.cwd = function () {
    return s || (s = o.call(process)), s
  };
  try {
    process.cwd()
  } catch (e) {}
  var l = process.chdir;

  function c(e) {
    return e ? function (t, n, i) {
      return e.call(r, t, n, (function (e) {
        m(e) && (e = null), i && i.apply(this, arguments)
      }))
    } : e
  }

  function u(e) {
    return e ? function (t, n) {
      try {
        return e.call(r, t, n)
      } catch (e) {
        if (!m(e)) throw e
      }
    } : e
  }

  function h(e) {
    return e ? function (t, n, i, o) {
      return e.call(r, t, n, i, (function (e) {
        m(e) && (e = null), o && o.apply(this, arguments)
      }))
    } : e
  }

  function p(e) {
    return e ? function (t, n, i) {
      try {
        return e.call(r, t, n, i)
      } catch (e) {
        if (!m(e)) throw e
      }
    } : e
  }

  function d(e) {
    return e ? function (t, n) {
      return e.call(r, t, (function (e, t) {
        if (!t) return n.apply(this, arguments);
        t.uid < 0 && (t.uid += 4294967296), t.gid < 0 && (t.gid += 4294967296), n && n.apply(this, arguments)
      }))
    } : e
  }

  function f(e) {
    return e ? function (t) {
      var n = e.call(r, t);
      return n.uid < 0 && (n.uid += 4294967296), n.gid < 0 && (n.gid += 4294967296), n
    } : e
  }

  function m(e) {
    return !e || ("ENOSYS" === e.code || !(process.getuid && 0 === process.getuid() || "EINVAL" !== e.code && "EPERM" !== e.code))
  }
  process.chdir = function (e) {
    s = null, l.call(process, e)
  }, e.exports = function (e) {
    i.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./) && function (e) {
      e.lchmod = function (t, n, r) {
        e.open(t, i.O_WRONLY | i.O_SYMLINK, n, (function (t, i) {
          t ? r && r(t) : e.fchmod(i, n, (function (t) {
            e.close(i, (function (e) {
              r && r(t || e)
            }))
          }))
        }))
      }, e.lchmodSync = function (t, n) {
        var r, o = e.openSync(t, i.O_WRONLY | i.O_SYMLINK, n),
          s = !0;
        try {
          r = e.fchmodSync(o, n), s = !1
        } finally {
          if (s) try {
            e.closeSync(o)
          } catch (e) {} else e.closeSync(o)
        }
        return r
      }
    }(e);
    e.lutimes || function (e) {
      i.hasOwnProperty("O_SYMLINK") ? (e.lutimes = function (t, n, r, o) {
        e.open(t, i.O_SYMLINK, (function (t, i) {
          t ? o && o(t) : e.futimes(i, n, r, (function (t) {
            e.close(i, (function (e) {
              o && o(t || e)
            }))
          }))
        }))
      }, e.lutimesSync = function (t, n, r) {
        var o, s = e.openSync(t, i.O_SYMLINK),
          a = !0;
        try {
          o = e.futimesSync(s, n, r), a = !1
        } finally {
          if (a) try {
            e.closeSync(s)
          } catch (e) {} else e.closeSync(s)
        }
        return o
      }) : (e.lutimes = function (e, t, n, r) {
        r && process.nextTick(r)
      }, e.lutimesSync = function () {})
    }(e);
    e.chown = h(e.chown), e.fchown = h(e.fchown), e.lchown = h(e.lchown), e.chmod = c(e.chmod), e.fchmod = c(e.fchmod), e.lchmod = c(e.lchmod), e.chownSync = p(e.chownSync), e.fchownSync = p(e.fchownSync), e.lchownSync = p(e.lchownSync), e.chmodSync = u(e.chmodSync), e.fchmodSync = u(e.fchmodSync), e.lchmodSync = u(e.lchmodSync), e.stat = d(e.stat), e.fstat = d(e.fstat), e.lstat = d(e.lstat), e.statSync = f(e.statSync), e.fstatSync = f(e.fstatSync), e.lstatSync = f(e.lstatSync), e.lchmod || (e.lchmod = function (e, t, n) {
      n && process.nextTick(n)
    }, e.lchmodSync = function () {});
    e.lchown || (e.lchown = function (e, t, n, r) {
      r && process.nextTick(r)
    }, e.lchownSync = function () {});
    "win32" === a && (e.rename = (t = e.rename, function (n, r, i) {
      var o = Date.now(),
        s = 0;
      t(n, r, (function a(l) {
        if (l && ("EACCES" === l.code || "EPERM" === l.code) && Date.now() - o < 6e4) return setTimeout((function () {
          e.stat(r, (function (e, o) {
            e && "ENOENT" === e.code ? t(n, r, a) : i(l)
          }))
        }), s), void(s < 100 && (s += 10));
        i && i(l)
      }))
    }));
    var t;
    e.read = (r = e.read, function (t, n, i, o, s, a) {
      var l;
      if (a && "function" == typeof a) {
        var c = 0;
        l = function (u, h, p) {
          if (u && "EAGAIN" === u.code && c < 10) return c++, r.call(e, t, n, i, o, s, l);
          a.apply(this, arguments)
        }
      }
      return r.call(e, t, n, i, o, s, l)
    }), e.readSync = (n = e.readSync, function (t, r, i, o, s) {
      for (var a = 0;;) try {
        return n.call(e, t, r, i, o, s)
      } catch (e) {
        if ("EAGAIN" === e.code && a < 10) {
          a++;
          continue
        }
        throw e
      }
    });
    var n;
    var r
  }
}, function (e, t, n) {
  var r = n(43).Stream;
  e.exports = function (e) {
    return {
      ReadStream: function t(n, i) {
        if (!(this instanceof t)) return new t(n, i);
        r.call(this);
        var o = this;
        this.path = n, this.fd = null, this.readable = !0, this.paused = !1, this.flags = "r", this.mode = 438, this.bufferSize = 65536, i = i || {};
        for (var s = Object.keys(i), a = 0, l = s.length; a < l; a++) {
          var c = s[a];
          this[c] = i[c]
        }
        this.encoding && this.setEncoding(this.encoding);
        if (void 0 !== this.start) {
          if ("number" != typeof this.start) throw TypeError("start must be a Number");
          if (void 0 === this.end) this.end = 1 / 0;
          else if ("number" != typeof this.end) throw TypeError("end must be a Number");
          if (this.start > this.end) throw new Error("start must be <= end");
          this.pos = this.start
        }
        if (null !== this.fd) return void process.nextTick((function () {
          o._read()
        }));
        e.open(this.path, this.flags, this.mode, (function (e, t) {
          if (e) return o.emit("error", e), void(o.readable = !1);
          o.fd = t, o.emit("open", t), o._read()
        }))
      },
      WriteStream: function t(n, i) {
        if (!(this instanceof t)) return new t(n, i);
        r.call(this), this.path = n, this.fd = null, this.writable = !0, this.flags = "w", this.encoding = "binary", this.mode = 438, this.bytesWritten = 0, i = i || {};
        for (var o = Object.keys(i), s = 0, a = o.length; s < a; s++) {
          var l = o[s];
          this[l] = i[l]
        }
        if (void 0 !== this.start) {
          if ("number" != typeof this.start) throw TypeError("start must be a Number");
          if (this.start < 0) throw new Error("start must be >= zero");
          this.pos = this.start
        }
        this.busy = !1, this._queue = [], null === this.fd && (this._open = e.open, this._queue.push([this._open, this.path, this.flags, this.mode, void 0]), this.flush())
      }
    }
  }
}, function (e, t, n) {
  "use strict";
  const r = n(1),
    i = n(17),
    o = n(21).pathExists,
    s = n(61);
  e.exports = function (e, t, n, a) {
    "function" == typeof n && (a = n, n = {});
    const l = r.dirname(e);
    o(l, (r, o) => r ? a(r) : o ? s.writeJson(e, t, n, a) : void i.mkdirs(l, r => {
      if (r) return a(r);
      s.writeJson(e, t, n, a)
    }))
  }
}, function (e, t, n) {
  "use strict";
  const r = n(13),
    i = n(1),
    o = n(17),
    s = n(61);
  e.exports = function (e, t, n) {
    const a = i.dirname(e);
    r.existsSync(a) || o.mkdirsSync(a), s.writeJsonSync(e, t, n)
  }
}, function (e, t, n) {
  "use strict";
  const r = n(13),
    i = n(1),
    o = n(97).copySync,
    s = n(45).removeSync,
    a = n(17).mkdirsSync,
    l = n(100);

  function c(e, t, n) {
    return r.statSync(e).isDirectory() ? function (e, t, n) {
      const r = {
        overwrite: !1
      };
      n ? (s(t), i()) : i();

      function i() {
        return o(e, t, r), s(e)
      }
    }(e, t, n) : function (e, t, n) {
      const i = l(65536),
        o = n ? "w" : "wx",
        s = r.openSync(e, "r"),
        a = r.fstatSync(s),
        c = r.openSync(t, o, a.mode);
      let u = 0;
      for (; u < a.size;) {
        const e = r.readSync(s, i, 0, 65536, u);
        r.writeSync(c, i, 0, e), u += e
      }
      return r.closeSync(s), r.closeSync(c), r.unlinkSync(e)
    }(e, t, n)
  }
  e.exports = {
    moveSync: function e(t, n, o) {
      const l = (o = o || {}).overwrite || o.clobber || !1;
      if (t = i.resolve(t), n = i.resolve(n), t === n) return r.accessSync(t);
      if (function (e, t) {
          try {
            return r.statSync(e).isDirectory() && e !== t && t.indexOf(e) > -1 && t.split(i.dirname(e) + i.sep)[1].split(i.sep)[0] === i.basename(e)
          } catch (e) {
            return !1
          }
        }(t, n)) throw new Error(`Cannot move '${t}' into itself '${n}'.`);
      a(i.dirname(n)),
        function () {
          if (l) try {
            r.renameSync(t, n)
          } catch (r) {
            if ("ENOTEMPTY" === r.code || "EEXIST" === r.code || "EPERM" === r.code) return s(n), o.overwrite = !1, e(t, n, o);
            if ("EXDEV" !== r.code) throw r;
            return c(t, n, l)
          } else try {
            r.linkSync(t, n), r.unlinkSync(t)
          } catch (e) {
            if ("EXDEV" === e.code || "EISDIR" === e.code || "EPERM" === e.code || "ENOTSUP" === e.code) return c(t, n, l);
            throw e
          }
        }()
    }
  }
}, function (e, t, n) {
  "use strict";
  const r = n(16).fromCallback,
    i = n(13),
    o = n(1),
    s = n(101).copy,
    a = n(45).remove,
    l = n(17).mkdirp,
    c = n(21).pathExists;

  function u(e, t, n, r) {
    i.rename(e, t, i => i ? "EXDEV" !== i.code ? r(i) : function (e, t, n, r) {
      s(e, t, {
        overwrite: n,
        errorOnExist: !0
      }, t => t ? r(t) : a(e, r))
    }(e, t, n, r) : r())
  }
  e.exports = {
    move: r((function (e, t, n, r) {
      "function" == typeof n && (r = n, n = {});
      const s = n.overwrite || n.clobber || !1;
      if (e = o.resolve(e), t = o.resolve(t), e === t) return i.access(e, r);
      i.stat(e, (n, i) => n ? r(n) : i.isDirectory() && function (e, t) {
        const n = e.split(o.sep),
          r = t.split(o.sep);
        return n.reduce((e, t, n) => e && r[n] === t, !0)
      }(e, t) ? r(new Error(`Cannot move '${e}' to a subdirectory of itself, '${t}'.`)) : void l(o.dirname(t), n => n ? r(n) : function (e, t, n, r) {
        if (n) return a(t, i => i ? r(i) : u(e, t, n, r));
        c(t, (i, o) => i ? r(i) : o ? r(new Error("dest already exists.")) : u(e, t, n, r))
      }(e, t, s, r)))
    }))
  }
}, function (e, t, n) {
  "use strict";
  const r = n(16).fromCallback,
    i = n(13),
    o = n(1),
    s = n(17),
    a = n(21).pathExists;
  e.exports = {
    outputFile: r((function (e, t, n, r) {
      "function" == typeof n && (r = n, n = "utf8");
      const l = o.dirname(e);
      a(l, (o, a) => o ? r(o) : a ? i.writeFile(e, t, n, r) : void s.mkdirs(l, o => {
        if (o) return r(o);
        i.writeFile(e, t, n, r)
      }))
    })),
    outputFileSync: function (e, ...t) {
      const n = o.dirname(e);
      if (i.existsSync(n)) return i.writeFileSync(e, ...t);
      s.mkdirsSync(n), i.writeFileSync(e, ...t)
    }
  }
}, function (e, t, n) {
  "use strict";
  const r = n(1),
    i = n(8),
    o = n(194),
    s = n(92),
    a = n(206),
    l = n(94),
    c = n(208),
    u = n(213),
    h = n(214),
    p = n(216),
    d = n(217);

  function f(e, t, n) {
    let i;
    return (n = Object.assign({
      extendEnv: !0,
      env: {}
    }, n)).extendEnv && (n.env = Object.assign({}, process.env, n.env)), !0 === n.__winShell ? (delete n.__winShell, i = {
      command: e,
      args: t,
      options: n,
      file: e,
      original: {
        cmd: e,
        args: t
      }
    }) : i = o._parse(e, t, n), (n = Object.assign({
      maxBuffer: 1e7,
      buffer: !0,
      stripEof: !0,
      preferLocal: !0,
      localDir: i.options.cwd || process.cwd(),
      encoding: "utf8",
      reject: !0,
      cleanup: !0
    }, i.options)).stdio = d(n), n.preferLocal && (n.env = a.env(Object.assign({}, n, {
      cwd: n.localDir
    }))), n.detached && (n.cleanup = !1), "cmd.exe" === r.basename(i.command) && i.args.unshift("/q"), {
      cmd: i.command,
      args: i.args,
      opts: n,
      parsed: i
    }
  }

  function m(e, t) {
    return t && e.stripEof && (t = s(t)), t
  }

  function g(e, t, n) {
    let r = "/bin/sh",
      i = ["-c", t];
    return (n = Object.assign({}, n)).__winShell = !0, r = process.env.comspec || "cmd.exe", i = ["/s", "/c", `"${t}"`], n.windowsVerbatimArguments = !0, n.shell && (r = n.shell, delete n.shell), e(r, i, n)
  }

  function y(e, t, {
    encoding: n,
    buffer: r,
    maxBuffer: i
  }) {
    if (!e[t]) return null;
    let o;
    return o = r ? n ? c(e[t], {
      encoding: n,
      maxBuffer: i
    }) : c.buffer(e[t], {
      maxBuffer: i
    }) : new Promise((n, r) => {
      e[t].once("end", n).once("error", r)
    }), o.catch(e => {
      throw e.stream = t, e.message = `${t} ${e.message}`, e
    })
  }

  function v(e, t) {
    const {
      stdout: n,
      stderr: r
    } = e;
    let i = e.error;
    const {
      code: o,
      signal: s
    } = e, {
      parsed: a,
      joinedCmd: l
    } = t, c = t.timedOut || !1;
    if (!i) {
      let e = "";
      Array.isArray(a.opts.stdio) ? ("inherit" !== a.opts.stdio[2] && (e += e.length > 0 ? r : "\n" + r), "inherit" !== a.opts.stdio[1] && (e += "\n" + n)) : "inherit" !== a.opts.stdio && (e = `\n${r}${n}`), i = new Error(`Command failed: ${l}${e}`), i.code = o < 0 ? p(o) : o
    }
    return i.stdout = n, i.stderr = r, i.failed = !0, i.signal = s || null, i.cmd = l, i.timedOut = c, i
  }

  function w(e, t) {
    let n = e;
    return Array.isArray(t) && t.length > 0 && (n += " " + t.join(" ")), n
  }
  e.exports = (e, t, n) => {
    const r = f(e, t, n),
      {
        encoding: s,
        buffer: a,
        maxBuffer: c
      } = r.opts,
      p = w(e, t);
    let d, g;
    try {
      d = i.spawn(r.cmd, r.args, r.opts)
    } catch (e) {
      return Promise.reject(e)
    }
    r.opts.cleanup && (g = h(() => {
      d.kill()
    }));
    let b = null,
      S = !1;
    const C = () => {
      b && (clearTimeout(b), b = null), g && g()
    };
    r.opts.timeout > 0 && (b = setTimeout(() => {
      b = null, S = !0, d.kill(r.opts.killSignal)
    }, r.opts.timeout));
    const E = new Promise(e => {
      d.on("exit", (t, n) => {
        C(), e({
          code: t,
          signal: n
        })
      }), d.on("error", t => {
        C(), e({
          error: t
        })
      }), d.stdin && d.stdin.on("error", t => {
        C(), e({
          error: t
        })
      })
    });

    function k() {
      d.stdout && d.stdout.destroy(), d.stderr && d.stderr.destroy()
    }
    const x = () => u(Promise.all([E, y(d, "stdout", {
      encoding: s,
      buffer: a,
      maxBuffer: c
    }), y(d, "stderr", {
      encoding: s,
      buffer: a,
      maxBuffer: c
    })]).then(e => {
      const t = e[0];
      if (t.stdout = e[1], t.stderr = e[2], t.error || 0 !== t.code || null !== t.signal) {
        const e = v(t, {
          joinedCmd: p,
          parsed: r,
          timedOut: S
        });
        if (e.killed = e.killed || d.killed, !r.opts.reject) return e;
        throw e
      }
      return {
        stdout: m(r.opts, t.stdout),
        stderr: m(r.opts, t.stderr),
        code: 0,
        failed: !1,
        killed: !1,
        signal: null,
        cmd: p,
        timedOut: !1
      }
    }), k);
    return o._enoent.hookChildProcess(d, r.parsed),
      function (e, t) {
        null != t && (l(t) ? t.pipe(e.stdin) : e.stdin.end(t))
      }(d, r.opts.input), d.then = (e, t) => x().then(e, t), d.catch = e => x().catch(e), d
  }, e.exports.stdout = (...t) => e.exports(...t).then(e => e.stdout), e.exports.stderr = (...t) => e.exports(...t).then(e => e.stderr), e.exports.shell = (t, n) => g(e.exports, t, n), e.exports.sync = (e, t, n) => {
    const r = f(e, t, n),
      o = w(e, t);
    if (l(r.opts.input)) throw new TypeError("The `input` option cannot be a stream in sync mode");
    const s = i.spawnSync(r.cmd, r.args, r.opts);
    if (s.code = s.status, s.error || 0 !== s.status || null !== s.signal) {
      const e = v(s, {
        joinedCmd: o,
        parsed: r
      });
      if (!r.opts.reject) return e;
      throw e
    }
    return {
      stdout: m(r.opts, s.stdout),
      stderr: m(r.opts, s.stderr),
      code: 0,
      failed: !1,
      signal: null,
      cmd: o,
      timedOut: !1
    }
  }, e.exports.shellSync = (t, n) => g(e.exports.sync, t, n)
}, function (e, t, n) {
  "use strict";
  const r = n(8),
    i = n(195),
    o = n(205);

  function s(e, t, n) {
    const s = i(e, t, n),
      a = r.spawn(s.command, s.args, s.options);
    return o.hookChildProcess(a, s), a
  }
  e.exports = s, e.exports.spawn = s, e.exports.sync = function (e, t, n) {
    const s = i(e, t, n),
      a = r.spawnSync(s.command, s.args, s.options);
    return a.error = a.error || o.verifyENOENTSync(a.status, s), a
  }, e.exports._parse = i, e.exports._enoent = o
}, function (e, t, n) {
  "use strict";
  const r = n(1),
    i = n(196),
    o = n(197),
    s = n(200),
    a = n(201),
    l = n(204),
    c = /\.(?:com|exe)$/i,
    u = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i,
    h = i(() => l.satisfies(process.version, "^4.8.0 || ^5.7.0 || >= 6.0.0", !0)) || !1;

  function p(e) {
    const t = function (e) {
        e.file = o(e);
        const t = e.file && a(e.file);
        return t ? (e.args.unshift(e.file), e.command = t, o(e)) : e.file
      }(e),
      n = !c.test(t);
    if (e.options.forceShell || n) {
      const n = u.test(t);
      e.command = r.normalize(e.command), e.command = s.command(e.command), e.args = e.args.map(e => s.argument(e, n));
      const i = [e.command].concat(e.args).join(" ");
      e.args = ["/d", "/s", "/c", `"${i}"`], e.command = process.env.comspec || "cmd.exe", e.options.windowsVerbatimArguments = !0
    }
    return e
  }
  e.exports = function (e, t, n) {
    t && !Array.isArray(t) && (n = t, t = null);
    const r = {
      command: e,
      args: t = t ? t.slice(0) : [],
      options: n = Object.assign({}, n),
      file: void 0,
      original: {
        command: e,
        args: t
      }
    };
    return n.shell ? function (e) {
      if (h) return e;
      const t = [e.command].concat(e.args).join(" ");
      return e.command = "string" == typeof e.options.shell ? e.options.shell : process.env.comspec || "cmd.exe", e.args = ["/d", "/s", "/c", `"${t}"`], e.options.windowsVerbatimArguments = !0, e
    }(r) : p(r)
  }
}, function (e, t, n) {
  "use strict";
  e.exports = function (e) {
    try {
      return e()
    } catch (e) {}
  }
}, function (e, t, n) {
  "use strict";
  const r = n(1),
    i = n(198),
    o = n(199)();

  function s(e, t) {
    const n = process.cwd(),
      s = null != e.options.cwd;
    if (s) try {
      process.chdir(e.options.cwd)
    } catch (e) {}
    let a;
    try {
      a = i.sync(e.command, {
        path: (e.options.env || process.env)[o],
        pathExt: t ? r.delimiter : void 0
      })
    } catch (e) {} finally {
      process.chdir(n)
    }
    return a && (a = r.resolve(s ? e.options.cwd : "", a)), a
  }
  e.exports = function (e) {
    return s(e) || s(e, !0)
  }
}, function (e, t, n) {
  e.exports = a, a.sync = function (e, t) {
    for (var n = s(e, t = t || {}), a = n.env, l = n.ext, c = n.extExe, u = [], h = 0, p = a.length; h < p; h++) {
      var d = a[h];
      '"' === d.charAt(0) && '"' === d.slice(-1) && (d = d.slice(1, -1));
      var f = r.join(d, e);
      !d && /^\.[\\\/]/.test(e) && (f = e.slice(0, 2) + f);
      for (var m = 0, g = l.length; m < g; m++) {
        var y = f + l[m];
        try {
          if (i.sync(y, {
              pathExt: c
            })) {
            if (!t.all) return y;
            u.push(y)
          }
        } catch (e) {}
      }
    }
    if (t.all && u.length) return u;
    if (t.nothrow) return null;
    throw o(e)
  };
  var r = n(1),
    i = n(91);

  function o(e) {
    var t = new Error("not found: " + e);
    return t.code = "ENOENT", t
  }

  function s(e, t) {
    var n = t.colon || ";",
      r = t.path || process.env.PATH || "",
      i = [""],
      o = "";
    return (r = r.split(n)).unshift(process.cwd()), i = (o = t.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM").split(n), -1 !== e.indexOf(".") && "" !== i[0] && i.unshift(""), (e.match(/\//) || e.match(/\\/)) && (r = [""]), {
      env: r,
      ext: i,
      extExe: o
    }
  }

  function a(e, t, n) {
    "function" == typeof t && (n = t, t = {});
    var a = s(e, t),
      l = a.env,
      c = a.ext,
      u = a.extExe,
      h = [];
    ! function s(a, p) {
      if (a === p) return t.all && h.length ? n(null, h) : n(o(e));
      var d = l[a];
      '"' === d.charAt(0) && '"' === d.slice(-1) && (d = d.slice(1, -1));
      var f = r.join(d, e);
      !d && /^\.[\\\/]/.test(e) && (f = e.slice(0, 2) + f),
        function e(r, o) {
          if (r === o) return s(a + 1, p);
          var l = c[r];
          i(f + l, {
            pathExt: u
          }, (function (i, s) {
            if (!i && s) {
              if (!t.all) return n(null, f + l);
              h.push(f + l)
            }
            return e(r + 1, o)
          }))
        }(0, c.length)
    }(0, l.length)
  }
}, function (e, t, n) {
  "use strict";
  e.exports = e => {
    const t = (e = e || {}).env || process.env;
    return "win32" !== (e.platform || "win32") ? "PATH" : Object.keys(t).find(e => "PATH" === e.toUpperCase()) || "Path"
  }
}, function (e, t, n) {
  "use strict";
  const r = /([()\][%!^"`<>&|;, *?])/g;
  e.exports.command = function (e) {
    return e = e.replace(r, "^$1")
  }, e.exports.argument = function (e, t) {
    return e = (e = `"${e=(e=(e=""+e).replace(/(\\*)"/g,'$1$1\\"')).replace(/(\\*)$/,"$1$1")}"`).replace(r, "^$1"), t && (e = e.replace(r, "^$1")), e
  }
}, function (e, t, n) {
  "use strict";
  const r = n(7),
    i = n(202);
  e.exports = function (e) {
    let t, n;
    Buffer.alloc ? t = Buffer.alloc(150) : (t = new Buffer(150), t.fill(0));
    try {
      n = r.openSync(e, "r"), r.readSync(n, t, 0, 150, 0), r.closeSync(n)
    } catch (e) {}
    return i(t.toString())
  }
}, function (e, t, n) {
  "use strict";
  var r = n(203);
  e.exports = function (e) {
    var t = e.match(r);
    if (!t) return null;
    var n = t[0].replace(/#! ?/, "").split(" "),
      i = n[0].split("/").pop(),
      o = n[1];
    return "env" === i ? o : i + (o ? " " + o : "")
  }
}, function (e, t, n) {
  "use strict";
  e.exports = /^#!.*/
}, function (e, t) {
  var n;
  t = e.exports = $, n = "object" == typeof process && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? function () {
    var e = Array.prototype.slice.call(arguments, 0);
    e.unshift("SEMVER"), console.log.apply(console, e)
  } : function () {}, t.SEMVER_SPEC_VERSION = "2.0.0";
  var r = Number.MAX_SAFE_INTEGER || 9007199254740991,
    i = t.re = [],
    o = t.src = [],
    s = 0,
    a = s++;
  o[a] = "0|[1-9]\\d*";
  var l = s++;
  o[l] = "[0-9]+";
  var c = s++;
  o[c] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
  var u = s++;
  o[u] = "(" + o[a] + ")\\.(" + o[a] + ")\\.(" + o[a] + ")";
  var h = s++;
  o[h] = "(" + o[l] + ")\\.(" + o[l] + ")\\.(" + o[l] + ")";
  var p = s++;
  o[p] = "(?:" + o[a] + "|" + o[c] + ")";
  var d = s++;
  o[d] = "(?:" + o[l] + "|" + o[c] + ")";
  var f = s++;
  o[f] = "(?:-(" + o[p] + "(?:\\." + o[p] + ")*))";
  var m = s++;
  o[m] = "(?:-?(" + o[d] + "(?:\\." + o[d] + ")*))";
  var g = s++;
  o[g] = "[0-9A-Za-z-]+";
  var y = s++;
  o[y] = "(?:\\+(" + o[g] + "(?:\\." + o[g] + ")*))";
  var v = s++,
    w = "v?" + o[u] + o[f] + "?" + o[y] + "?";
  o[v] = "^" + w + "$";
  var b = "[v=\\s]*" + o[h] + o[m] + "?" + o[y] + "?",
    S = s++;
  o[S] = "^" + b + "$";
  var C = s++;
  o[C] = "((?:<|>)?=?)";
  var E = s++;
  o[E] = o[l] + "|x|X|\\*";
  var k = s++;
  o[k] = o[a] + "|x|X|\\*";
  var x = s++;
  o[x] = "[v=\\s]*(" + o[k] + ")(?:\\.(" + o[k] + ")(?:\\.(" + o[k] + ")(?:" + o[f] + ")?" + o[y] + "?)?)?";
  var T = s++;
  o[T] = "[v=\\s]*(" + o[E] + ")(?:\\.(" + o[E] + ")(?:\\.(" + o[E] + ")(?:" + o[m] + ")?" + o[y] + "?)?)?";
  var R = s++;
  o[R] = "^" + o[C] + "\\s*" + o[x] + "$";
  var D = s++;
  o[D] = "^" + o[C] + "\\s*" + o[T] + "$";
  var _ = s++;
  o[_] = "(?:^|[^\\d])(\\d{1,16})(?:\\.(\\d{1,16}))?(?:\\.(\\d{1,16}))?(?:$|[^\\d])";
  var A = s++;
  o[A] = "(?:~>?)";
  var M = s++;
  o[M] = "(\\s*)" + o[A] + "\\s+", i[M] = new RegExp(o[M], "g");
  var P = s++;
  o[P] = "^" + o[A] + o[x] + "$";
  var I = s++;
  o[I] = "^" + o[A] + o[T] + "$";
  var O = s++;
  o[O] = "(?:\\^)";
  var L = s++;
  o[L] = "(\\s*)" + o[O] + "\\s+", i[L] = new RegExp(o[L], "g");
  var N = s++;
  o[N] = "^" + o[O] + o[x] + "$";
  var F = s++;
  o[F] = "^" + o[O] + o[T] + "$";
  var B = s++;
  o[B] = "^" + o[C] + "\\s*(" + b + ")$|^$";
  var H = s++;
  o[H] = "^" + o[C] + "\\s*(" + w + ")$|^$";
  var z = s++;
  o[z] = "(\\s*)" + o[C] + "\\s*(" + b + "|" + o[x] + ")", i[z] = new RegExp(o[z], "g");
  var U = s++;
  o[U] = "^\\s*(" + o[x] + ")\\s+-\\s+(" + o[x] + ")\\s*$";
  var W = s++;
  o[W] = "^\\s*(" + o[T] + ")\\s+-\\s+(" + o[T] + ")\\s*$";
  var V = s++;
  o[V] = "(<|>)?=?\\s*\\*";
  for (var j = 0; j < 35; j++) n(j, o[j]), i[j] || (i[j] = new RegExp(o[j]));

  function G(e, t) {
    if (t && "object" == typeof t || (t = {
        loose: !!t,
        includePrerelease: !1
      }), e instanceof $) return e;
    if ("string" != typeof e) return null;
    if (e.length > 256) return null;
    if (!(t.loose ? i[S] : i[v]).test(e)) return null;
    try {
      return new $(e, t)
    } catch (e) {
      return null
    }
  }

  function $(e, t) {
    if (t && "object" == typeof t || (t = {
        loose: !!t,
        includePrerelease: !1
      }), e instanceof $) {
      if (e.loose === t.loose) return e;
      e = e.version
    } else if ("string" != typeof e) throw new TypeError("Invalid Version: " + e);
    if (e.length > 256) throw new TypeError("version is longer than 256 characters");
    if (!(this instanceof $)) return new $(e, t);
    n("SemVer", e, t), this.options = t, this.loose = !!t.loose;
    var o = e.trim().match(t.loose ? i[S] : i[v]);
    if (!o) throw new TypeError("Invalid Version: " + e);
    if (this.raw = e, this.major = +o[1], this.minor = +o[2], this.patch = +o[3], this.major > r || this.major < 0) throw new TypeError("Invalid major version");
    if (this.minor > r || this.minor < 0) throw new TypeError("Invalid minor version");
    if (this.patch > r || this.patch < 0) throw new TypeError("Invalid patch version");
    o[4] ? this.prerelease = o[4].split(".").map((function (e) {
      if (/^[0-9]+$/.test(e)) {
        var t = +e;
        if (t >= 0 && t < r) return t
      }
      return e
    })) : this.prerelease = [], this.build = o[5] ? o[5].split(".") : [], this.format()
  }
  t.parse = G, t.valid = function (e, t) {
    var n = G(e, t);
    return n ? n.version : null
  }, t.clean = function (e, t) {
    var n = G(e.trim().replace(/^[=v]+/, ""), t);
    return n ? n.version : null
  }, t.SemVer = $, $.prototype.format = function () {
    return this.version = this.major + "." + this.minor + "." + this.patch, this.prerelease.length && (this.version += "-" + this.prerelease.join(".")), this.version
  }, $.prototype.toString = function () {
    return this.version
  }, $.prototype.compare = function (e) {
    return n("SemVer.compare", this.version, this.options, e), e instanceof $ || (e = new $(e, this.options)), this.compareMain(e) || this.comparePre(e)
  }, $.prototype.compareMain = function (e) {
    return e instanceof $ || (e = new $(e, this.options)), K(this.major, e.major) || K(this.minor, e.minor) || K(this.patch, e.patch)
  }, $.prototype.comparePre = function (e) {
    if (e instanceof $ || (e = new $(e, this.options)), this.prerelease.length && !e.prerelease.length) return -1;
    if (!this.prerelease.length && e.prerelease.length) return 1;
    if (!this.prerelease.length && !e.prerelease.length) return 0;
    var t = 0;
    do {
      var r = this.prerelease[t],
        i = e.prerelease[t];
      if (n("prerelease compare", t, r, i), void 0 === r && void 0 === i) return 0;
      if (void 0 === i) return 1;
      if (void 0 === r) return -1;
      if (r !== i) return K(r, i)
    } while (++t)
  }, $.prototype.inc = function (e, t) {
    switch (e) {
      case "premajor":
        this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", t);
        break;
      case "preminor":
        this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", t);
        break;
      case "prepatch":
        this.prerelease.length = 0, this.inc("patch", t), this.inc("pre", t);
        break;
      case "prerelease":
        0 === this.prerelease.length && this.inc("patch", t), this.inc("pre", t);
        break;
      case "major":
        0 === this.minor && 0 === this.patch && 0 !== this.prerelease.length || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
        break;
      case "minor":
        0 === this.patch && 0 !== this.prerelease.length || this.minor++, this.patch = 0, this.prerelease = [];
        break;
      case "patch":
        0 === this.prerelease.length && this.patch++, this.prerelease = [];
        break;
      case "pre":
        if (0 === this.prerelease.length) this.prerelease = [0];
        else {
          for (var n = this.prerelease.length; --n >= 0;) "number" == typeof this.prerelease[n] && (this.prerelease[n]++, n = -2); - 1 === n && this.prerelease.push(0)
        }
        t && (this.prerelease[0] === t ? isNaN(this.prerelease[1]) && (this.prerelease = [t, 0]) : this.prerelease = [t, 0]);
        break;
      default:
        throw new Error("invalid increment argument: " + e)
    }
    return this.format(), this.raw = this.version, this
  }, t.inc = function (e, t, n, r) {
    "string" == typeof n && (r = n, n = void 0);
    try {
      return new $(e, n).inc(t, r).version
    } catch (e) {
      return null
    }
  }, t.diff = function (e, t) {
    if (X(e, t)) return null;
    var n = G(e),
      r = G(t),
      i = "";
    if (n.prerelease.length || r.prerelease.length) {
      i = "pre";
      var o = "prerelease"
    }
    for (var s in n)
      if (("major" === s || "minor" === s || "patch" === s) && n[s] !== r[s]) return i + s;
    return o
  }, t.compareIdentifiers = K;
  var q = /^[0-9]+$/;

  function K(e, t) {
    var n = q.test(e),
      r = q.test(t);
    return n && r && (e = +e, t = +t), e === t ? 0 : n && !r ? -1 : r && !n ? 1 : e < t ? -1 : 1
  }

  function Y(e, t, n) {
    return new $(e, n).compare(new $(t, n))
  }

  function Q(e, t, n) {
    return Y(e, t, n) > 0
  }

  function Z(e, t, n) {
    return Y(e, t, n) < 0
  }

  function X(e, t, n) {
    return 0 === Y(e, t, n)
  }

  function J(e, t, n) {
    return 0 !== Y(e, t, n)
  }

  function ee(e, t, n) {
    return Y(e, t, n) >= 0
  }

  function te(e, t, n) {
    return Y(e, t, n) <= 0
  }

  function ne(e, t, n, r) {
    switch (t) {
      case "===":
        return "object" == typeof e && (e = e.version), "object" == typeof n && (n = n.version), e === n;
      case "!==":
        return "object" == typeof e && (e = e.version), "object" == typeof n && (n = n.version), e !== n;
      case "":
      case "=":
      case "==":
        return X(e, n, r);
      case "!=":
        return J(e, n, r);
      case ">":
        return Q(e, n, r);
      case ">=":
        return ee(e, n, r);
      case "<":
        return Z(e, n, r);
      case "<=":
        return te(e, n, r);
      default:
        throw new TypeError("Invalid operator: " + t)
    }
  }

  function re(e, t) {
    if (t && "object" == typeof t || (t = {
        loose: !!t,
        includePrerelease: !1
      }), e instanceof re) {
      if (e.loose === !!t.loose) return e;
      e = e.value
    }
    if (!(this instanceof re)) return new re(e, t);
    n("comparator", e, t), this.options = t, this.loose = !!t.loose, this.parse(e), this.semver === ie ? this.value = "" : this.value = this.operator + this.semver.version, n("comp", this)
  }
  t.rcompareIdentifiers = function (e, t) {
    return K(t, e)
  }, t.major = function (e, t) {
    return new $(e, t).major
  }, t.minor = function (e, t) {
    return new $(e, t).minor
  }, t.patch = function (e, t) {
    return new $(e, t).patch
  }, t.compare = Y, t.compareLoose = function (e, t) {
    return Y(e, t, !0)
  }, t.rcompare = function (e, t, n) {
    return Y(t, e, n)
  }, t.sort = function (e, n) {
    return e.sort((function (e, r) {
      return t.compare(e, r, n)
    }))
  }, t.rsort = function (e, n) {
    return e.sort((function (e, r) {
      return t.rcompare(e, r, n)
    }))
  }, t.gt = Q, t.lt = Z, t.eq = X, t.neq = J, t.gte = ee, t.lte = te, t.cmp = ne, t.Comparator = re;
  var ie = {};

  function oe(e, t) {
    if (t && "object" == typeof t || (t = {
        loose: !!t,
        includePrerelease: !1
      }), e instanceof oe) return e.loose === !!t.loose && e.includePrerelease === !!t.includePrerelease ? e : new oe(e.raw, t);
    if (e instanceof re) return new oe(e.value, t);
    if (!(this instanceof oe)) return new oe(e, t);
    if (this.options = t, this.loose = !!t.loose, this.includePrerelease = !!t.includePrerelease, this.raw = e, this.set = e.split(/\s*\|\|\s*/).map((function (e) {
        return this.parseRange(e.trim())
      }), this).filter((function (e) {
        return e.length
      })), !this.set.length) throw new TypeError("Invalid SemVer Range: " + e);
    this.format()
  }

  function se(e) {
    return !e || "x" === e.toLowerCase() || "*" === e
  }

  function ae(e, t, n, r, i, o, s, a, l, c, u, h, p) {
    return ((t = se(n) ? "" : se(r) ? ">=" + n + ".0.0" : se(i) ? ">=" + n + "." + r + ".0" : ">=" + t) + " " + (a = se(l) ? "" : se(c) ? "<" + (+l + 1) + ".0.0" : se(u) ? "<" + l + "." + (+c + 1) + ".0" : h ? "<=" + l + "." + c + "." + u + "-" + h : "<=" + a)).trim()
  }

  function le(e, t, r) {
    for (var i = 0; i < e.length; i++)
      if (!e[i].test(t)) return !1;
    if (t.prerelease.length && !r.includePrerelease) {
      for (i = 0; i < e.length; i++)
        if (n(e[i].semver), e[i].semver !== ie && e[i].semver.prerelease.length > 0) {
          var o = e[i].semver;
          if (o.major === t.major && o.minor === t.minor && o.patch === t.patch) return !0
        } return !1
    }
    return !0
  }

  function ce(e, t, n) {
    try {
      t = new oe(t, n)
    } catch (e) {
      return !1
    }
    return t.test(e)
  }

  function ue(e, t, n, r) {
    var i, o, s, a, l;
    switch (e = new $(e, r), t = new oe(t, r), n) {
      case ">":
        i = Q, o = te, s = Z, a = ">", l = ">=";
        break;
      case "<":
        i = Z, o = ee, s = Q, a = "<", l = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"')
    }
    if (ce(e, t, r)) return !1;
    for (var c = 0; c < t.set.length; ++c) {
      var u = t.set[c],
        h = null,
        p = null;
      if (u.forEach((function (e) {
          e.semver === ie && (e = new re(">=0.0.0")), h = h || e, p = p || e, i(e.semver, h.semver, r) ? h = e : s(e.semver, p.semver, r) && (p = e)
        })), h.operator === a || h.operator === l) return !1;
      if ((!p.operator || p.operator === a) && o(e, p.semver)) return !1;
      if (p.operator === l && s(e, p.semver)) return !1
    }
    return !0
  }
  re.prototype.parse = function (e) {
    var t = this.options.loose ? i[B] : i[H],
      n = e.match(t);
    if (!n) throw new TypeError("Invalid comparator: " + e);
    this.operator = n[1], "=" === this.operator && (this.operator = ""), n[2] ? this.semver = new $(n[2], this.options.loose) : this.semver = ie
  }, re.prototype.toString = function () {
    return this.value
  }, re.prototype.test = function (e) {
    return n("Comparator.test", e, this.options.loose), this.semver === ie || ("string" == typeof e && (e = new $(e, this.options)), ne(e, this.operator, this.semver, this.options))
  }, re.prototype.intersects = function (e, t) {
    if (!(e instanceof re)) throw new TypeError("a Comparator is required");
    var n;
    if (t && "object" == typeof t || (t = {
        loose: !!t,
        includePrerelease: !1
      }), "" === this.operator) return n = new oe(e.value, t), ce(this.value, n, t);
    if ("" === e.operator) return n = new oe(this.value, t), ce(e.semver, n, t);
    var r = !(">=" !== this.operator && ">" !== this.operator || ">=" !== e.operator && ">" !== e.operator),
      i = !("<=" !== this.operator && "<" !== this.operator || "<=" !== e.operator && "<" !== e.operator),
      o = this.semver.version === e.semver.version,
      s = !(">=" !== this.operator && "<=" !== this.operator || ">=" !== e.operator && "<=" !== e.operator),
      a = ne(this.semver, "<", e.semver, t) && (">=" === this.operator || ">" === this.operator) && ("<=" === e.operator || "<" === e.operator),
      l = ne(this.semver, ">", e.semver, t) && ("<=" === this.operator || "<" === this.operator) && (">=" === e.operator || ">" === e.operator);
    return r || i || o && s || a || l
  }, t.Range = oe, oe.prototype.format = function () {
    return this.range = this.set.map((function (e) {
      return e.join(" ").trim()
    })).join("||").trim(), this.range
  }, oe.prototype.toString = function () {
    return this.range
  }, oe.prototype.parseRange = function (e) {
    var t = this.options.loose;
    e = e.trim();
    var r = t ? i[W] : i[U];
    e = e.replace(r, ae), n("hyphen replace", e), e = e.replace(i[z], "$1$2$3"), n("comparator trim", e, i[z]), e = (e = (e = e.replace(i[M], "$1~")).replace(i[L], "$1^")).split(/\s+/).join(" ");
    var o = t ? i[B] : i[H],
      s = e.split(" ").map((function (e) {
        return function (e, t) {
          return n("comp", e, t), e = function (e, t) {
            return e.trim().split(/\s+/).map((function (e) {
              return function (e, t) {
                n("caret", e, t);
                var r = t.loose ? i[F] : i[N];
                return e.replace(r, (function (t, r, i, o, s) {
                  var a;
                  return n("caret", e, t, r, i, o, s), se(r) ? a = "" : se(i) ? a = ">=" + r + ".0.0 <" + (+r + 1) + ".0.0" : se(o) ? a = "0" === r ? ">=" + r + "." + i + ".0 <" + r + "." + (+i + 1) + ".0" : ">=" + r + "." + i + ".0 <" + (+r + 1) + ".0.0" : s ? (n("replaceCaret pr", s), a = "0" === r ? "0" === i ? ">=" + r + "." + i + "." + o + "-" + s + " <" + r + "." + i + "." + (+o + 1) : ">=" + r + "." + i + "." + o + "-" + s + " <" + r + "." + (+i + 1) + ".0" : ">=" + r + "." + i + "." + o + "-" + s + " <" + (+r + 1) + ".0.0") : (n("no pr"), a = "0" === r ? "0" === i ? ">=" + r + "." + i + "." + o + " <" + r + "." + i + "." + (+o + 1) : ">=" + r + "." + i + "." + o + " <" + r + "." + (+i + 1) + ".0" : ">=" + r + "." + i + "." + o + " <" + (+r + 1) + ".0.0"), n("caret return", a), a
                }))
              }(e, t)
            })).join(" ")
          }(e, t), n("caret", e), e = function (e, t) {
            return e.trim().split(/\s+/).map((function (e) {
              return function (e, t) {
                var r = t.loose ? i[I] : i[P];
                return e.replace(r, (function (t, r, i, o, s) {
                  var a;
                  return n("tilde", e, t, r, i, o, s), se(r) ? a = "" : se(i) ? a = ">=" + r + ".0.0 <" + (+r + 1) + ".0.0" : se(o) ? a = ">=" + r + "." + i + ".0 <" + r + "." + (+i + 1) + ".0" : s ? (n("replaceTilde pr", s), a = ">=" + r + "." + i + "." + o + "-" + s + " <" + r + "." + (+i + 1) + ".0") : a = ">=" + r + "." + i + "." + o + " <" + r + "." + (+i + 1) + ".0", n("tilde return", a), a
                }))
              }(e, t)
            })).join(" ")
          }(e, t), n("tildes", e), e = function (e, t) {
            return n("replaceXRanges", e, t), e.split(/\s+/).map((function (e) {
              return function (e, t) {
                e = e.trim();
                var r = t.loose ? i[D] : i[R];
                return e.replace(r, (function (t, r, i, o, s, a) {
                  n("xRange", e, t, r, i, o, s, a);
                  var l = se(i),
                    c = l || se(o),
                    u = c || se(s);
                  return "=" === r && u && (r = ""), l ? t = ">" === r || "<" === r ? "<0.0.0" : "*" : r && u ? (c && (o = 0), s = 0, ">" === r ? (r = ">=", c ? (i = +i + 1, o = 0, s = 0) : (o = +o + 1, s = 0)) : "<=" === r && (r = "<", c ? i = +i + 1 : o = +o + 1), t = r + i + "." + o + "." + s) : c ? t = ">=" + i + ".0.0 <" + (+i + 1) + ".0.0" : u && (t = ">=" + i + "." + o + ".0 <" + i + "." + (+o + 1) + ".0"), n("xRange return", t), t
                }))
              }(e, t)
            })).join(" ")
          }(e, t), n("xrange", e), e = function (e, t) {
            return n("replaceStars", e, t), e.trim().replace(i[V], "")
          }(e, t), n("stars", e), e
        }(e, this.options)
      }), this).join(" ").split(/\s+/);
    return this.options.loose && (s = s.filter((function (e) {
      return !!e.match(o)
    }))), s = s.map((function (e) {
      return new re(e, this.options)
    }), this)
  }, oe.prototype.intersects = function (e, t) {
    if (!(e instanceof oe)) throw new TypeError("a Range is required");
    return this.set.some((function (n) {
      return n.every((function (n) {
        return e.set.some((function (e) {
          return e.every((function (e) {
            return n.intersects(e, t)
          }))
        }))
      }))
    }))
  }, t.toComparators = function (e, t) {
    return new oe(e, t).set.map((function (e) {
      return e.map((function (e) {
        return e.value
      })).join(" ").trim().split(" ")
    }))
  }, oe.prototype.test = function (e) {
    if (!e) return !1;
    "string" == typeof e && (e = new $(e, this.options));
    for (var t = 0; t < this.set.length; t++)
      if (le(this.set[t], e, this.options)) return !0;
    return !1
  }, t.satisfies = ce, t.maxSatisfying = function (e, t, n) {
    var r = null,
      i = null;
    try {
      var o = new oe(t, n)
    } catch (e) {
      return null
    }
    return e.forEach((function (e) {
      o.test(e) && (r && -1 !== i.compare(e) || (i = new $(r = e, n)))
    })), r
  }, t.minSatisfying = function (e, t, n) {
    var r = null,
      i = null;
    try {
      var o = new oe(t, n)
    } catch (e) {
      return null
    }
    return e.forEach((function (e) {
      o.test(e) && (r && 1 !== i.compare(e) || (i = new $(r = e, n)))
    })), r
  }, t.minVersion = function (e, t) {
    e = new oe(e, t);
    var n = new $("0.0.0");
    if (e.test(n)) return n;
    if (n = new $("0.0.0-0"), e.test(n)) return n;
    n = null;
    for (var r = 0; r < e.set.length; ++r) {
      e.set[r].forEach((function (e) {
        var t = new $(e.semver.version);
        switch (e.operator) {
          case ">":
            0 === t.prerelease.length ? t.patch++ : t.prerelease.push(0), t.raw = t.format();
          case "":
          case ">=":
            n && !Q(n, t) || (n = t);
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error("Unexpected operation: " + e.operator)
        }
      }))
    }
    if (n && e.test(n)) return n;
    return null
  }, t.validRange = function (e, t) {
    try {
      return new oe(e, t).range || "*"
    } catch (e) {
      return null
    }
  }, t.ltr = function (e, t, n) {
    return ue(e, t, "<", n)
  }, t.gtr = function (e, t, n) {
    return ue(e, t, ">", n)
  }, t.outside = ue, t.prerelease = function (e, t) {
    var n = G(e, t);
    return n && n.prerelease.length ? n.prerelease : null
  }, t.intersects = function (e, t, n) {
    return e = new oe(e, n), t = new oe(t, n), e.intersects(t)
  }, t.coerce = function (e) {
    if (e instanceof $) return e;
    if ("string" != typeof e) return null;
    var t = e.match(i[_]);
    if (null == t) return null;
    return G(t[1] + "." + (t[2] || "0") + "." + (t[3] || "0"))
  }
}, function (e, t, n) {
  "use strict";

  function r(e, t) {
    return Object.assign(new Error(`${t} ${e.command} ENOENT`), {
      code: "ENOENT",
      errno: "ENOENT",
      syscall: `${t} ${e.command}`,
      path: e.command,
      spawnargs: e.args
    })
  }

  function i(e, t) {
    return 1 !== e || t.file ? null : r(t.original, "spawn")
  }
  e.exports = {
    hookChildProcess: function (e, t) {
      const n = e.emit;
      e.emit = function (r, o) {
        if ("exit" === r) {
          const r = i(o, t);
          if (r) return n.call(e, "error", r)
        }
        return n.apply(e, arguments)
      }
    },
    verifyENOENT: i,
    verifyENOENTSync: function (e, t) {
      return 1 !== e || t.file ? null : r(t.original, "spawnSync")
    },
    notFoundError: r
  }
}, function (e, t, n) {
  "use strict";
  const r = n(1),
    i = n(207);
  e.exports = e => {
    let t;
    e = Object.assign({
      cwd: process.cwd(),
      path: process.env[i()]
    }, e);
    let n = r.resolve(e.cwd);
    const o = [];
    for (; t !== n;) o.push(r.join(n, "node_modules/.bin")), t = n, n = r.resolve(n, "..");
    return o.push(r.dirname(process.execPath)), o.concat(e.path).join(r.delimiter)
  }, e.exports.env = t => {
    t = Object.assign({
      env: process.env
    }, t);
    const n = Object.assign({}, t.env),
      r = i({
        env: n
      });
    return t.path = n[r], n[r] = e.exports(t), n
  }
}, function (e, t, n) {
  "use strict";
  e.exports = e => {
    const t = (e = e || {}).env || process.env;
    return "win32" !== (e.platform || "win32") ? "PATH" : Object.keys(t).find(e => "PATH" === e.toUpperCase()) || "Path"
  }
}, function (e, t, n) {
  "use strict";
  const r = n(209),
    i = n(212);
  class o extends Error {
    constructor() {
      super("maxBuffer exceeded"), this.name = "MaxBufferError"
    }
  }

  function s(e, t) {
    if (!e) return Promise.reject(new Error("Expected a stream"));
    t = Object.assign({
      maxBuffer: 1 / 0
    }, t);
    const {
      maxBuffer: n
    } = t;
    let s;
    return new Promise((a, l) => {
      const c = e => {
        e && (e.bufferedData = s.getBufferedValue()), l(e)
      };
      s = r(e, i(t), e => {
        e ? c(e) : a()
      }), s.on("data", () => {
        s.getBufferedLength() > n && c(new o)
      })
    }).then(() => s.getBufferedValue())
  }
  e.exports = s, e.exports.buffer = (e, t) => s(e, Object.assign({}, t, {
    encoding: "buffer"
  })), e.exports.array = (e, t) => s(e, Object.assign({}, t, {
    array: !0
  })), e.exports.MaxBufferError = o
}, function (e, t, n) {
  var r = n(103),
    i = n(211),
    o = n(7),
    s = function () {},
    a = /^v?\.0/.test(process.version),
    l = function (e) {
      return "function" == typeof e
    },
    c = function (e, t, n, c) {
      c = r(c);
      var u = !1;
      e.on("close", (function () {
        u = !0
      })), i(e, {
        readable: t,
        writable: n
      }, (function (e) {
        if (e) return c(e);
        u = !0, c()
      }));
      var h = !1;
      return function (t) {
        if (!u && !h) return h = !0,
          function (e) {
            return !!a && (!!o && ((e instanceof(o.ReadStream || s) || e instanceof(o.WriteStream || s)) && l(e.close)))
          }(e) ? e.close(s) : function (e) {
            return e.setHeader && l(e.abort)
          }(e) ? e.abort() : l(e.destroy) ? e.destroy() : void c(t || new Error("stream was destroyed"))
      }
    },
    u = function (e) {
      e()
    },
    h = function (e, t) {
      return e.pipe(t)
    };
  e.exports = function () {
    var e, t = Array.prototype.slice.call(arguments),
      n = l(t[t.length - 1] || s) && t.pop() || s;
    if (Array.isArray(t[0]) && (t = t[0]), t.length < 2) throw new Error("pump requires two streams per minimum");
    var r = t.map((function (i, o) {
      var s = o < t.length - 1;
      return c(i, s, o > 0, (function (t) {
        e || (e = t), t && r.forEach(u), s || (r.forEach(u), n(e))
      }))
    }));
    return t.reduce(h)
  }
}, function (e, t) {
  e.exports = function e(t, n) {
    if (t && n) return e(t)(n);
    if ("function" != typeof t) throw new TypeError("need wrapper function");
    return Object.keys(t).forEach((function (e) {
      r[e] = t[e]
    })), r;

    function r() {
      for (var e = new Array(arguments.length), n = 0; n < e.length; n++) e[n] = arguments[n];
      var r = t.apply(this, e),
        i = e[e.length - 1];
      return "function" == typeof r && r !== i && Object.keys(i).forEach((function (e) {
        r[e] = i[e]
      })), r
    }
  }
}, function (e, t, n) {
  var r = n(103),
    i = function () {},
    o = function (e, t, n) {
      if ("function" == typeof t) return o(e, null, t);
      t || (t = {}), n = r(n || i);
      var s = e._writableState,
        a = e._readableState,
        l = t.readable || !1 !== t.readable && e.readable,
        c = t.writable || !1 !== t.writable && e.writable,
        u = function () {
          e.writable || h()
        },
        h = function () {
          c = !1, l || n.call(e)
        },
        p = function () {
          l = !1, c || n.call(e)
        },
        d = function (t) {
          n.call(e, t ? new Error("exited with error code: " + t) : null)
        },
        f = function (t) {
          n.call(e, t)
        },
        m = function () {
          return (!l || a && a.ended) && (!c || s && s.ended) ? void 0 : n.call(e, new Error("premature close"))
        },
        g = function () {
          e.req.on("finish", h)
        };
      return ! function (e) {
          return e.setHeader && "function" == typeof e.abort
        }(e) ? c && !s && (e.on("end", u), e.on("close", u)) : (e.on("complete", h), e.on("abort", m), e.req ? g() : e.on("request", g)),
        function (e) {
          return e.stdio && Array.isArray(e.stdio) && 3 === e.stdio.length
        }(e) && e.on("exit", d), e.on("end", p), e.on("finish", h), !1 !== t.error && e.on("error", f), e.on("close", m),
        function () {
          e.removeListener("complete", h), e.removeListener("abort", m), e.removeListener("request", g), e.req && e.req.removeListener("finish", h), e.removeListener("end", u), e.removeListener("close", u), e.removeListener("finish", h), e.removeListener("exit", d), e.removeListener("end", p), e.removeListener("error", f), e.removeListener("close", m)
        }
    };
  e.exports = o
}, function (e, t, n) {
  "use strict";
  const {
    PassThrough: r
  } = n(43);
  e.exports = e => {
    e = Object.assign({}, e);
    const {
      array: t
    } = e;
    let {
      encoding: n
    } = e;
    const i = "buffer" === n;
    let o = !1;
    t ? o = !(n || i) : n = n || "utf8", i && (n = null);
    let s = 0;
    const a = [],
      l = new r({
        objectMode: o
      });
    return n && l.setEncoding(n), l.on("data", e => {
      a.push(e), o ? s = a.length : s += e.length
    }), l.getBufferedValue = () => t ? a : i ? Buffer.concat(a, s) : a.join(""), l.getBufferedLength = () => s, l
  }
}, function (e, t, n) {
  "use strict";
  e.exports = (e, t) => (t = t || (() => {}), e.then(e => new Promise(e => {
    e(t())
  }).then(() => e), e => new Promise(e => {
    e(t())
  }).then(() => {
    throw e
  })))
}, function (e, t, n) {
  var r, i = n(44),
    o = n(215),
    s = n(62);

  function a() {
    u && (u = !1, o.forEach((function (e) {
      try {
        process.removeListener(e, c[e])
      } catch (e) {}
    })), process.emit = f, process.reallyExit = p, r.count -= 1)
  }

  function l(e, t, n) {
    r.emitted[e] || (r.emitted[e] = !0, r.emit(e, t, n))
  }
  "function" != typeof s && (s = s.EventEmitter), process.__signal_exit_emitter__ ? r = process.__signal_exit_emitter__ : ((r = process.__signal_exit_emitter__ = new s).count = 0, r.emitted = {}), r.infinite || (r.setMaxListeners(1 / 0), r.infinite = !0), e.exports = function (e, t) {
    i.equal(typeof e, "function", "a callback must be provided for exit handler"), !1 === u && h();
    var n = "exit";
    t && t.alwaysLast && (n = "afterexit");
    return r.on(n, e),
      function () {
        r.removeListener(n, e), 0 === r.listeners("exit").length && 0 === r.listeners("afterexit").length && a()
      }
  }, e.exports.unload = a;
  var c = {};
  o.forEach((function (e) {
    c[e] = function () {
      process.listeners(e).length === r.count && (a(), l("exit", null, e), l("afterexit", null, e), process.kill(process.pid, e))
    }
  })), e.exports.signals = function () {
    return o
  }, e.exports.load = h;
  var u = !1;

  function h() {
    u || (u = !0, r.count += 1, o = o.filter((function (e) {
      try {
        return process.on(e, c[e]), !0
      } catch (e) {
        return !1
      }
    })), process.emit = m, process.reallyExit = d)
  }
  var p = process.reallyExit;

  function d(e) {
    process.exitCode = e || 0, l("exit", process.exitCode, null), l("afterexit", process.exitCode, null), p.call(process, process.exitCode)
  }
  var f = process.emit;

  function m(e, t) {
    if ("exit" === e) {
      void 0 !== t && (process.exitCode = t);
      var n = f.apply(this, arguments);
      return l("exit", process.exitCode, null), l("afterexit", process.exitCode, null), n
    }
    return f.apply(this, arguments)
  }
}, function (e, t, n) {
  e.exports = ["SIGABRT", "SIGALRM", "SIGHUP", "SIGINT", "SIGTERM"]
}, function (e, t, n) {
  "use strict";
  const r = n(36);
  let i;
  if ("function" == typeof r.getSystemErrorName) e.exports = r.getSystemErrorName;
  else {
    try {
      if (i = process.binding("uv"), "function" != typeof i.errname) throw new TypeError("uv.errname is not a function")
    } catch (e) {
      console.error("execa/lib/errname: unable to establish process.binding('uv')", e), i = null
    }
    e.exports = e => o(i, e)
  }

  function o(e, t) {
    if (e) return e.errname(t);
    if (!(t < 0)) throw new Error("err >= 0");
    return "Unknown system error " + t
  }
  e.exports.__test__ = o
}, function (e, t, n) {
  "use strict";
  const r = ["stdin", "stdout", "stderr"];
  e.exports = e => {
    if (!e) return null;
    if (e.stdio && (e => r.some(t => Boolean(e[t])))(e)) throw new Error("It's not possible to provide `stdio` in combination with one of " + r.map(e => `\`${e}\``).join(", "));
    if ("string" == typeof e.stdio) return e.stdio;
    const t = e.stdio || [];
    if (!Array.isArray(t)) throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof t}\``);
    const n = [],
      i = Math.max(t.length, r.length);
    for (let o = 0; o < i; o++) {
      let i = null;
      void 0 !== t[o] ? i = t[o] : void 0 !== e[r[o]] && (i = e[r[o]]), n[o] = i
    }
    return n
  }
}, function (e, t, n) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  const r = n(219);
  var i;

  function o(e) {
    return e === i.HKEY_CLASSES_ROOT ? 2147483648 : e === i.HKEY_CURRENT_USER ? 2147483649 : e === i.HKEY_LOCAL_MACHINE ? 2147483650 : e === i.HKEY_USERS ? 2147483651 : e === i.HKEY_PERFORMANCE_DATA ? 2147483652 : e === i.HKEY_CURRENT_CONFIG ? 2147483653 : e === i.HKEY_DYN_DATA ? 2147483654 : e === i.HKEY_CURRENT_USER_LOCAL_SETTINGS ? 2147483655 : e === i.HKEY_PERFORMANCE_TEXT ? 2147483728 : e === i.HKEY_PERFORMANCE_NLSTEXT ? 2147483744 : function (e, t) {
      throw new Error(t)
    }(0, "The key does not map to an expected number value")
  }

  function s(e, t) {
    if (!r) return [];
    const n = o(e);
    return r.readValues(n, t)
  }

  function a(e, t) {
    if (!r) return [];
    const n = o(e);
    return r.enumKeys(n, t)
  }! function (e) {
    e.REG_BINARY = "REG_BINARY", e.REG_DWORD = "REG_DWORD", e.REG_DWORD_LITTLE_ENDIAN = "REG_DWORD_LITTLE_ENDIAN", e.REG_DWORD_BIG_ENDIAN = "REG_DWORD_BIG_ENDIAN", e.REG_EXPAND_SZ = "REG_EXPAND_SZ", e.REG_LINK = "REG_LINK", e.REG_MULTI_SZ = "REG_MULTI_SZ", e.REG_NONE = "REG_NONE", e.REG_QWORD = "REG_QWORD", e.REG_QWORD_LITTLE_ENDIAN = "REG_QWORD_LITTLE_ENDIAN", e.REG_SZ = "REG_SZ"
  }(t.RegistryValueType || (t.RegistryValueType = {})),
  function (e) {
    e.HKEY_CLASSES_ROOT = "HKEY_CLASSES_ROOT", e.HKEY_CURRENT_CONFIG = "HKEY_CURRENT_CONFIG", e.HKEY_DYN_DATA = "HKEY_DYN_DATA", e.HKEY_CURRENT_USER_LOCAL_SETTINGS = "HKEY_CURRENT_USER_LOCAL_SETTINGS", e.HKEY_CURRENT_USER = "HKEY_CURRENT_USER", e.HKEY_LOCAL_MACHINE = "HKEY_LOCAL_MACHINE", e.HKEY_PERFORMANCE_DATA = "HKEY_PERFORMANCE_DATA", e.HKEY_PERFORMANCE_TEXT = "HKEY_PERFORMANCE_TEXT", e.HKEY_PERFORMANCE_NLSTEXT = "HKEY_PERFORMANCE_NLSTEXT", e.HKEY_USERS = "HKEY_USERS"
  }(i = t.HKEY || (t.HKEY = {})), t.enumerateValues = s, t.enumerateValuesSafe = function (e, t) {
    try {
      return s(e, t)
    } catch (e) {
      return []
    }
  }, t.enumerateKeys = a, t.enumerateKeysSafe = function (e, t) {
    try {
      return a(e, t)
    } catch (e) {
      return []
    }
  }
}, function (e, t, n) {
  (function (e) {
    const t = n(1).join(__dirname, "registry.node");
    try {
      global.process.dlopen(e, t)
    } catch (e) {
      throw new Error("Cannot open " + t + ": " + e)
    }
  }).call(this, n(42)(e))
}, function (e, t, n) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  const r = n(7),
    i = n(8),
    o = n(104),
    s = n(221);
  class a {
    static pathExists(e) {
      try {
        return r.accessSync(e, r.F_OK), !0
      } catch (e) {
        return !1
      }
    }
    static spawn(e, t, n) {
      let r = {};
      n && n.env && (r = n.env);
      const {
        env: o,
        gitLocation: a
      } = s.setupEnvironment(r), c = {
        env: o,
        cwd: t
      }, u = i.spawn(a, e, c);
      return l(u), u
    }
    static exec(e, t, n) {
      return new Promise((function (r, c) {
        let u = {};
        n && n.env && (u = n.env);
        const {
          env: h,
          gitLocation: p
        } = s.setupEnvironment(u), d = {
          cwd: t,
          encoding: "utf8",
          maxBuffer: n ? n.maxBuffer : 10485760,
          env: h
        }, f = i.execFile(p, e, d, (function (e, n, i) {
          if (!e) return void r({
            stdout: n,
            stderr: i,
            exitCode: 0
          });
          let s = e.code;
          if ("string" != typeof s) "number" != typeof s ? "stdout maxBuffer exceeded" === e.message ? c(new Error(`The output from the command could not fit into the allocated stdout buffer. Set options.maxBuffer to a larger value than ${d.maxBuffer} bytes`)) : c(e) : r({
            stdout: n,
            stderr: i,
            exitCode: s
          });
          else if ("ENOENT" === s) {
            let n = e.message;
            !1 === a.pathExists(t) ? (n = "Unable to find path to repository on disk.", s = o.RepositoryDoesNotExistErrorCode) : (n = `Git could not be found at the expected path: '${p}'. This might be a problem with how the application is packaged, so confirm this folder hasn't been removed when packaging.`, s = o.GitNotFoundErrorCode);
            const r = new Error(n);
            r.name = e.name, r.code = s, c(r)
          } else c(e)
        }));
        l(f), n && void 0 !== n.stdin && f.stdin.end(n.stdin, n.stdinEncoding), n && n.processCallback && n.processCallback(f)
      }))
    }
    static parseError(e) {
      for (const [t, n] of Object.entries(o.GitErrorRegexes))
        if (e.match(t)) return n;
      return null
    }
  }

  function l(e) {
    e.stdin && e.stdin.on("error", t => {
      const n = t.code;
      if ("EPIPE" !== n && "EOF" !== n && "ECONNRESET" !== n && e.stdin.listeners("error").length <= 1) throw t
    })
  }
  t.GitProcess = a
}, function (e, t, n) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  const r = n(1);

  function i() {
    return null != process.env.LOCAL_GIT_DIRECTORY ? r.resolve(process.env.LOCAL_GIT_DIRECTORY) : function () {
      {
        const e = r.sep;
        return r.resolve(__dirname, "..", "..", "git").replace(/[\\\/]app.asar[\\\/]/, `${e}app.asar.unpacked${e}`)
      }
    }()
  }

  function o() {
    if (null != process.env.GIT_EXEC_PATH) return r.resolve(process.env.GIT_EXEC_PATH);
    const e = i();
    return "x64" === process.arch ? r.join(e, "mingw64", "libexec", "git-core") : r.join(e, "mingw32", "libexec", "git-core")
  }
  t.setupEnvironment = function (e) {
    const t = function () {
      const e = i();
      return r.join(e, "cmd", "git.exe")
    }();
    let n = process.env.PATH || "";
    const s = i();
    n = "x64" === process.arch ? `${s}\\mingw64\\bin;${s}\\mingw64\\usr\\bin;${n}` : `${s}\\mingw32\\bin;${s}\\mingw32\\usr\\bin;${n}`;
    const a = Object.assign({}, process.env, {
      GIT_EXEC_PATH: o(),
      PATH: n
    }, e);
    return a.Path && delete a.Path, {
      env: a,
      gitLocation: t
    }
  }
}, function (e, t, n) {
  (function (e) {
    const t = n(1).join(__dirname, "keytar.node");
    try {
      global.process.dlopen(e, t)
    } catch (e) {
      throw new Error("Cannot open " + t + ": " + e)
    }
  }).call(this, n(42)(e))
}, function (e, t) {
  e.exports = require("timers")
}, function (e, t, n) {
  var r = n(88),
    i = n(89),
    o = r(),
    s = [1 | o[0], o[1], o[2], o[3], o[4], o[5]],
    a = 16383 & (o[6] << 8 | o[7]),
    l = 0,
    c = 0;
  e.exports = function (e, t, n) {
    var r = t && n || 0,
      o = t || [],
      u = void 0 !== (e = e || {}).clockseq ? e.clockseq : a,
      h = void 0 !== e.msecs ? e.msecs : (new Date).getTime(),
      p = void 0 !== e.nsecs ? e.nsecs : c + 1,
      d = h - l + (p - c) / 1e4;
    if (d < 0 && void 0 === e.clockseq && (u = u + 1 & 16383), (d < 0 || h > l) && void 0 === e.nsecs && (p = 0), p >= 1e4) throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    l = h, c = p, a = u;
    var f = (1e4 * (268435455 & (h += 122192928e5)) + p) % 4294967296;
    o[r++] = f >>> 24 & 255, o[r++] = f >>> 16 & 255, o[r++] = f >>> 8 & 255, o[r++] = 255 & f;
    var m = h / 4294967296 * 1e4 & 268435455;
    o[r++] = m >>> 8 & 255, o[r++] = 255 & m, o[r++] = m >>> 24 & 15 | 16, o[r++] = m >>> 16 & 255, o[r++] = u >>> 8 | 128, o[r++] = 255 & u;
    for (var g = e.node || s, y = 0; y < 6; ++y) o[r + y] = g[y];
    return t || i(o)
  }
}, function (e, t) {
  "function" == typeof Object.create ? e.exports = function (e, t) {
    e.super_ = t, e.prototype = Object.create(t.prototype, {
      constructor: {
        value: e,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    })
  } : e.exports = function (e, t) {
    e.super_ = t;
    var n = function () {};
    n.prototype = t.prototype, e.prototype = new n, e.prototype.constructor = e
  }
}, function (e, t) {
  function n(e) {
    var t = [];
    for (var n in e) t.push(n);
    return t
  }(e.exports = "function" == typeof Object.keys ? Object.keys : n).shim = n
}, function (e, t) {
  var n = "[object Arguments]" == function () {
    return Object.prototype.toString.call(arguments)
  }();

  function r(e) {
    return "[object Arguments]" == Object.prototype.toString.call(e)
  }

  function i(e) {
    return e && "object" == typeof e && "number" == typeof e.length && Object.prototype.hasOwnProperty.call(e, "callee") && !Object.prototype.propertyIsEnumerable.call(e, "callee") || !1
  }(t = e.exports = n ? r : i).supported = r, t.unsupported = i
}, function (e, t, n) {
  "use strict";
  const r = (e, t) => {
    for (const n of Reflect.ownKeys(t)) Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(t, n));
    return e
  };
  e.exports = r, e.exports.default = r
}, function (e, t, n) {
  "use strict";
  const r = e => e instanceof Promise || null !== e && "object" == typeof e && "function" == typeof e.then && "function" == typeof e.catch;
  e.exports = r, e.exports.default = r
}, function (e, t, n) {
  "use strict";
  var r = this && this.__awaiter || function (e, t, n, r) {
      return new(n || (n = Promise))((function (i, o) {
        function s(e) {
          try {
            l(r.next(e))
          } catch (e) {
            o(e)
          }
        }

        function a(e) {
          try {
            l(r.throw(e))
          } catch (e) {
            o(e)
          }
        }

        function l(e) {
          e.done ? i(e.value) : new n((function (t) {
            t(e.value)
          })).then(s, a)
        }
        l((r = r.apply(e, t || [])).next())
      }))
    },
    i = this && this.__importDefault || function (e) {
      return e && e.__esModule ? e : {
        default: e
      }
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  const o = i(n(231));

  function s(e, t = "maxAge") {
    let n, i, s;
    const a = () => r(this, void 0, void 0, (function* () {
        if (void 0 !== n) return;
        const a = a => r(this, void 0, void 0, (function* () {
          s = o.default();
          const r = a[1][t] - Date.now();
          return r <= 0 ? (e.delete(a[0]), void s.resolve()) : (n = a[0], i = setTimeout(() => {
            e.delete(a[0]), s && s.resolve()
          }, r), "function" == typeof i.unref && i.unref(), s.promise)
        }));
        try {
          for (const t of e) yield a(t)
        } catch (e) {}
        n = void 0
      })),
      l = e.set.bind(e);
    return e.set = (t, r) => {
      e.has(t) && e.delete(t);
      const o = l(t, r);
      return n && n === t && (n = void 0, void 0 !== i && (clearTimeout(i), i = void 0), void 0 !== s && (s.reject(void 0), s = void 0)), a(), o
    }, a(), e
  }
  t.default = s, e.exports = s, e.exports.default = s
}, function (e, t, n) {
  "use strict";
  e.exports = () => {
    const e = {};
    return e.promise = new Promise((t, n) => {
      e.resolve = t, e.reject = n
    }), e
  }
}, function (e, t, n) {
  "use strict";
  var r = n(233);

  function i() {}

  function o() {}
  o.resetWarningCache = i, e.exports = function () {
    function e(e, t, n, i, o, s) {
      if (s !== r) {
        var a = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
        throw a.name = "Invariant Violation", a
      }
    }

    function t() {
      return e
    }
    e.isRequired = e;
    var n = {
      array: e,
      bool: e,
      func: e,
      number: e,
      object: e,
      string: e,
      symbol: e,
      any: e,
      arrayOf: t,
      element: e,
      elementType: e,
      instanceOf: t,
      node: e,
      objectOf: t,
      oneOf: t,
      oneOfType: t,
      shape: t,
      exact: t,
      checkPropTypes: o,
      resetWarningCache: i
    };
    return n.PropTypes = n, n
  }
}, function (e, t, n) {
  "use strict";
  e.exports = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED"
}, function (e, t, n) {
  n(235), e.exports = n(20).Object.assign
}, function (e, t, n) {
  var r = n(25);
  r(r.S + r.F, "Object", {
    assign: n(237)
  })
}, function (e, t) {
  e.exports = function (e) {
    if ("function" != typeof e) throw TypeError(e + " is not a function!");
    return e
  }
}, function (e, t, n) {
  "use strict";
  var r = n(39),
    i = n(70),
    o = n(48),
    s = n(49),
    a = n(109),
    l = Object.assign;
  e.exports = !l || n(30)((function () {
    var e = {},
      t = {},
      n = Symbol(),
      r = "abcdefghijklmnopqrst";
    return e[n] = 7, r.split("").forEach((function (e) {
      t[e] = e
    })), 7 != l({}, e)[n] || Object.keys(l({}, t)).join("") != r
  })) ? function (e, t) {
    for (var n = s(e), l = arguments.length, c = 1, u = i.f, h = o.f; l > c;)
      for (var p, d = a(arguments[c++]), f = u ? r(d).concat(u(d)) : r(d), m = f.length, g = 0; m > g;) h.call(d, p = f[g++]) && (n[p] = d[p]);
    return n
  } : l
}, function (e, t, n) {
  var r = n(31),
    i = n(239),
    o = n(240);
  e.exports = function (e) {
    return function (t, n, s) {
      var a, l = r(t),
        c = i(l.length),
        u = o(s, c);
      if (e && n != n) {
        for (; c > u;)
          if ((a = l[u++]) != a) return !0
      } else
        for (; c > u; u++)
          if ((e || u in l) && l[u] === n) return e || u || 0;
      return !e && -1
    }
  }
}, function (e, t, n) {
  var r = n(66),
    i = Math.min;
  e.exports = function (e) {
    return e > 0 ? i(r(e), 9007199254740991) : 0
  }
}, function (e, t, n) {
  var r = n(66),
    i = Math.max,
    o = Math.min;
  e.exports = function (e, t) {
    return (e = r(e)) < 0 ? i(e + t, 0) : o(e, t)
  }
}, function (e, t, n) {
  n(242), e.exports = n(20).Object.getPrototypeOf
}, function (e, t, n) {
  var r = n(49),
    i = n(111);
  n(112)("getPrototypeOf", (function () {
    return function (e) {
      return i(r(e))
    }
  }))
}, function (e, t, n) {
  e.exports = {
    default: n(244),
    __esModule: !0
  }
}, function (e, t, n) {
  n(245);
  var r = n(20).Object;
  e.exports = function (e, t, n) {
    return r.defineProperty(e, t, n)
  }
}, function (e, t, n) {
  var r = n(25);
  r(r.S + r.F * !n(27), "Object", {
    defineProperty: n(26).f
  })
}, function (e, t, n) {
  e.exports = {
    default: n(247),
    __esModule: !0
  }
}, function (e, t, n) {
  n(248), n(253), e.exports = n(75).f("iterator")
}, function (e, t, n) {
  "use strict";
  var r = n(249)(!0);
  n(114)(String, "String", (function (e) {
    this._t = String(e), this._i = 0
  }), (function () {
    var e, t = this._t,
      n = this._i;
    return n >= t.length ? {
      value: void 0,
      done: !0
    } : (e = r(t, n), this._i += e.length, {
      value: e,
      done: !1
    })
  }))
}, function (e, t, n) {
  var r = n(66),
    i = n(65);
  e.exports = function (e) {
    return function (t, n) {
      var o, s, a = String(i(t)),
        l = r(n),
        c = a.length;
      return l < 0 || l >= c ? e ? "" : void 0 : (o = a.charCodeAt(l)) < 55296 || o > 56319 || l + 1 === c || (s = a.charCodeAt(l + 1)) < 56320 || s > 57343 ? e ? a.charAt(l) : o : e ? a.slice(l, l + 2) : s - 56320 + (o - 55296 << 10) + 65536
    }
  }
}, function (e, t, n) {
  "use strict";
  var r = n(73),
    i = n(46),
    o = n(74),
    s = {};
  n(29)(s, n(32)("iterator"), (function () {
    return this
  })), e.exports = function (e, t, n) {
    e.prototype = r(s, {
      next: i(1, n)
    }), o(e, t + " Iterator")
  }
}, function (e, t, n) {
  var r = n(26),
    i = n(37),
    o = n(39);
  e.exports = n(27) ? Object.defineProperties : function (e, t) {
    i(e);
    for (var n, s = o(t), a = s.length, l = 0; a > l;) r.f(e, n = s[l++], t[n]);
    return e
  }
}, function (e, t, n) {
  var r = n(22).document;
  e.exports = r && r.documentElement
}, function (e, t, n) {
  n(254);
  for (var r = n(22), i = n(29), o = n(72), s = n(32)("toStringTag"), a = "CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,TextTrackList,TouchList".split(","), l = 0; l < a.length; l++) {
    var c = a[l],
      u = r[c],
      h = u && u.prototype;
    h && !h[s] && i(h, s, c), o[c] = o.Array
  }
}, function (e, t, n) {
  "use strict";
  var r = n(255),
    i = n(256),
    o = n(72),
    s = n(31);
  e.exports = n(114)(Array, "Array", (function (e, t) {
    this._t = s(e), this._i = 0, this._k = t
  }), (function () {
    var e = this._t,
      t = this._k,
      n = this._i++;
    return !e || n >= e.length ? (this._t = void 0, i(1)) : i(0, "keys" == t ? n : "values" == t ? e[n] : [n, e[n]])
  }), "values"), o.Arguments = o.Array, r("keys"), r("values"), r("entries")
}, function (e, t) {
  e.exports = function () {}
}, function (e, t) {
  e.exports = function (e, t) {
    return {
      value: t,
      done: !!e
    }
  }
}, function (e, t, n) {
  e.exports = {
    default: n(258),
    __esModule: !0
  }
}, function (e, t, n) {
  n(259), n(264), n(265), n(266), e.exports = n(20).Symbol
}, function (e, t, n) {
  "use strict";
  var r = n(22),
    i = n(28),
    o = n(27),
    s = n(25),
    a = n(115),
    l = n(260).KEY,
    c = n(30),
    u = n(68),
    h = n(74),
    p = n(47),
    d = n(32),
    f = n(75),
    m = n(76),
    g = n(261),
    y = n(262),
    v = n(37),
    w = n(31),
    b = n(64),
    S = n(46),
    C = n(73),
    E = n(263),
    k = n(117),
    x = n(26),
    T = n(39),
    R = k.f,
    D = x.f,
    _ = E.f,
    A = r.Symbol,
    M = r.JSON,
    P = M && M.stringify,
    I = d("_hidden"),
    O = d("toPrimitive"),
    L = {}.propertyIsEnumerable,
    N = u("symbol-registry"),
    F = u("symbols"),
    B = u("op-symbols"),
    H = Object.prototype,
    z = "function" == typeof A,
    U = r.QObject,
    W = !U || !U.prototype || !U.prototype.findChild,
    V = o && c((function () {
      return 7 != C(D({}, "a", {
        get: function () {
          return D(this, "a", {
            value: 7
          }).a
        }
      })).a
    })) ? function (e, t, n) {
      var r = R(H, t);
      r && delete H[t], D(e, t, n), r && e !== H && D(H, t, r)
    } : D,
    j = function (e) {
      var t = F[e] = C(A.prototype);
      return t._k = e, t
    },
    G = z && "symbol" == typeof A.iterator ? function (e) {
      return "symbol" == typeof e
    } : function (e) {
      return e instanceof A
    },
    $ = function (e, t, n) {
      return e === H && $(B, t, n), v(e), t = b(t, !0), v(n), i(F, t) ? (n.enumerable ? (i(e, I) && e[I][t] && (e[I][t] = !1), n = C(n, {
        enumerable: S(0, !1)
      })) : (i(e, I) || D(e, I, S(1, {})), e[I][t] = !0), V(e, t, n)) : D(e, t, n)
    },
    q = function (e, t) {
      v(e);
      for (var n, r = g(t = w(t)), i = 0, o = r.length; o > i;) $(e, n = r[i++], t[n]);
      return e
    },
    K = function (e) {
      var t = L.call(this, e = b(e, !0));
      return !(this === H && i(F, e) && !i(B, e)) && (!(t || !i(this, e) || !i(F, e) || i(this, I) && this[I][e]) || t)
    },
    Y = function (e, t) {
      if (e = w(e), t = b(t, !0), e !== H || !i(F, t) || i(B, t)) {
        var n = R(e, t);
        return !n || !i(F, t) || i(e, I) && e[I][t] || (n.enumerable = !0), n
      }
    },
    Q = function (e) {
      for (var t, n = _(w(e)), r = [], o = 0; n.length > o;) i(F, t = n[o++]) || t == I || t == l || r.push(t);
      return r
    },
    Z = function (e) {
      for (var t, n = e === H, r = _(n ? B : w(e)), o = [], s = 0; r.length > s;) !i(F, t = r[s++]) || n && !i(H, t) || o.push(F[t]);
      return o
    };
  z || (a((A = function () {
    if (this instanceof A) throw TypeError("Symbol is not a constructor!");
    var e = p(arguments.length > 0 ? arguments[0] : void 0),
      t = function (n) {
        this === H && t.call(B, n), i(this, I) && i(this[I], e) && (this[I][e] = !1), V(this, e, S(1, n))
      };
    return o && W && V(H, e, {
      configurable: !0,
      set: t
    }), j(e)
  }).prototype, "toString", (function () {
    return this._k
  })), k.f = Y, x.f = $, n(116).f = E.f = Q, n(48).f = K, n(70).f = Z, o && !n(71) && a(H, "propertyIsEnumerable", K, !0), f.f = function (e) {
    return j(d(e))
  }), s(s.G + s.W + s.F * !z, {
    Symbol: A
  });
  for (var X = "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","), J = 0; X.length > J;) d(X[J++]);
  for (var ee = T(d.store), te = 0; ee.length > te;) m(ee[te++]);
  s(s.S + s.F * !z, "Symbol", {
    for: function (e) {
      return i(N, e += "") ? N[e] : N[e] = A(e)
    },
    keyFor: function (e) {
      if (!G(e)) throw TypeError(e + " is not a symbol!");
      for (var t in N)
        if (N[t] === e) return t
    },
    useSetter: function () {
      W = !0
    },
    useSimple: function () {
      W = !1
    }
  }), s(s.S + s.F * !z, "Object", {
    create: function (e, t) {
      return void 0 === t ? C(e) : q(C(e), t)
    },
    defineProperty: $,
    defineProperties: q,
    getOwnPropertyDescriptor: Y,
    getOwnPropertyNames: Q,
    getOwnPropertySymbols: Z
  }), M && s(s.S + s.F * (!z || c((function () {
    var e = A();
    return "[null]" != P([e]) || "{}" != P({
      a: e
    }) || "{}" != P(Object(e))
  }))), "JSON", {
    stringify: function (e) {
      if (void 0 !== e && !G(e)) {
        for (var t, n, r = [e], i = 1; arguments.length > i;) r.push(arguments[i++]);
        return "function" == typeof (t = r[1]) && (n = t), !n && y(t) || (t = function (e, t) {
          if (n && (t = n.call(this, e, t)), !G(t)) return t
        }), r[1] = t, P.apply(M, r)
      }
    }
  }), A.prototype[O] || n(29)(A.prototype, O, A.prototype.valueOf), h(A, "Symbol"), h(Math, "Math", !0), h(r.JSON, "JSON", !0)
}, function (e, t, n) {
  var r = n(47)("meta"),
    i = n(38),
    o = n(28),
    s = n(26).f,
    a = 0,
    l = Object.isExtensible || function () {
      return !0
    },
    c = !n(30)((function () {
      return l(Object.preventExtensions({}))
    })),
    u = function (e) {
      s(e, r, {
        value: {
          i: "O" + ++a,
          w: {}
        }
      })
    },
    h = e.exports = {
      KEY: r,
      NEED: !1,
      fastKey: function (e, t) {
        if (!i(e)) return "symbol" == typeof e ? e : ("string" == typeof e ? "S" : "P") + e;
        if (!o(e, r)) {
          if (!l(e)) return "F";
          if (!t) return "E";
          u(e)
        }
        return e[r].i
      },
      getWeak: function (e, t) {
        if (!o(e, r)) {
          if (!l(e)) return !0;
          if (!t) return !1;
          u(e)
        }
        return e[r].w
      },
      onFreeze: function (e) {
        return c && h.NEED && l(e) && !o(e, r) && u(e), e
      }
    }
}, function (e, t, n) {
  var r = n(39),
    i = n(70),
    o = n(48);
  e.exports = function (e) {
    var t = r(e),
      n = i.f;
    if (n)
      for (var s, a = n(e), l = o.f, c = 0; a.length > c;) l.call(e, s = a[c++]) && t.push(s);
    return t
  }
}, function (e, t, n) {
  var r = n(110);
  e.exports = Array.isArray || function (e) {
    return "Array" == r(e)
  }
}, function (e, t, n) {
  var r = n(31),
    i = n(116).f,
    o = {}.toString,
    s = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
  e.exports.f = function (e) {
    return s && "[object Window]" == o.call(e) ? function (e) {
      try {
        return i(e)
      } catch (e) {
        return s.slice()
      }
    }(e) : i(r(e))
  }
}, function (e, t) {}, function (e, t, n) {
  n(76)("asyncIterator")
}, function (e, t, n) {
  n(76)("observable")
}, function (e, t, n) {
  e.exports = {
    default: n(268),
    __esModule: !0
  }
}, function (e, t, n) {
  n(269), e.exports = n(20).Object.setPrototypeOf
}, function (e, t, n) {
  var r = n(25);
  r(r.S, "Object", {
    setPrototypeOf: n(270).set
  })
}, function (e, t, n) {
  var r = n(38),
    i = n(37),
    o = function (e, t) {
      if (i(e), !r(t) && null !== t) throw TypeError(t + ": can't set as prototype!")
    };
  e.exports = {
    set: Object.setPrototypeOf || ("__proto__" in {} ? function (e, t, r) {
      try {
        (r = n(105)(Function.call, n(117).f(Object.prototype, "__proto__").set, 2))(e, []), t = !(e instanceof Array)
      } catch (e) {
        t = !0
      }
      return function (e, n) {
        return o(e, n), t ? e.__proto__ = n : r(e, n), e
      }
    }({}, !1) : void 0),
    check: o
  }
}, function (e, t, n) {
  e.exports = {
    default: n(272),
    __esModule: !0
  }
}, function (e, t, n) {
  n(273);
  var r = n(20).Object;
  e.exports = function (e, t) {
    return r.create(e, t)
  }
}, function (e, t, n) {
  var r = n(25);
  r(r.S, "Object", {
    create: n(73)
  })
}, function (e, t, n) {
  "use strict";
  var r = n(275),
    i = n(276),
    o = n(277);
  e.exports = function () {
    function e(e, t, n, r, s, a) {
      a !== o && i(!1, "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types")
    }

    function t() {
      return e
    }
    e.isRequired = e;
    var n = {
      array: e,
      bool: e,
      func: e,
      number: e,
      object: e,
      string: e,
      symbol: e,
      any: e,
      arrayOf: t,
      element: e,
      instanceOf: t,
      node: e,
      objectOf: t,
      oneOf: t,
      oneOfType: t,
      shape: t,
      exact: t
    };
    return n.checkPropTypes = r, n.PropTypes = n, n
  }
}, function (e, t, n) {
  "use strict";

  function r(e) {
    return function () {
      return e
    }
  }
  var i = function () {};
  i.thatReturns = r, i.thatReturnsFalse = r(!1), i.thatReturnsTrue = r(!0), i.thatReturnsNull = r(null), i.thatReturnsThis = function () {
    return this
  }, i.thatReturnsArgument = function (e) {
    return e
  }, e.exports = i
}, function (e, t, n) {
  "use strict";
  e.exports = function (e, t, n, r, i, o, s, a) {
    if (!e) {
      var l;
      if (void 0 === t) l = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var c = [n, r, i, o, s, a],
          u = 0;
        (l = new Error(t.replace(/%s/g, (function () {
          return c[u++]
        })))).name = "Invariant Violation"
      }
      throw l.framesToPop = 1, l
    }
  }
}, function (e, t, n) {
  "use strict";
  e.exports = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED"
}, function (e, t, n) {
  n(279), e.exports = n(20).Object.keys
}, function (e, t, n) {
  var r = n(49),
    i = n(39);
  n(112)("keys", (function () {
    return function (e) {
      return i(r(e))
    }
  }))
}, function (e, t, n) {
  (function () {
    var t, r, i, o;
    i = n(51), t = n(79), n(118), r = function (e) {
      return e.candidate
    }, o = function (e, t) {
      return t.score - e.score
    }, e.exports = function (e, n, s) {
      var a, l, c, u, h, p, d, f, m, g, y, v, w;
      for (f = [], c = s.key, h = s.maxResults, u = s.maxInners, y = s.usePathScoring, m = null != u && u > 0 ? u : e.length + 1, a = null != c, d = y ? t : i, v = 0, w = e.length; v < w && (l = e[v], !((g = a ? l[c] : l) && (p = d.score(g, n, s)) > 0) || (f.push({
          candidate: l,
          score: p
        }), --m)); v++);
      return f.sort(o), e = f.map(r), null != h && (e = e.slice(0, h)), e
    }
  }).call(this)
}, function (e, t, n) {
  (function () {
    var e, r, i, o, s, a, l, c, u, h;
    h = n(51), i = h.isMatch, o = h.isWordStart, u = h.scoreConsecutives, c = h.scoreCharacter, l = h.scoreAcronyms, t.match = s = function (t, n, o) {
      var s, l, c, u, h, p;
      return s = o.allowErrors, h = o.preparedQuery, u = o.pathSeparator, s || i(t, h.core_lw, h.core_up) ? (p = t.toLowerCase(), 0 === (c = r(t, p, h)).length || t.indexOf(u) > -1 && (l = e(t, p, h, u), c = a(c, l)), c) : []
    }, t.wrap = function (e, t, n) {
      var r, i, o, a, l, c, u, h, p;
      if (null != n.wrap && (c = (p = n.wrap).tagClass, h = p.tagOpen, u = p.tagClose), null == c && (c = "highlight"), null == h && (h = '<strong class="' + c + '">'), null == u && (u = "</strong>"), e === t) return h + e + u;
      if (0 === (o = s(e, 0, n)).length) return e;
      for (a = "", r = -1, l = 0; ++r < o.length;) {
        for ((i = o[r]) > l && (a += e.substring(l, i), l = i); ++r < o.length;) {
          if (o[r] !== i + 1) {
            r--;
            break
          }
          i++
        }++i > l && (a += h, a += e.substring(l, i), a += u, l = i)
      }
      return l <= e.length - 1 && (a += e.substring(l)), a
    }, e = function (e, t, n, i) {
      var o, s, a;
      for (a = e.length - 1; e[a] === i;) a--;
      if (-1 === (o = e.lastIndexOf(i, a))) return [];
      for (s = n.depth; s-- > 0;)
        if (-1 === (o = e.lastIndexOf(i, o - 1))) return [];
      return o++, a++, r(e.slice(o, a), t.slice(o, a), n, o)
    }, a = function (e, t) {
      var n, r, i, o, s, a, l;
      if (s = e.length, 0 === (a = t.length)) return e.slice();
      if (0 === s) return t.slice();
      for (i = -1, r = t[o = 0], l = []; ++i < s;) {
        for (n = e[i]; r <= n && ++o < a;) r < n && l.push(r), r = t[o];
        l.push(n)
      }
      for (; o < a;) l.push(t[o++]);
      return l
    }, r = function (e, t, n, r) {
      var i, s, a, h, p, d, f, m, g, y, v, w, b, S, C, E, k, x, T, R, D, _;
      for (null == r && (r = 0), S = n.query, C = n.query_lw, g = e.length, w = S.length, i = l(e, t, S, C).score, x = new Array(w), p = new Array(w), 0, 1, 2, 3, _ = new Array(g * w), b = -1, m = -1; ++m < w;) x[m] = 0, p[m] = 0;
      for (f = -1; ++f < g;)
        for (E = 0, T = 0, h = 0, R = t[f], m = -1; ++m < w;) d = 0, s = 0, k = T, C[m] === R && (D = o(f, e, t), d = h > 0 ? h : u(e, t, S, C, f, m, D), s = k + c(f, m, D, i, d)), T = x[m], h = p[m], E > T ? v = 2 : (E = T, v = 1), s > E ? (E = s, v = 3) : d = 0, x[m] = E, p[m] = d, _[++b] = E > 0 ? v : 0;
      for (b = (f = g - 1) * w + (m = w - 1), a = !0, y = []; a && f >= 0 && m >= 0;) switch (_[b]) {
        case 1:
          f--, b -= w;
          break;
        case 2:
          m--, b--;
          break;
        case 3:
          y.push(f + r), m--, f--, b -= w + 1;
          break;
        default:
          a = !1
      }
      return y.reverse(), y
    }
  }).call(this)
}, function (e, t, n) {
  ! function (e) {
    "use strict";
    e.defineMode("javascript", (function (t, n) {
      var r, i, o = t.indentUnit,
        s = n.statementIndent,
        a = n.jsonld,
        l = n.json || a,
        c = n.typescript,
        u = n.wordCharacters || /[\w$\xa1-\uffff]/,
        h = function () {
          function e(e) {
            return {
              type: e,
              style: "keyword"
            }
          }
          var t = e("keyword a"),
            n = e("keyword b"),
            r = e("keyword c"),
            i = e("keyword d"),
            o = e("operator"),
            s = {
              type: "atom",
              style: "atom"
            };
          return {
            if: e("if"),
            while: t,
            with: t,
            else: n,
            do: n,
            try: n,
            finally: n,
            return: i,
            break: i,
            continue: i,
            new: e("new"),
            delete: r,
            void: r,
            throw: r,
            debugger: e("debugger"),
            var: e("var"),
            const: e("var"),
            let: e("var"),
            function: e("function"),
            catch: e("catch"),
            for: e("for"),
            switch: e("switch"),
            case: e("case"),
            default: e("default"),
            in: o,
            typeof: o,
            instanceof: o,
            true: s,
            false: s,
            null: s,
            undefined: s,
            NaN: s,
            Infinity: s,
            this: e("this"),
            class: e("class"),
            super: e("atom"),
            yield: r,
            export: e("export"),
            import: e("import"),
            extends: r,
            await: r
          }
        }(),
        p = /[+\-*&%=<>!?|~^@]/,
        d = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;

      function f(e, t, n) {
        return r = e, i = n, t
      }

      function m(e, t) {
        var n, r = e.next();
        if ('"' == r || "'" == r) return t.tokenize = (n = r, function (e, t) {
          var r, i = !1;
          if (a && "@" == e.peek() && e.match(d)) return t.tokenize = m, f("jsonld-keyword", "meta");
          for (; null != (r = e.next()) && (r != n || i);) i = !i && "\\" == r;
          return i || (t.tokenize = m), f("string", "string")
        }), t.tokenize(e, t);
        if ("." == r && e.match(/^\d[\d_]*(?:[eE][+\-]?[\d_]+)?/)) return f("number", "number");
        if ("." == r && e.match("..")) return f("spread", "meta");
        if (/[\[\]{}\(\),;\:\.]/.test(r)) return f(r);
        if ("=" == r && e.eat(">")) return f("=>", "operator");
        if ("0" == r && e.match(/^(?:x[\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/)) return f("number", "number");
        if (/\d/.test(r)) return e.match(/^[\d_]*(?:n|(?:\.[\d_]*)?(?:[eE][+\-]?[\d_]+)?)?/), f("number", "number");
        if ("/" == r) return e.eat("*") ? (t.tokenize = g, g(e, t)) : e.eat("/") ? (e.skipToEnd(), f("comment", "comment")) : qe(e, t, 1) ? (function (e) {
          for (var t, n = !1, r = !1; null != (t = e.next());) {
            if (!n) {
              if ("/" == t && !r) return;
              "[" == t ? r = !0 : r && "]" == t && (r = !1)
            }
            n = !n && "\\" == t
          }
        }(e), e.match(/^\b(([gimyus])(?![gimyus]*\2))+\b/), f("regexp", "string-2")) : (e.eat("="), f("operator", "operator", e.current()));
        if ("`" == r) return t.tokenize = y, y(e, t);
        if ("#" == r) return e.skipToEnd(), f("error", "error");
        if ("<" == r && e.match("!--") || "-" == r && e.match("->")) return e.skipToEnd(), f("comment", "comment");
        if (p.test(r)) return ">" == r && t.lexical && ">" == t.lexical.type || (e.eat("=") ? "!" != r && "=" != r || e.eat("=") : /[<>*+\-]/.test(r) && (e.eat(r), ">" == r && e.eat(r))), f("operator", "operator", e.current());
        if (u.test(r)) {
          e.eatWhile(u);
          var i = e.current();
          if ("." != t.lastType) {
            if (h.propertyIsEnumerable(i)) {
              var o = h[i];
              return f(o.type, o.style, i)
            }
            if ("async" == i && e.match(/^(\s|\/\*.*?\*\/)*[\[\(\w]/, !1)) return f("async", "keyword", i)
          }
          return f("variable", "variable", i)
        }
      }

      function g(e, t) {
        for (var n, r = !1; n = e.next();) {
          if ("/" == n && r) {
            t.tokenize = m;
            break
          }
          r = "*" == n
        }
        return f("comment", "comment")
      }

      function y(e, t) {
        for (var n, r = !1; null != (n = e.next());) {
          if (!r && ("`" == n || "$" == n && e.eat("{"))) {
            t.tokenize = m;
            break
          }
          r = !r && "\\" == n
        }
        return f("quasi", "string-2", e.current())
      }

      function v(e, t) {
        t.fatArrowAt && (t.fatArrowAt = null);
        var n = e.string.indexOf("=>", e.start);
        if (!(n < 0)) {
          if (c) {
            var r = /:\s*(?:\w+(?:<[^>]*>|\[\])?|\{[^}]*\})\s*$/.exec(e.string.slice(e.start, n));
            r && (n = r.index)
          }
          for (var i = 0, o = !1, s = n - 1; s >= 0; --s) {
            var a = e.string.charAt(s),
              l = "([{}])".indexOf(a);
            if (l >= 0 && l < 3) {
              if (!i) {
                ++s;
                break
              }
              if (0 == --i) {
                "(" == a && (o = !0);
                break
              }
            } else if (l >= 3 && l < 6) ++i;
            else if (u.test(a)) o = !0;
            else if (/["'\/`]/.test(a))
              for (;; --s) {
                if (0 == s) return;
                if (e.string.charAt(s - 1) == a && "\\" != e.string.charAt(s - 2)) {
                  s--;
                  break
                }
              } else if (o && !i) {
                ++s;
                break
              }
          }
          o && !i && (t.fatArrowAt = s)
        }
      }
      var w = {
        atom: !0,
        number: !0,
        variable: !0,
        string: !0,
        regexp: !0,
        this: !0,
        "jsonld-keyword": !0
      };

      function b(e, t, n, r, i, o) {
        this.indented = e, this.column = t, this.type = n, this.prev = i, this.info = o, null != r && (this.align = r)
      }

      function S(e, t) {
        for (var n = e.localVars; n; n = n.next)
          if (n.name == t) return !0;
        for (var r = e.context; r; r = r.prev)
          for (n = r.vars; n; n = n.next)
            if (n.name == t) return !0
      }
      var C = {
        state: null,
        column: null,
        marked: null,
        cc: null
      };

      function E() {
        for (var e = arguments.length - 1; e >= 0; e--) C.cc.push(arguments[e])
      }

      function k() {
        return E.apply(null, arguments), !0
      }

      function x(e, t) {
        for (var n = t; n; n = n.next)
          if (n.name == e) return !0;
        return !1
      }

      function T(e) {
        var t = C.state;
        if (C.marked = "def", t.context)
          if ("var" == t.lexical.info && t.context && t.context.block) {
            var r = function e(t, n) {
              if (n) {
                if (n.block) {
                  var r = e(t, n.prev);
                  return r ? r == n.prev ? n : new D(r, n.vars, !0) : null
                }
                return x(t, n.vars) ? n : new D(n.prev, new _(t, n.vars), !1)
              }
              return null
            }(e, t.context);
            if (null != r) return void(t.context = r)
          } else if (!x(e, t.localVars)) return void(t.localVars = new _(e, t.localVars));
        n.globalVars && !x(e, t.globalVars) && (t.globalVars = new _(e, t.globalVars))
      }

      function R(e) {
        return "public" == e || "private" == e || "protected" == e || "abstract" == e || "readonly" == e
      }

      function D(e, t, n) {
        this.prev = e, this.vars = t, this.block = n
      }

      function _(e, t) {
        this.name = e, this.next = t
      }
      var A = new _("this", new _("arguments", null));

      function M() {
        C.state.context = new D(C.state.context, C.state.localVars, !1), C.state.localVars = A
      }

      function P() {
        C.state.context = new D(C.state.context, C.state.localVars, !0), C.state.localVars = null
      }

      function I() {
        C.state.localVars = C.state.context.vars, C.state.context = C.state.context.prev
      }

      function O(e, t) {
        var n = function () {
          var n = C.state,
            r = n.indented;
          if ("stat" == n.lexical.type) r = n.lexical.indented;
          else
            for (var i = n.lexical; i && ")" == i.type && i.align; i = i.prev) r = i.indented;
          n.lexical = new b(r, C.stream.column(), e, null, n.lexical, t)
        };
        return n.lex = !0, n
      }

      function L() {
        var e = C.state;
        e.lexical.prev && (")" == e.lexical.type && (e.indented = e.lexical.indented), e.lexical = e.lexical.prev)
      }

      function N(e) {
        return function t(n) {
          return n == e ? k() : ";" == e || "}" == n || ")" == n || "]" == n ? E() : k(t)
        }
      }

      function F(e, t) {
        return "var" == e ? k(O("vardef", t), ve, N(";"), L) : "keyword a" == e ? k(O("form"), U, F, L) : "keyword b" == e ? k(O("form"), F, L) : "keyword d" == e ? C.stream.match(/^\s*$/, !1) ? k() : k(O("stat"), V, N(";"), L) : "debugger" == e ? k(N(";")) : "{" == e ? k(O("}"), P, oe, L, I) : ";" == e ? k() : "if" == e ? ("else" == C.state.lexical.info && C.state.cc[C.state.cc.length - 1] == L && C.state.cc.pop()(), k(O("form"), U, F, L, ke)) : "function" == e ? k(De) : "for" == e ? k(O("form"), xe, F, L) : "class" == e || c && "interface" == t ? (C.marked = "keyword", k(O("form", "class" == e ? e : t), Ie, L)) : "variable" == e ? c && "declare" == t ? (C.marked = "keyword", k(F)) : c && ("module" == t || "enum" == t || "type" == t) && C.stream.match(/^\s*\w/, !1) ? (C.marked = "keyword", "enum" == t ? k(Ge) : "type" == t ? k(Ae, N("operator"), ue, N(";")) : k(O("form"), we, N("{"), O("}"), oe, L, L)) : c && "namespace" == t ? (C.marked = "keyword", k(O("form"), H, F, L)) : c && "abstract" == t ? (C.marked = "keyword", k(F)) : k(O("stat"), X) : "switch" == e ? k(O("form"), U, N("{"), O("}", "switch"), P, oe, L, L, I) : "case" == e ? k(H, N(":")) : "default" == e ? k(N(":")) : "catch" == e ? k(O("form"), M, B, F, L, I) : "export" == e ? k(O("stat"), Fe, L) : "import" == e ? k(O("stat"), He, L) : "async" == e ? k(F) : "@" == t ? k(H, F) : E(O("stat"), H, N(";"), L)
      }

      function B(e) {
        if ("(" == e) return k(Me, N(")"))
      }

      function H(e, t) {
        return W(e, t, !1)
      }

      function z(e, t) {
        return W(e, t, !0)
      }

      function U(e) {
        return "(" != e ? E() : k(O(")"), H, N(")"), L)
      }

      function W(e, t, n) {
        if (C.state.fatArrowAt == C.stream.start) {
          var r = n ? Y : K;
          if ("(" == e) return k(M, O(")"), re(Me, ")"), L, N("=>"), r, I);
          if ("variable" == e) return E(M, we, N("=>"), r, I)
        }
        var i = n ? G : j;
        return w.hasOwnProperty(e) ? k(i) : "function" == e ? k(De, i) : "class" == e || c && "interface" == t ? (C.marked = "keyword", k(O("form"), Pe, L)) : "keyword c" == e || "async" == e ? k(n ? z : H) : "(" == e ? k(O(")"), V, N(")"), L, i) : "operator" == e || "spread" == e ? k(n ? z : H) : "[" == e ? k(O("]"), je, L, i) : "{" == e ? ie(ee, "}", null, i) : "quasi" == e ? E($, i) : "new" == e ? k(function (e) {
          return function (t) {
            return "." == t ? k(e ? Z : Q) : "variable" == t && c ? k(me, e ? G : j) : E(e ? z : H)
          }
        }(n)) : "import" == e ? k(H) : k()
      }

      function V(e) {
        return e.match(/[;\}\)\],]/) ? E() : E(H)
      }

      function j(e, t) {
        return "," == e ? k(H) : G(e, t, !1)
      }

      function G(e, t, n) {
        var r = 0 == n ? j : G,
          i = 0 == n ? H : z;
        return "=>" == e ? k(M, n ? Y : K, I) : "operator" == e ? /\+\+|--/.test(t) || c && "!" == t ? k(r) : c && "<" == t && C.stream.match(/^([^>]|<.*?>)*>\s*\(/, !1) ? k(O(">"), re(ue, ">"), L, r) : "?" == t ? k(H, N(":"), i) : k(i) : "quasi" == e ? E($, r) : ";" != e ? "(" == e ? ie(z, ")", "call", r) : "." == e ? k(J, r) : "[" == e ? k(O("]"), V, N("]"), L, r) : c && "as" == t ? (C.marked = "keyword", k(ue, r)) : "regexp" == e ? (C.state.lastType = C.marked = "operator", C.stream.backUp(C.stream.pos - C.stream.start - 1), k(i)) : void 0 : void 0
      }

      function $(e, t) {
        return "quasi" != e ? E() : "${" != t.slice(t.length - 2) ? k($) : k(H, q)
      }

      function q(e) {
        if ("}" == e) return C.marked = "string-2", C.state.tokenize = y, k($)
      }

      function K(e) {
        return v(C.stream, C.state), E("{" == e ? F : H)
      }

      function Y(e) {
        return v(C.stream, C.state), E("{" == e ? F : z)
      }

      function Q(e, t) {
        if ("target" == t) return C.marked = "keyword", k(j)
      }

      function Z(e, t) {
        if ("target" == t) return C.marked = "keyword", k(G)
      }

      function X(e) {
        return ":" == e ? k(L, F) : E(j, N(";"), L)
      }

      function J(e) {
        if ("variable" == e) return C.marked = "property", k()
      }

      function ee(e, t) {
        return "async" == e ? (C.marked = "property", k(ee)) : "variable" == e || "keyword" == C.style ? (C.marked = "property", "get" == t || "set" == t ? k(te) : (c && C.state.fatArrowAt == C.stream.start && (n = C.stream.match(/^\s*:\s*/, !1)) && (C.state.fatArrowAt = C.stream.pos + n[0].length), k(ne))) : "number" == e || "string" == e ? (C.marked = a ? "property" : C.style + " property", k(ne)) : "jsonld-keyword" == e ? k(ne) : c && R(t) ? (C.marked = "keyword", k(ee)) : "[" == e ? k(H, se, N("]"), ne) : "spread" == e ? k(z, ne) : "*" == t ? (C.marked = "keyword", k(ee)) : ":" == e ? E(ne) : void 0;
        var n
      }

      function te(e) {
        return "variable" != e ? E(ne) : (C.marked = "property", k(De))
      }

      function ne(e) {
        return ":" == e ? k(z) : "(" == e ? E(De) : void 0
      }

      function re(e, t, n) {
        function r(i, o) {
          if (n ? n.indexOf(i) > -1 : "," == i) {
            var s = C.state.lexical;
            return "call" == s.info && (s.pos = (s.pos || 0) + 1), k((function (n, r) {
              return n == t || r == t ? E() : E(e)
            }), r)
          }
          return i == t || o == t ? k() : n && n.indexOf(";") > -1 ? E(e) : k(N(t))
        }
        return function (n, i) {
          return n == t || i == t ? k() : E(e, r)
        }
      }

      function ie(e, t, n) {
        for (var r = 3; r < arguments.length; r++) C.cc.push(arguments[r]);
        return k(O(t, n), re(e, t), L)
      }

      function oe(e) {
        return "}" == e ? k() : E(F, oe)
      }

      function se(e, t) {
        if (c) {
          if (":" == e) return k(ue);
          if ("?" == t) return k(se)
        }
      }

      function ae(e, t) {
        if (c && (":" == e || "in" == t)) return k(ue)
      }

      function le(e) {
        if (c && ":" == e) return C.stream.match(/^\s*\w+\s+is\b/, !1) ? k(H, ce, ue) : k(ue)
      }

      function ce(e, t) {
        if ("is" == t) return C.marked = "keyword", k()
      }

      function ue(e, t) {
        return "keyof" == t || "typeof" == t || "infer" == t ? (C.marked = "keyword", k("typeof" == t ? z : ue)) : "variable" == e || "void" == t ? (C.marked = "type", k(fe)) : "|" == t || "&" == t ? k(ue) : "string" == e || "number" == e || "atom" == e ? k(fe) : "[" == e ? k(O("]"), re(ue, "]", ","), L, fe) : "{" == e ? k(O("}"), re(pe, "}", ",;"), L, fe) : "(" == e ? k(re(de, ")"), he, fe) : "<" == e ? k(re(ue, ">"), ue) : void 0
      }

      function he(e) {
        if ("=>" == e) return k(ue)
      }

      function pe(e, t) {
        return "variable" == e || "keyword" == C.style ? (C.marked = "property", k(pe)) : "?" == t || "number" == e || "string" == e ? k(pe) : ":" == e ? k(ue) : "[" == e ? k(N("variable"), ae, N("]"), pe) : "(" == e ? E(_e, pe) : void 0
      }

      function de(e, t) {
        return "variable" == e && C.stream.match(/^\s*[?:]/, !1) || "?" == t ? k(de) : ":" == e ? k(ue) : "spread" == e ? k(de) : E(ue)
      }

      function fe(e, t) {
        return "<" == t ? k(O(">"), re(ue, ">"), L, fe) : "|" == t || "." == e || "&" == t ? k(ue) : "[" == e ? k(ue, N("]"), fe) : "extends" == t || "implements" == t ? (C.marked = "keyword", k(ue)) : "?" == t ? k(ue, N(":"), ue) : void 0
      }

      function me(e, t) {
        if ("<" == t) return k(O(">"), re(ue, ">"), L, fe)
      }

      function ge() {
        return E(ue, ye)
      }

      function ye(e, t) {
        if ("=" == t) return k(ue)
      }

      function ve(e, t) {
        return "enum" == t ? (C.marked = "keyword", k(Ge)) : E(we, se, Ce, Ee)
      }

      function we(e, t) {
        return c && R(t) ? (C.marked = "keyword", k(we)) : "variable" == e ? (T(t), k()) : "spread" == e ? k(we) : "[" == e ? ie(Se, "]") : "{" == e ? ie(be, "}") : void 0
      }

      function be(e, t) {
        return "variable" != e || C.stream.match(/^\s*:/, !1) ? ("variable" == e && (C.marked = "property"), "spread" == e ? k(we) : "}" == e ? E() : "[" == e ? k(H, N("]"), N(":"), be) : k(N(":"), we, Ce)) : (T(t), k(Ce))
      }

      function Se() {
        return E(we, Ce)
      }

      function Ce(e, t) {
        if ("=" == t) return k(z)
      }

      function Ee(e) {
        if ("," == e) return k(ve)
      }

      function ke(e, t) {
        if ("keyword b" == e && "else" == t) return k(O("form", "else"), F, L)
      }

      function xe(e, t) {
        return "await" == t ? k(xe) : "(" == e ? k(O(")"), Te, L) : void 0
      }

      function Te(e) {
        return "var" == e ? k(ve, Re) : "variable" == e ? k(Re) : E(Re)
      }

      function Re(e, t) {
        return ")" == e ? k() : ";" == e ? k(Re) : "in" == t || "of" == t ? (C.marked = "keyword", k(H, Re)) : E(H, Re)
      }

      function De(e, t) {
        return "*" == t ? (C.marked = "keyword", k(De)) : "variable" == e ? (T(t), k(De)) : "(" == e ? k(M, O(")"), re(Me, ")"), L, le, F, I) : c && "<" == t ? k(O(">"), re(ge, ">"), L, De) : void 0
      }

      function _e(e, t) {
        return "*" == t ? (C.marked = "keyword", k(_e)) : "variable" == e ? (T(t), k(_e)) : "(" == e ? k(M, O(")"), re(Me, ")"), L, le, I) : c && "<" == t ? k(O(">"), re(ge, ">"), L, _e) : void 0
      }

      function Ae(e, t) {
        return "keyword" == e || "variable" == e ? (C.marked = "type", k(Ae)) : "<" == t ? k(O(">"), re(ge, ">"), L) : void 0
      }

      function Me(e, t) {
        return "@" == t && k(H, Me), "spread" == e ? k(Me) : c && R(t) ? (C.marked = "keyword", k(Me)) : c && "this" == e ? k(se, Ce) : E(we, se, Ce)
      }

      function Pe(e, t) {
        return "variable" == e ? Ie(e, t) : Oe(e, t)
      }

      function Ie(e, t) {
        if ("variable" == e) return T(t), k(Oe)
      }

      function Oe(e, t) {
        return "<" == t ? k(O(">"), re(ge, ">"), L, Oe) : "extends" == t || "implements" == t || c && "," == e ? ("implements" == t && (C.marked = "keyword"), k(c ? ue : H, Oe)) : "{" == e ? k(O("}"), Le, L) : void 0
      }

      function Le(e, t) {
        return "async" == e || "variable" == e && ("static" == t || "get" == t || "set" == t || c && R(t)) && C.stream.match(/^\s+[\w$\xa1-\uffff]/, !1) ? (C.marked = "keyword", k(Le)) : "variable" == e || "keyword" == C.style ? (C.marked = "property", k(c ? Ne : De, Le)) : "number" == e || "string" == e ? k(c ? Ne : De, Le) : "[" == e ? k(H, se, N("]"), c ? Ne : De, Le) : "*" == t ? (C.marked = "keyword", k(Le)) : c && "(" == e ? E(_e, Le) : ";" == e || "," == e ? k(Le) : "}" == e ? k() : "@" == t ? k(H, Le) : void 0
      }

      function Ne(e, t) {
        if ("?" == t) return k(Ne);
        if (":" == e) return k(ue, Ce);
        if ("=" == t) return k(z);
        var n = C.state.lexical.prev;
        return E(n && "interface" == n.info ? _e : De)
      }

      function Fe(e, t) {
        return "*" == t ? (C.marked = "keyword", k(Ve, N(";"))) : "default" == t ? (C.marked = "keyword", k(H, N(";"))) : "{" == e ? k(re(Be, "}"), Ve, N(";")) : E(F)
      }

      function Be(e, t) {
        return "as" == t ? (C.marked = "keyword", k(N("variable"))) : "variable" == e ? E(z, Be) : void 0
      }

      function He(e) {
        return "string" == e ? k() : "(" == e ? E(H) : E(ze, Ue, Ve)
      }

      function ze(e, t) {
        return "{" == e ? ie(ze, "}") : ("variable" == e && T(t), "*" == t && (C.marked = "keyword"), k(We))
      }

      function Ue(e) {
        if ("," == e) return k(ze, Ue)
      }

      function We(e, t) {
        if ("as" == t) return C.marked = "keyword", k(ze)
      }

      function Ve(e, t) {
        if ("from" == t) return C.marked = "keyword", k(H)
      }

      function je(e) {
        return "]" == e ? k() : E(re(z, "]"))
      }

      function Ge() {
        return E(O("form"), we, N("{"), O("}"), re($e, "}"), L, L)
      }

      function $e() {
        return E(we, Ce)
      }

      function qe(e, t, n) {
        return t.tokenize == m && /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\[{}\(,;:]|=>)$/.test(t.lastType) || "quasi" == t.lastType && /\{\s*$/.test(e.string.slice(0, e.pos - (n || 0)))
      }
      return I.lex = !0, L.lex = !0, {
        startState: function (e) {
          var t = {
            tokenize: m,
            lastType: "sof",
            cc: [],
            lexical: new b((e || 0) - o, 0, "block", !1),
            localVars: n.localVars,
            context: n.localVars && new D(null, null, !1),
            indented: e || 0
          };
          return n.globalVars && "object" == typeof n.globalVars && (t.globalVars = n.globalVars), t
        },
        token: function (e, t) {
          if (e.sol() && (t.lexical.hasOwnProperty("align") || (t.lexical.align = !1), t.indented = e.indentation(), v(e, t)), t.tokenize != g && e.eatSpace()) return null;
          var n = t.tokenize(e, t);
          return "comment" == r ? n : (t.lastType = "operator" != r || "++" != i && "--" != i ? r : "incdec", function (e, t, n, r, i) {
            var o = e.cc;
            for (C.state = e, C.stream = i, C.marked = null, C.cc = o, C.style = t, e.lexical.hasOwnProperty("align") || (e.lexical.align = !0);;)
              if ((o.length ? o.pop() : l ? H : F)(n, r)) {
                for (; o.length && o[o.length - 1].lex;) o.pop()();
                return C.marked ? C.marked : "variable" == n && S(e, r) ? "variable-2" : t
              }
          }(t, n, r, i, e))
        },
        indent: function (t, r) {
          if (t.tokenize == g) return e.Pass;
          if (t.tokenize != m) return 0;
          var i, a = r && r.charAt(0),
            l = t.lexical;
          if (!/^\s*else\b/.test(r))
            for (var c = t.cc.length - 1; c >= 0; --c) {
              var u = t.cc[c];
              if (u == L) l = l.prev;
              else if (u != ke) break
            }
          for (;
            ("stat" == l.type || "form" == l.type) && ("}" == a || (i = t.cc[t.cc.length - 1]) && (i == j || i == G) && !/^[,\.=+\-*:?[\(]/.test(r));) l = l.prev;
          s && ")" == l.type && "stat" == l.prev.type && (l = l.prev);
          var h = l.type,
            d = a == h;
          return "vardef" == h ? l.indented + ("operator" == t.lastType || "," == t.lastType ? l.info.length + 1 : 0) : "form" == h && "{" == a ? l.indented : "form" == h ? l.indented + o : "stat" == h ? l.indented + (function (e, t) {
            return "operator" == e.lastType || "," == e.lastType || p.test(t.charAt(0)) || /[,.]/.test(t.charAt(0))
          }(t, r) ? s || o : 0) : "switch" != l.info || d || 0 == n.doubleIndentSwitch ? l.align ? l.column + (d ? 0 : 1) : l.indented + (d ? 0 : o) : l.indented + (/^(?:case|default)\b/.test(r) ? o : 2 * o)
        },
        electricInput: /^\s*(?:case .*?:|default:|\{|\})$/,
        blockCommentStart: l ? null : "/*",
        blockCommentEnd: l ? null : "*/",
        blockCommentContinue: l ? null : " * ",
        lineComment: l ? null : "//",
        fold: "brace",
        closeBrackets: "()[]{}''\"\"``",
        helperType: l ? "json" : "javascript",
        jsonldMode: a,
        jsonMode: l,
        expressionAllowed: qe,
        skipExpression: function (e) {
          var t = e.cc[e.cc.length - 1];
          t != H && t != z || e.cc.pop()
        }
      }
    })), e.registerHelper("wordChars", "javascript", /[\w$]/), e.defineMIME("text/javascript", "javascript"), e.defineMIME("text/ecmascript", "javascript"), e.defineMIME("application/javascript", "javascript"), e.defineMIME("application/x-javascript", "javascript"), e.defineMIME("application/ecmascript", "javascript"), e.defineMIME("application/json", {
      name: "javascript",
      json: !0
    }), e.defineMIME("application/x-json", {
      name: "javascript",
      json: !0
    }), e.defineMIME("application/ld+json", {
      name: "javascript",
      jsonld: !0
    }), e.defineMIME("text/typescript", {
      name: "javascript",
      typescript: !0
    }), e.defineMIME("application/typescript", {
      name: "javascript",
      typescript: !0
    })
  }(n(14))
}, function (e, t, n) {
  ! function (e) {
    "use strict";

    function t(e) {
      e.state.markedSelection && e.operation((function () {
        ! function (e) {
          if (!e.somethingSelected()) return s(e);
          if (e.listSelections().length > 1) return a(e);
          var t = e.getCursor("start"),
            n = e.getCursor("end"),
            r = e.state.markedSelection;
          if (!r.length) return o(e, t, n);
          var l = r[0].find(),
            c = r[r.length - 1].find();
          if (!l || !c || n.line - t.line <= 8 || i(t, c.to) >= 0 || i(n, l.from) <= 0) return a(e);
          for (; i(t, l.from) > 0;) r.shift().clear(), l = r[0].find();
          for (i(t, l.from) < 0 && (l.to.line - t.line < 8 ? (r.shift().clear(), o(e, t, l.to, 0)) : o(e, t, l.from, 0)); i(n, c.to) < 0;) r.pop().clear(), c = r[r.length - 1].find();
          i(n, c.to) > 0 && (n.line - c.from.line < 8 ? (r.pop().clear(), o(e, c.from, n)) : o(e, c.to, n))
        }(e)
      }))
    }

    function n(e) {
      e.state.markedSelection && e.state.markedSelection.length && e.operation((function () {
        s(e)
      }))
    }
    e.defineOption("styleSelectedText", !1, (function (r, i, o) {
      var l = o && o != e.Init;
      i && !l ? (r.state.markedSelection = [], r.state.markedSelectionStyle = "string" == typeof i ? i : "CodeMirror-selectedtext", a(r), r.on("cursorActivity", t), r.on("change", n)) : !i && l && (r.off("cursorActivity", t), r.off("change", n), s(r), r.state.markedSelection = r.state.markedSelectionStyle = null)
    }));
    var r = e.Pos,
      i = e.cmpPos;

    function o(e, t, n, o) {
      if (0 != i(t, n))
        for (var s = e.state.markedSelection, a = e.state.markedSelectionStyle, l = t.line;;) {
          var c = l == t.line ? t : r(l, 0),
            u = l + 8,
            h = u >= n.line,
            p = h ? n : r(u, 0),
            d = e.markText(c, p, {
              className: a
            });
          if (null == o ? s.push(d) : s.splice(o++, 0, d), h) break;
          l = u
        }
    }

    function s(e) {
      for (var t = e.state.markedSelection, n = 0; n < t.length; ++n) t[n].clear();
      t.length = 0
    }

    function a(e) {
      s(e);
      for (var t = e.listSelections(), n = 0; n < t.length; n++) o(e, t[n].from(), t[n].to())
    }
  }(n(14))
}, function (e, t, n) {
  ! function (e) {
    "use strict";

    function t(e, t) {
      this.cm = e, this.options = t, this.widget = null, this.debounce = 0, this.tick = 0, this.startPos = this.cm.getCursor("start"), this.startLen = this.cm.getLine(this.startPos.line).length - this.cm.getSelection().length;
      var n = this;
      e.on("cursorActivity", this.activityFunc = function () {
        n.cursorActivity()
      })
    }
    e.showHint = function (e, t, n) {
      if (!t) return e.showHint(n);
      n && n.async && (t.async = !0);
      var r = {
        hint: t
      };
      if (n)
        for (var i in n) r[i] = n[i];
      return e.showHint(r)
    }, e.defineExtension("showHint", (function (n) {
      n = function (e, t, n) {
        var r = e.options.hintOptions,
          i = {};
        for (var o in l) i[o] = l[o];
        if (r)
          for (var o in r) void 0 !== r[o] && (i[o] = r[o]);
        if (n)
          for (var o in n) void 0 !== n[o] && (i[o] = n[o]);
        return i.hint.resolve && (i.hint = i.hint.resolve(e, t)), i
      }(this, this.getCursor("start"), n);
      var r = this.listSelections();
      if (!(r.length > 1)) {
        if (this.somethingSelected()) {
          if (!n.hint.supportsSelection) return;
          for (var i = 0; i < r.length; i++)
            if (r[i].head.line != r[i].anchor.line) return
        }
        this.state.completionActive && this.state.completionActive.close();
        var o = this.state.completionActive = new t(this, n);
        o.options.hint && (e.signal(this, "startCompletion", this), o.update(!0))
      }
    })), e.defineExtension("closeHint", (function () {
      this.state.completionActive && this.state.completionActive.close()
    }));
    var n = window.requestAnimationFrame || function (e) {
        return setTimeout(e, 1e3 / 60)
      },
      r = window.cancelAnimationFrame || clearTimeout;

    function i(e) {
      return "string" == typeof e ? e : e.text
    }

    function o(e, t) {
      for (; t && t != e;) {
        if ("LI" === t.nodeName.toUpperCase() && t.parentNode == e) return t;
        t = t.parentNode
      }
    }

    function s(t, n) {
      this.completion = t, this.data = n, this.picked = !1;
      var r = this,
        s = t.cm,
        a = s.getInputField().ownerDocument,
        l = a.defaultView || a.parentWindow,
        c = this.hints = a.createElement("ul"),
        u = t.cm.options.theme;
      c.className = "CodeMirror-hints " + u, this.selectedHint = n.selectedHint || 0;
      for (var h = n.list, p = 0; p < h.length; ++p) {
        var d = c.appendChild(a.createElement("li")),
          f = h[p],
          m = "CodeMirror-hint" + (p != this.selectedHint ? "" : " CodeMirror-hint-active");
        null != f.className && (m = f.className + " " + m), d.className = m, f.render ? f.render(d, n, f) : d.appendChild(a.createTextNode(f.displayText || i(f))), d.hintId = p
      }
      var g = t.options.container || a.body,
        y = s.cursorCoords(t.options.alignWithWord ? n.from : null),
        v = y.left,
        w = y.bottom,
        b = !0,
        S = 0,
        C = 0;
      if (g !== a.body) {
        var E = -1 !== ["absolute", "relative", "fixed"].indexOf(l.getComputedStyle(g).position) ? g : g.offsetParent,
          k = E.getBoundingClientRect(),
          x = a.body.getBoundingClientRect();
        S = k.left - x.left - E.scrollLeft, C = k.top - x.top - E.scrollTop
      }
      c.style.left = v - S + "px", c.style.top = w - C + "px";
      var T = l.innerWidth || Math.max(a.body.offsetWidth, a.documentElement.offsetWidth),
        R = l.innerHeight || Math.max(a.body.offsetHeight, a.documentElement.offsetHeight);
      g.appendChild(c);
      var D = c.getBoundingClientRect(),
        _ = D.bottom - R,
        A = c.scrollHeight > c.clientHeight + 1,
        M = s.getScrollInfo();
      if (_ > 0) {
        var P = D.bottom - D.top;
        if (y.top - (y.bottom - D.top) - P > 0) c.style.top = (w = y.top - P - C) + "px", b = !1;
        else if (P > R) {
          c.style.height = R - 5 + "px", c.style.top = (w = y.bottom - D.top - C) + "px";
          var I = s.getCursor();
          n.from.ch != I.ch && (y = s.cursorCoords(I), c.style.left = (v = y.left - S) + "px", D = c.getBoundingClientRect())
        }
      }
      var O, L = D.right - T;
      if (L > 0 && (D.right - D.left > T && (c.style.width = T - 5 + "px", L -= D.right - D.left - T), c.style.left = (v = y.left - L - S) + "px"), A)
        for (var N = c.firstChild; N; N = N.nextSibling) N.style.paddingRight = s.display.nativeBarWidth + "px";
      return s.addKeyMap(this.keyMap = function (e, t) {
        var n = {
          Up: function () {
            t.moveFocus(-1)
          },
          Down: function () {
            t.moveFocus(1)
          },
          PageUp: function () {
            t.moveFocus(1 - t.menuSize(), !0)
          },
          PageDown: function () {
            t.moveFocus(t.menuSize() - 1, !0)
          },
          Home: function () {
            t.setFocus(0)
          },
          End: function () {
            t.setFocus(t.length - 1)
          },
          Enter: t.pick,
          Tab: t.pick,
          Esc: t.close
        };
        /Mac/.test(navigator.platform) && (n["Ctrl-P"] = function () {
          t.moveFocus(-1)
        }, n["Ctrl-N"] = function () {
          t.moveFocus(1)
        });
        var r = e.options.customKeys,
          i = r ? {} : n;

        function o(e, r) {
          var o;
          o = "string" != typeof r ? function (e) {
            return r(e, t)
          } : n.hasOwnProperty(r) ? n[r] : r, i[e] = o
        }
        if (r)
          for (var s in r) r.hasOwnProperty(s) && o(s, r[s]);
        var a = e.options.extraKeys;
        if (a)
          for (var s in a) a.hasOwnProperty(s) && o(s, a[s]);
        return i
      }(t, {
        moveFocus: function (e, t) {
          r.changeActive(r.selectedHint + e, t)
        },
        setFocus: function (e) {
          r.changeActive(e)
        },
        menuSize: function () {
          return r.screenAmount()
        },
        length: h.length,
        close: function () {
          t.close()
        },
        pick: function () {
          r.pick()
        },
        data: n
      })), t.options.closeOnUnfocus && (s.on("blur", this.onBlur = function () {
        O = setTimeout((function () {
          t.close()
        }), 100)
      }), s.on("focus", this.onFocus = function () {
        clearTimeout(O)
      })), s.on("scroll", this.onScroll = function () {
        var e = s.getScrollInfo(),
          n = s.getWrapperElement().getBoundingClientRect(),
          r = w + M.top - e.top,
          i = r - (l.pageYOffset || (a.documentElement || a.body).scrollTop);
        if (b || (i += c.offsetHeight), i <= n.top || i >= n.bottom) return t.close();
        c.style.top = r + "px", c.style.left = v + M.left - e.left + "px"
      }), e.on(c, "dblclick", (function (e) {
        var t = o(c, e.target || e.srcElement);
        t && null != t.hintId && (r.changeActive(t.hintId), r.pick())
      })), e.on(c, "click", (function (e) {
        var n = o(c, e.target || e.srcElement);
        n && null != n.hintId && (r.changeActive(n.hintId), t.options.completeOnSingleClick && r.pick())
      })), e.on(c, "mousedown", (function () {
        setTimeout((function () {
          s.focus()
        }), 20)
      })), e.signal(n, "select", h[this.selectedHint], c.childNodes[this.selectedHint]), !0
    }

    function a(e, t, n, r) {
      if (e.async) e(t, r, n);
      else {
        var i = e(t, n);
        i && i.then ? i.then(r) : r(i)
      }
    }
    t.prototype = {
      close: function () {
        this.active() && (this.cm.state.completionActive = null, this.tick = null, this.cm.off("cursorActivity", this.activityFunc), this.widget && this.data && e.signal(this.data, "close"), this.widget && this.widget.close(), e.signal(this.cm, "endCompletion", this.cm))
      },
      active: function () {
        return this.cm.state.completionActive == this
      },
      pick: function (t, n) {
        var r = t.list[n];
        r.hint ? r.hint(this.cm, t, r) : this.cm.replaceRange(i(r), r.from || t.from, r.to || t.to, "complete"), e.signal(t, "pick", r), this.close()
      },
      cursorActivity: function () {
        this.debounce && (r(this.debounce), this.debounce = 0);
        var e = this.cm.getCursor(),
          t = this.cm.getLine(e.line);
        if (e.line != this.startPos.line || t.length - e.ch != this.startLen - this.startPos.ch || e.ch < this.startPos.ch || this.cm.somethingSelected() || !e.ch || this.options.closeCharacters.test(t.charAt(e.ch - 1))) this.close();
        else {
          var i = this;
          this.debounce = n((function () {
            i.update()
          })), this.widget && this.widget.disable()
        }
      },
      update: function (e) {
        if (null != this.tick) {
          var t = this,
            n = ++this.tick;
          a(this.options.hint, this.cm, this.options, (function (r) {
            t.tick == n && t.finishUpdate(r, e)
          }))
        }
      },
      finishUpdate: function (t, n) {
        this.data && e.signal(this.data, "update");
        var r = this.widget && this.widget.picked || n && this.options.completeSingle;
        this.widget && this.widget.close(), this.data = t, t && t.list.length && (r && 1 == t.list.length ? this.pick(t, 0) : (this.widget = new s(this, t), e.signal(t, "shown")))
      }
    }, s.prototype = {
      close: function () {
        if (this.completion.widget == this) {
          this.completion.widget = null, this.hints.parentNode.removeChild(this.hints), this.completion.cm.removeKeyMap(this.keyMap);
          var e = this.completion.cm;
          this.completion.options.closeOnUnfocus && (e.off("blur", this.onBlur), e.off("focus", this.onFocus)), e.off("scroll", this.onScroll)
        }
      },
      disable: function () {
        this.completion.cm.removeKeyMap(this.keyMap);
        var e = this;
        this.keyMap = {
          Enter: function () {
            e.picked = !0
          }
        }, this.completion.cm.addKeyMap(this.keyMap)
      },
      pick: function () {
        this.completion.pick(this.data, this.selectedHint)
      },
      changeActive: function (t, n) {
        if (t >= this.data.list.length ? t = n ? this.data.list.length - 1 : 0 : t < 0 && (t = n ? 0 : this.data.list.length - 1), this.selectedHint != t) {
          var r = this.hints.childNodes[this.selectedHint];
          r && (r.className = r.className.replace(" CodeMirror-hint-active", "")), (r = this.hints.childNodes[this.selectedHint = t]).className += " CodeMirror-hint-active", r.offsetTop < this.hints.scrollTop ? this.hints.scrollTop = r.offsetTop - 3 : r.offsetTop + r.offsetHeight > this.hints.scrollTop + this.hints.clientHeight && (this.hints.scrollTop = r.offsetTop + r.offsetHeight - this.hints.clientHeight + 3), e.signal(this.data, "select", this.data.list[this.selectedHint], r)
        }
      },
      screenAmount: function () {
        return Math.floor(this.hints.clientHeight / this.hints.firstChild.offsetHeight) || 1
      }
    }, e.registerHelper("hint", "auto", {
      resolve: function (t, n) {
        var r, i = t.getHelpers(n, "hint");
        if (i.length) {
          var o = function (e, t, n) {
            var r = function (e, t) {
              if (!e.somethingSelected()) return t;
              for (var n = [], r = 0; r < t.length; r++) t[r].supportsSelection && n.push(t[r]);
              return n
            }(e, i);
            ! function i(o) {
              if (o == r.length) return t(null);
              a(r[o], e, n, (function (e) {
                e && e.list.length > 0 ? t(e) : i(o + 1)
              }))
            }(0)
          };
          return o.async = !0, o.supportsSelection = !0, o
        }
        return (r = t.getHelper(t.getCursor(), "hintWords")) ? function (t) {
          return e.hint.fromList(t, {
            words: r
          })
        } : e.hint.anyword ? function (t, n) {
          return e.hint.anyword(t, n)
        } : function () {}
      }
    }), e.registerHelper("hint", "fromList", (function (t, n) {
      var r, i = t.getCursor(),
        o = t.getTokenAt(i),
        s = e.Pos(i.line, o.start),
        a = i;
      o.start < i.ch && /\w/.test(o.string.charAt(i.ch - o.start - 1)) ? r = o.string.substr(0, i.ch - o.start) : (r = "", s = i);
      for (var l = [], c = 0; c < n.words.length; c++) {
        var u = n.words[c];
        u.slice(0, r.length) == r && l.push(u)
      }
      if (l.length) return {
        list: l,
        from: s,
        to: a
      }
    })), e.commands.autocomplete = e.showHint;
    var l = {
      hint: e.hint.auto,
      completeSingle: !0,
      alignWithWord: !0,
      closeCharacters: /[\s()\[\]{};:>,]/,
      closeOnUnfocus: !0,
      completeOnSingleClick: !0,
      container: null,
      customKeys: null,
      extraKeys: null
    };
    e.defineOption("hintOptions", null)
  }(n(14))
}, function (e, t, n) {
  ! function (e) {
    "use strict";

    function t() {
      this.posFrom = this.posTo = this.lastQuery = this.query = null, this.overlay = null
    }

    function n(e) {
      return e.state.search || (e.state.search = new t)
    }

    function r(e) {
      return "string" == typeof e && e == e.toLowerCase()
    }

    function i(e, t, n) {
      return e.getSearchCursor(t, n, {
        caseFold: r(t),
        multiline: !0
      })
    }

    function o(e, t, n, r, i) {
      e.openDialog ? e.openDialog(t, i, {
        value: r,
        selectValueOnOpen: !0
      }) : i(prompt(n, r))
    }

    function s(e) {
      return e.replace(/\\([nrt\\])/g, (function (e, t) {
        return "n" == t ? "\n" : "r" == t ? "\r" : "t" == t ? "\t" : "\\" == t ? "\\" : e
      }))
    }

    function a(e) {
      var t = e.match(/^\/(.*)\/([a-z]*)$/);
      if (t) try {
        e = new RegExp(t[1], -1 == t[2].indexOf("i") ? "" : "i")
      } catch (e) {} else e = s(e);
      return ("string" == typeof e ? "" == e : e.test("")) && (e = /x^/), e
    }

    function l(e, t, n) {
      t.queryText = n, t.query = a(n), e.removeOverlay(t.overlay, r(t.query)), t.overlay = function (e, t) {
        return "string" == typeof e ? e = new RegExp(e.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&"), t ? "gi" : "g") : e.global || (e = new RegExp(e.source, e.ignoreCase ? "gi" : "g")), {
          token: function (t) {
            e.lastIndex = t.pos;
            var n = e.exec(t.string);
            if (n && n.index == t.pos) return t.pos += n[0].length || 1, "searching";
            n ? t.pos = n.index : t.skipToEnd()
          }
        }
      }(t.query, r(t.query)), e.addOverlay(t.overlay), e.showMatchesOnScrollbar && (t.annotate && (t.annotate.clear(), t.annotate = null), t.annotate = e.showMatchesOnScrollbar(t.query, r(t.query)))
    }

    function c(t, r, i, s) {
      var a = n(t);
      if (a.query) return u(t, r);
      var c = t.getSelection() || a.lastQuery;
      if (c instanceof RegExp && "x^" == c.source && (c = null), i && t.openDialog) {
        var d = null,
          f = function (n, r) {
            e.e_stop(r), n && (n != a.queryText && (l(t, a, n), a.posFrom = a.posTo = t.getCursor()), d && (d.style.opacity = 1), u(t, r.shiftKey, (function (e, n) {
              var r;
              n.line < 3 && document.querySelector && (r = t.display.wrapper.querySelector(".CodeMirror-dialog")) && r.getBoundingClientRect().bottom - 4 > t.cursorCoords(n, "window").top && ((d = r).style.opacity = .4)
            })))
          };
        ! function (e, t, n, r, i) {
          e.openDialog(t, r, {
            value: n,
            selectValueOnOpen: !0,
            closeOnEnter: !1,
            onClose: function () {
              h(e)
            },
            onKeyDown: i
          })
        }(t, p(t), c, f, (function (r, i) {
          var o = e.keyName(r),
            s = t.getOption("extraKeys"),
            a = s && s[o] || e.keyMap[t.getOption("keyMap")][o];
          "findNext" == a || "findPrev" == a || "findPersistentNext" == a || "findPersistentPrev" == a ? (e.e_stop(r), l(t, n(t), i), t.execCommand(a)) : "find" != a && "findPersistent" != a || (e.e_stop(r), f(i, r))
        })), s && c && (l(t, a, c), u(t, r))
      } else o(t, p(t), "Search for:", c, (function (e) {
        e && !a.query && t.operation((function () {
          l(t, a, e), a.posFrom = a.posTo = t.getCursor(), u(t, r)
        }))
      }))
    }

    function u(t, r, o) {
      t.operation((function () {
        var s = n(t),
          a = i(t, s.query, r ? s.posFrom : s.posTo);
        (a.find(r) || (a = i(t, s.query, r ? e.Pos(t.lastLine()) : e.Pos(t.firstLine(), 0))).find(r)) && (t.setSelection(a.from(), a.to()), t.scrollIntoView({
          from: a.from(),
          to: a.to()
        }, 20), s.posFrom = a.from(), s.posTo = a.to(), o && o(a.from(), a.to()))
      }))
    }

    function h(e) {
      e.operation((function () {
        var t = n(e);
        t.lastQuery = t.query, t.query && (t.query = t.queryText = null, e.removeOverlay(t.overlay), t.annotate && (t.annotate.clear(), t.annotate = null))
      }))
    }

    function p(e) {
      return '<span class="CodeMirror-search-label">' + e.phrase("Search:") + '</span> <input type="text" style="width: 10em" class="CodeMirror-search-field"/> <span style="color: #888" class="CodeMirror-search-hint">' + e.phrase("(Use /re/ syntax for regexp search)") + "</span>"
    }

    function d(e, t, n) {
      e.operation((function () {
        for (var r = i(e, t); r.findNext();)
          if ("string" != typeof t) {
            var o = e.getRange(r.from(), r.to()).match(t);
            r.replace(n.replace(/\$(\d)/g, (function (e, t) {
              return o[t]
            })))
          } else r.replace(n)
      }))
    }

    function f(e, t) {
      if (!e.getOption("readOnly")) {
        var r = e.getSelection() || n(e).lastQuery,
          l = '<span class="CodeMirror-search-label">' + (t ? e.phrase("Replace all:") : e.phrase("Replace:")) + "</span>";
        o(e, l + function (e) {
          return ' <input type="text" style="width: 10em" class="CodeMirror-search-field"/> <span style="color: #888" class="CodeMirror-search-hint">' + e.phrase("(Use /re/ syntax for regexp search)") + "</span>"
        }(e), l, r, (function (n) {
          n && (n = a(n), o(e, function (e) {
            return '<span class="CodeMirror-search-label">' + e.phrase("With:") + '</span> <input type="text" style="width: 10em" class="CodeMirror-search-field"/>'
          }(e), e.phrase("Replace with:"), "", (function (r) {
            if (r = s(r), t) d(e, n, r);
            else {
              h(e);
              var o = i(e, n, e.getCursor("from")),
                a = function () {
                  var t, s = o.from();
                  !(t = o.findNext()) && (o = i(e, n), !(t = o.findNext()) || s && o.from().line == s.line && o.from().ch == s.ch) || (e.setSelection(o.from(), o.to()), e.scrollIntoView({
                    from: o.from(),
                    to: o.to()
                  }), function (e, t, n, r) {
                    e.openConfirm ? e.openConfirm(t, r) : confirm(n) && r[0]()
                  }(e, function (e) {
                    return '<span class="CodeMirror-search-label">' + e.phrase("Replace?") + "</span> <button>" + e.phrase("Yes") + "</button> <button>" + e.phrase("No") + "</button> <button>" + e.phrase("All") + "</button> <button>" + e.phrase("Stop") + "</button> "
                  }(e), e.phrase("Replace?"), [function () {
                    l(t)
                  }, a, function () {
                    d(e, n, r)
                  }]))
                },
                l = function (e) {
                  o.replace("string" == typeof n ? r : r.replace(/\$(\d)/g, (function (t, n) {
                    return e[n]
                  }))), a()
                };
              a()
            }
          })))
        }))
      }
    }
    e.commands.find = function (e) {
      h(e), c(e)
    }, e.commands.findPersistent = function (e) {
      h(e), c(e, !1, !0)
    }, e.commands.findPersistentNext = function (e) {
      c(e, !1, !0, !0)
    }, e.commands.findPersistentPrev = function (e) {
      c(e, !0, !0, !0)
    }, e.commands.findNext = c, e.commands.findPrev = function (e) {
      c(e, !0)
    }, e.commands.clearSearch = h, e.commands.replace = f, e.commands.replaceAll = function (e) {
      f(e, !0)
    }
  }(n(14), n(286), n(287))
}, function (e, t, n) {
  ! function (e) {
    "use strict";
    var t, n, r = e.Pos;

    function i(e, t) {
      for (var n = function (e) {
          var t = e.flags;
          return null != t ? t : (e.ignoreCase ? "i" : "") + (e.global ? "g" : "") + (e.multiline ? "m" : "")
        }(e), r = n, i = 0; i < t.length; i++) - 1 == r.indexOf(t.charAt(i)) && (r += t.charAt(i));
      return n == r ? e : new RegExp(e.source, r)
    }

    function o(e, t, n) {
      t = i(t, "g");
      for (var o = n.line, s = n.ch, a = e.lastLine(); o <= a; o++, s = 0) {
        t.lastIndex = s;
        var l = e.getLine(o),
          c = t.exec(l);
        if (c) return {
          from: r(o, c.index),
          to: r(o, c.index + c[0].length),
          match: c
        }
      }
    }

    function s(e, t, n) {
      if (! function (e) {
          return /\\s|\\n|\n|\\W|\\D|\[\^/.test(e.source)
        }(t)) return o(e, t, n);
      t = i(t, "gm");
      for (var s, a = 1, l = n.line, c = e.lastLine(); l <= c;) {
        for (var u = 0; u < a && !(l > c); u++) {
          var h = e.getLine(l++);
          s = null == s ? h : s + "\n" + h
        }
        a *= 2, t.lastIndex = n.ch;
        var p = t.exec(s);
        if (p) {
          var d = s.slice(0, p.index).split("\n"),
            f = p[0].split("\n"),
            m = n.line + d.length - 1,
            g = d[d.length - 1].length;
          return {
            from: r(m, g),
            to: r(m + f.length - 1, 1 == f.length ? g + f[0].length : f[f.length - 1].length),
            match: p
          }
        }
      }
    }

    function a(e, t) {
      for (var n, r = 0;;) {
        t.lastIndex = r;
        var i = t.exec(e);
        if (!i) return n;
        if ((r = (n = i).index + (n[0].length || 1)) == e.length) return n
      }
    }

    function l(e, t, n) {
      t = i(t, "g");
      for (var o = n.line, s = n.ch, l = e.firstLine(); o >= l; o--, s = -1) {
        var c = e.getLine(o);
        s > -1 && (c = c.slice(0, s));
        var u = a(c, t);
        if (u) return {
          from: r(o, u.index),
          to: r(o, u.index + u[0].length),
          match: u
        }
      }
    }

    function c(e, t, n) {
      t = i(t, "gm");
      for (var o, s = 1, l = n.line, c = e.firstLine(); l >= c;) {
        for (var u = 0; u < s; u++) {
          var h = e.getLine(l--);
          o = null == o ? h.slice(0, n.ch) : h + "\n" + o
        }
        s *= 2;
        var p = a(o, t);
        if (p) {
          var d = o.slice(0, p.index).split("\n"),
            f = p[0].split("\n"),
            m = l + d.length,
            g = d[d.length - 1].length;
          return {
            from: r(m, g),
            to: r(m + f.length - 1, 1 == f.length ? g + f[0].length : f[f.length - 1].length),
            match: p
          }
        }
      }
    }

    function u(e, t, n, r) {
      if (e.length == t.length) return n;
      for (var i = 0, o = n + Math.max(0, e.length - t.length);;) {
        if (i == o) return i;
        var s = i + o >> 1,
          a = r(e.slice(0, s)).length;
        if (a == n) return s;
        a > n ? o = s : i = s + 1
      }
    }

    function h(e, i, o, s) {
      if (!i.length) return null;
      var a = s ? t : n,
        l = a(i).split(/\r|\n\r?/);
      e: for (var c = o.line, h = o.ch, p = e.lastLine() + 1 - l.length; c <= p; c++, h = 0) {
        var d = e.getLine(c).slice(h),
          f = a(d);
        if (1 == l.length) {
          var m = f.indexOf(l[0]);
          if (-1 == m) continue e;
          return o = u(d, f, m, a) + h, {
            from: r(c, u(d, f, m, a) + h),
            to: r(c, u(d, f, m + l[0].length, a) + h)
          }
        }
        var g = f.length - l[0].length;
        if (f.slice(g) == l[0]) {
          for (var y = 1; y < l.length - 1; y++)
            if (a(e.getLine(c + y)) != l[y]) continue e;
          var v = e.getLine(c + l.length - 1),
            w = a(v),
            b = l[l.length - 1];
          if (w.slice(0, b.length) == b) return {
            from: r(c, u(d, f, g, a) + h),
            to: r(c + l.length - 1, u(v, w, b.length, a))
          }
        }
      }
    }

    function p(e, i, o, s) {
      if (!i.length) return null;
      var a = s ? t : n,
        l = a(i).split(/\r|\n\r?/);
      e: for (var c = o.line, h = o.ch, p = e.firstLine() - 1 + l.length; c >= p; c--, h = -1) {
        var d = e.getLine(c);
        h > -1 && (d = d.slice(0, h));
        var f = a(d);
        if (1 == l.length) {
          var m = f.lastIndexOf(l[0]);
          if (-1 == m) continue e;
          return {
            from: r(c, u(d, f, m, a)),
            to: r(c, u(d, f, m + l[0].length, a))
          }
        }
        var g = l[l.length - 1];
        if (f.slice(0, g.length) == g) {
          var y = 1;
          for (o = c - l.length + 1; y < l.length - 1; y++)
            if (a(e.getLine(o + y)) != l[y]) continue e;
          var v = e.getLine(c + 1 - l.length),
            w = a(v);
          if (w.slice(w.length - l[0].length) == l[0]) return {
            from: r(c + 1 - l.length, u(v, w, v.length - l[0].length, a)),
            to: r(c, u(d, f, g.length, a))
          }
        }
      }
    }

    function d(e, t, n, a) {
      var u;
      this.atOccurrence = !1, this.doc = e, n = n ? e.clipPos(n) : r(0, 0), this.pos = {
        from: n,
        to: n
      }, "object" == typeof a ? u = a.caseFold : (u = a, a = null), "string" == typeof t ? (null == u && (u = !1), this.matches = function (n, r) {
        return (n ? p : h)(e, t, r, u)
      }) : (t = i(t, "gm"), a && !1 === a.multiline ? this.matches = function (n, r) {
        return (n ? l : o)(e, t, r)
      } : this.matches = function (n, r) {
        return (n ? c : s)(e, t, r)
      })
    }
    String.prototype.normalize ? (t = function (e) {
      return e.normalize("NFD").toLowerCase()
    }, n = function (e) {
      return e.normalize("NFD")
    }) : (t = function (e) {
      return e.toLowerCase()
    }, n = function (e) {
      return e
    }), d.prototype = {
      findNext: function () {
        return this.find(!1)
      },
      findPrevious: function () {
        return this.find(!0)
      },
      find: function (t) {
        for (var n = this.matches(t, this.doc.clipPos(t ? this.pos.from : this.pos.to)); n && 0 == e.cmpPos(n.from, n.to);) t ? n.from.ch ? n.from = r(n.from.line, n.from.ch - 1) : n = n.from.line == this.doc.firstLine() ? null : this.matches(t, this.doc.clipPos(r(n.from.line - 1))) : n.to.ch < this.doc.getLine(n.to.line).length ? n.to = r(n.to.line, n.to.ch + 1) : n = n.to.line == this.doc.lastLine() ? null : this.matches(t, r(n.to.line + 1, 0));
        if (n) return this.pos = n, this.atOccurrence = !0, this.pos.match || !0;
        var i = r(t ? this.doc.firstLine() : this.doc.lastLine() + 1, 0);
        return this.pos = {
          from: i,
          to: i
        }, this.atOccurrence = !1
      },
      from: function () {
        if (this.atOccurrence) return this.pos.from
      },
      to: function () {
        if (this.atOccurrence) return this.pos.to
      },
      replace: function (t, n) {
        if (this.atOccurrence) {
          var i = e.splitLines(t);
          this.doc.replaceRange(i, this.pos.from, this.pos.to, n), this.pos.to = r(this.pos.from.line + i.length - 1, i[i.length - 1].length + (1 == i.length ? this.pos.from.ch : 0))
        }
      }
    }, e.defineExtension("getSearchCursor", (function (e, t, n) {
      return new d(this.doc, e, t, n)
    })), e.defineDocExtension("getSearchCursor", (function (e, t, n) {
      return new d(this, e, t, n)
    })), e.defineExtension("selectMatches", (function (t, n) {
      for (var r = [], i = this.getSearchCursor(t, this.getCursor("from"), n); i.findNext() && !(e.cmpPos(i.to(), this.getCursor("to")) > 0);) r.push({
        anchor: i.from(),
        head: i.to()
      });
      r.length && this.setSelections(r, 0)
    }))
  }(n(14))
}, function (e, t, n) {
  ! function (e) {
    function t(t, n, r) {
      var i, o = t.getWrapperElement();
      return (i = o.appendChild(document.createElement("div"))).className = r ? "CodeMirror-dialog CodeMirror-dialog-bottom" : "CodeMirror-dialog CodeMirror-dialog-top", "string" == typeof n ? i.innerHTML = n : i.appendChild(n), e.addClass(o, "dialog-opened"), i
    }

    function n(e, t) {
      e.state.currentNotificationClose && e.state.currentNotificationClose(), e.state.currentNotificationClose = t
    }
    e.defineExtension("openDialog", (function (r, i, o) {
      o || (o = {}), n(this, null);
      var s = t(this, r, o.bottom),
        a = !1,
        l = this;

      function c(t) {
        if ("string" == typeof t) h.value = t;
        else {
          if (a) return;
          a = !0, e.rmClass(s.parentNode, "dialog-opened"), s.parentNode.removeChild(s), l.focus(), o.onClose && o.onClose(s)
        }
      }
      var u, h = s.getElementsByTagName("input")[0];
      return h ? (h.focus(), o.value && (h.value = o.value, !1 !== o.selectValueOnOpen && h.select()), o.onInput && e.on(h, "input", (function (e) {
        o.onInput(e, h.value, c)
      })), o.onKeyUp && e.on(h, "keyup", (function (e) {
        o.onKeyUp(e, h.value, c)
      })), e.on(h, "keydown", (function (t) {
        o && o.onKeyDown && o.onKeyDown(t, h.value, c) || ((27 == t.keyCode || !1 !== o.closeOnEnter && 13 == t.keyCode) && (h.blur(), e.e_stop(t), c()), 13 == t.keyCode && i(h.value, t))
      })), !1 !== o.closeOnBlur && e.on(h, "blur", c)) : (u = s.getElementsByTagName("button")[0]) && (e.on(u, "click", (function () {
        c(), l.focus()
      })), !1 !== o.closeOnBlur && e.on(u, "blur", c), u.focus()), c
    })), e.defineExtension("openConfirm", (function (r, i, o) {
      n(this, null);
      var s = t(this, r, o && o.bottom),
        a = s.getElementsByTagName("button"),
        l = !1,
        c = this,
        u = 1;

      function h() {
        l || (l = !0, e.rmClass(s.parentNode, "dialog-opened"), s.parentNode.removeChild(s), c.focus())
      }
      a[0].focus();
      for (var p = 0; p < a.length; ++p) {
        var d = a[p];
        ! function (t) {
          e.on(d, "click", (function (n) {
            e.e_preventDefault(n), h(), t && t(c)
          }))
        }(i[p]), e.on(d, "blur", (function () {
          --u, setTimeout((function () {
            u <= 0 && h()
          }), 200)
        })), e.on(d, "focus", (function () {
          ++u
        }))
      }
    })), e.defineExtension("openNotification", (function (r, i) {
      n(this, c);
      var o, s = t(this, r, i && i.bottom),
        a = !1,
        l = i && void 0 !== i.duration ? i.duration : 5e3;

      function c() {
        a || (a = !0, clearTimeout(o), e.rmClass(s.parentNode, "dialog-opened"), s.parentNode.removeChild(s))
      }
      return e.on(s, "click", (function (t) {
        e.e_preventDefault(t), c()
      })), l && (o = setTimeout(c, l)), c
    }))
  }(n(14))
}, function (e, t, n) {
  "use strict";
  var r = n(289);

  function i() {}
  e.exports = function () {
    function e(e, t, n, i, o, s) {
      if (s !== r) {
        var a = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
        throw a.name = "Invariant Violation", a
      }
    }

    function t() {
      return e
    }
    e.isRequired = e;
    var n = {
      array: e,
      bool: e,
      func: e,
      number: e,
      object: e,
      string: e,
      symbol: e,
      any: e,
      arrayOf: t,
      element: e,
      instanceOf: t,
      node: e,
      objectOf: t,
      oneOf: t,
      oneOfType: t,
      shape: t,
      exact: t
    };
    return n.checkPropTypes = i, n.PropTypes = n, n
  }
}, function (e, t, n) {
  "use strict";
  e.exports = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED"
}, function (e, t) {
  e.exports = function () {
    for (var e = arguments.length, t = [], n = 0; n < e; n++) t[n] = arguments[n];
    if (0 !== (t = t.filter((function (e) {
        return null != e
      }))).length) return 1 === t.length ? t[0] : t.reduce((function (e, t) {
      return function () {
        e.apply(this, arguments), t.apply(this, arguments)
      }
    }))
  }
}, function (e, t, n) {
  "use strict";
  e.exports = function () {}
}, function (e, t, n) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  var r, i, o = Object.assign || function (e) {
      for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t];
        for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
      }
      return e
    },
    s = f(n(293)),
    a = f(n(295)),
    l = f(n(119)),
    c = n(296),
    u = f(n(0)),
    h = f(n(80)),
    p = n(18),
    d = n(120);

  function f(e) {
    return e && e.__esModule ? e : {
      default: e
    }
  }

  function m(e, t) {
    for (var n = Object.getOwnPropertyNames(t), r = 0; r < n.length; r++) {
      var i = n[r],
        o = Object.getOwnPropertyDescriptor(t, i);
      o && o.configurable && void 0 === e[i] && Object.defineProperty(e, i, o)
    }
    return e
  }

  function g(e, t) {
    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
  }

  function y(e, t) {
    if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return !t || "object" != typeof t && "function" != typeof t ? e : t
  }
  var v = [];
  c.transitionEnd && v.push(c.transitionEnd), c.animationEnd && v.push(c.animationEnd);
  h.default.node, d.nameShape.isRequired, h.default.bool, h.default.bool, h.default.bool, h.default.number, h.default.number, h.default.number;
  var w = (i = r = function (e) {
    function t() {
      var n, r;
      g(this, t);
      for (var i = arguments.length, o = Array(i), s = 0; s < i; s++) o[s] = arguments[s];
      return n = r = y(this, e.call.apply(e, [this].concat(o))), r.componentWillAppear = function (e) {
        r.props.appear ? r.transition("appear", e, r.props.appearTimeout) : e()
      }, r.componentWillEnter = function (e) {
        r.props.enter ? r.transition("enter", e, r.props.enterTimeout) : e()
      }, r.componentWillLeave = function (e) {
        r.props.leave ? r.transition("leave", e, r.props.leaveTimeout) : e()
      }, y(r, n)
    }
    return function (e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
      e.prototype = Object.create(t && t.prototype, {
        constructor: {
          value: e,
          enumerable: !1,
          writable: !0,
          configurable: !0
        }
      }), t && (Object.setPrototypeOf, m(e, t))
    }(t, e), t.prototype.componentWillMount = function () {
      this.classNameAndNodeQueue = [], this.transitionTimeouts = []
    }, t.prototype.componentWillUnmount = function () {
      this.unmounted = !0, this.timeout && clearTimeout(this.timeout), this.transitionTimeouts.forEach((function (e) {
        clearTimeout(e)
      })), this.classNameAndNodeQueue.length = 0
    }, t.prototype.transition = function (e, t, n) {
      var r = (0, p.findDOMNode)(this);
      if (r) {
        var i = this.props.name[e] || this.props.name + "-" + e,
          o = this.props.name[e + "Active"] || i + "-active",
          l = null,
          u = void 0;
        (0, s.default)(r, i), this.queueClassAndNode(o, r);
        var h = function (e) {
          e && e.target !== r || (clearTimeout(l), u && u(), (0, a.default)(r, i), (0, a.default)(r, o), u && u(), t && t())
        };
        n ? (l = setTimeout(h, n), this.transitionTimeouts.push(l)) : c.transitionEnd && (u = function (e, t) {
          return v.length ? v.forEach((function (n) {
              return e.addEventListener(n, t, !1)
            })) : setTimeout(t, 0),
            function () {
              v.length && v.forEach((function (n) {
                return e.removeEventListener(n, t, !1)
              }))
            }
        }(r, h))
      } else t && t()
    }, t.prototype.queueClassAndNode = function (e, t) {
      var n = this;
      this.classNameAndNodeQueue.push({
        className: e,
        node: t
      }), this.rafHandle || (this.rafHandle = (0, l.default)((function () {
        return n.flushClassNameAndNodeQueueOnNextFrame()
      })))
    }, t.prototype.flushClassNameAndNodeQueueOnNextFrame = function () {
      var e = this;
      this.rafHandle = (0, l.default)((function () {
        return e.flushClassNameAndNodeQueue()
      }))
    }, t.prototype.flushClassNameAndNodeQueue = function () {
      this.unmounted || this.classNameAndNodeQueue.forEach((function (e) {
        e.node.scrollTop, (0, s.default)(e.node, e.className)
      })), this.classNameAndNodeQueue.length = 0, this.rafHandle = null
    }, t.prototype.render = function () {
      var e = o({}, this.props);
      return delete e.name, delete e.appear, delete e.enter, delete e.leave, delete e.appearTimeout, delete e.enterTimeout, delete e.leaveTimeout, delete e.children, u.default.cloneElement(u.default.Children.only(this.props.children), e)
    }, t
  }(u.default.Component), r.displayName = "CSSTransitionGroupChild", i);
  t.default = w, e.exports = t.default
}, function (e, t, n) {
  "use strict";
  var r = n(50);
  t.__esModule = !0, t.default = function (e, t) {
    e.classList ? e.classList.add(t) : (0, i.default)(e, t) || ("string" == typeof e.className ? e.className = e.className + " " + t : e.setAttribute("class", (e.className && e.className.baseVal || "") + " " + t))
  };
  var i = r(n(294));
  e.exports = t.default
}, function (e, t, n) {
  "use strict";
  t.__esModule = !0, t.default = function (e, t) {
    return e.classList ? !!t && e.classList.contains(t) : -1 !== (" " + (e.className.baseVal || e.className) + " ").indexOf(" " + t + " ")
  }, e.exports = t.default
}, function (e, t, n) {
  "use strict";

  function r(e, t) {
    return e.replace(new RegExp("(^|\\s)" + t + "(?:\\s|$)", "g"), "$1").replace(/\s+/g, " ").replace(/^\s*|\s*$/g, "")
  }
  e.exports = function (e, t) {
    e.classList ? e.classList.remove(t) : "string" == typeof e.className ? e.className = r(e.className, t) : e.setAttribute("class", r(e.className && e.className.baseVal || "", t))
  }
}, function (e, t, n) {
  "use strict";
  var r = n(50);
  t.__esModule = !0, t.default = t.animationEnd = t.animationDelay = t.animationTiming = t.animationDuration = t.animationName = t.transitionEnd = t.transitionDuration = t.transitionDelay = t.transitionTiming = t.transitionProperty = t.transform = void 0;
  var i, o, s, a, l, c, u, h, p, d, f, m = r(n(78)),
    g = "transform";
  if (t.transform = g, t.animationEnd = s, t.transitionEnd = o, t.transitionDelay = u, t.transitionTiming = c, t.transitionDuration = l, t.transitionProperty = a, t.animationDelay = f, t.animationTiming = d, t.animationDuration = p, t.animationName = h, m.default) {
    var y = function () {
      for (var e, t, n = document.createElement("div").style, r = {
          O: function (e) {
            return "o" + e.toLowerCase()
          },
          Moz: function (e) {
            return e.toLowerCase()
          },
          Webkit: function (e) {
            return "webkit" + e
          },
          ms: function (e) {
            return "MS" + e
          }
        }, i = Object.keys(r), o = "", s = 0; s < i.length; s++) {
        var a = i[s];
        if (a + "TransitionProperty" in n) {
          o = "-" + a.toLowerCase(), e = r[a]("TransitionEnd"), t = r[a]("AnimationEnd");
          break
        }
      }!e && "transitionProperty" in n && (e = "transitionend");
      !t && "animationName" in n && (t = "animationend");
      return n = null, {
        animationEnd: t,
        transitionEnd: e,
        prefix: o
      }
    }();
    i = y.prefix, t.transitionEnd = o = y.transitionEnd, t.animationEnd = s = y.animationEnd, t.transform = g = i + "-" + g, t.transitionProperty = a = i + "-transition-property", t.transitionDuration = l = i + "-transition-duration", t.transitionDelay = u = i + "-transition-delay", t.transitionTiming = c = i + "-transition-timing-function", t.animationName = h = i + "-animation-name", t.animationDuration = p = i + "-animation-duration", t.animationTiming = d = i + "-animation-delay", t.animationDelay = f = i + "-animation-timing-function"
  }
  var v = {
    transform: g,
    end: o,
    property: a,
    timing: c,
    delay: u,
    duration: l
  };
  t.default = v
}, function (e, t, n) {
  (function (e) {
    const t = n(1).join(__dirname, "fs_admin.node");
    try {
      global.process.dlopen(e, t)
    } catch (e) {
      throw new Error("Cannot open " + t + ": " + e)
    }
  }).call(this, n(42)(e))
}, function (e, t, n) {
  e.exports = n.p + "fff110f06938764612a1a3588659e22e.cmd"
}, function (e, t, n) {
  "use strict";
  const r = (e, ...t) => new Promise(n => {
    n(e(...t))
  });
  e.exports = r, e.exports.default = r
}, function (e, t, n) {
  ! function () {
    "use strict";
    var e = function (e) {
      return new t(e)
    };

    function t(e) {
      if (!e || 1 !== e.nodeType) throw new Error("A DOM Element reference is required");
      this.el = e, this.classList = e.classList
    }

    function n(e, t) {
      if (t = t || "a method", "string" != typeof e) throw new TypeError("Failed to execute '" + t + "' on 'ClassList': the token provided ('" + e + "') is not a string.");
      if ("" === e) throw new SyntaxError("Failed to execute '" + t + "' on 'ClassList': the token provided must not be empty.");
      if (/\s/.test(e)) throw new Error("Failed to execute '" + t + "' on 'ClassList': the token provided ('" + e + "') contains HTML space characters, which are not valid in tokens.")
    }
    t.prototype.toArray = function () {
      var e = (this.el.getAttribute("class") || "").replace(/^\s+|\s+$/g, "").split(/\s+/);
      return "" === e[0] && e.shift(), e
    }, t.prototype.add = function (e) {
      var t;
      n(e, "add"), this.classList ? this.classList.add(e) : -1 === (t = this.toArray()).indexOf(e) && (t.push(e), this.el.setAttribute("class", t.join(" ")))
    }, t.prototype.contains = function (e) {
      return n(e, "contains"), this.classList ? this.classList.contains(e) : this.toArray().indexOf(e) > -1
    }, t.prototype.remove = function (e) {
      var t, r, i, o, s;
      if ("[object RegExp]" == Object.prototype.toString.call(e))
        for (i = 0, s = (t = this.toArray()).length; i < s; i++) e.test(t[i]) && this.remove(t[i]);
      else n(e, "remove"), this.classList ? this.classList.remove(e) : (o = (r = this.toArray()).indexOf(e)) > -1 && (r.splice(o, 1), this.el.setAttribute("class", r.join(" ")))
    }, t.prototype.toggle = function (e, t) {
      n(e, "toggle");
      var r = this.contains(e),
        i = r ? !0 !== t && "remove" : !1 !== t && "add";
      return i && this[i](e), "boolean" == typeof t ? t : !r
    };
    var r = function (e, t) {
      var n = window.Element.prototype,
        r = n.matches || n.mozMatchesSelector || n.msMatchesSelector || n.oMatchesSelector || n.webkitMatchesSelector;
      if (!e || 1 !== e.nodeType) return !1;
      var i = e.parentNode;
      if (r) return r.call(e, t);
      for (var o = i.querySelectorAll(t), s = o.length, a = 0; a < s; a++)
        if (o[a] === e) return !0;
      return !1
    };
    document.addEventListener("DOMContentLoaded", (function () {
      var t = !1,
        n = 0,
        i = ["input:not([type])", "input[type=text]", "input[type=search]", "input[type=url]", "input[type=tel]", "input[type=email]", "input[type=password]", "input[type=number]", "input[type=date]", "input[type=month]", "input[type=week]", "input[type=time]", "input[type=datetime]", "input[type=datetime-local]", "textarea", "[role=textbox]"].join(",");

      function o(t) {
        e(t).contains("focus-ring") || (e(t).add("focus-ring"), t.setAttribute("data-focus-ring-added", ""))
      }
      document.body.addEventListener("keydown", (function () {
        t = !0, r(document.activeElement, ":focus") && o(document.activeElement), 0 !== n && clearTimeout(n), n = setTimeout((function () {
          t = !1, n = 0
        }), 100)
      }), !0), document.body.addEventListener("focus", (function (e) {
        var n;
        (t || (n = e.target, r(n, i) && r(n, ":not([readonly])"))) && o(e.target)
      }), !0), document.body.addEventListener("blur", (function (t) {
        var n;
        (n = t.target).hasAttribute("data-focus-ring-added") && (e(n).remove("focus-ring"), n.removeAttribute("data-focus-ring-added"))
      }), !0)
    }))
  }()
}, function (e, t, n) {}, , , , , , , function (e, t, n) {
  "use strict";
  n.r(t);
  var r = n(4),
    i = n(1),
    o = n(7),
    s = n(121),
    a = n.n(s),
    l = n(122),
    c = n.n(l);
  const u = ["renderer.js", "main.js"];

  function h(e) {
    if (!u.some(t => e.endsWith(t))) return null;
    e.startsWith("file://") && (e = a()(e));
    const t = e + ".map";
    if (!o.existsSync(t)) return null;
    try {
      const e = o.readFileSync(t, "utf8");
      return {
        url: i.basename(t),
        map: e
      }
    } catch (e) {
      return null
    }
  }
  const p = new WeakMap;
  let d;

  function f(e, t) {
    return p.set(e, t), e + t.map(e => "\n    at " + e).join("")
  }

  function m(e) {
    return {
      name: e.name,
      message: e.message,
      stack: g(e)
    }
  }

  function g(e) {
    let t = p.get(e);
    return t || ((e.stack || "").toString(), t = p.get(e)), t ? d(e, t) : e.stack
  }

  function y(e, t) {
    return t ? function (e, t) {
      return (e = m(e)).stack ? t ? `${t}\n${e.stack}` : e.stack.trim() : t ? `${t}\n${e.name}: ${e.message}` : `${e.name}: ${e.message}`
    }(t, e) : e
  }

  function v(e, t, n) {
    r.ipcRenderer.send("log", e, y("[ui] " + t, n))
  }
  global.log = {
    error(e, t) {
      v("error", e, t), console.error(y(e, t))
    },
    warn(e, t) {
      v("warn", e, t), console.warn(y(e, t))
    },
    info(e, t) {
      v("info", e, t), console.info(y(e, t))
    },
    debug(e, t) {
      v("debug", e, t), console.debug(y(e, t))
    }
  };
  var w = n(0),
    b = n.n(w),
    S = n(18),
    C = n.n(S),
    E = n(12),
    k = n.n(E);

  function x(e, t) {
    if (null == e) return {};
    var n, r, i = {},
      o = Object.keys(e);
    for (r = 0; r < o.length; r++) n = o[r], t.indexOf(n) >= 0 || (i[n] = e[n]);
    return i
  }

  function T() {
    return (T = Object.assign || function (e) {
      for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t];
        for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
      }
      return e
    }).apply(this, arguments)
  }

  function R(e, t) {
    e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e.__proto__ = t
  }
  n(63);
  var D = b.a.createContext(null);

  function _(e, t) {
    var n = Object.create(null);
    return e && w.Children.map(e, (function (e) {
      return e
    })).forEach((function (e) {
      n[e.key] = function (e) {
        return t && Object(w.isValidElement)(e) ? t(e) : e
      }(e)
    })), n
  }

  function A(e, t, n) {
    return null != n[t] ? n[t] : e.props[t]
  }

  function M(e, t, n) {
    var r = _(e.children),
      i = function (e, t) {
        function n(n) {
          return n in t ? t[n] : e[n]
        }
        e = e || {}, t = t || {};
        var r, i = Object.create(null),
          o = [];
        for (var s in e) s in t ? o.length && (i[s] = o, o = []) : o.push(s);
        var a = {};
        for (var l in t) {
          if (i[l])
            for (r = 0; r < i[l].length; r++) {
              var c = i[l][r];
              a[i[l][r]] = n(c)
            }
          a[l] = n(l)
        }
        for (r = 0; r < o.length; r++) a[o[r]] = n(o[r]);
        return a
      }(t, r);
    return Object.keys(i).forEach((function (o) {
      var s = i[o];
      if (Object(w.isValidElement)(s)) {
        var a = o in t,
          l = o in r,
          c = t[o],
          u = Object(w.isValidElement)(c) && !c.props.in;
        !l || a && !u ? l || !a || u ? l && a && Object(w.isValidElement)(c) && (i[o] = Object(w.cloneElement)(s, {
          onExited: n.bind(null, s),
          in: c.props.in,
          exit: A(s, "exit", e),
          enter: A(s, "enter", e)
        })) : i[o] = Object(w.cloneElement)(s, {
          in: !1
        }) : i[o] = Object(w.cloneElement)(s, {
          onExited: n.bind(null, s),
          in: !0,
          exit: A(s, "exit", e),
          enter: A(s, "enter", e)
        })
      }
    })), i
  }
  var P = Object.values || function (e) {
      return Object.keys(e).map((function (t) {
        return e[t]
      }))
    },
    I = function (e) {
      function t(t, n) {
        var r, i = (r = e.call(this, t, n) || this).handleExited.bind(function (e) {
          if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return e
        }(r));
        return r.state = {
          contextValue: {
            isMounting: !0
          },
          handleExited: i,
          firstRender: !0
        }, r
      }
      R(t, e);
      var n = t.prototype;
      return n.componentDidMount = function () {
        this.mounted = !0, this.setState({
          contextValue: {
            isMounting: !1
          }
        })
      }, n.componentWillUnmount = function () {
        this.mounted = !1
      }, t.getDerivedStateFromProps = function (e, t) {
        var n, r, i = t.children,
          o = t.handleExited;
        return {
          children: t.firstRender ? (n = e, r = o, _(n.children, (function (e) {
            return Object(w.cloneElement)(e, {
              onExited: r.bind(null, e),
              in: !0,
              appear: A(e, "appear", n),
              enter: A(e, "enter", n),
              exit: A(e, "exit", n)
            })
          }))) : M(e, i, o),
          firstRender: !1
        }
      }, n.handleExited = function (e, t) {
        var n = _(this.props.children);
        e.key in n || (e.props.onExited && e.props.onExited(t), this.mounted && this.setState((function (t) {
          var n = T({}, t.children);
          return delete n[e.key], {
            children: n
          }
        })))
      }, n.render = function () {
        var e = this.props,
          t = e.component,
          n = e.childFactory,
          r = x(e, ["component", "childFactory"]),
          i = this.state.contextValue,
          o = P(this.state.children).map(n);
        return delete r.appear, delete r.enter, delete r.exit, null === t ? b.a.createElement(D.Provider, {
          value: i
        }, o) : b.a.createElement(D.Provider, {
          value: i
        }, b.a.createElement(t, r, o))
      }, t
    }(b.a.Component);
  I.propTypes = {}, I.defaultProps = {
    component: "div",
    childFactory: function (e) {
      return e
    }
  };
  var O = I;

  function L(e, t) {
    return e.replace(new RegExp("(^|\\s)" + t + "(?:\\s|$)", "g"), "$1").replace(/\s+/g, " ").replace(/^\s*|\s*$/g, "")
  }
  var N = !1,
    F = function (e) {
      function t(t, n) {
        var r;
        r = e.call(this, t, n) || this;
        var i, o = n && !n.isMounting ? t.enter : t.appear;
        return r.appearStatus = null, t.in ? o ? (i = "exited", r.appearStatus = "entering") : i = "entered" : i = t.unmountOnExit || t.mountOnEnter ? "unmounted" : "exited", r.state = {
          status: i
        }, r.nextCallback = null, r
      }
      R(t, e), t.getDerivedStateFromProps = function (e, t) {
        return e.in && "unmounted" === t.status ? {
          status: "exited"
        } : null
      };
      var n = t.prototype;
      return n.componentDidMount = function () {
        this.updateStatus(!0, this.appearStatus)
      }, n.componentDidUpdate = function (e) {
        var t = null;
        if (e !== this.props) {
          var n = this.state.status;
          this.props.in ? "entering" !== n && "entered" !== n && (t = "entering") : "entering" !== n && "entered" !== n || (t = "exiting")
        }
        this.updateStatus(!1, t)
      }, n.componentWillUnmount = function () {
        this.cancelNextCallback()
      }, n.getTimeouts = function () {
        var e, t, n, r = this.props.timeout;
        return e = t = n = r, null != r && "number" != typeof r && (e = r.exit, t = r.enter, n = void 0 !== r.appear ? r.appear : t), {
          exit: e,
          enter: t,
          appear: n
        }
      }, n.updateStatus = function (e, t) {
        void 0 === e && (e = !1), null !== t ? (this.cancelNextCallback(), "entering" === t ? this.performEnter(e) : this.performExit()) : this.props.unmountOnExit && "exited" === this.state.status && this.setState({
          status: "unmounted"
        })
      }, n.performEnter = function (e) {
        var t = this,
          n = this.props.enter,
          r = this.context ? this.context.isMounting : e,
          i = this.props.nodeRef ? [r] : [C.a.findDOMNode(this), r],
          o = i[0],
          s = i[1],
          a = this.getTimeouts(),
          l = r ? a.appear : a.enter;
        !e && !n || N ? this.safeSetState({
          status: "entered"
        }, (function () {
          t.props.onEntered(o)
        })) : (this.props.onEnter(o, s), this.safeSetState({
          status: "entering"
        }, (function () {
          t.props.onEntering(o, s), t.onTransitionEnd(l, (function () {
            t.safeSetState({
              status: "entered"
            }, (function () {
              t.props.onEntered(o, s)
            }))
          }))
        })))
      }, n.performExit = function () {
        var e = this,
          t = this.props.exit,
          n = this.getTimeouts(),
          r = this.props.nodeRef ? void 0 : C.a.findDOMNode(this);
        t && !N ? (this.props.onExit(r), this.safeSetState({
          status: "exiting"
        }, (function () {
          e.props.onExiting(r), e.onTransitionEnd(n.exit, (function () {
            e.safeSetState({
              status: "exited"
            }, (function () {
              e.props.onExited(r)
            }))
          }))
        }))) : this.safeSetState({
          status: "exited"
        }, (function () {
          e.props.onExited(r)
        }))
      }, n.cancelNextCallback = function () {
        null !== this.nextCallback && (this.nextCallback.cancel(), this.nextCallback = null)
      }, n.safeSetState = function (e, t) {
        t = this.setNextCallback(t), this.setState(e, t)
      }, n.setNextCallback = function (e) {
        var t = this,
          n = !0;
        return this.nextCallback = function (r) {
          n && (n = !1, t.nextCallback = null, e(r))
        }, this.nextCallback.cancel = function () {
          n = !1
        }, this.nextCallback
      }, n.onTransitionEnd = function (e, t) {
        this.setNextCallback(t);
        var n = this.props.nodeRef ? this.props.nodeRef.current : C.a.findDOMNode(this),
          r = null == e && !this.props.addEndListener;
        if (n && !r) {
          if (this.props.addEndListener) {
            var i = this.props.nodeRef ? [this.nextCallback] : [n, this.nextCallback],
              o = i[0],
              s = i[1];
            this.props.addEndListener(o, s)
          }
          null != e && setTimeout(this.nextCallback, e)
        } else setTimeout(this.nextCallback, 0)
      }, n.render = function () {
        var e = this.state.status;
        if ("unmounted" === e) return null;
        var t = this.props,
          n = t.children,
          r = (t.in, t.mountOnEnter, t.unmountOnExit, t.appear, t.enter, t.exit, t.timeout, t.addEndListener, t.onEnter, t.onEntering, t.onEntered, t.onExit, t.onExiting, t.onExited, t.nodeRef, x(t, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]));
        return b.a.createElement(D.Provider, {
          value: null
        }, "function" == typeof n ? n(e, r) : b.a.cloneElement(b.a.Children.only(n), r))
      }, t
    }(b.a.Component);

  function B() {}
  F.contextType = D, F.propTypes = {}, F.defaultProps = {
    in: !1,
    mountOnEnter: !1,
    unmountOnExit: !1,
    appear: !1,
    enter: !0,
    exit: !0,
    onEnter: B,
    onEntering: B,
    onEntered: B,
    onExit: B,
    onExiting: B,
    onExited: B
  }, F.UNMOUNTED = "unmounted", F.EXITED = "exited", F.ENTERING = "entering", F.ENTERED = "entered", F.EXITING = "exiting";
  var H = F,
    z = function (e, t) {
      return e && t && t.split(" ").forEach((function (t) {
        return r = t, void((n = e).classList ? n.classList.remove(r) : "string" == typeof n.className ? n.className = L(n.className, r) : n.setAttribute("class", L(n.className && n.className.baseVal || "", r)));
        var n, r
      }))
    },
    U = function (e) {
      function t() {
        for (var t, n = arguments.length, r = new Array(n), i = 0; i < n; i++) r[i] = arguments[i];
        return (t = e.call.apply(e, [this].concat(r)) || this).appliedClasses = {
          appear: {},
          enter: {},
          exit: {}
        }, t.onEnter = function (e, n) {
          var r = t.resolveArguments(e, n),
            i = r[0],
            o = r[1];
          t.removeClasses(i, "exit"), t.addClass(i, o ? "appear" : "enter", "base"), t.props.onEnter && t.props.onEnter(e, n)
        }, t.onEntering = function (e, n) {
          var r = t.resolveArguments(e, n),
            i = r[0],
            o = r[1] ? "appear" : "enter";
          t.addClass(i, o, "active"), t.props.onEntering && t.props.onEntering(e, n)
        }, t.onEntered = function (e, n) {
          var r = t.resolveArguments(e, n),
            i = r[0],
            o = r[1] ? "appear" : "enter";
          t.removeClasses(i, o), t.addClass(i, o, "done"), t.props.onEntered && t.props.onEntered(e, n)
        }, t.onExit = function (e) {
          var n = t.resolveArguments(e)[0];
          t.removeClasses(n, "appear"), t.removeClasses(n, "enter"), t.addClass(n, "exit", "base"), t.props.onExit && t.props.onExit(e)
        }, t.onExiting = function (e) {
          var n = t.resolveArguments(e)[0];
          t.addClass(n, "exit", "active"), t.props.onExiting && t.props.onExiting(e)
        }, t.onExited = function (e) {
          var n = t.resolveArguments(e)[0];
          t.removeClasses(n, "exit"), t.addClass(n, "exit", "done"), t.props.onExited && t.props.onExited(e)
        }, t.resolveArguments = function (e, n) {
          return t.props.nodeRef ? [t.props.nodeRef.current, e] : [e, n]
        }, t.getClassNames = function (e) {
          var n = t.props.classNames,
            r = "string" == typeof n,
            i = r ? "" + (r && n ? n + "-" : "") + e : n[e];
          return {
            baseClassName: i,
            activeClassName: r ? i + "-active" : n[e + "Active"],
            doneClassName: r ? i + "-done" : n[e + "Done"]
          }
        }, t
      }
      R(t, e);
      var n = t.prototype;
      return n.addClass = function (e, t, n) {
        var r = this.getClassNames(t)[n + "ClassName"],
          i = this.getClassNames("enter").doneClassName;
        "appear" === t && "done" === n && i && (r += " " + i), "active" === n && e && e.scrollTop, r && (this.appliedClasses[t][n] = r, function (e, t) {
          e && t && t.split(" ").forEach((function (t) {
            return r = t, void((n = e).classList ? n.classList.add(r) : function (e, t) {
              return e.classList ? !!t && e.classList.contains(t) : -1 !== (" " + (e.className.baseVal || e.className) + " ").indexOf(" " + t + " ")
            }(n, r) || ("string" == typeof n.className ? n.className = n.className + " " + r : n.setAttribute("class", (n.className && n.className.baseVal || "") + " " + r)));
            var n, r
          }))
        }(e, r))
      }, n.removeClasses = function (e, t) {
        var n = this.appliedClasses[t],
          r = n.base,
          i = n.active,
          o = n.done;
        this.appliedClasses[t] = {}, r && z(e, r), i && z(e, i), o && z(e, o)
      }, n.render = function () {
        var e = this.props,
          t = (e.classNames, x(e, ["classNames"]));
        return b.a.createElement(H, T({}, t, {
          onEnter: this.onEnter,
          onEntered: this.onEntered,
          onEntering: this.onEntering,
          onExit: this.onExit,
          onExiting: this.onExiting,
          onExited: this.onExited
        }))
      }, t
    }(b.a.Component);
  U.defaultProps = {
    classNames: ""
  }, U.propTypes = {};
  var W, V, j, G, $, q, K = U;

  function Y(e) {
    return "merge" === e.kind
  }

  function Q(e) {
    return "rebase" === e.kind
  }

  function Z(e) {
    throw new Error(e)
  }

  function X(e, t) {
    throw new Error(t)
  }

  function J(e, t) {
    return null == t ? Z(e) : t
  }! function (e) {
    e[e.Repository = 0] = "Repository", e[e.CloningRepository = 1] = "CloningRepository", e[e.MissingRepository = 2] = "MissingRepository"
  }(W || (W = {})),
  function (e) {
    e[e.Repository = 0] = "Repository", e[e.Branch = 1] = "Branch", e[e.AppMenu = 2] = "AppMenu", e[e.AddMenu = 3] = "AddMenu"
  }(V || (V = {})),
  function (e) {
    e[e.Changes = 0] = "Changes", e[e.History = 1] = "History"
  }(j || (j = {})),
  function (e) {
    e.WorkingDirectory = "WorkingDirectory", e.Stash = "Stash"
  }(G || (G = {})),
  function (e) {
    e.History = "History", e.Compare = "Compare"
  }($ || ($ = {})),
  function (e) {
    e.Ahead = "Ahead", e.Behind = "Behind"
  }(q || (q = {}));
  const ee = {
    moveItemToTrash: r.shell.moveItemToTrash,
    beep: r.shell.beep,
    openExternal: e => new Promise((t, n) => {
      r.ipcRenderer.once("open-external-result", (e, {
        result: n
      }) => {
        t(n)
      }), r.ipcRenderer.send("open-external", {
        path: e
      })
    }),
    showItemInFolder: e => {
      r.ipcRenderer.send("show-item-in-folder", {
        path: e
      })
    },
    showFolderContents: e => {
      r.ipcRenderer.send("show-folder-contents", {
        path: e
      })
    },
    openPath: r.shell.openPath
  };

  function te(e, t) {
    const n = i.join(e.path, t);
    return ee.showItemInFolder(n)
  }
  var ne = n(11);

  function re(e) {
    r.ipcRenderer.send("execute-menu-item", {
      id: e
    })
  }
  async function ie(e) {
    const t = await r.ipcRenderer.invoke("show-contextual-menu", function e(t) {
      return t.map(t => Object.assign(Object.assign({}, t), {
        action: void 0,
        submenu: t.submenu ? e(t.submenu) : void 0
      }))
    }(e));
    if (null !== t) {
      const n = function (e, t) {
        let n = {
          submenu: e
        };
        for (const e of t) {
          if (void 0 === n || void 0 === n.submenu) return;
          n = n.submenu[e]
        }
        return n
      }(e, t);
      void 0 !== n && void 0 !== n.action && n.action()
    }
  }

  function oe(e) {
    r.ipcRenderer.send("update-preferred-app-menu-item-labels", e)
  }

  function se(e) {
    return {
      message: e.message || "" + e,
      name: e.name || "" + e.name,
      stack: e.stack || void 0
    }
  }
  class ae extends Error {
    constructor(e, t) {
      super(e.message), this.name = e.name, this.stack = e.stack, this.underlyingError = e, this.metadata = t
    }
  }
  const le = /^Can not find Squirrel$/,
    ce = /System\.Net\.WebException: The remote name could not be resolved: 'central\.github\.com'/,
    ue = /A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond/;
  const he = /^\[([a-z]{1,})\]\s(.*)/i;

  function pe(e) {
    return null != e
  }

  function de(e) {
    return e.map(e => function (e) {
      const t = e.trim(),
        n = he.exec(t);
      if (null === n) return log.debug("[ReleaseNotes] unable to convert text into entry: " + e), null;
      const r = n[1].toLowerCase(),
        i = n[2];
      return "new" === r || "fixed" === r || "improved" === r || "added" === r || "pretext" === r || "removed" === r ? {
        kind: r,
        message: i
      } : (log.debug(`[ReleaseNotes] kind ${r} was found but is not a valid entry`), {
        kind: "other",
        message: i
      })
    }(e)).filter(pe)
  }
  async function fe() {
    return function (e) {
      const t = de(e.notes),
        n = t.filter(e => "new" === e.kind || "added" === e.kind || "improved" === e.kind),
        r = t.filter(e => "fixed" === e.kind),
        i = t.filter(e => "removed" === e.kind || "other" === e.kind),
        o = k()(e.pub_date).format("MMMM Do YYYY");
      return {
        latestVersion: e.version,
        datePublished: o,
        pretext: void 0,
        enhancements: n,
        bugfixes: r,
        other: i
      }
    }((await async function () {
      const e = await fetch("https://central.github.com/deployments/desktop/desktop/changelog.json");
      if (e.ok) {
        return await e.json()
      }
      return []
    }())[0])
  }

  function me(e, t) {
    const n = localStorage.getItem(e);
    return null === n ? t : "1" === n || "true" === n || "0" !== n && "false" !== n && t
  }

  function ge(e, t) {
    localStorage.setItem(e, t ? "1" : "0")
  }

  function ye(e, t) {
    const n = localStorage.getItem(e);
    if (null === n || 0 === n.length) return t;
    const r = parseInt(n, 10);
    return isNaN(r) ? t : r
  }

  function ve(e, t) {
    localStorage.setItem(e, t.toString())
  }

  function we(e) {
    return (localStorage.getItem(e) || "").split(Se).map(parseFloat).filter(e => !isNaN(e))
  }

  function be(e, t) {
    localStorage.setItem(e, t.join(Se))
  }
  const Se = ",",
    Ce = r.remote.autoUpdater;
  var Ee;
  ! function (e) {
    e[e.CheckingForUpdates = 0] = "CheckingForUpdates", e[e.UpdateAvailable = 1] = "UpdateAvailable", e[e.UpdateNotAvailable = 2] = "UpdateNotAvailable", e[e.UpdateReady = 3] = "UpdateReady"
  }(Ee || (Ee = {}));
  const ke = new class {
    constructor() {
      this.emitter = new ne.Emitter, this.status = Ee.UpdateNotAvailable, this.lastSuccessfulCheck = null, this.newRelease = null, this.userInitiatedUpdate = !0, this.onAutoUpdaterError = e => {
        this.status = Ee.UpdateNotAvailable; {
          const t = function (e) {
            return le.test(e.message) ? new Error("The application is missing a dependency it needs to check and install updates. This is very, very bad.") : ce.test(e.message) ? new Error("GitHub Desktop was not able to contact the update server. Ensure you have internet connectivity and try again.") : ue.test(e.message) ? new Error("GitHub Desktop was not able to check for updates due to a timeout. Ensure you have internet connectivity and try again.") : null
          }(e);
          this.emitError(t || e)
        }
      }, this.onCheckingForUpdate = () => {
        this.status = Ee.CheckingForUpdates, this.emitDidChange()
      }, this.onUpdateAvailable = () => {
        this.touchLastChecked(), this.status = Ee.UpdateAvailable, this.emitDidChange()
      }, this.onUpdateNotAvailable = () => {
        this.touchLastChecked(), this.status = Ee.UpdateNotAvailable, this.emitDidChange()
      }, this.onUpdateDownloaded = async () => {
        this.newRelease = await fe(), this.status = Ee.UpdateReady, this.emitDidChange()
      };
      const e = ye("last-successful-update-check", 0);
      e > 0 && (this.lastSuccessfulCheck = new Date(e)), Ce.on("error", this.onAutoUpdaterError), Ce.on("checking-for-update", this.onCheckingForUpdate), Ce.on("update-available", this.onUpdateAvailable), Ce.on("update-not-available", this.onUpdateNotAvailable), Ce.on("update-downloaded", this.onUpdateDownloaded), window.addEventListener("beforeunload", () => {
        Ce.removeListener("error", this.onAutoUpdaterError), Ce.removeListener("checking-for-update", this.onCheckingForUpdate), Ce.removeListener("update-available", this.onUpdateAvailable), Ce.removeListener("update-not-available", this.onUpdateNotAvailable), Ce.removeListener("update-downloaded", this.onUpdateDownloaded)
      })
    }
    touchLastChecked() {
      const e = new Date;
      this.lastSuccessfulCheck = e, ve("last-successful-update-check", e.getTime())
    }
    onDidChange(e) {
      return this.emitter.on("did-change", e)
    }
    emitDidChange() {
      this.emitter.emit("did-change", this.state)
    }
    onError(e) {
      return this.emitter.on("error", e)
    }
    emitError(e) {
      const t = new ae(e, {
        backgroundTask: !this.userInitiatedUpdate
      });
      this.emitter.emit("error", t)
    }
    get state() {
      return {
        status: this.status,
        lastSuccessfulCheck: this.lastSuccessfulCheck,
        newRelease: this.newRelease
      }
    }
    checkForUpdates(e) {
      if (this.status !== Ee.UpdateReady) {
        this.userInitiatedUpdate = !e;
        try {
          Ce.setFeedURL({
            url: "https://central.github.com/api/deployments/desktop/desktop/latest?version=2.5.4&env=production"
          }), Ce.checkForUpdates()
        } catch (e) {
          this.emitError(e)
        }
      }
    }
    quitAndInstallUpdate() {
      r.ipcRenderer.sendSync("will-quit"), Ce.quitAndInstall()
    }
  };
  const xe = function (e, t, n) {
    const r = () => function (e, t) {
      return me("features/" + e, t)
    }(e, t);
    if (n) {
      const e = r();
      return () => e
    }
    return r
  }("should-render-application-menu", !0, !0);
  var Te = n(9),
    Re = n(15);
  class De {
    constructor(e, t, n, r, i, o, s) {
      this.login = e, this.endpoint = t, this.token = n, this.emails = r, this.avatarURL = i, this.id = o, this.name = s
    }
    static anonymous() {
      return new De("", pt(), "", [], "", -1, "")
    }
    withToken(e) {
      return new De(this.login, this.endpoint, e, this.emails, this.avatarURL, this.id, this.name)
    }
  }
  let _e = null,
    Ae = null,
    Me = null,
    Pe = null,
    Ie = null;

  function Oe() {
    return _e || (_e = r.remote.app), _e
  }

  function Le() {
    return Ae || (Ae = Oe().getVersion()), Ae
  }

  function Ne() {
    return Pe || (Pe = Oe().getAppPath()), Pe
  }
  class Fe extends Error {
    constructor(e, t) {
      let n;
      if (t && t.message) {
        n = t.message;
        const e = t.errors,
          r = e && e.map(e => e.message).join(", ");
        r && (n = `${n} (${r})`)
      } else n = `API error ${e.url}: ${e.statusText} (${e.status})`;
      super(n), this.responseStatus = e.status, this.apiError = t
    }
  }
  async function Be(e) {
    try {
      return await e.json()
    } catch (t) {
      const n = e.headers.get("Content-Length") || "(missing)",
        r = e.headers.get("X-GitHub-Request-Id") || "(missing)";
      throw log.warn(`deserialize: invalid JSON found at '${e.url}' - status: ${e.status}, length: '${n}' id: '${r}'`, t), t
    }
  }

  function He(e, t, n, r, i, o) {
    const s = function (e, t) {
      let n = "/" === t[0] ? t.substr(1) : t;
      n.startsWith("api/v3/") && (n = n.substr(7));
      const r = e.endsWith("/") ? e : e + "/";
      return new Te.URL(n, r).toString()
    }(e, r);
    let a = {
      Accept: "application/vnd.github.v3+json, application/json",
      "Content-Type": "application/json",
      "User-Agent": ze()
    };
    t && (a.Authorization = "token " + t), a = Object.assign(Object.assign({}, a), o);
    const l = {
      headers: a,
      method: n,
      body: JSON.stringify(i)
    };
    return fetch(s, l)
  }

  function ze() {
    return `GitHubDesktop/${Le()} (Windows)`
  }
  async function Ue(e) {
    if (e.ok) return Be(e); {
      let t;
      try {
        t = await Be(e)
      } catch (t) {
        throw new Fe(e, null)
      }
      throw new Fe(e, t)
    }
  }

  function We(e, t) {
    const n = Object.keys(t).map(e => `${e}=${encodeURIComponent(t[e])}`).join("&");
    return n.length ? -1 === e.indexOf("?") ? `${e}?${n}` : `${e}&${n}` : e
  }
  var Ve;

  function je(e) {
    return e === Ve.Sms ? "We just sent you a message via SMS with your authentication code. Enter the code in the form below to verify your identity." : "Open the two-factor authentication app on your device to view your authentication code and verify your identity."
  }! function (e) {
    e[e.Sms = 0] = "Sms", e[e.App = 1] = "App"
  }(Ve || (Ve = {}));
  var Ge = n(52),
    $e = n(81),
    qe = n.n($e);

  function Ke(e) {
    if (window.crypto) {
      const t = new Uint8Array(e);
      return crypto.getRandomValues(t), t
    }
    return Object(Ge.randomBytes)(e)
  }

  function Ye() {
    return qe()({
      random: Ke(16)
    })
  }
  var Qe = n(123),
    Ze = n.n(Qe);
  const Xe = process.env.DESKTOP_GITHUB_DOTCOM_API_ENDPOINT,
    Je = "de0e3c7e9973e1c4dd77",
    et = "1273305a5fc2737c2ca2911948ba24a9d961e2a3";
  Je.length && et.length || log.warn("DESKTOP_OAUTH_CLIENT_ID and/or DESKTOP_OAUTH_CLIENT_SECRET is undefined. You won't be able to authenticate new users.");
  const tt = ["repo", "user", "workflow"],
    nt = ["repo", "user"];
  var rt;
  ! function (e) {
    e[e.NotModified = 304] = "NotModified", e[e.NotFound = 404] = "NotFound"
  }(rt || (rt = {}));
  class it extends Error {}

  function ot(e) {
    const t = e.headers.get("Link");
    if (!t) return null;
    for (const e of t.split(",")) {
      const t = e.match(/<([^>]+)>; rel="([^"]+)"/);
      if (t && "next" === t[2]) {
        return Te.parse(t[1]).path || null
      }
    }
    return null
  }

  function st(e) {
    const t = ot(e);
    if (!t) return null;
    const {
      pathname: n,
      query: r
    } = Te.parse(t, !0), {
      per_page: i,
      page: o
    } = r, s = "string" == typeof i ? parseInt(i, 10) : NaN, a = "string" == typeof o ? parseInt(o, 10) : NaN;
    if (!s || !a) return t;
    const l = (a - 1) * s,
      c = Math.min(100, 2 * s);
    return s !== c && l % c == 0 ? (r.per_page = "" + c, r.page = "" + (l / c + 1), Te.format({
      pathname: n,
      query: r
    })) : t
  }
  class at {
    constructor(e, t) {
      this.endpoint = e, this.token = t
    }
    static fromAccount(e) {
      return new at(e.endpoint, e.token)
    }
    async fetchRepository(e, t) {
      try {
        const n = await this.request("GET", `repos/${e}/${t}`);
        return n.status === rt.NotFound ? (log.warn(`fetchRepository: '${e}/${t}' returned a 404`), null) : await Ue(n)
      } catch (n) {
        return log.warn(`fetchRepository: an error occurred for '${e}/${t}'`, n), null
      }
    }
    async fetchRepositories() {
      try {
        return (await this.fetchAll("user/repos")).filter(e => null !== e.owner)
      } catch (e) {
        return log.warn("fetchRepositories: " + e), null
      }
    }
    async fetchAccount() {
      try {
        const e = await this.request("GET", "user");
        return await Ue(e)
      } catch (e) {
        throw log.warn("fetchAccount: failed with endpoint " + this.endpoint, e), e
      }
    }
    async fetchEmails() {
      try {
        const e = await this.request("GET", "user/emails"),
          t = await Ue(e);
        return Array.isArray(t) ? t : []
      } catch (e) {
        return log.warn("fetchEmails: failed with endpoint " + this.endpoint, e), []
      }
    }
    async fetchOrgs() {
      try {
        return await this.fetchAll("user/orgs")
      } catch (e) {
        return log.warn("fetchOrgs: failed with endpoint " + this.endpoint, e), []
      }
    }
    async createRepository(e, t, n, r) {
      try {
        const i = e ? `orgs/${e.login}/repos` : "user/repos",
          o = await this.request("POST", i, {
            name: t,
            description: n,
            private: r
          });
        return await Ue(o)
      } catch (t) {
        if (t instanceof Fe) {
          if (null !== e) throw new Error(`Unable to create repository for organization '${e.login}'. Verify that the repository does not already exist and that you have permission to create a repository there.`);
          throw t
        }
        throw log.error("createRepository: failed with endpoint " + this.endpoint, t), new Error("Unable to publish repository. Please check if you have an internet connection and try again.")
      }
    }
    async forkRepository(e, t) {
      try {
        const n = `/repos/${e}/${t}/forks`,
          r = await this.request("POST", n);
        return await Ue(r)
      } catch (n) {
        throw log.error(`forkRepository: failed to fork ${e}/${t} at endpoint: ${this.endpoint}`, n), n
      }
    }
    async fetchIssues(e, t, n, r) {
      const i = {
        state: n
      };
      r && !isNaN(r.getTime()) && (i.since = r.toISOString().replace(/\.\d{3}Z$/, "Z"));
      const o = We(`repos/${e}/${t}/issues`, i);
      try {
        return (await this.fetchAll(o)).filter(e => !e.pullRequest)
      } catch (n) {
        throw log.warn(`fetchIssues: failed for repository ${e}/${t}`, n), n
      }
    }
    async fetchAllOpenPullRequests(e, t) {
      const n = We(`repos/${e}/${t}/pulls`, {
        state: "open"
      });
      try {
        return await this.fetchAll(n)
      } catch (n) {
        throw log.warn(`failed fetching open PRs for repository ${e}/${t}`, n), n
      }
    }
    async fetchUpdatedPullRequests(e, t, n, r = 320) {
      const i = n.getTime(),
        o = We(`repos/${e}/${t}/pulls`, {
          state: "all",
          sort: "updated",
          direction: "desc"
        });
      try {
        return (await this.fetchAll(o, {
          perPage: 10,
          getNextPagePath: st,
          continue (e) {
            if (e.length >= r) throw new it("got max pull requests, aborting");
            const t = e[e.length - 1];
            return void 0 !== t && Date.parse(t.updated_at) > i
          },
          suppressErrors: !1
        })).filter(e => Date.parse(e.updated_at) >= i)
      } catch (n) {
        throw log.warn(`failed fetching updated PRs for repository ${e}/${t}`, n), n
      }
    }
    async fetchPullRequest(e, t, n) {
      try {
        const r = `/repos/${e}/${t}/pulls/${n}`,
          i = await this.request("GET", r);
        return await Ue(i)
      } catch (r) {
        throw log.warn(`failed fetching PR for ${e}/${t}/pulls/${n}`, r), r
      }
    }
    async fetchCombinedRefStatus(e, t, n) {
      const r = `repos/${e}/${t}/commits/${n}/status`,
        i = await this.request("GET", r);
      return await Ue(i)
    }
    async fetchPushControl(e, t, n) {
      const r = `repos/${e}/${t}/branches/${encodeURIComponent(n)}/push_control`,
        i = {
          Accept: "application/vnd.github.phandalin-preview"
        };
      try {
        const e = await this.request("GET", r, void 0, i);
        return await Ue(e)
      } catch (e) {
        return log.info("[fetchPushControl] unable to check if branch is potentially pushable", e), {
          pattern: null,
          required_signatures: !1,
          required_status_checks: [],
          required_approving_review_count: 0,
          required_linear_history: !1,
          allow_actor: !0,
          allow_deletions: !0,
          allow_force_pushes: !0
        }
      }
    }
    async fetchProtectedBranches(e, t) {
      const n = `repos/${e}/${t}/branches?protected=true`;
      try {
        const e = await this.request("GET", n);
        return await Ue(e)
      } catch (e) {
        return log.info("[fetchProtectedBranches] unable to list protected branches", e), new Array
      }
    }
    async fetchAll(e, t) {
      const n = new Array,
        r = Object.assign({
          perPage: 100
        }, t);
      let i = We(e, {
        per_page: "" + r.perPage
      });
      do {
        const t = await this.request("GET", i);
        if (!1 !== r.suppressErrors && !t.ok) return log.warn(`fetchAll: '${e}' returned a ${t.status}`), n;
        const o = await Ue(t);
        o && n.push(...o), i = r.getNextPagePath ? r.getNextPagePath(t) : ot(t)
      } while (i && (!r.continue || r.continue(n)));
      return n
    }
    request(e, t, n, r) {
      return He(this.endpoint, this.token, e, t, n, r)
    }
    async getFetchPollInterval(e, t) {
      const n = `repos/${e}/${t}/git`;
      try {
        const e = (await this.request("HEAD", n)).headers.get("x-poll-interval");
        if (e) {
          const t = parseInt(e, 10);
          return isNaN(t) ? null : t
        }
        return null
      } catch (n) {
        return log.warn(`getFetchPollInterval: failed for ${e}/${t}`, n), null
      }
    }
    async fetchMentionables(e, t, n) {
      const r = {
        Accept: "application/vnd.github.jerry-maguire-preview"
      };
      void 0 !== n && (r["If-None-Match"] = n);
      try {
        const n = `repos/${e}/${t}/mentionables/users`,
          i = await this.request("GET", n, void 0, r);
        if (i.status === rt.NotFound) return log.warn(`fetchMentionables: '${n}' returned a 404`), null;
        if (i.status === rt.NotModified) return null;
        const o = await Ue(i);
        return {
          users: o,
          etag: i.headers.get("etag") || void 0
        }
      } catch (n) {
        return log.warn(`fetchMentionables: failed for ${e}/${t}`, n), null
      }
    }
    async fetchUser(e) {
      try {
        const t = await this.request("GET", "users/" + encodeURIComponent(e));
        return 404 === t.status ? null : await Ue(t)
      } catch (e) {
        throw log.warn("fetchUser: failed with endpoint " + this.endpoint, e), e
      }
    }
  }
  var lt;
  async function ct(e, t, n, r) {
    const i = "Basic " + Buffer.from(`${t}:${n}`, "utf8").toString("base64"),
      o = r ? {
        "X-GitHub-OTP": r
      } : {},
      s = await async function () {
        let e = "unknown";
        try {
          e = await Ze()()
        } catch (t) {
          log.error(`getNote: unable to resolve machine username, using '${e}' as a fallback`, t)
        }
        return `GitHub Desktop on ${e}@${Re.hostname()}`
      }(), a = await He(e, null, "POST", "authorizations", {
        scopes: ft(e),
        client_id: Je,
        client_secret: et,
        note: s,
        note_url: "https://desktop.github.com/",
        fingerprint: Ye()
      }, Object.assign({
        Authorization: i
      }, o));
    try {
      const e = await Ue(a);
      if (e) {
        const t = e.token;
        if (t && "string" == typeof t && t.length) return {
          kind: lt.Authorized,
          token: t
        }
      }
    } catch (e) {
      if (401 === a.status) {
        const e = a.headers.get("x-github-otp");
        if (e) {
          const t = e.split(";");
          if (2 === t.length) {
            switch (t[1].trim()) {
              case "app":
                return {
                  kind: lt.TwoFactorAuthenticationRequired, type: Ve.App
                };
              case "sms":
                return {
                  kind: lt.TwoFactorAuthenticationRequired, type: Ve.Sms
                };
              default:
                return {
                  kind: lt.Failed, response: a
                }
            }
          }
        }
        return {
          kind: lt.Failed,
          response: a
        }
      }
      const t = e instanceof Fe && e.apiError;
      if (t) {
        if (403 === a.status && "This API can only be accessed with username and password Basic Auth" === t.message) return {
          kind: lt.PersonalAccessTokenBlocked
        };
        if (410 === a.status) return {
          kind: lt.WebFlowRequired
        };
        if (422 === a.status)
          if (t.errors)
            for (const e of t.errors) {
              const t = "oauthaccess" === e.resource.toLowerCase();
              if ("user" === e.field.toLowerCase() && t) return {
                kind: lt.UserRequiresVerification
              }
            } else if ("Invalid OAuth application client_id or secret." === t.message) return {
              kind: lt.EnterpriseTooOld
            }
      }
    }
    return {
      kind: lt.Error,
      response: a
    }
  }
  async function ut(e, t) {
    const n = new at(e, t);
    try {
      const r = await n.fetchAccount(),
        i = await n.fetchEmails();
      return new De(r.login, e, t, i, r.avatar_url, r.id, r.name || r.login)
    } catch (t) {
      throw log.warn("fetchUser: failed with endpoint " + e, t), t
    }
  }

  function ht(e) {
    if (e !== pt() || Xe) {
      const t = Te.parse(e);
      return `${t.protocol}//${t.hostname}`
    }
    return "https://github.com"
  }

  function pt() {
    return Xe && Xe.length > 0 ? Xe : "https://api.github.com"
  }

  function dt(e, t) {
    return e.find(e => e.endpoint === t) || null
  }

  function ft(e) {
    return e === pt() ? tt : nt
  }! function (e) {
    e[e.Authorized = 0] = "Authorized", e[e.Failed = 1] = "Failed", e[e.TwoFactorAuthenticationRequired = 2] = "TwoFactorAuthenticationRequired", e[e.UserRequiresVerification = 3] = "UserRequiresVerification", e[e.PersonalAccessTokenBlocked = 4] = "PersonalAccessTokenBlocked", e[e.Error = 5] = "Error", e[e.EnterpriseTooOld = 6] = "EnterpriseTooOld", e[e.WebFlowRequired = 7] = "WebFlowRequired"
  }(lt || (lt = {}));
  const mt = [{
    protocol: "https",
    regex: new RegExp("^https?://(?:.+@)?(.+)/(.+)/(.+?)(?:/|.git/?)?$")
  }, {
    protocol: "ssh",
    regex: new RegExp("^git@(.+):(.+)/(.+?)(?:/|.git)?$")
  }, {
    protocol: "ssh",
    regex: new RegExp("^git:(.+)/(.+)/(.+?)(?:/|.git)?$")
  }, {
    protocol: "ssh",
    regex: new RegExp("^ssh://git@(.+)/(.+)/(.+?)(?:/|.git)?$")
  }];

  function gt(e) {
    for (const {
        protocol: t,
        regex: n
      } of mt) {
      const r = e.match(n);
      if (!r) continue;
      const i = r[1],
        o = r[2],
        s = r[3];
      if (i) return {
        protocol: t,
        hostname: i,
        owner: o,
        name: s
      }
    }
    return null
  }

  function yt(e) {
    const t = gt(e);
    if (t) {
      const {
        owner: e,
        name: n,
        hostname: r
      } = t;
      if (e && n) return {
        owner: e,
        name: n,
        hostname: r
      }
    }
    const n = e.split("/");
    if (2 === n.length && n[0].length > 0 && n[1].length > 0) {
      return {
        owner: n[0],
        name: n[1],
        hostname: null
      }
    }
    return null
  }

  function vt(e, t) {
    return e < t ? -1 : e > t ? 1 : 0
  }

  function wt(e, t) {
    return e < t ? 1 : e > t ? -1 : 0
  }

  function bt(e, t) {
    return e.toLowerCase() === t.toLowerCase()
  }

  function St(e, t) {
    return vt(e.toLowerCase(), t.toLowerCase())
  }

  function Ct(e, t) {
    for (const n of e) {
      const e = Et(n, t);
      if (e) return e
    }
    return null
  }

  function Et(e, t) {
    const n = ht(e.endpoint),
      r = Te.parse(n).hostname,
      i = gt(t);
    if (!i) return null;
    const o = i.owner,
      s = i.name;
    return r && i.hostname.toLowerCase() === r.toLowerCase() && o && s ? {
      name: s,
      owner: o,
      endpoint: e.endpoint
    } : null
  }

  function kt(e, t) {
    return e.find(e => i.normalize(e.path).toLowerCase() === i.normalize(t).toLowerCase()) || null
  }

  function xt(e, t) {
    return Tt(e.htmlURL, t) || Tt(e.cloneURL, t)
  }

  function Tt(e, t) {
    if (null == e) return !1;
    const n = gt(e),
      r = gt(t.url);
    return null != r && null != n && (!!bt(r.hostname, n.hostname) && (null != r.owner && null != n.owner && (null != r.name && null != n.name && (bt(r.owner, n.owner) && bt(r.name, n.name)))))
  }

  function Rt(e, t) {
    return null !== t.cloneURL && Dt(t.cloneURL, e)
  }

  function Dt(e, t) {
    const n = yt(e),
      r = yt(t);
    return null !== n && null !== r && n.hostname === r.hostname && n.owner === r.owner && n.name === r.name
  }
  var _t = Object.keys,
    At = Array.isArray,
    Mt = "undefined" != typeof self ? self : "undefined" != typeof window ? window : global;

  function Pt(e, t) {
    return "object" != typeof t || _t(t).forEach((function (n) {
      e[n] = t[n]
    })), e
  }
  var It = Object.getPrototypeOf,
    Ot = {}.hasOwnProperty;

  function Lt(e, t) {
    return Ot.call(e, t)
  }

  function Nt(e, t) {
    "function" == typeof t && (t = t(It(e))), _t(t).forEach((function (n) {
      Bt(e, n, t[n])
    }))
  }
  var Ft = Object.defineProperty;

  function Bt(e, t, n, r) {
    Ft(e, t, Pt(n && Lt(n, "get") && "function" == typeof n.get ? {
      get: n.get,
      set: n.set,
      configurable: !0
    } : {
      value: n,
      configurable: !0,
      writable: !0
    }, r))
  }

  function Ht(e) {
    return {
      from: function (t) {
        return e.prototype = Object.create(t.prototype), Bt(e.prototype, "constructor", e), {
          extend: Nt.bind(null, e.prototype)
        }
      }
    }
  }
  var zt = Object.getOwnPropertyDescriptor;
  var Ut = [].slice;

  function Wt(e, t, n) {
    return Ut.call(e, t, n)
  }

  function Vt(e, t) {
    return t(e)
  }

  function jt(e) {
    if (!e) throw new Error("Assertion Failed")
  }

  function Gt(e) {
    Mt.setImmediate ? setImmediate(e) : setTimeout(e, 0)
  }

  function $t(e, t) {
    return e.reduce((function (e, n, r) {
      var i = t(n, r);
      return i && (e[i[0]] = i[1]), e
    }), {})
  }

  function qt(e, t) {
    return function () {
      try {
        e.apply(this, arguments)
      } catch (e) {
        t(e)
      }
    }
  }

  function Kt(e, t, n) {
    try {
      e.apply(null, n)
    } catch (e) {
      t && t(e)
    }
  }

  function Yt(e, t) {
    if (Lt(e, t)) return e[t];
    if (!t) return e;
    if ("string" != typeof t) {
      for (var n = [], r = 0, i = t.length; r < i; ++r) {
        var o = Yt(e, t[r]);
        n.push(o)
      }
      return n
    }
    var s = t.indexOf(".");
    if (-1 !== s) {
      var a = e[t.substr(0, s)];
      return void 0 === a ? void 0 : Yt(a, t.substr(s + 1))
    }
  }

  function Qt(e, t, n) {
    if (e && void 0 !== t && (!("isFrozen" in Object) || !Object.isFrozen(e)))
      if ("string" != typeof t && "length" in t) {
        jt("string" != typeof n && "length" in n);
        for (var r = 0, i = t.length; r < i; ++r) Qt(e, t[r], n[r])
      } else {
        var o = t.indexOf(".");
        if (-1 !== o) {
          var s = t.substr(0, o),
            a = t.substr(o + 1);
          if ("" === a) void 0 === n ? delete e[s] : e[s] = n;
          else {
            var l = e[s];
            l || (l = e[s] = {}), Qt(l, a, n)
          }
        } else void 0 === n ? delete e[t] : e[t] = n
      }
  }

  function Zt(e) {
    var t = {};
    for (var n in e) Lt(e, n) && (t[n] = e[n]);
    return t
  }
  var Xt = [].concat;

  function Jt(e) {
    return Xt.apply([], e)
  }
  var en = "Boolean,String,Date,RegExp,Blob,File,FileList,ArrayBuffer,DataView,Uint8ClampedArray,ImageData,Map,Set".split(",").concat(Jt([8, 16, 32, 64].map((function (e) {
    return ["Int", "Uint", "Float"].map((function (t) {
      return t + e + "Array"
    }))
  })))).filter((function (e) {
    return Mt[e]
  })).map((function (e) {
    return Mt[e]
  }));

  function tn(e) {
    if (!e || "object" != typeof e) return e;
    var t;
    if (At(e)) {
      t = [];
      for (var n = 0, r = e.length; n < r; ++n) t.push(tn(e[n]))
    } else if (en.indexOf(e.constructor) >= 0) t = e;
    else
      for (var i in t = e.constructor ? Object.create(e.constructor.prototype) : {}, e) Lt(e, i) && (t[i] = tn(e[i]));
    return t
  }

  function nn(e, t, n, r) {
    return n = n || {}, r = r || "", _t(e).forEach((function (i) {
      if (Lt(t, i)) {
        var o = e[i],
          s = t[i];
        "object" == typeof o && "object" == typeof s && o && s && "" + o.constructor == "" + s.constructor ? nn(o, s, n, r + i + ".") : o !== s && (n[r + i] = t[i])
      } else n[r + i] = void 0
    })), _t(t).forEach((function (i) {
      Lt(e, i) || (n[r + i] = t[i])
    })), n
  }
  var rn = "undefined" != typeof Symbol && Symbol.iterator,
    on = rn ? function (e) {
      var t;
      return null != e && (t = e[rn]) && t.apply(e)
    } : function () {
      return null
    },
    sn = {};

  function an(e) {
    var t, n, r, i;
    if (1 === arguments.length) {
      if (At(e)) return e.slice();
      if (this === sn && "string" == typeof e) return [e];
      if (i = on(e)) {
        for (n = []; !(r = i.next()).done;) n.push(r.value);
        return n
      }
      if (null == e) return [e];
      if ("number" == typeof (t = e.length)) {
        for (n = new Array(t); t--;) n[t] = e[t];
        return n
      }
      return [e]
    }
    for (t = arguments.length, n = new Array(t); t--;) n[t] = arguments[t];
    return n
  }
  var ln = "undefined" != typeof location && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);

  function cn(e, t) {
    ln = e, un = t
  }
  var un = function () {
      return !0
    },
    hn = !new Error("").stack;

  function pn() {
    if (hn) try {
      throw pn.arguments, new Error
    } catch (e) {
      return e
    }
    return new Error
  }

  function dn(e, t) {
    var n = e.stack;
    return n ? (t = t || 0, 0 === n.indexOf(e.name) && (t += (e.name + e.message).split("\n").length), n.split("\n").slice(t).filter(un).map((function (e) {
      return "\n" + e
    })).join("")) : ""
  }
  var fn = ["Unknown", "Constraint", "Data", "TransactionInactive", "ReadOnly", "Version", "NotFound", "InvalidState", "InvalidAccess", "Abort", "Timeout", "QuotaExceeded", "Syntax", "DataClone"],
    mn = ["Modify", "Bulk", "OpenFailed", "VersionChange", "Schema", "Upgrade", "InvalidTable", "MissingAPI", "NoSuchDatabase", "InvalidArgument", "SubTransaction", "Unsupported", "Internal", "DatabaseClosed", "PrematureCommit", "ForeignAwait"].concat(fn),
    gn = {
      VersionChanged: "Database version changed by other database connection",
      DatabaseClosed: "Database has been closed",
      Abort: "Transaction aborted",
      TransactionInactive: "Transaction has already completed or failed"
    };

  function yn(e, t) {
    this._e = pn(), this.name = e, this.message = t
  }

  function vn(e, t, n, r) {
    this._e = pn(), this.failures = t, this.failedKeys = r, this.successCount = n
  }

  function wn(e, t) {
    this._e = pn(), this.name = "BulkError", this.failures = t, this.message = function (e, t) {
      return e + ". Errors: " + t.map((function (e) {
        return e.toString()
      })).filter((function (e, t, n) {
        return n.indexOf(e) === t
      })).join("\n")
    }(e, t)
  }
  Ht(yn).from(Error).extend({
    stack: {
      get: function () {
        return this._stack || (this._stack = this.name + ": " + this.message + dn(this._e, 2))
      }
    },
    toString: function () {
      return this.name + ": " + this.message
    }
  }), Ht(vn).from(yn), Ht(wn).from(yn);
  var bn = mn.reduce((function (e, t) {
      return e[t] = t + "Error", e
    }), {}),
    Sn = yn,
    Cn = mn.reduce((function (e, t) {
      var n = t + "Error";

      function r(e, r) {
        this._e = pn(), this.name = n, e ? "string" == typeof e ? (this.message = e, this.inner = r || null) : "object" == typeof e && (this.message = e.name + " " + e.message, this.inner = e) : (this.message = gn[t] || n, this.inner = null)
      }
      return Ht(r).from(Sn), e[t] = r, e
    }), {});
  Cn.Syntax = SyntaxError, Cn.Type = TypeError, Cn.Range = RangeError;
  var En = fn.reduce((function (e, t) {
    return e[t + "Error"] = Cn[t], e
  }), {});
  var kn = mn.reduce((function (e, t) {
    return -1 === ["Syntax", "Type", "Range"].indexOf(t) && (e[t + "Error"] = Cn[t]), e
  }), {});

  function xn() {}

  function Tn(e) {
    return e
  }

  function Rn(e, t) {
    return null == e || e === Tn ? t : function (n) {
      return t(e(n))
    }
  }

  function Dn(e, t) {
    return function () {
      e.apply(this, arguments), t.apply(this, arguments)
    }
  }

  function _n(e, t) {
    return e === xn ? t : function () {
      var n = e.apply(this, arguments);
      void 0 !== n && (arguments[0] = n);
      var r = this.onsuccess,
        i = this.onerror;
      this.onsuccess = null, this.onerror = null;
      var o = t.apply(this, arguments);
      return r && (this.onsuccess = this.onsuccess ? Dn(r, this.onsuccess) : r), i && (this.onerror = this.onerror ? Dn(i, this.onerror) : i), void 0 !== o ? o : n
    }
  }

  function An(e, t) {
    return e === xn ? t : function () {
      e.apply(this, arguments);
      var n = this.onsuccess,
        r = this.onerror;
      this.onsuccess = this.onerror = null, t.apply(this, arguments), n && (this.onsuccess = this.onsuccess ? Dn(n, this.onsuccess) : n), r && (this.onerror = this.onerror ? Dn(r, this.onerror) : r)
    }
  }

  function Mn(e, t) {
    return e === xn ? t : function (n) {
      var r = e.apply(this, arguments);
      Pt(n, r);
      var i = this.onsuccess,
        o = this.onerror;
      this.onsuccess = null, this.onerror = null;
      var s = t.apply(this, arguments);
      return i && (this.onsuccess = this.onsuccess ? Dn(i, this.onsuccess) : i), o && (this.onerror = this.onerror ? Dn(o, this.onerror) : o), void 0 === r ? void 0 === s ? void 0 : s : Pt(r, s)
    }
  }

  function Pn(e, t) {
    return e === xn ? t : function () {
      return !1 !== t.apply(this, arguments) && e.apply(this, arguments)
    }
  }

  function In(e, t) {
    return e === xn ? t : function () {
      var n = e.apply(this, arguments);
      if (n && "function" == typeof n.then) {
        for (var r = this, i = arguments.length, o = new Array(i); i--;) o[i] = arguments[i];
        return n.then((function () {
          return t.apply(r, o)
        }))
      }
      return t.apply(this, arguments)
    }
  }
  kn.ModifyError = vn, kn.DexieError = yn, kn.BulkError = wn;
  var On = {},
    Ln = function () {
      try {
        return new Function("let F=async ()=>{},p=F();return [p,Object.getPrototypeOf(p),Promise.resolve(),F.constructor];")()
      } catch (t) {
        var e = Mt.Promise;
        return e ? [e.resolve(), e.prototype, e.resolve()] : []
      }
    }(),
    Nn = Ln[0],
    Fn = Ln[1],
    Bn = Ln[2],
    Hn = Fn && Fn.then,
    zn = Nn && Nn.constructor,
    Un = Ln[3],
    Wn = !!Bn,
    Vn = !1,
    jn = Bn ? function () {
      Bn.then(pr)
    } : Mt.setImmediate ? setImmediate.bind(null, pr) : Mt.MutationObserver ? function () {
      var e = document.createElement("div");
      new MutationObserver((function () {
        pr(), e = null
      })).observe(e, {
        attributes: !0
      }), e.setAttribute("i", "1")
    } : function () {
      setTimeout(pr, 0)
    },
    Gn = function (e, t) {
      er.push([e, t]), qn && (jn(), qn = !1)
    },
    $n = !0,
    qn = !0,
    Kn = [],
    Yn = [],
    Qn = null,
    Zn = Tn,
    Xn = {
      id: "global",
      global: !0,
      ref: 0,
      unhandleds: [],
      onunhandled: Lr,
      pgp: !1,
      env: {},
      finalize: function () {
        this.unhandleds.forEach((function (e) {
          try {
            Lr(e[0], e[1])
          } catch (e) {}
        }))
      }
    },
    Jn = Xn,
    er = [],
    tr = 0,
    nr = [];

  function rr(e) {
    if ("object" != typeof this) throw new TypeError("Promises must be constructed via new");
    this._listeners = [], this.onuncatched = xn, this._lib = !1;
    var t = this._PSD = Jn;
    if (ln && (this._stackHolder = pn(), this._prev = null, this._numPrev = 0), "function" != typeof e) {
      if (e !== On) throw new TypeError("Not a function");
      return this._state = arguments[1], this._value = arguments[2], void(!1 === this._state && ar(this, this._value))
    }
    this._state = null, this._value = null, ++t.ref, sr(this, e)
  }
  var ir = {
    get: function () {
      var e = Jn,
        t = Cr;

      function n(n, r) {
        var i = this,
          o = !e.global && (e !== Jn || t !== Cr);
        o && Tr();
        var s = new rr((function (t, s) {
          cr(i, new or(Ir(n, e, o), Ir(r, e, o), t, s, e))
        }));
        return ln && hr(s, this), s
      }
      return n.prototype = On, n
    },
    set: function (e) {
      Bt(this, "then", e && e.prototype === On ? ir : {
        get: function () {
          return e
        },
        set: ir.set
      })
    }
  };

  function or(e, t, n, r, i) {
    this.onFulfilled = "function" == typeof e ? e : null, this.onRejected = "function" == typeof t ? t : null, this.resolve = n, this.reject = r, this.psd = i
  }

  function sr(e, t) {
    try {
      t((function (t) {
        if (null === e._state) {
          if (t === e) throw new TypeError("A promise cannot be resolved with itself.");
          var n = e._lib && dr();
          t && "function" == typeof t.then ? sr(e, (function (e, n) {
            t instanceof rr ? t._then(e, n) : t.then(e, n)
          })) : (e._state = !0, e._value = t, lr(e)), n && fr()
        }
      }), ar.bind(null, e))
    } catch (t) {
      ar(e, t)
    }
  }

  function ar(e, t) {
    if (Yn.push(t), null === e._state) {
      var n = e._lib && dr();
      t = Zn(t), e._state = !1, e._value = t, ln && null !== t && "object" == typeof t && !t._promise && Kt((function () {
          var n = function e(t, n) {
            var r;
            return zt(t, n) || (r = It(t)) && e(r, n)
          }(t, "stack");
          t._promise = e, Bt(t, "stack", {
            get: function () {
              return Vn ? n && (n.get ? n.get.apply(t) : n.value) : e.stack
            }
          })
        })),
        function (e) {
          Kn.some((function (t) {
            return t._value === e._value
          })) || Kn.push(e)
        }(e), lr(e), n && fr()
    }
  }

  function lr(e) {
    var t = e._listeners;
    e._listeners = [];
    for (var n = 0, r = t.length; n < r; ++n) cr(e, t[n]);
    var i = e._PSD;
    --i.ref || i.finalize(), 0 === tr && (++tr, Gn((function () {
      0 == --tr && mr()
    }), []))
  }

  function cr(e, t) {
    if (null !== e._state) {
      var n = e._state ? t.onFulfilled : t.onRejected;
      if (null === n) return (e._state ? t.resolve : t.reject)(e._value);
      ++t.psd.ref, ++tr, Gn(ur, [n, e, t])
    } else e._listeners.push(t)
  }

  function ur(e, t, n) {
    try {
      Qn = t;
      var r, i = t._value;
      t._state ? r = e(i) : (Yn.length && (Yn = []), r = e(i), -1 === Yn.indexOf(i) && function (e) {
        var t = Kn.length;
        for (; t;)
          if (Kn[--t]._value === e._value) return void Kn.splice(t, 1)
      }(t)), n.resolve(r)
    } catch (e) {
      n.reject(e)
    } finally {
      Qn = null, 0 == --tr && mr(), --n.psd.ref || n.psd.finalize()
    }
  }

  function hr(e, t) {
    var n = t ? t._numPrev + 1 : 0;
    n < 100 && (e._prev = t, e._numPrev = n)
  }

  function pr() {
    dr() && fr()
  }

  function dr() {
    var e = $n;
    return $n = !1, qn = !1, e
  }

  function fr() {
    var e, t, n;
    do {
      for (; er.length > 0;)
        for (e = er, er = [], n = e.length, t = 0; t < n; ++t) {
          var r = e[t];
          r[0].apply(null, r[1])
        }
    } while (er.length > 0);
    $n = !0, qn = !0
  }

  function mr() {
    var e = Kn;
    Kn = [], e.forEach((function (e) {
      e._PSD.onunhandled.call(null, e._value, e)
    }));
    for (var t = nr.slice(0), n = t.length; n;) t[--n]()
  }

  function gr(e) {
    return new rr(On, !1, e)
  }

  function yr(e, t) {
    var n = Jn;
    return function () {
      var r = dr(),
        i = Jn;
      try {
        return Ar(n, !0), e.apply(this, arguments)
      } catch (e) {
        t && t(e)
      } finally {
        Ar(i, !1), r && fr()
      }
    }
  }
  Nt(rr.prototype, {
    then: ir,
    _then: function (e, t) {
      cr(this, new or(null, null, e, t, Jn))
    },
    catch: function (e) {
      if (1 === arguments.length) return this.then(null, e);
      var t = arguments[0],
        n = arguments[1];
      return "function" == typeof t ? this.then(null, (function (e) {
        return e instanceof t ? n(e) : gr(e)
      })) : this.then(null, (function (e) {
        return e && e.name === t ? n(e) : gr(e)
      }))
    },
    finally: function (e) {
      return this.then((function (t) {
        return e(), t
      }), (function (t) {
        return e(), gr(t)
      }))
    },
    stack: {
      get: function () {
        if (this._stack) return this._stack;
        try {
          Vn = !0;
          var e = function e(t, n, r) {
            if (n.length === r) return n;
            var i = "";
            if (!1 === t._state) {
              var o, s, a = t._value;
              null != a ? (o = a.name || "Error", s = a.message || a, i = dn(a, 0)) : (o = a, s = ""), n.push(o + (s ? ": " + s : "") + i)
            }
            ln && ((i = dn(t._stackHolder, 2)) && -1 === n.indexOf(i) && n.push(i), t._prev && e(t._prev, n, r));
            return n
          }(this, [], 20).join("\nFrom previous: ");
          return null !== this._state && (this._stack = e), e
        } finally {
          Vn = !1
        }
      }
    },
    timeout: function (e, t) {
      var n = this;
      return e < 1 / 0 ? new rr((function (r, i) {
        var o = setTimeout((function () {
          return i(new Cn.Timeout(t))
        }), e);
        n.then(r, i).finally(clearTimeout.bind(null, o))
      })) : this
    }
  }), "undefined" != typeof Symbol && Symbol.toStringTag && Bt(rr.prototype, Symbol.toStringTag, "Promise"), Xn.env = Mr(), Nt(rr, {
    all: function () {
      var e = an.apply(null, arguments).map(Rr);
      return new rr((function (t, n) {
        0 === e.length && t([]);
        var r = e.length;
        e.forEach((function (i, o) {
          return rr.resolve(i).then((function (n) {
            e[o] = n, --r || t(e)
          }), n)
        }))
      }))
    },
    resolve: function (e) {
      if (e instanceof rr) return e;
      if (e && "function" == typeof e.then) return new rr((function (t, n) {
        e.then(t, n)
      }));
      var t = new rr(On, !0, e);
      return hr(t, Qn), t
    },
    reject: gr,
    race: function () {
      var e = an.apply(null, arguments).map(Rr);
      return new rr((function (t, n) {
        e.map((function (e) {
          return rr.resolve(e).then(t, n)
        }))
      }))
    },
    PSD: {
      get: function () {
        return Jn
      },
      set: function (e) {
        return Jn = e
      }
    },
    newPSD: kr,
    usePSD: Pr,
    scheduler: {
      get: function () {
        return Gn
      },
      set: function (e) {
        Gn = e
      }
    },
    rejectionMapper: {
      get: function () {
        return Zn
      },
      set: function (e) {
        Zn = e
      }
    },
    follow: function (e, t) {
      return new rr((function (n, r) {
        return kr((function (t, n) {
          var r = Jn;
          r.unhandleds = [], r.onunhandled = n, r.finalize = Dn((function () {
            var e = this;
            ! function (e) {
              nr.push((function t() {
                e(), nr.splice(nr.indexOf(t), 1)
              })), ++tr, Gn((function () {
                0 == --tr && mr()
              }), [])
            }((function () {
              0 === e.unhandleds.length ? t() : n(e.unhandleds[0])
            }))
          }), r.finalize), e()
        }), t, n, r)
      }))
    }
  });
  var vr = {
      awaits: 0,
      echoes: 0,
      id: 0
    },
    wr = 0,
    br = [],
    Sr = 0,
    Cr = 0,
    Er = 0;

  function kr(e, t, n, r) {
    var i = Jn,
      o = Object.create(i);
    o.parent = i, o.ref = 0, o.global = !1, o.id = ++Er;
    var s = Xn.env;
    o.env = Wn ? {
      Promise: rr,
      PromiseProp: {
        value: rr,
        configurable: !0,
        writable: !0
      },
      all: rr.all,
      race: rr.race,
      resolve: rr.resolve,
      reject: rr.reject,
      nthen: Or(s.nthen, o),
      gthen: Or(s.gthen, o)
    } : {}, t && Pt(o, t), ++i.ref, o.finalize = function () {
      --this.parent.ref || this.parent.finalize()
    };
    var a = Pr(o, e, n, r);
    return 0 === o.ref && o.finalize(), a
  }

  function xr() {
    return vr.id || (vr.id = ++wr), ++vr.awaits, vr.echoes += 7, vr.id
  }

  function Tr(e) {
    !vr.awaits || e && e !== vr.id || (0 == --vr.awaits && (vr.id = 0), vr.echoes = 7 * vr.awaits)
  }

  function Rr(e) {
    return vr.echoes && e && e.constructor === zn ? (xr(), e.then((function (e) {
      return Tr(), e
    }), (function (e) {
      return Tr(), Nr(e)
    }))) : e
  }

  function Dr(e) {
    ++Cr, vr.echoes && 0 != --vr.echoes || (vr.echoes = vr.id = 0), br.push(Jn), Ar(e, !0)
  }

  function _r() {
    var e = br[br.length - 1];
    br.pop(), Ar(e, !1)
  }

  function Ar(e, t) {
    var n, r = Jn;
    if ((t ? !vr.echoes || Sr++ && e === Jn : !Sr || --Sr && e === Jn) || (n = t ? Dr.bind(null, e) : _r, Hn.call(Nn, n)), e !== Jn && (Jn = e, r === Xn && (Xn.env = Mr()), Wn)) {
      var i = Xn.env.Promise,
        o = e.env;
      Fn.then = o.nthen, i.prototype.then = o.gthen, (r.global || e.global) && (Object.defineProperty(Mt, "Promise", o.PromiseProp), i.all = o.all, i.race = o.race, i.resolve = o.resolve, i.reject = o.reject)
    }
  }

  function Mr() {
    var e = Mt.Promise;
    return Wn ? {
      Promise: e,
      PromiseProp: Object.getOwnPropertyDescriptor(Mt, "Promise"),
      all: e.all,
      race: e.race,
      resolve: e.resolve,
      reject: e.reject,
      nthen: Fn.then,
      gthen: e.prototype.then
    } : {}
  }

  function Pr(e, t, n, r, i) {
    var o = Jn;
    try {
      return Ar(e, !0), t(n, r, i)
    } finally {
      Ar(o, !1)
    }
  }

  function Ir(e, t, n) {
    return "function" != typeof e ? e : function () {
      var r = Jn;
      n && xr(), Ar(t, !0);
      try {
        return e.apply(this, arguments)
      } finally {
        Ar(r, !1)
      }
    }
  }

  function Or(e, t) {
    return function (n, r) {
      return e.call(this, Ir(n, t, !1), Ir(r, t, !1))
    }
  }

  function Lr(e, t) {
    var n;
    try {
      n = t.onuncatched(e)
    } catch (e) {}
    if (!1 !== n) try {
      var r, i = {
        promise: t,
        reason: e
      };
      if (Mt.document && document.createEvent ? ((r = document.createEvent("Event")).initEvent("unhandledrejection", !0, !0), Pt(r, i)) : Mt.CustomEvent && Pt(r = new CustomEvent("unhandledrejection", {
          detail: i
        }), i), r && Mt.dispatchEvent && (dispatchEvent(r), !Mt.PromiseRejectionEvent && Mt.onunhandledrejection)) try {
        Mt.onunhandledrejection(r)
      } catch (e) {}
      r.defaultPrevented || console.warn("Unhandled rejection: " + (e.stack || e))
    } catch (e) {}
  }
  var Nr = rr.reject;

  function Fr(e) {
    var t = {},
      n = function (n, r) {
        if (r) {
          for (var i = arguments.length, o = new Array(i - 1); --i;) o[i - 1] = arguments[i];
          return t[n].subscribe.apply(null, o), e
        }
        if ("string" == typeof n) return t[n]
      };
    n.addEventType = o;
    for (var r = 1, i = arguments.length; r < i; ++r) o(arguments[r]);
    return n;

    function o(e, r, i) {
      if ("object" == typeof e) return s(e);
      r || (r = Pn), i || (i = xn);
      var o = {
        subscribers: [],
        fire: i,
        subscribe: function (e) {
          -1 === o.subscribers.indexOf(e) && (o.subscribers.push(e), o.fire = r(o.fire, e))
        },
        unsubscribe: function (e) {
          o.subscribers = o.subscribers.filter((function (t) {
            return t !== e
          })), o.fire = o.subscribers.reduce(r, i)
        }
      };
      return t[e] = n[e] = o, o
    }

    function s(e) {
      _t(e).forEach((function (t) {
        var n = e[t];
        if (At(n)) o(t, e[t][0], e[t][1]);
        else {
          if ("asap" !== n) throw new Cn.InvalidArgument("Invalid event config");
          var r = o(t, Tn, (function () {
            for (var e = arguments.length, t = new Array(e); e--;) t[e] = arguments[e];
            r.subscribers.forEach((function (e) {
              Gt((function () {
                e.apply(null, t)
              }))
            }))
          }))
        }
      }))
    }
  }
  var Br, Hr = String.fromCharCode(65535),
    zr = function () {
      try {
        return IDBKeyRange.only([
          []
        ]), [
          []
        ]
      } catch (e) {
        return Hr
      }
    }(),
    Ur = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.",
    Wr = [],
    Vr = "undefined" != typeof navigator && /(MSIE|Trident|Edge)/.test(navigator.userAgent),
    jr = Vr,
    Gr = Vr,
    $r = function (e) {
      return !/(dexie\.js|dexie\.min\.js)/.test(e)
    };

  function qr(e, t) {
    var n, r, i, o, s, a = qr.dependencies,
      l = Pt({
        addons: qr.addons,
        autoOpen: !0,
        indexedDB: a.indexedDB,
        IDBKeyRange: a.IDBKeyRange
      }, t),
      c = l.addons,
      u = l.autoOpen,
      h = l.indexedDB,
      p = l.IDBKeyRange,
      d = this._dbSchema = {},
      f = [],
      m = [],
      g = {},
      y = null,
      v = null,
      w = !1,
      b = null,
      S = !1,
      C = "readwrite",
      E = this,
      k = new rr((function (e) {
        n = e
      })),
      x = new rr((function (e, t) {
        r = t
      })),
      T = !0,
      R = !!ii(h);

    function D(e) {
      this._cfg = {
        version: e,
        storesSource: null,
        dbschema: {},
        tables: {},
        contentUpgrade: null
      }, this.stores({})
    }

    function _(e, t, n) {
      var r = E._createTransaction(C, m, d);
      r.create(t), r._completion.catch(n);
      var i = r._reject.bind(r);
      kr((function () {
        Jn.trans = r, 0 === e ? (_t(d).forEach((function (e) {
          A(t, e, d[e].primKey, d[e].indexes)
        })), rr.follow((function () {
          return E.on.populate.fire(r)
        })).catch(i)) : function (e, t, n) {
          var r = [],
            i = f.filter((function (t) {
              return t._cfg.version === e
            }))[0];
          if (!i) throw new Cn.Upgrade("Dexie specification of currently installed DB version is missing");
          d = E._dbSchema = i._cfg.dbschema;
          var o = !1;

          function s() {
            return r.length ? rr.resolve(r.shift()(t.idbtrans)).then(s) : rr.resolve()
          }
          return f.filter((function (t) {
            return t._cfg.version > e
          })).forEach((function (e) {
            r.push((function () {
              var r = d,
                i = e._cfg.dbschema;
              Q(r, n), Q(i, n), d = E._dbSchema = i;
              var s = function (e, t) {
                var n = {
                  del: [],
                  add: [],
                  change: []
                };
                for (var r in e) t[r] || n.del.push(r);
                for (r in t) {
                  var i = e[r],
                    o = t[r];
                  if (i) {
                    var s = {
                      name: r,
                      def: o,
                      recreate: !1,
                      del: [],
                      add: [],
                      change: []
                    };
                    if (i.primKey.src !== o.primKey.src) s.recreate = !0, n.change.push(s);
                    else {
                      var a = i.idxByName,
                        l = o.idxByName;
                      for (var c in a) l[c] || s.del.push(c);
                      for (c in l) {
                        var u = a[c],
                          h = l[c];
                        u ? u.src !== h.src && s.change.push(h) : s.add.push(h)
                      }(s.del.length > 0 || s.add.length > 0 || s.change.length > 0) && n.change.push(s)
                    }
                  } else n.add.push([r, o])
                }
                return n
              }(r, i);
              if (s.add.forEach((function (e) {
                  A(n, e[0], e[1].primKey, e[1].indexes)
                })), s.change.forEach((function (e) {
                  if (e.recreate) throw new Cn.Upgrade("Not yet support for changing primary key");
                  var t = n.objectStore(e.name);
                  e.add.forEach((function (e) {
                    M(t, e)
                  })), e.change.forEach((function (e) {
                    t.deleteIndex(e.name), M(t, e)
                  })), e.del.forEach((function (e) {
                    t.deleteIndex(e)
                  }))
                })), e._cfg.contentUpgrade) return o = !0, rr.follow((function () {
                e._cfg.contentUpgrade(t)
              }))
            })), r.push((function (t) {
              o && jr || function (e, t) {
                for (var n = 0; n < t.db.objectStoreNames.length; ++n) {
                  var r = t.db.objectStoreNames[n];
                  null == e[r] && t.db.deleteObjectStore(r)
                }
              }(e._cfg.dbschema, t)
            }))
          })), s().then((function () {
            ! function (e, t) {
              _t(e).forEach((function (n) {
                t.db.objectStoreNames.contains(n) || A(t, n, e[n].primKey, e[n].indexes)
              }))
            }(d, n)
          }))
        }(e, r, t).catch(i)
      }))
    }

    function A(e, t, n, r) {
      var i = e.db.createObjectStore(t, n.keyPath ? {
        keyPath: n.keyPath,
        autoIncrement: n.auto
      } : {
        autoIncrement: n.auto
      });
      return r.forEach((function (e) {
        M(i, e)
      })), i
    }

    function M(e, t) {
      e.createIndex(t.name, t.keyPath, {
        unique: t.unique,
        multiEntry: t.multi
      })
    }

    function P(e, t, n) {
      var r = arguments.length;
      if (r < 2) throw new Cn.InvalidArgument("Too few arguments");
      for (var i = new Array(r - 1); --r;) i[r - 1] = arguments[r];
      n = i.pop();
      var o = Jt(i);
      return [e, o, n]
    }

    function I(e, t, n) {
      this.name = e, this.schema = t, this._tx = n, this.hook = g[e] ? g[e].hook : Fr(null, {
        creating: [_n, xn],
        reading: [Rn, Tn],
        updating: [Mn, xn],
        deleting: [An, xn]
      })
    }

    function O(e, t, n) {
      return (n ? Xr : Qr)((function (n) {
        e.push(n), t && t()
      }))
    }

    function L(e, t, n, r, i) {
      return new rr((function (o, s) {
        var a = n.length,
          l = a - 1;
        if (0 === a) return o();
        if (r) {
          var c, u = Xr(s),
            h = Yr(null);
          Kt((function () {
            for (var r = 0; r < a; ++r) {
              c = {
                onsuccess: null,
                onerror: null
              };
              var s = n[r];
              i.call(c, s[0], s[1], t);
              var p = e.delete(s[0]);
              p._hookCtx = c, p.onerror = u, p.onsuccess = r === l ? Yr(o) : h
            }
          }), (function (e) {
            throw c.onerror && c.onerror(e), e
          }))
        } else
          for (var p = 0; p < a; ++p) {
            var d = e.delete(n[p]);
            d.onerror = Qr(s), p === l && (d.onsuccess = yr((function () {
              return o()
            })))
          }
      }))
    }

    function N(e, t, n, r) {
      var i = this;
      this.db = E, this.mode = e, this.storeNames = t, this.idbtrans = null, this.on = Fr(this, "complete", "error", "abort"), this.parent = r || null, this.active = !0, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new rr((function (e, t) {
        i._resolve = e, i._reject = t
      })), this._completion.then((function () {
        i.active = !1, i.on.complete.fire()
      }), (function (e) {
        var t = i.active;
        return i.active = !1, i.on.error.fire(e), i.parent ? i.parent._reject(e) : t && i.idbtrans && i.idbtrans.abort(), Nr(e)
      }))
    }

    function F(e, t, n) {
      this._ctx = {
        table: e,
        index: ":id" === t ? null : t,
        or: n
      }
    }

    function B(e, t) {
      var n = null,
        r = null;
      if (t) try {
        n = t()
      } catch (e) {
        r = e
      }
      var i = e._ctx,
        o = i.table;
      this._ctx = {
        table: o,
        index: i.index,
        isPrimKey: !i.index || o.schema.primKey.keyPath && i.index === o.schema.primKey.name,
        range: n,
        keysOnly: !1,
        dir: "next",
        unique: "",
        algorithm: null,
        filter: null,
        replayFilter: null,
        justLimit: !0,
        isMatch: null,
        offset: 0,
        limit: 1 / 0,
        error: r,
        or: i.or,
        valueMapper: o.hook.reading.fire
      }
    }

    function H(e, t) {
      return !(e.filter || e.algorithm || e.or) && (t ? e.justLimit : !e.replayFilter)
    }

    function z(e, t) {
      return e._cfg.version - t._cfg.version
    }

    function U(e, t, n) {
      t.forEach((function (t) {
        var r = n[t];
        e.forEach((function (e) {
          t in e || (e === N.prototype || e instanceof N ? Bt(e, t, {
            get: function () {
              return this.table(t)
            }
          }) : e[t] = new I(t, r))
        }))
      }))
    }

    function W(e, t, n, r, i, o) {
      var s = yr(o ? function (e, t, r) {
        return n(o(e), t, r)
      } : n, i);
      e.onerror || (e.onerror = Qr(i)), e.onsuccess = qt(t ? function () {
        var n = e.result;
        if (n) {
          var o = function () {
            n.continue()
          };
          t(n, (function (e) {
            o = e
          }), r, i) && s(n.value, n, (function (e) {
            o = e
          })), o()
        } else r()
      } : function () {
        var t = e.result;
        if (t) {
          var n = function () {
            t.continue()
          };
          s(t.value, t, (function (e) {
            n = e
          })), n()
        } else r()
      }, i)
    }

    function V(e, t) {
      return h.cmp(e, t)
    }

    function j(e, t) {
      return V(e, t) > 0 ? e : t
    }

    function G(e, t) {
      return h.cmp(e, t)
    }

    function $(e, t) {
      return h.cmp(t, e)
    }

    function q(e, t) {
      return e < t ? -1 : e === t ? 0 : 1
    }

    function K(e, t) {
      return e > t ? -1 : e === t ? 0 : 1
    }

    function Y(e, t) {
      return e ? t ? function () {
        return e.apply(this, arguments) && t.apply(this, arguments)
      } : e : t
    }

    function Q(e, t) {
      for (var n = t.db.objectStoreNames, r = 0; r < n.length; ++r) {
        var o = n[r],
          s = t.objectStore(o);
        i = "getAll" in s;
        for (var a = 0; a < s.indexNames.length; ++a) {
          var l = s.indexNames[a],
            c = s.index(l).keyPath,
            u = "string" == typeof c ? c : "[" + Wt(c).join("+") + "]";
          if (e[o]) {
            var h = e[o].idxByName[u];
            h && (h.name = l)
          }
        }
      }
      /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && Mt.WorkerGlobalScope && Mt instanceof Mt.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604 && (i = !1)
    }

    function Z(e) {
      E.on("blocked").fire(e), Wr.filter((function (e) {
        return e.name === E.name && e !== E && !e._vcFired
      })).map((function (t) {
        return t.on("versionchange").fire(e)
      }))
    }
    this.version = function (e) {
      if (y || w) throw new Cn.Schema("Cannot add version when database is open");
      this.verno = Math.max(this.verno, e);
      var t = f.filter((function (t) {
        return t._cfg.version === e
      }))[0];
      return t || (t = new D(e), f.push(t), f.sort(z), T = !1, t)
    }, Pt(D.prototype, {
      stores: function (e) {
        this._cfg.storesSource = this._cfg.storesSource ? Pt(this._cfg.storesSource, e) : e;
        var t = {};
        f.forEach((function (e) {
          Pt(t, e._cfg.storesSource)
        }));
        var n = this._cfg.dbschema = {};
        return this._parseStoresSpec(t, n), d = E._dbSchema = n, [g, E, N.prototype].forEach((function (e) {
          for (var t in e) e[t] instanceof I && delete e[t]
        })), U([g, E, N.prototype, this._cfg.tables], _t(n), n), m = _t(n), this
      },
      upgrade: function (e) {
        return this._cfg.contentUpgrade = e, this
      },
      _parseStoresSpec: function (e, t) {
        _t(e).forEach((function (n) {
          if (null !== e[n]) {
            var r = {},
              i = function (e) {
                var t = [];
                return e.split(",").forEach((function (e) {
                  var n = (e = e.trim()).replace(/([&*]|\+\+)/g, ""),
                    r = /^\[/.test(n) ? n.match(/^\[(.*)\]$/)[1].split("+") : n;
                  t.push(new ti(n, r || null, /\&/.test(e), /\*/.test(e), /\+\+/.test(e), At(r), /\./.test(e)))
                })), t
              }(e[n]),
              o = i.shift();
            if (o.multi) throw new Cn.Schema("Primary key cannot be multi-valued");
            o.keyPath && Qt(r, o.keyPath, o.auto ? 0 : o.keyPath), i.forEach((function (e) {
              if (e.auto) throw new Cn.Schema("Only primary key can be marked as autoIncrement (++)");
              if (!e.keyPath) throw new Cn.Schema("Index must have a name and cannot be an empty string");
              Qt(r, e.keyPath, e.compound ? e.keyPath.map((function () {
                return ""
              })) : "")
            })), t[n] = new ni(n, o, i, r)
          }
        }))
      }
    }), this._allTables = g, this._createTransaction = function (e, t, n, r) {
      return new N(e, t, n, r)
    }, this._whenReady = function (e) {
      return S || Jn.letThrough ? e() : new rr((function (e, t) {
        if (!w) {
          if (!u) return void t(new Cn.DatabaseClosed);
          E.open().catch(xn)
        }
        k.then(e, t)
      })).then(e)
    }, this.verno = 0, this.open = function () {
      if (w || y) return k.then((function () {
        return v ? Nr(v) : E
      }));
      ln && (x._stackHolder = pn()), w = !0, v = null, S = !1;
      var t = n,
        r = null;
      return rr.race([x, new rr((function (t, n) {
        if (!h) throw new Cn.MissingAPI("indexedDB API not found. If using IE10+, make sure to run your code on a server URL (not locally). If using old Safari versions, make sure to include indexedDB polyfill.");
        var i = T ? h.open(e) : h.open(e, Math.round(10 * E.verno));
        if (!i) throw new Cn.MissingAPI("IndexedDB API not available");
        i.onerror = Qr(n), i.onblocked = yr(Z), i.onupgradeneeded = yr((function (t) {
          if (r = i.transaction, T && !E._allowEmptyDB) {
            i.onerror = Jr, r.abort(), i.result.close();
            var o = h.deleteDatabase(e);
            o.onsuccess = o.onerror = yr((function () {
              n(new Cn.NoSuchDatabase("Database " + e + " doesnt exist"))
            }))
          } else {
            r.onerror = Qr(n), _((t.oldVersion > Math.pow(2, 62) ? 0 : t.oldVersion) / 10, r, n)
          }
        }), n), i.onsuccess = yr((function () {
          if (r = null, y = i.result, Wr.push(E), T) ! function () {
            if (E.verno = y.version / 10, E._dbSchema = d = {}, 0 === (m = Wt(y.objectStoreNames, 0)).length) return;
            var e = y.transaction(ri(m), "readonly");
            m.forEach((function (t) {
              for (var n = e.objectStore(t), r = n.keyPath, i = r && "string" == typeof r && -1 !== r.indexOf("."), o = new ti(r, r || "", !1, !1, !!n.autoIncrement, r && "string" != typeof r, i), s = [], a = 0; a < n.indexNames.length; ++a) {
                var l = n.index(n.indexNames[a]);
                i = (r = l.keyPath) && "string" == typeof r && -1 !== r.indexOf(".");
                var c = new ti(l.name, r, !!l.unique, !!l.multiEntry, !1, r && "string" != typeof r, i);
                s.push(c)
              }
              d[t] = new ni(t, o, s, {})
            })), U([g], _t(d), d)
          }();
          else if (y.objectStoreNames.length > 0) try {
            Q(d, y.transaction(ri(y.objectStoreNames), "readonly"))
          } catch (e) {}
          y.onversionchange = yr((function (e) {
            E._vcFired = !0, E.on("versionchange").fire(e)
          })), R || "__dbnames" === e || Br.dbnames.put({
            name: e
          }).catch(xn), t()
        }), n)
      }))]).then((function () {
        return b = [], rr.resolve(qr.vip(E.on.ready.fire)).then((function e() {
          if (b.length > 0) {
            var t = b.reduce(In, xn);
            return b = [], rr.resolve(qr.vip(t)).then(e)
          }
        }))
      })).finally((function () {
        b = null
      })).then((function () {
        return w = !1, E
      })).catch((function (e) {
        try {
          r && r.abort()
        } catch (e) {}
        return w = !1, E.close(), Nr(v = e)
      })).finally((function () {
        S = !0, t()
      }))
    }, this.close = function () {
      var e = Wr.indexOf(E);
      if (e >= 0 && Wr.splice(e, 1), y) {
        try {
          y.close()
        } catch (e) {}
        y = null
      }
      u = !1, v = new Cn.DatabaseClosed, w && r(v), k = new rr((function (e) {
        n = e
      })), x = new rr((function (e, t) {
        r = t
      }))
    }, this.delete = function () {
      var t = arguments.length > 0;
      return new rr((function (n, r) {
        if (t) throw new Cn.InvalidArgument("Arguments not allowed in db.delete()");

        function i() {
          E.close();
          var t = h.deleteDatabase(e);
          t.onsuccess = yr((function () {
            R || Br.dbnames.delete(e).catch(xn), n()
          })), t.onerror = Qr(r), t.onblocked = Z
        }
        w ? k.then(i) : i()
      }))
    }, this.backendDB = function () {
      return y
    }, this.isOpen = function () {
      return null !== y
    }, this.hasBeenClosed = function () {
      return v && v instanceof Cn.DatabaseClosed
    }, this.hasFailed = function () {
      return null !== v
    }, this.dynamicallyOpened = function () {
      return T
    }, this.name = e, Nt(this, {
      tables: {
        get: function () {
          return _t(g).map((function (e) {
            return g[e]
          }))
        }
      }
    }), this.on = Fr(this, "populate", "blocked", "versionchange", {
      ready: [In, xn]
    }), this.on.ready.subscribe = Vt(this.on.ready.subscribe, (function (e) {
      return function (t, n) {
        qr.vip((function () {
          S ? (v || rr.resolve().then(t), n && e(t)) : b ? (b.push(t), n && e(t)) : (e(t), n || e((function e() {
            E.on.ready.unsubscribe(t), E.on.ready.unsubscribe(e)
          })))
        }))
      }
    })), this.transaction = function () {
      var e = P.apply(this, arguments);
      return this._transaction.apply(this, e)
    }, this._transaction = function (e, t, n) {
      var r = Jn.trans;
      r && r.db === E && -1 === e.indexOf("!") || (r = null);
      var i = -1 !== e.indexOf("?");
      e = e.replace("!", "").replace("?", "");
      try {
        var o = t.map((function (e) {
          var t = e instanceof I ? e.name : e;
          if ("string" != typeof t) throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
          return t
        }));
        if ("r" == e || "readonly" == e) e = "readonly";
        else {
          if ("rw" != e && e != C) throw new Cn.InvalidArgument("Invalid transaction mode: " + e);
          e = C
        }
        if (r) {
          if ("readonly" === r.mode && e === C) {
            if (!i) throw new Cn.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
            r = null
          }
          r && o.forEach((function (e) {
            if (r && -1 === r.storeNames.indexOf(e)) {
              if (!i) throw new Cn.SubTransaction("Table " + e + " not included in parent transaction.");
              r = null
            }
          })), i && r && !r.active && (r = null)
        }
      } catch (e) {
        return r ? r._promise(null, (function (t, n) {
          n(e)
        })) : Nr(e)
      }
      return r ? r._promise(e, s, "lock") : Jn.trans ? Pr(Jn.transless, (function () {
        return E._whenReady(s)
      })) : E._whenReady(s);

      function s() {
        return rr.resolve().then((function () {
          var t, i = Jn.transless || Jn,
            s = E._createTransaction(e, o, d, r),
            a = {
              trans: s,
              transless: i
            };
          r ? s.idbtrans = r.idbtrans : s.create(), n.constructor === Un && xr();
          var l = rr.follow((function () {
            if (t = n.call(s, s))
              if (t.constructor === zn) {
                var e = Tr.bind(null, null);
                t.then(e, e)
              } else "function" == typeof t.next && "function" == typeof t.throw && (t = ei(t))
          }), a);
          return (t && "function" == typeof t.then ? rr.resolve(t).then((function (e) {
            return s.active ? e : Nr(new Cn.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"))
          })) : l.then((function () {
            return t
          }))).then((function (e) {
            return r && s._resolve(), s._completion.then((function () {
              return e
            }))
          })).catch((function (e) {
            return s._reject(e), Nr(e)
          }))
        }))
      }
    }, this.table = function (e) {
      if (!Lt(g, e)) throw new Cn.InvalidTable("Table " + e + " does not exist");
      return g[e]
    }, Nt(I.prototype, {
      _trans: function (e, t, n) {
        var r = this._tx || Jn.trans;
        return r && r.db === E ? r === Jn.trans ? r._promise(e, t, n) : kr((function () {
          return r._promise(e, t, n)
        }), {
          trans: r,
          transless: Jn.transless || Jn
        }) : function e(t, n, r) {
          if (S || Jn.letThrough) {
            var i = E._createTransaction(t, n, d);
            try {
              i.create()
            } catch (e) {
              return Nr(e)
            }
            return i._promise(t, (function (e, t) {
              return kr((function () {
                return Jn.trans = i, r(e, t, i)
              }))
            })).then((function (e) {
              return i._completion.then((function () {
                return e
              }))
            }))
          }
          if (!w) {
            if (!u) return Nr(new Cn.DatabaseClosed);
            E.open().catch(xn)
          }
          return k.then((function () {
            return e(t, n, r)
          }))
        }(e, [this.name], t)
      },
      _idbstore: function (e, t, n) {
        var r = this.name;
        return this._trans(e, (function (e, n, i) {
          if (-1 === i.storeNames.indexOf(r)) throw new Cn.NotFound("Table" + r + " not part of transaction");
          return t(e, n, i.idbtrans.objectStore(r), i)
        }), n)
      },
      get: function (e, t) {
        if (e && e.constructor === Object) return this.where(e).first(t);
        var n = this;
        return this._idbstore("readonly", (function (t, r, i) {
          var o = i.get(e);
          o.onerror = Qr(r), o.onsuccess = yr((function () {
            t(n.hook.reading.fire(o.result))
          }), r)
        })).then(t)
      },
      where: function (e) {
        if ("string" == typeof e) return new F(this, e);
        if (At(e)) return new F(this, "[" + e.join("+") + "]");
        var t = _t(e);
        if (1 === t.length) return this.where(t[0]).equals(e[t[0]]);
        var n = this.schema.indexes.concat(this.schema.primKey).filter((function (e) {
          return e.compound && t.every((function (t) {
            return e.keyPath.indexOf(t) >= 0
          })) && e.keyPath.every((function (e) {
            return t.indexOf(e) >= 0
          }))
        }))[0];
        if (n && zr !== Hr) return this.where(n.name).equals(n.keyPath.map((function (t) {
          return e[t]
        })));
        n || console.warn("The query " + JSON.stringify(e) + " on " + this.name + " would benefit of a compound index [" + t.join("+") + "]");
        var r = this.schema.idxByName,
          i = t.reduce((function (t, n) {
            return [t[0] || r[n], t[0] || !r[n] ? Y(t[1], (function (t) {
              return "" + Yt(t, n) == "" + e[n]
            })) : t[1]]
          }), [null, null]),
          o = i[0];
        return o ? this.where(o.name).equals(e[o.keyPath]).filter(i[1]) : n ? this.filter(i[1]) : this.where(t).equals("")
      },
      count: function (e) {
        return this.toCollection().count(e)
      },
      offset: function (e) {
        return this.toCollection().offset(e)
      },
      limit: function (e) {
        return this.toCollection().limit(e)
      },
      reverse: function () {
        return this.toCollection().reverse()
      },
      filter: function (e) {
        return this.toCollection().and(e)
      },
      each: function (e) {
        return this.toCollection().each(e)
      },
      toArray: function (e) {
        return this.toCollection().toArray(e)
      },
      orderBy: function (e) {
        return new B(new F(this, At(e) ? "[" + e.join("+") + "]" : e))
      },
      toCollection: function () {
        return new B(new F(this))
      },
      mapToClass: function (e, t) {
        this.schema.mappedClass = e;
        var n = Object.create(e.prototype);
        t && Kr(n, t), this.schema.instanceTemplate = n;
        var r = function (t) {
          if (!t) return t;
          var n = Object.create(e.prototype);
          for (var r in t)
            if (Lt(t, r)) try {
              n[r] = t[r]
            } catch (e) {}
          return n
        };
        return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = r, this.hook("reading", r), e
      },
      defineClass: function (e) {
        return this.mapToClass(qr.defineClass(e), e)
      },
      bulkDelete: function (e) {
        return this.hook.deleting.fire === xn ? this._idbstore(C, (function (t, n, r, i) {
          t(L(r, i, e, !1, xn))
        })) : this.where(":id").anyOf(e).delete().then((function () {}))
      },
      bulkPut: function (e, t) {
        var n = this;
        return this._idbstore(C, (function (r, i, o) {
          if (!o.keyPath && !n.schema.primKey.auto && !t) throw new Cn.InvalidArgument("bulkPut() with non-inbound keys requires keys array in second argument");
          if (o.keyPath && t) throw new Cn.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
          if (t && t.length !== e.length) throw new Cn.InvalidArgument("Arguments objects and keys must have the same length");
          if (0 === e.length) return r();
          var s, a, l = function (e) {
              0 === c.length ? r(e) : i(new wn(n.name + ".bulkPut(): " + c.length + " of " + u + " operations failed", c))
            },
            c = [],
            u = e.length,
            h = n;
          if (n.hook.creating.fire === xn && n.hook.updating.fire === xn) {
            a = O(c);
            for (var p = 0, d = e.length; p < d; ++p)(s = t ? o.put(e[p], t[p]) : o.put(e[p])).onerror = a;
            s.onerror = O(c, l), s.onsuccess = Zr(l)
          } else {
            var f = t || o.keyPath && e.map((function (e) {
                return Yt(e, o.keyPath)
              })),
              m = f && $t(f, (function (t, n) {
                return null != t && [t, e[n]]
              }));
            (f ? h.where(":id").anyOf(f.filter((function (e) {
              return null != e
            }))).modify((function () {
              this.value = m[this.primKey], m[this.primKey] = null
            })).catch(vn, (function (e) {
              c = e.failures
            })).then((function () {
              for (var n = [], r = t && [], i = f.length - 1; i >= 0; --i) {
                var o = f[i];
                (null == o || m[o]) && (n.push(e[i]), t && r.push(o), null != o && (m[o] = null))
              }
              return n.reverse(), t && r.reverse(), h.bulkAdd(n, r)
            })).then((function (e) {
              var t = f[f.length - 1];
              return null != t ? t : e
            })) : h.bulkAdd(e)).then(l).catch(wn, (function (e) {
              c = c.concat(e.failures), l()
            })).catch(i)
          }
        }), "locked")
      },
      bulkAdd: function (e, t) {
        var n = this,
          r = this.hook.creating.fire;
        return this._idbstore(C, (function (i, o, s, a) {
          if (!s.keyPath && !n.schema.primKey.auto && !t) throw new Cn.InvalidArgument("bulkAdd() with non-inbound keys requires keys array in second argument");
          if (s.keyPath && t) throw new Cn.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
          if (t && t.length !== e.length) throw new Cn.InvalidArgument("Arguments objects and keys must have the same length");
          if (0 === e.length) return i();

          function l(e) {
            0 === p.length ? i(e) : o(new wn(n.name + ".bulkAdd(): " + p.length + " of " + d + " operations failed", p))
          }
          var c, u, h, p = [],
            d = e.length;
          if (r !== xn) {
            var f, m = s.keyPath;
            u = O(p, null, !0), h = Yr(null), Kt((function () {
              for (var n = 0, i = e.length; n < i; ++n) {
                f = {
                  onerror: null,
                  onsuccess: null
                };
                var o = t && t[n],
                  l = e[n],
                  p = t ? o : m ? Yt(l, m) : void 0,
                  d = r.call(f, p, l, a);
                null == p && null != d && (m ? Qt(l = tn(l), m, d) : o = d), (c = null != o ? s.add(l, o) : s.add(l))._hookCtx = f, n < i - 1 && (c.onerror = u, f.onsuccess && (c.onsuccess = h))
              }
            }), (function (e) {
              throw f.onerror && f.onerror(e), e
            })), c.onerror = O(p, l, !0), c.onsuccess = Yr(l)
          } else {
            u = O(p);
            for (var g = 0, y = e.length; g < y; ++g)(c = t ? s.add(e[g], t[g]) : s.add(e[g])).onerror = u;
            c.onerror = O(p, l), c.onsuccess = Zr(l)
          }
        }))
      },
      add: function (e, t) {
        var n = this.hook.creating.fire;
        return this._idbstore(C, (function (r, i, o, s) {
          var a = {
            onsuccess: null,
            onerror: null
          };
          if (n !== xn) {
            var l = null != t ? t : o.keyPath ? Yt(e, o.keyPath) : void 0,
              c = n.call(a, l, e, s);
            null == l && null != c && (o.keyPath ? Qt(e, o.keyPath, c) : t = c)
          }
          try {
            var u = null != t ? o.add(e, t) : o.add(e);
            u._hookCtx = a, u.onerror = Xr(i), u.onsuccess = Yr((function (t) {
              var n = o.keyPath;
              n && Qt(e, n, t), r(t)
            }))
          } catch (e) {
            throw a.onerror && a.onerror(e), e
          }
        }))
      },
      put: function (e, t) {
        var n = this,
          r = this.hook.creating.fire,
          i = this.hook.updating.fire;
        if (r !== xn || i !== xn) {
          var o = this.schema.primKey.keyPath,
            s = void 0 !== t ? t : o && Yt(e, o);
          return null == s ? this.add(e) : (e = tn(e), this._trans(C, (function () {
            return n.where(":id").equals(s).modify((function () {
              this.value = e
            })).then((function (r) {
              return 0 === r ? n.add(e, t) : s
            }))
          }), "locked"))
        }
        return this._idbstore(C, (function (n, r, i) {
          var o = void 0 !== t ? i.put(e, t) : i.put(e);
          o.onerror = Qr(r), o.onsuccess = yr((function (t) {
            var r = i.keyPath;
            r && Qt(e, r, t.target.result), n(o.result)
          }))
        }))
      },
      delete: function (e) {
        return this.hook.deleting.subscribers.length ? this.where(":id").equals(e).delete() : this._idbstore(C, (function (t, n, r) {
          var i = r.delete(e);
          i.onerror = Qr(n), i.onsuccess = yr((function () {
            t(i.result)
          }))
        }))
      },
      clear: function () {
        return this.hook.deleting.subscribers.length ? this.toCollection().delete() : this._idbstore(C, (function (e, t, n) {
          var r = n.clear();
          r.onerror = Qr(t), r.onsuccess = yr((function () {
            e(r.result)
          }))
        }))
      },
      update: function (e, t) {
        if ("object" != typeof t || At(t)) throw new Cn.InvalidArgument("Modifications must be an object.");
        if ("object" != typeof e || At(e)) return this.where(":id").equals(e).modify(t);
        _t(t).forEach((function (n) {
          Qt(e, n, t[n])
        }));
        var n = Yt(e, this.schema.primKey.keyPath);
        return void 0 === n ? Nr(new Cn.InvalidArgument("Given object does not contain its primary key")) : this.where(":id").equals(n).modify(t)
      }
    }), Nt(N.prototype, {
      _lock: function () {
        return jt(!Jn.global), ++this._reculock, 1 !== this._reculock || Jn.global || (Jn.lockOwnerFor = this), this
      },
      _unlock: function () {
        if (jt(!Jn.global), 0 == --this._reculock)
          for (Jn.global || (Jn.lockOwnerFor = null); this._blockedFuncs.length > 0 && !this._locked();) {
            var e = this._blockedFuncs.shift();
            try {
              Pr(e[1], e[0])
            } catch (e) {}
          }
        return this
      },
      _locked: function () {
        return this._reculock && Jn.lockOwnerFor !== this
      },
      create: function (e) {
        var t = this;
        if (!this.mode) return this;
        if (jt(!this.idbtrans), !e && !y) switch (v && v.name) {
          case "DatabaseClosedError":
            throw new Cn.DatabaseClosed(v);
          case "MissingAPIError":
            throw new Cn.MissingAPI(v.message, v);
          default:
            throw new Cn.OpenFailed(v)
        }
        if (!this.active) throw new Cn.TransactionInactive;
        return jt(null === this._completion._state), (e = this.idbtrans = e || y.transaction(ri(this.storeNames), this.mode)).onerror = yr((function (n) {
          Jr(n), t._reject(e.error)
        })), e.onabort = yr((function (n) {
          Jr(n), t.active && t._reject(new Cn.Abort(e.error)), t.active = !1, t.on("abort").fire(n)
        })), e.oncomplete = yr((function () {
          t.active = !1, t._resolve()
        })), this
      },
      _promise: function (e, t, n) {
        var r = this;
        if (e === C && this.mode !== C) return Nr(new Cn.ReadOnly("Transaction is readonly"));
        if (!this.active) return Nr(new Cn.TransactionInactive);
        if (this._locked()) return new rr((function (i, o) {
          r._blockedFuncs.push([function () {
            r._promise(e, t, n).then(i, o)
          }, Jn])
        }));
        if (n) return kr((function () {
          var e = new rr((function (e, n) {
            r._lock();
            var i = t(e, n, r);
            i && i.then && i.then(e, n)
          }));
          return e.finally((function () {
            return r._unlock()
          })), e._lib = !0, e
        }));
        var i = new rr((function (e, n) {
          var i = t(e, n, r);
          i && i.then && i.then(e, n)
        }));
        return i._lib = !0, i
      },
      _root: function () {
        return this.parent ? this.parent._root() : this
      },
      waitFor: function (e) {
        var t = this._root();
        if (e = rr.resolve(e), t._waitingFor) t._waitingFor = t._waitingFor.then((function () {
          return e
        }));
        else {
          t._waitingFor = e, t._waitingQueue = [];
          var n = t.idbtrans.objectStore(t.storeNames[0]);
          ! function e() {
            for (++t._spinCount; t._waitingQueue.length;) t._waitingQueue.shift()();
            t._waitingFor && (n.get(-1 / 0).onsuccess = e)
          }()
        }
        var r = t._waitingFor;
        return new rr((function (n, i) {
          e.then((function (e) {
            return t._waitingQueue.push(yr(n.bind(null, e)))
          }), (function (e) {
            return t._waitingQueue.push(yr(i.bind(null, e)))
          })).finally((function () {
            t._waitingFor === r && (t._waitingFor = null)
          }))
        }))
      },
      abort: function () {
        this.active && this._reject(new Cn.Abort), this.active = !1
      },
      tables: {
        get: (o = "Transaction.tables", s = function () {
          return g
        }, function () {
          return console.warn(o + " is deprecated. See https://github.com/dfahlander/Dexie.js/wiki/Deprecations. " + dn(pn(), 1)), s.apply(this, arguments)
        })
      },
      table: function (e) {
        return new I(e, E.table(e).schema, this)
      }
    }), Nt(F.prototype, (function () {
      function e(e, t, n) {
        var r = e instanceof F ? new B(e) : e;
        return r._ctx.error = n ? new n(t) : new TypeError(t), r
      }

      function t(e) {
        return new B(e, (function () {
          return p.only("")
        })).limit(0)
      }

      function n(e, t, n, r, i, o) {
        for (var s = Math.min(e.length, r.length), a = -1, l = 0; l < s; ++l) {
          var c = t[l];
          if (c !== r[l]) return i(e[l], n[l]) < 0 ? e.substr(0, l) + n[l] + n.substr(l + 1) : i(e[l], r[l]) < 0 ? e.substr(0, l) + r[l] + n.substr(l + 1) : a >= 0 ? e.substr(0, a) + t[a] + n.substr(a + 1) : null;
          i(e[l], c) < 0 && (a = l)
        }
        return s < r.length && "next" === o ? e + n.substr(e.length) : s < e.length && "prev" === o ? e.substr(0, n.length) : a < 0 ? null : e.substr(0, a) + r[a] + n.substr(a + 1)
      }

      function r(t, r, i, o) {
        var s, a, l, c, u, h, d, f = i.length;
        if (!i.every((function (e) {
            return "string" == typeof e
          }))) return e(t, "String expected.");

        function m(e) {
          s = function (e) {
            return "next" === e ? function (e) {
              return e.toUpperCase()
            } : function (e) {
              return e.toLowerCase()
            }
          }(e), a = function (e) {
            return "next" === e ? function (e) {
              return e.toLowerCase()
            } : function (e) {
              return e.toUpperCase()
            }
          }(e), l = "next" === e ? q : K;
          var t = i.map((function (e) {
            return {
              lower: a(e),
              upper: s(e)
            }
          })).sort((function (e, t) {
            return l(e.lower, t.lower)
          }));
          c = t.map((function (e) {
            return e.upper
          })), u = t.map((function (e) {
            return e.lower
          })), h = e, d = "next" === e ? "" : o
        }
        m("next");
        var g = new B(t, (function () {
          return p.bound(c[0], u[f - 1] + o)
        }));
        g._ondirectionchange = function (e) {
          m(e)
        };
        var y = 0;
        return g._addAlgorithm((function (e, t, i) {
          var o = e.key;
          if ("string" != typeof o) return !1;
          var s = a(o);
          if (r(s, u, y)) return !0;
          for (var p = null, m = y; m < f; ++m) {
            var g = n(o, s, c[m], u[m], l, h);
            null === g && null === p ? y = m + 1 : (null === p || l(p, g) > 0) && (p = g)
          }
          return t(null !== p ? function () {
            e.continue(p + d)
          } : i), !1
        })), g
      }
      return {
        between: function (n, r, i, o) {
          i = !1 !== i, o = !0 === o;
          try {
            return V(n, r) > 0 || 0 === V(n, r) && (i || o) && (!i || !o) ? t(this) : new B(this, (function () {
              return p.bound(n, r, !i, !o)
            }))
          } catch (t) {
            return e(this, Ur)
          }
        },
        equals: function (e) {
          return new B(this, (function () {
            return p.only(e)
          }))
        },
        above: function (e) {
          return new B(this, (function () {
            return p.lowerBound(e, !0)
          }))
        },
        aboveOrEqual: function (e) {
          return new B(this, (function () {
            return p.lowerBound(e)
          }))
        },
        below: function (e) {
          return new B(this, (function () {
            return p.upperBound(e, !0)
          }))
        },
        belowOrEqual: function (e) {
          return new B(this, (function () {
            return p.upperBound(e)
          }))
        },
        startsWith: function (t) {
          return "string" != typeof t ? e(this, "String expected.") : this.between(t, t + Hr, !0, !0)
        },
        startsWithIgnoreCase: function (e) {
          return "" === e ? this.startsWith(e) : r(this, (function (e, t) {
            return 0 === e.indexOf(t[0])
          }), [e], Hr)
        },
        equalsIgnoreCase: function (e) {
          return r(this, (function (e, t) {
            return e === t[0]
          }), [e], "")
        },
        anyOfIgnoreCase: function () {
          var e = an.apply(sn, arguments);
          return 0 === e.length ? t(this) : r(this, (function (e, t) {
            return -1 !== t.indexOf(e)
          }), e, "")
        },
        startsWithAnyOfIgnoreCase: function () {
          var e = an.apply(sn, arguments);
          return 0 === e.length ? t(this) : r(this, (function (e, t) {
            return t.some((function (t) {
              return 0 === e.indexOf(t)
            }))
          }), e, Hr)
        },
        anyOf: function () {
          var n = an.apply(sn, arguments),
            r = G;
          try {
            n.sort(r)
          } catch (t) {
            return e(this, Ur)
          }
          if (0 === n.length) return t(this);
          var i = new B(this, (function () {
            return p.bound(n[0], n[n.length - 1])
          }));
          i._ondirectionchange = function (e) {
            r = "next" === e ? G : $, n.sort(r)
          };
          var o = 0;
          return i._addAlgorithm((function (e, t, i) {
            for (var s = e.key; r(s, n[o]) > 0;)
              if (++o === n.length) return t(i), !1;
            return 0 === r(s, n[o]) || (t((function () {
              e.continue(n[o])
            })), !1)
          })), i
        },
        notEqual: function (e) {
          return this.inAnyRange([
            [-1 / 0, e],
            [e, zr]
          ], {
            includeLowers: !1,
            includeUppers: !1
          })
        },
        noneOf: function () {
          var t = an.apply(sn, arguments);
          if (0 === t.length) return new B(this);
          try {
            t.sort(G)
          } catch (t) {
            return e(this, Ur)
          }
          var n = t.reduce((function (e, t) {
            return e ? e.concat([
              [e[e.length - 1][1], t]
            ]) : [
              [-1 / 0, t]
            ]
          }), null);
          return n.push([t[t.length - 1], zr]), this.inAnyRange(n, {
            includeLowers: !1,
            includeUppers: !1
          })
        },
        inAnyRange: function (n, r) {
          if (0 === n.length) return t(this);
          if (!n.every((function (e) {
              return void 0 !== e[0] && void 0 !== e[1] && G(e[0], e[1]) <= 0
            }))) return e(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", Cn.InvalidArgument);
          var i = !r || !1 !== r.includeLowers,
            o = r && !0 === r.includeUppers;
          var s, a = G;

          function l(e, t) {
            return a(e[0], t[0])
          }
          try {
            (s = n.reduce((function (e, t) {
              for (var n = 0, r = e.length; n < r; ++n) {
                var i = e[n];
                if (V(t[0], i[1]) < 0 && V(t[1], i[0]) > 0) {
                  i[0] = (o = i[0], s = t[0], V(o, s) < 0 ? o : s), i[1] = j(i[1], t[1]);
                  break
                }
              }
              var o, s;
              return n === r && e.push(t), e
            }), [])).sort(l)
          } catch (t) {
            return e(this, Ur)
          }
          var c = 0,
            u = o ? function (e) {
              return G(e, s[c][1]) > 0
            } : function (e) {
              return G(e, s[c][1]) >= 0
            },
            h = i ? function (e) {
              return $(e, s[c][0]) > 0
            } : function (e) {
              return $(e, s[c][0]) >= 0
            };
          var d = u,
            f = new B(this, (function () {
              return p.bound(s[0][0], s[s.length - 1][1], !i, !o)
            }));
          return f._ondirectionchange = function (e) {
            "next" === e ? (d = u, a = G) : (d = h, a = $), s.sort(l)
          }, f._addAlgorithm((function (e, t, n) {
            for (var r = e.key; d(r);)
              if (++c === s.length) return t(n), !1;
            return !! function (e) {
              return !u(e) && !h(e)
            }(r) || (0 === V(r, s[c][1]) || 0 === V(r, s[c][0]) || t((function () {
              a === G ? e.continue(s[c][0]) : e.continue(s[c][1])
            })), !1)
          })), f
        },
        startsWithAnyOf: function () {
          var n = an.apply(sn, arguments);
          return n.every((function (e) {
            return "string" == typeof e
          })) ? 0 === n.length ? t(this) : this.inAnyRange(n.map((function (e) {
            return [e, e + Hr]
          }))) : e(this, "startsWithAnyOf() only works with strings")
        }
      }
    })), Nt(B.prototype, (function () {
      function e(e, t) {
        e.filter = Y(e.filter, t)
      }

      function t(e, t, n) {
        var r = e.replayFilter;
        e.replayFilter = r ? function () {
          return Y(r(), t())
        } : t, e.justLimit = n && !r
      }

      function n(e, t) {
        if (e.isPrimKey) return t;
        var n = e.table.schema.idxByName[e.index];
        if (!n) throw new Cn.Schema("KeyPath " + e.index + " on object store " + t.name + " is not indexed");
        return t.index(n.name)
      }

      function r(e, t) {
        var r = n(e, t);
        return e.keysOnly && "openKeyCursor" in r ? r.openKeyCursor(e.range || null, e.dir + e.unique) : r.openCursor(e.range || null, e.dir + e.unique)
      }

      function o(e, t, n, i, o) {
        var s = e.replayFilter ? Y(e.filter, e.replayFilter()) : e.filter;
        e.or ? function () {
          var a = {},
            l = 0;

          function c() {
            2 == ++l && n()
          }

          function u(e, n, r) {
            if (!s || s(n, r, c, i)) {
              var o = n.primaryKey,
                l = "" + o;
              "[object ArrayBuffer]" === l && (l = "" + new Uint8Array(o)), Lt(a, l) || (a[l] = !0, t(e, n, r))
            }
          }
          e.or._iterate(u, c, i, o), W(r(e, o), e.algorithm, u, c, i, !e.keysOnly && e.valueMapper)
        }() : W(r(e, o), Y(e.algorithm, s), t, n, i, !e.keysOnly && e.valueMapper)
      }
      return {
        _read: function (e, t) {
          var n = this._ctx;
          return n.error ? n.table._trans(null, Nr.bind(null, n.error)) : n.table._idbstore("readonly", e).then(t)
        },
        _write: function (e) {
          var t = this._ctx;
          return t.error ? t.table._trans(null, Nr.bind(null, t.error)) : t.table._idbstore(C, e, "locked")
        },
        _addAlgorithm: function (e) {
          var t = this._ctx;
          t.algorithm = Y(t.algorithm, e)
        },
        _iterate: function (e, t, n, r) {
          return o(this._ctx, e, t, n, r)
        },
        clone: function (e) {
          var t = Object.create(this.constructor.prototype),
            n = Object.create(this._ctx);
          return e && Pt(n, e), t._ctx = n, t
        },
        raw: function () {
          return this._ctx.valueMapper = null, this
        },
        each: function (e) {
          var t = this._ctx;
          return this._read((function (n, r, i) {
            o(t, e, n, r, i)
          }))
        },
        count: function (e) {
          var t = this._ctx;
          if (H(t, !0)) return this._read((function (e, r, i) {
            var o = n(t, i),
              s = t.range ? o.count(t.range) : o.count();
            s.onerror = Qr(r), s.onsuccess = function (n) {
              e(Math.min(n.target.result, t.limit))
            }
          }), e);
          var r = 0;
          return this._read((function (e, n, i) {
            o(t, (function () {
              return ++r, !1
            }), (function () {
              e(r)
            }), n, i)
          }), e)
        },
        sortBy: function (e, t) {
          var n = e.split(".").reverse(),
            r = n[0],
            i = n.length - 1;

          function o(e, t) {
            return t ? o(e[n[t]], t - 1) : e[r]
          }
          var s = "next" === this._ctx.dir ? 1 : -1;

          function a(e, t) {
            var n = o(e, i),
              r = o(t, i);
            return n < r ? -s : n > r ? s : 0
          }
          return this.toArray((function (e) {
            return e.sort(a)
          })).then(t)
        },
        toArray: function (e) {
          var t = this._ctx;
          return this._read((function (e, r, s) {
            if (i && "next" === t.dir && H(t, !0) && t.limit > 0) {
              var a = t.table.hook.reading.fire,
                l = n(t, s),
                c = t.limit < 1 / 0 ? l.getAll(t.range, t.limit) : l.getAll(t.range);
              c.onerror = Qr(r), c.onsuccess = Zr(a === Tn ? e : function (t) {
                try {
                  e(t.map(a))
                } catch (e) {
                  r(e)
                }
              })
            } else {
              var u = [];
              o(t, (function (e) {
                u.push(e)
              }), (function () {
                e(u)
              }), r, s)
            }
          }), e)
        },
        offset: function (e) {
          var n = this._ctx;
          return e <= 0 || (n.offset += e, H(n) ? t(n, (function () {
            var t = e;
            return function (e, n) {
              return 0 === t || (1 === t ? (--t, !1) : (n((function () {
                e.advance(t), t = 0
              })), !1))
            }
          })) : t(n, (function () {
            var t = e;
            return function () {
              return --t < 0
            }
          }))), this
        },
        limit: function (e) {
          return this._ctx.limit = Math.min(this._ctx.limit, e), t(this._ctx, (function () {
            var t = e;
            return function (e, n, r) {
              return --t <= 0 && n(r), t >= 0
            }
          }), !0), this
        },
        until: function (t, n) {
          return e(this._ctx, (function (e, r, i) {
            return !t(e.value) || (r(i), n)
          })), this
        },
        first: function (e) {
          return this.limit(1).toArray((function (e) {
            return e[0]
          })).then(e)
        },
        last: function (e) {
          return this.reverse().first(e)
        },
        filter: function (t) {
          return e(this._ctx, (function (e) {
              return t(e.value)
            })),
            function (e, t) {
              e.isMatch = Y(e.isMatch, t)
            }(this._ctx, t), this
        },
        and: function (e) {
          return this.filter(e)
        },
        or: function (e) {
          return new F(this._ctx.table, e, this)
        },
        reverse: function () {
          return this._ctx.dir = "prev" === this._ctx.dir ? "next" : "prev", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this
        },
        desc: function () {
          return this.reverse()
        },
        eachKey: function (e) {
          var t = this._ctx;
          return t.keysOnly = !t.isMatch, this.each((function (t, n) {
            e(n.key, n)
          }))
        },
        eachUniqueKey: function (e) {
          return this._ctx.unique = "unique", this.eachKey(e)
        },
        eachPrimaryKey: function (e) {
          var t = this._ctx;
          return t.keysOnly = !t.isMatch, this.each((function (t, n) {
            e(n.primaryKey, n)
          }))
        },
        keys: function (e) {
          var t = this._ctx;
          t.keysOnly = !t.isMatch;
          var n = [];
          return this.each((function (e, t) {
            n.push(t.key)
          })).then((function () {
            return n
          })).then(e)
        },
        primaryKeys: function (e) {
          var t = this._ctx;
          if (i && "next" === t.dir && H(t, !0) && t.limit > 0) return this._read((function (e, r, i) {
            var o = n(t, i),
              s = t.limit < 1 / 0 ? o.getAllKeys(t.range, t.limit) : o.getAllKeys(t.range);
            s.onerror = Qr(r), s.onsuccess = Zr(e)
          })).then(e);
          t.keysOnly = !t.isMatch;
          var r = [];
          return this.each((function (e, t) {
            r.push(t.primaryKey)
          })).then((function () {
            return r
          })).then(e)
        },
        uniqueKeys: function (e) {
          return this._ctx.unique = "unique", this.keys(e)
        },
        firstKey: function (e) {
          return this.limit(1).keys((function (e) {
            return e[0]
          })).then(e)
        },
        lastKey: function (e) {
          return this.reverse().firstKey(e)
        },
        distinct: function () {
          var t = this._ctx,
            n = t.index && t.table.schema.idxByName[t.index];
          if (!n || !n.multi) return this;
          var r = {};
          return e(this._ctx, (function (e) {
            var t = e.primaryKey.toString(),
              n = Lt(r, t);
            return r[t] = !0, !n
          })), this
        },
        modify: function (e) {
          var t = this,
            n = this._ctx.table.hook,
            r = n.updating.fire,
            i = n.deleting.fire;
          return this._write((function (n, o, s, a) {
            var l;
            if ("function" == typeof e) l = r === xn && i === xn ? e : function (t) {
              var n = tn(t);
              if (!1 === e.call(this, t, this)) return !1;
              if (Lt(this, "value")) {
                var o = nn(n, this.value),
                  s = r.call(this, o, this.primKey, n, a);
                s && (t = this.value, _t(s).forEach((function (e) {
                  Qt(t, e, s[e])
                })))
              } else i.call(this, this.primKey, t, a)
            };
            else if (r === xn) {
              var c = _t(e),
                u = c.length;
              l = function (t) {
                for (var n = !1, r = 0; r < u; ++r) {
                  var i = c[r],
                    o = e[i];
                  Yt(t, i) !== o && (Qt(t, i, o), n = !0)
                }
                return n
              }
            } else {
              var h = e;
              e = Zt(h), l = function (t) {
                var n = !1,
                  i = r.call(this, e, this.primKey, tn(t), a);
                return i && Pt(e, i), _t(e).forEach((function (r) {
                  var i = e[r];
                  Yt(t, r) !== i && (Qt(t, r, i), n = !0)
                })), i && (e = Zt(h)), n
              }
            }
            var p = 0,
              d = 0,
              f = !1,
              m = [],
              g = [],
              y = null;

            function v(e) {
              return e && (m.push(e), g.push(y)), o(new vn("Error modifying one or more objects", m, d, g))
            }

            function w() {
              f && d + m.length === p && (m.length > 0 ? v() : n(d))
            }
            t.clone().raw()._iterate((function (e, t) {
              y = t.primaryKey;
              var n = {
                primKey: t.primaryKey,
                value: e,
                onsuccess: null,
                onerror: null
              };

              function r(e) {
                return m.push(e), g.push(n.primKey), w(), !0
              }
              if (!1 !== l.call(n, e, n)) {
                var i = !Lt(n, "value");
                ++p, Kt((function () {
                  var e = i ? t.delete() : t.update(n.value);
                  e._hookCtx = n, e.onerror = Xr(r), e.onsuccess = Yr((function () {
                    ++d, w()
                  }))
                }), r)
              } else n.onsuccess && n.onsuccess(n.value)
            }), (function () {
              f = !0, w()
            }), v, s)
          }))
        },
        delete: function () {
          var e = this,
            t = this._ctx,
            n = t.range,
            r = t.table.hook.deleting.fire,
            i = r !== xn;
          if (!i && H(t) && (t.isPrimKey && !Gr || !n)) return this._write((function (e, t, r) {
            var i = Qr(t),
              o = n ? r.count(n) : r.count();
            o.onerror = i, o.onsuccess = function () {
              var s = o.result;
              Kt((function () {
                var t = n ? r.delete(n) : r.clear();
                t.onerror = i, t.onsuccess = function () {
                  return e(s)
                }
              }), (function (e) {
                return t(e)
              }))
            }
          }));
          var o = i ? 2e3 : 1e4;
          return this._write((function (n, s, a, l) {
            var c = 0,
              u = e.clone({
                keysOnly: !t.isMatch && !i
              }).distinct().limit(o).raw(),
              h = [],
              p = function () {
                return u.each(i ? function (e, t) {
                  h.push([t.primaryKey, t.value])
                } : function (e, t) {
                  h.push(t.primaryKey)
                }).then((function () {
                  return i ? h.sort((function (e, t) {
                    return G(e[0], t[0])
                  })) : h.sort(G), L(a, l, h, i, r)
                })).then((function () {
                  var e = h.length;
                  return c += e, h = [], e < o ? c : p()
                }))
              };
            n(p())
          }))
        }
      }
    })), Pt(this, {
      Collection: B,
      Table: I,
      Transaction: N,
      Version: D,
      WhereClause: F
    }), E.on("versionchange", (function (e) {
      e.newVersion > 0 ? console.warn("Another connection wants to upgrade database '" + E.name + "'. Closing db now to resume the upgrade.") : console.warn("Another connection wants to delete database '" + E.name + "'. Closing db now to resume the delete request."), E.close()
    })), E.on("blocked", (function (e) {
      !e.newVersion || e.newVersion < e.oldVersion ? console.warn("Dexie.delete('" + E.name + "') was blocked") : console.warn("Upgrade '" + E.name + "' blocked by other connection holding version " + e.oldVersion / 10)
    })), c.forEach((function (e) {
      e(E)
    }))
  }

  function Kr(e, t) {
    return _t(t).forEach((function (n) {
      var r = function e(t) {
        if ("function" == typeof t) return new t;
        if (At(t)) return [e(t[0])];
        if (t && "object" == typeof t) {
          var n = {};
          return Kr(n, t), n
        }
        return t
      }(t[n]);
      e[n] = r
    })), e
  }

  function Yr(e) {
    return yr((function (t) {
      var n = t.target,
        r = n._hookCtx,
        i = r.value || n.result,
        o = r && r.onsuccess;
      o && o(i), e && e(i)
    }), e)
  }

  function Qr(e) {
    return yr((function (t) {
      return Jr(t), e(t.target.error), !1
    }))
  }

  function Zr(e) {
    return yr((function (t) {
      e(t.target.result)
    }))
  }

  function Xr(e) {
    return yr((function (t) {
      var n = t.target,
        r = n.error,
        i = n._hookCtx,
        o = i && i.onerror;
      return o && o(r), Jr(t), e(r), !1
    }))
  }

  function Jr(e) {
    e.stopPropagation && e.stopPropagation(), e.preventDefault && e.preventDefault()
  }

  function ei(e) {
    var t = function (t) {
        return e.next(t)
      },
      n = i(t),
      r = i((function (t) {
        return e.throw(t)
      }));

    function i(e) {
      return function (t) {
        var i = e(t),
          o = i.value;
        return i.done ? o : o && "function" == typeof o.then ? o.then(n, r) : At(o) ? rr.all(o).then(n, r) : n(o)
      }
    }
    return i(t)()
  }

  function ti(e, t, n, r, i, o, s) {
    this.name = e, this.keyPath = t, this.unique = n, this.multi = r, this.auto = i, this.compound = o, this.dotted = s;
    var a = "string" == typeof t ? t : t && "[" + [].join.call(t, "+") + "]";
    this.src = (n ? "&" : "") + (r ? "*" : "") + (i ? "++" : "") + a
  }

  function ni(e, t, n, r) {
    this.name = e, this.primKey = t || new ti, this.indexes = n || [new ti], this.instanceTemplate = r, this.mappedClass = null, this.idxByName = $t(n, (function (e) {
      return [e.name, e]
    }))
  }

  function ri(e) {
    return 1 === e.length ? e[0] : e
  }

  function ii(e) {
    var t = e && (e.getDatabaseNames || e.webkitGetDatabaseNames);
    return t && t.bind(e)
  }
  cn(ln, $r), Nt(qr, kn), Nt(qr, {
      delete: function (e) {
        var t = new qr(e),
          n = t.delete();
        return n.onblocked = function (e) {
          return t.on("blocked", e), this
        }, n
      },
      exists: function (e) {
        return new qr(e).open().then((function (e) {
          return e.close(), !0
        })).catch(qr.NoSuchDatabaseError, (function () {
          return !1
        }))
      },
      getDatabaseNames: function (e) {
        var t = ii(qr.dependencies.indexedDB);
        return t ? new rr((function (e, n) {
          var r = t();
          r.onsuccess = function (t) {
            e(Wt(t.target.result, 0))
          }, r.onerror = Qr(n)
        })).then(e) : Br.dbnames.toCollection().primaryKeys(e)
      },
      defineClass: function () {
        return function (e) {
          e && Pt(this, e)
        }
      },
      applyStructure: Kr,
      ignoreTransaction: function (e) {
        return Jn.trans ? Pr(Jn.transless, e) : e()
      },
      vip: function (e) {
        return kr((function () {
          return Jn.letThrough = !0, e()
        }))
      },
      async: function (e) {
        return function () {
          try {
            var t = ei(e.apply(this, arguments));
            return t && "function" == typeof t.then ? t : rr.resolve(t)
          } catch (e) {
            return Nr(e)
          }
        }
      },
      spawn: function (e, t, n) {
        try {
          var r = ei(e.apply(n, t || []));
          return r && "function" == typeof r.then ? r : rr.resolve(r)
        } catch (e) {
          return Nr(e)
        }
      },
      currentTransaction: {
        get: function () {
          return Jn.trans || null
        }
      },
      waitFor: function (e, t) {
        var n = rr.resolve("function" == typeof e ? qr.ignoreTransaction(e) : e).timeout(t || 6e4);
        return Jn.trans ? Jn.trans.waitFor(n) : n
      },
      Promise: rr,
      debug: {
        get: function () {
          return ln
        },
        set: function (e) {
          cn(e, "dexie" === e ? function () {
            return !0
          } : $r)
        }
      },
      derive: Ht,
      extend: Pt,
      props: Nt,
      override: Vt,
      Events: Fr,
      getByKeyPath: Yt,
      setByKeyPath: Qt,
      delByKeyPath: function (e, t) {
        "string" == typeof t ? Qt(e, t, void 0) : "length" in t && [].map.call(t, (function (t) {
          Qt(e, t, void 0)
        }))
      },
      shallowClone: Zt,
      deepClone: tn,
      getObjectDiff: nn,
      asap: Gt,
      maxKey: zr,
      minKey: -1 / 0,
      addons: [],
      connections: Wr,
      MultiModifyError: Cn.Modify,
      errnames: bn,
      IndexSpec: ti,
      TableSchema: ni,
      dependencies: function () {
        try {
          return {
            indexedDB: Mt.indexedDB || Mt.mozIndexedDB || Mt.webkitIndexedDB || Mt.msIndexedDB,
            IDBKeyRange: Mt.IDBKeyRange || Mt.webkitIDBKeyRange
          }
        } catch (e) {
          return {
            indexedDB: null,
            IDBKeyRange: null
          }
        }
      }(),
      semVer: "{version}",
      version: "{version}".split(".").map((function (e) {
        return parseInt(e)
      })).reduce((function (e, t, n) {
        return e + t / Math.pow(10, 2 * n)
      })),
      default: qr,
      Dexie: qr
    }), rr.rejectionMapper = function (e, t) {
      if (!e || e instanceof yn || e instanceof TypeError || e instanceof SyntaxError || !e.name || !En[e.name]) return e;
      var n = new En[e.name](t || e.message, e);
      return "stack" in e && Bt(n, "stack", {
        get: function () {
          return this.inner.stack
        }
      }), n
    }, (Br = new qr("__dbnames")).version(1).stores({
      dbnames: "name"
    }),
    function () {
      try {
        void 0 !== typeof localStorage && void 0 !== Mt.document && (JSON.parse(localStorage.getItem("Dexie.DatabaseNames") || "[]").forEach((function (e) {
          return Br.dbnames.put({
            name: e
          }).catch(xn)
        })), localStorage.removeItem("Dexie.DatabaseNames"))
      } catch (e) {}
    }();
  var oi = qr;

  function si() {
    return me("has-shown-welcome-flow", !1)
  }
  var ai = n(124);
  n(166);

  function li() {
    return "Windows " + Re.release()
  }
  let ci = null;

  function ui() {
    if (!ci) {
      let e = localStorage.getItem("stats-guid");
      e || (e = Ye(), localStorage.setItem("stats-guid", e)), ci = e
    }
    return ci
  }

  function hi(e, t) {
    const n = Object.assign({}, e);
    for (const e in t) n[e] = t[e];
    return n
  }
  var pi;

  function di(e) {
    switch (e) {
      case pi.Light:
        return "light";
      case pi.Dark:
        return "dark";
      default:
        return X(0, "Unknown theme " + e)
    }
  }! function (e) {
    e[e.Light = 0] = "Light", e[e.Dark = 1] = "Dark"
  }(pi || (pi = {}));

  function fi() {
    return "dark" === localStorage.getItem("theme") ? pi.Dark : pi.Light
  }

  function mi(e) {
    localStorage.setItem("theme", di(e))
  }

  function gi(e) {
    return yi(e.endpoint)
  }

  function yi(e) {
    return "GitHub - " + e
  }
  class vi {
    constructor() {
      this.emitter = new ne.Emitter
    }
    emitUpdate() {
      this.emitter.emit("did-update", {})
    }
    emitError(e) {
      this.emitter.emit("did-error", e)
    }
    onDidUpdate(e) {
      return this.emitter.on("did-update", e)
    }
    onDidError(e) {
      return this.emitter.on("did-error", e)
    }
  }
  class wi {
    constructor() {
      this.emitter = new ne.Emitter
    }
    emitUpdate(e) {
      this.emitter.emit("did-update", e)
    }
    emitError(e) {
      this.emitter.emit("did-error", e)
    }
    onDidUpdate(e) {
      return this.emitter.on("did-update", e)
    }
    onDidError(e) {
      return this.emitter.on("did-error", e)
    }
  }
  var bi, Si, Ci = n(3),
    Ei = n(125);

  function ki(e, t = new Map) {
    for (const n of e.items) t.set(n.id, n), "submenuItem" === n.type && ki(n.menu, t);
    return t
  }

  function xi(e) {
    return "menuItem" === e.type || "submenuItem" === e.type || "checkbox" === e.type || "radio" === e.type
  }

  function Ti(e) {
    return "separator" !== e.type && e.enabled && e.visible
  }

  function Ri(e, t) {
    const n = e.toLowerCase();
    for (const e of t)
      if (xi(e) && e.accessKey && e.accessKey.toLowerCase() === n) return e;
    return null
  }
  class Di {
    constructor(e, t, n) {
      this.menu = e, this.openMenus = t, this.menuItemById = n
    }
    static fromMenu(e) {
      const t = ki(e);
      return new Di(e, [e], t)
    }
    getItemById(e) {
      return this.menuItemById.get(e)
    }
    withMenu(e) {
      const t = ki(e),
        n = new Array;
      for (const r of this.openMenus) {
        let i;
        if (r.id) {
          const e = t.get(r.id);
          if (!e || "submenuItem" !== e.type) break;
          i = e.menu
        } else i = e;
        let o = void 0;
        r.selectedItem && (o = t.get(r.selectedItem.id)), n.push({
          id: i.id,
          type: "menu",
          items: i.items,
          selectedItem: o
        })
      }
      return new Di(e, n, t)
    }
    withOpenedMenu(e, t = !1) {
      const n = this.menuItemById.get(e.id);
      if (!n) return this;
      if ("submenuItem" !== n.type) throw new Error("Attempt to open a submenu from an item of wrong type: " + n.type);
      const r = this.openMenus.findIndex(e => -1 !== e.items.indexOf(n));
      if (-1 === r) return this;
      const i = this.openMenus.slice(0, r + 1);
      if (t) {
        const e = n.menu.items.find(Ti);
        i.push(Object.assign(Object.assign({}, n.menu), {
          selectedItem: e
        }))
      } else i.push(n.menu);
      return new Di(this.menu, i, this.menuItemById)
    }
    withClosedMenu(e) {
      if (!e.id) return this;
      const t = this.openMenus.findIndex(t => t.id === e.id);
      if (-1 === t) return this;
      const n = this.openMenus.slice(0, t);
      return new Di(this.menu, n, this.menuItemById)
    }
    withLastMenu(e) {
      const t = this.openMenus.findIndex(t => t.id === e.id);
      if (-1 === t) return this;
      const n = this.openMenus.slice(0, t + 1);
      return new Di(this.menu, n, this.menuItemById)
    }
    withSelectedItem(e) {
      const t = this.menuItemById.get(e.id);
      if (!t) return this;
      const n = this.openMenus.findIndex(e => -1 !== e.items.indexOf(t));
      if (-1 === n) return this;
      const r = this.openMenus.slice(),
        i = r[n];
      r[n] = Object.assign(Object.assign({}, i), {
        selectedItem: t
      });
      for (let e = n + 1; e < r.length; e++) r[e] = Object.assign(Object.assign({}, r[e]), {
        selectedItem: void 0
      });
      for (let e = n - 1; e >= 0; e--) {
        const t = r[e],
          n = r[e + 1],
          i = t.items.find(e => "submenuItem" === e.type && e.id === n.id);
        r[e] = Object.assign(Object.assign({}, t), {
          selectedItem: i
        })
      }
      return new Di(this.menu, r, this.menuItemById)
    }
    withDeselectedMenu(e) {
      const t = this.openMenus.findIndex(t => t.id === e.id);
      if (-1 === t) return this;
      const n = this.openMenus[t],
        r = this.openMenus.slice();
      r[t] = Object.assign(Object.assign({}, n), {
        selectedItem: void 0
      });
      for (let e = t - 1; e >= 0; e--) {
        const t = r[e],
          n = r[e + 1],
          i = t.items.find(e => "submenuItem" === e.type && e.id === n.id);
        r[e] = Object.assign(Object.assign({}, t), {
          selectedItem: i
        })
      }
      return new Di(this.menu, r, this.menuItemById)
    }
    withReset() {
      return new Di(this.menu, [this.menu], this.menuItemById)
    }
  }! function (e) {
    e[e.Branches = 0] = "Branches", e[e.PullRequests = 1] = "PullRequests"
  }(bi || (bi = {})),
  function (e) {
    e[e.DotCom = 0] = "DotCom", e[e.Enterprise = 1] = "Enterprise", e[e.Generic = 2] = "Generic"
  }(Si || (Si = {}));
  let _i = 1;
  class Ai {
    constructor(e, t) {
      this.path = e, this.url = t, this.id = _i++
    }
    get name() {
      return i.basename(this.url, ".git")
    }
    get hash() {
      return `${this.id}+${this.path}+${this.url}`
    }
  }
  var Mi, Pi, Ii, Oi, Li;

  function Ni(e) {
    switch (e.trim()) {
      case "CR":
        return "CR";
      case "LF":
        return "LF";
      case "CRLF":
        return "CRLF";
      default:
        return null
    }
  }! function (e) {
    e[e.Text = 0] = "Text", e[e.Image = 1] = "Image", e[e.Binary = 2] = "Binary", e[e.Submodule = 3] = "Submodule", e[e.LargeText = 4] = "LargeText", e[e.Unrenderable = 5] = "Unrenderable"
  }(Mi || (Mi = {})),
  function (e) {
    e[e.Context = 0] = "Context", e[e.Add = 1] = "Add", e[e.Delete = 2] = "Delete", e[e.Hunk = 3] = "Hunk"
  }(Pi || (Pi = {}));
  class Fi {
    constructor(e, t, n, r, i = !1) {
      this.text = e, this.type = t, this.oldLineNumber = n, this.newLineNumber = r, this.noTrailingNewLine = i
    }
    withNoTrailingNewLine(e) {
      return new Fi(this.text, this.type, this.oldLineNumber, this.newLineNumber, e)
    }
    isIncludeableLine() {
      return this.type === Pi.Add || this.type === Pi.Delete
    }
    get content() {
      return this.text.substr(1)
    }
  }

  function Bi(e, t) {
    switch (e) {
      case Ii.All:
        return t;
      case Ii.None:
        return !t;
      case Ii.Partial:
        return !1;
      default:
        return X(0, "Unknown selection type " + e)
    }
  }! function (e) {
    e.All = "All", e.Partial = "Partial", e.None = "None"
  }(Ii || (Ii = {}));
  class Hi {
    constructor(e, t = null, n = null) {
      this.defaultSelectionType = e, this.divergingLines = t, this.selectableLines = n
    }
    static fromInitialSelection(e) {
      return e !== Ii.All && e !== Ii.None ? X(0, "Can only instantiate a DiffSelection with All or None as the initial selection") : new Hi(e, null, null)
    }
    getSelectionType() {
      const e = this.divergingLines,
        t = this.selectableLines;
      if (!e) return this.defaultSelectionType;
      if (0 === e.size) return this.defaultSelectionType;
      if (t && t.size === e.size) {
        if ([...t].every(t => e.has(t))) return this.defaultSelectionType === Ii.All ? Ii.None : Ii.All
      }
      return Ii.Partial
    }
    isSelected(e) {
      const t = !!this.divergingLines && this.divergingLines.has(e);
      return this.defaultSelectionType === Ii.All ? !t : this.defaultSelectionType === Ii.None ? t : X(this.defaultSelectionType, "Unknown base selection type " + this.defaultSelectionType)
    }
    isSelectable(e) {
      return !this.selectableLines || this.selectableLines.has(e)
    }
    withLineSelection(e, t) {
      return this.withRangeSelection(e, 1, t)
    }
    withRangeSelection(e, t, n) {
      const r = this.getSelectionType(),
        i = e + t;
      if (Bi(r, n)) return this;
      if (r === Ii.Partial) {
        const t = new Set(this.divergingLines);
        if (Bi(this.defaultSelectionType, n))
          for (let n = e; n < i; n++) t.delete(n);
        else
          for (let n = e; n < i; n++) this.isSelectable(n) && t.add(n);
        return new Hi(this.defaultSelectionType, 0 === t.size ? null : t, this.selectableLines)
      } {
        const t = new Set;
        for (let n = e; n < i; n++) this.isSelectable(n) && t.add(n);
        return new Hi(r, t, this.selectableLines)
      }
    }
    withToggleLineSelection(e) {
      return this.withLineSelection(e, !this.isSelected(e))
    }
    withSelectAll() {
      return new Hi(Ii.All, null, this.selectableLines)
    }
    withSelectNone() {
      return new Hi(Ii.None, null, this.selectableLines)
    }
    withSelectableLines(e) {
      const t = this.divergingLines ? new Set([...this.divergingLines].filter(t => e.has(t))) : null;
      return new Hi(this.defaultSelectionType, t, e)
    }
  }
  class zi {
    constructor(e, t, n) {
      this.contents = e, this.mediaType = t, this.bytes = n
    }
  }
  class Ui {
    constructor(e, t, n, r) {
      this.header = e, this.lines = t, this.unifiedDiffStart = n, this.unifiedDiffEnd = r
    }
  }
  class Wi {
    constructor(e, t, n, r) {
      this.oldStartLine = e, this.oldLineCount = t, this.newStartLine = n, this.newLineCount = r
    }
  }! function (e) {
    e[e.TwoUp = 0] = "TwoUp", e[e.Swipe = 1] = "Swipe", e[e.OnionSkin = 2] = "OnionSkin", e[e.Difference = 3] = "Difference"
  }(Oi || (Oi = {})),
  function (e) {
    e[e.BackgroundTask = 0] = "BackgroundTask", e[e.UserInitiatedTask = 1] = "UserInitiatedTask"
  }(Li || (Li = {}));
  class Vi {
    constructor(e, t, n, r = null, i = null, o = "master", s = null, a = null, l = null, c = null, u = null) {
      this.name = e, this.owner = t, this.dbID = n, this.isPrivate = r, this.htmlURL = i, this.defaultBranch = o, this.cloneURL = s, this.issuesEnabled = a, this.isArchived = l, this.permissions = c, this.parent = u
    }
    get endpoint() {
      return this.owner.endpoint
    }
    get fullName() {
      return `${this.owner.login}/${this.name}`
    }
    get fork() {
      return !!this.parent
    }
    get hash() {
      return `${this.dbID}+${this.defaultBranch}+${this.isPrivate}+${this.cloneURL}+${this.name}+${this.htmlURL}+${this.owner.hash}+${this.parent&&this.parent.hash}`
    }
  }

  function ji(e) {
    return null === e.permissions || "read" !== e.permissions
  }
  class Gi {
    constructor(e, t, n) {
      this.login = e, this.endpoint = t, this.id = n
    }
    get hash() {
      return `${this.login}+${this.endpoint}+${this.id}`
    }
  }
  var $i, qi, Ki, Yi, Qi, Zi;
  ! function (e) {
    e.Parent = "parent", e.Self = "self"
  }($i || ($i = {}));
  class Xi {
    constructor(e, t, n, r, o = {}, s) {
      this.id = t, this.gitHubRepository = n, this.missing = r, this.workflowPreferences = o, this._isTutorialRepository = s, this.mainWorkTree = {
        path: e
      }, this.name = n && n.name || function (e) {
        const t = i.basename(e);
        return 0 === t.length ? e : t
      }(e)
    }
    get path() {
      return this.mainWorkTree.path
    }
    get hash() {
      return `${this.id}+${this.gitHubRepository&&this.gitHubRepository.hash}+${this.path}+${this.missing}+${this.name}+${this.isTutorialRepository}+${this.workflowPreferences.forkContributionTarget}`
    }
    get isTutorialRepository() {
      return !0 === this._isTutorialRepository
    }
  }

  function Ji(e) {
    return e.gitHubRepository instanceof Vi
  }

  function eo(e) {
    return Ji(e) && null !== e.gitHubRepository.parent
  }

  function to(e) {
    const {
      gitHubRepository: t
    } = e;
    return null !== t ? t.fullName : e.name
  }

  function no(e) {
    return Ji(e) ? ro(e).htmlURL : null
  }

  function ro(e) {
    if (!eo(e)) return e.gitHubRepository;
    const t = io(e);
    switch (t) {
      case $i.Self:
        return e.gitHubRepository;
      case $i.Parent:
        return e.gitHubRepository.parent;
      default:
        return X(0, "Invalid fork contribution target")
    }
  }

  function io(e) {
    return void 0 !== e.workflowPreferences.forkContributionTarget ? e.workflowPreferences.forkContributionTarget : $i.Parent
  }

  function oo(e) {
    return e.kind === Ki.Conflicted
  }

  function so(e) {
    return e.hasOwnProperty("conflictMarkerCount")
  }

  function ao(e) {
    return !e.hasOwnProperty("conflictMarkerCount")
  }! function (e) {
    e.Modified = "M", e.Added = "A", e.Deleted = "D", e.Renamed = "R", e.Copied = "C", e.Unchanged = ".", e.Untracked = "?", e.Ignored = "!", e.UpdatedButUnmerged = "U"
  }(qi || (qi = {})),
  function (e) {
    e.New = "New", e.Modified = "Modified", e.Deleted = "Deleted", e.Copied = "Copied", e.Renamed = "Renamed", e.Conflicted = "Conflicted", e.Untracked = "Untracked"
  }(Ki || (Ki = {})),
  function (e) {
    e.AddedByUs = "added-by-us", e.DeletedByUs = "deleted-by-us", e.AddedByThem = "added-by-them", e.DeletedByThem = "deleted-by-them", e.BothDeleted = "both-deleted", e.BothAdded = "both-added", e.BothModified = "both-modified"
  }(Yi || (Yi = {}));
  class lo {
    constructor(e, t) {
      this.path = e, this.status = t, t.kind === Ki.Renamed || t.kind === Ki.Copied ? this.id = `${t.kind}+${e}+${t.oldPath}` : this.id = `${t.kind}+${e}`
    }
  }
  class co extends lo {
    constructor(e, t, n) {
      super(e, t), this.selection = n
    }
    withIncludeAll(e) {
      const t = e ? this.selection.withSelectAll() : this.selection.withSelectNone();
      return this.withSelection(t)
    }
    withSelection(e) {
      return new co(this.path, this.status, e)
    }
  }
  class uo extends lo {
    constructor(e, t, n) {
      super(e, t), this.commitish = n, this.commitish = n
    }
  }
  class ho {
    constructor(e, t = !0) {
      this.files = e, this.includeAll = t, this.fileIxById = new Map, e.forEach((e, t) => this.fileIxById.set(e.id, t))
    }
    static fromFiles(e) {
      return new ho(e, function (e) {
        if (!e.length) return !0;
        const t = e.every(e => e.selection.getSelectionType() === Ii.All),
          n = e.every(e => e.selection.getSelectionType() === Ii.None);
        let r = null;
        t ? r = !0 : n && (r = !1);
        return r
      }(e))
    }
    withIncludeAllFiles(e) {
      const t = this.files.map(t => t.withIncludeAll(e));
      return new ho(t, e)
    }
    findFileWithID(e) {
      const t = this.fileIxById.get(e);
      return void 0 !== t && this.files[t] || null
    }
    findFileIndexByID(e) {
      const t = this.fileIxById.get(e);
      return void 0 !== t ? t : -1
    }
  }

  function po() {
    return function () {
      {
        const e = Re.release();
        return void 0 !== e && Object(ai.compare)(e, "10.0.17666", ">=")
      }
    }()
  }

  function fo() {
    return !!po() && r.remote.nativeTheme.shouldUseDarkColors
  }! function (e) {
    e.Unknown = "Unknown", e.Unborn = "Unborn", e.Detached = "Detached", e.Valid = "Valid"
  }(Qi || (Qi = {})),
  function (e) {
    e[e.RenameBranch = 1] = "RenameBranch", e[e.DeleteBranch = 2] = "DeleteBranch", e[e.ConfirmDiscardChanges = 3] = "ConfirmDiscardChanges", e[e.Preferences = 4] = "Preferences", e[e.MergeBranch = 5] = "MergeBranch", e[e.RepositorySettings = 6] = "RepositorySettings", e[e.AddRepository = 7] = "AddRepository", e[e.CreateRepository = 8] = "CreateRepository", e[e.CloneRepository = 9] = "CloneRepository", e[e.CreateBranch = 10] = "CreateBranch", e[e.SignIn = 11] = "SignIn", e[e.About = 12] = "About", e[e.InstallGit = 13] = "InstallGit", e[e.PublishRepository = 14] = "PublishRepository", e[e.Acknowledgements = 15] = "Acknowledgements", e[e.UntrustedCertificate = 16] = "UntrustedCertificate", e[e.RemoveRepository = 17] = "RemoveRepository", e[e.TermsAndConditions = 18] = "TermsAndConditions", e[e.PushBranchCommits = 19] = "PushBranchCommits", e[e.CLIInstalled = 20] = "CLIInstalled", e[e.GenericGitAuthentication = 21] = "GenericGitAuthentication", e[e.ExternalEditorFailed = 22] = "ExternalEditorFailed", e[e.OpenShellFailed = 23] = "OpenShellFailed", e[e.InitializeLFS = 24] = "InitializeLFS", e[e.LFSAttributeMismatch = 25] = "LFSAttributeMismatch", e[e.UpstreamAlreadyExists = 26] = "UpstreamAlreadyExists", e[e.ReleaseNotes = 27] = "ReleaseNotes", e[e.DeletePullRequest = 28] = "DeletePullRequest", e[e.MergeConflicts = 29] = "MergeConflicts", e[e.AbortMerge = 30] = "AbortMerge", e[e.OversizedFiles = 31] = "OversizedFiles", e[e.UsageReportingChanges = 32] = "UsageReportingChanges", e[e.CommitConflictsWarning = 33] = "CommitConflictsWarning", e[e.PushNeedsPull = 34] = "PushNeedsPull", e[e.RebaseFlow = 35] = "RebaseFlow", e[e.ConfirmForcePush = 36] = "ConfirmForcePush", e[e.StashAndSwitchBranch = 37] = "StashAndSwitchBranch", e[e.ConfirmOverwriteStash = 38] = "ConfirmOverwriteStash", e[e.ConfirmDiscardStash = 39] = "ConfirmDiscardStash", e[e.CreateTutorialRepository = 40] = "CreateTutorialRepository", e[e.ConfirmExitTutorial = 41] = "ConfirmExitTutorial", e[e.PushRejectedDueToMissingWorkflowScope = 42] = "PushRejectedDueToMissingWorkflowScope", e[e.SAMLReauthRequired = 43] = "SAMLReauthRequired", e[e.CreateFork = 44] = "CreateFork", e[e.SChannelNoRevocationCheck = 45] = "SChannelNoRevocationCheck", e[e.CreateTag = 46] = "CreateTag", e[e.DeleteTag = 47] = "DeleteTag", e[e.LocalChangesOverwritten = 48] = "LocalChangesOverwritten", e[e.RebaseConflicts = 49] = "RebaseConflicts", e[e.ChooseForkSettings = 50] = "ChooseForkSettings", e[e.ConfirmDiscardSelection = 51] = "ConfirmDiscardSelection"
  }(Zi || (Zi = {}));
  const mo = new class {
    constructor() {
      this.emitter = new ne.Emitter, this.subscribe = () => {
        po() && r.remote.nativeTheme.addListener("updated", this.onThemeNotificationFromOS)
      }, this.onThemeNotificationFromOS = (e, t) => {
        const n = fo() ? pi.Dark : pi.Light;
        this.emitThemeChanged(n)
      }, this.subscribe()
    }
    dispose() {
      r.remote.nativeTheme.removeAllListeners()
    }
    onThemeChanged(e) {
      return this.emitter.on("theme-changed", e)
    }
    emitThemeChanged(e) {
      this.emitter.emit("theme-changed", e)
    }
  };
  r.remote.app.on("will-quit", () => {
    mo.dispose()
  });
  var go;
  n(53);
  ! function (e) {
    e.Atom = "Atom", e.MacVim = "MacVim", e.VSCode = "Visual Studio Code", e.VSCodeInsiders = "Visual Studio Code (Insiders)", e.VSCodium = "VSCodium", e.SublimeText = "Sublime Text", e.BBEdit = "BBEdit", e.PhpStorm = "PhpStorm", e.PyCharm = "PyCharm", e.RubyMine = "RubyMine", e.TextMate = "TextMate", e.Brackets = "Brackets", e.WebStorm = "WebStorm", e.Typora = "Typora", e.CodeRunner = "CodeRunner", e.SlickEdit = "SlickEdit", e.IntelliJ = "IntelliJ", e.Xcode = "Xcode", e.GoLand = "GoLand", e.AndroidStudio = "Android Studio", e.Rider = "Rider"
  }(go || (go = {}));
  var yo, vo, wo = n(6);

  function bo(e, t) {
    const n = e.find(e => e.name === t);
    return n && n.type === wo.RegistryValueType.REG_SZ ? n.data : ""
  }
  async function So(e) {
    const t = function (e) {
      switch (e) {
        case yo.Atom:
          return [{
            key: wo.HKEY.HKEY_CURRENT_USER,
            subKey: "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\atom"
          }];
        case yo.AtomBeta:
          return [{
            key: wo.HKEY.HKEY_CURRENT_USER,
            subKey: "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\atom-beta"
          }];
        case yo.AtomNightly:
          return [{
            key: wo.HKEY.HKEY_CURRENT_USER,
            subKey: "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\atom-nightly"
          }];
        case yo.VSCode:
          return [{
            key: wo.HKEY.HKEY_CURRENT_USER,
            subKey: "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\{771FD6B0-FA20-440A-A002-3B3BAC16DC50}_is1"
          }, {
            key: wo.HKEY.HKEY_CURRENT_USER,
            subKey: "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\{D628A17A-9713-46BF-8D57-E671B46A741E}_is1"
          }, {
            key: wo.HKEY.HKEY_LOCAL_MACHINE,
            subKey: "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\{EA457B21-F73E-494C-ACAB-524FDE069978}_is1"
          }, {
            key: wo.HKEY.HKEY_LOCAL_MACHINE,
            subKey: "SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\{F8A2A208-72B3-4D61-95FC-8A65D340689B}_is1"
          }];
        case yo.VSCodeInsiders:
          return [{
            key: wo.HKEY.HKEY_CURRENT_USER,
            subKey: "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\{217B4C08-948D-4276-BFBB-BEE930AE5A2C}_is1"
          }, {
            key: wo.HKEY.HKEY_CURRENT_USER,
            subKey: "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\{26F4A15E-E392-4887-8C09-7BC55712FD5B}_is1"
          }, {
            key: wo.HKEY.HKEY_LOCAL_MACHINE,
            subKey: "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\{1287CAD5-7C8D-410D-88B9-0D1EE4A83FF2}_is1"
          }, {
            key: wo.HKEY.HKEY_LOCAL_MACHINE,
            subKey: "SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\{C26E74D1-022E-4238-8B9D-1E7564A36CC9}_is1"
          }];
        case yo.VSCodium:
          return [{
            key: wo.HKEY.HKEY_CURRENT_USER,
            subKey: "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\{2E1F05D1-C245-4562-81EE-28188DB6FD17}_is1"
          }, {
            key: wo.HKEY.HKEY_CURRENT_USER,
            subKey: "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\{C6065F05-9603-4FC4-8101-B9781A25D88E}}_is1"
          }, {
            key: wo.HKEY.HKEY_LOCAL_MACHINE,
            subKey: "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\{D77B7E06-80BA-4137-BCF4-654B95CCEBC5}_is1"
          }, {
            key: wo.HKEY.HKEY_LOCAL_MACHINE,
            subKey: "SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\{E34003BB-9E10-4501-8C11-BE3FAA83F23F}_is1"
          }];
        case yo.SublimeText:
          return [{
            key: wo.HKEY.HKEY_LOCAL_MACHINE,
            subKey: "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\Sublime Text 3_is1"
          }];
        case yo.CFBuilder:
          return [{
            key: wo.HKEY.HKEY_LOCAL_MACHINE,
            subKey: "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\Adobe ColdFusion Builder 3_is1"
          }, {
            key: wo.HKEY.HKEY_LOCAL_MACHINE,
            subKey: "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\Adobe ColdFusion Builder 2016"
          }];
        case yo.Typora:
          return [{
            key: wo.HKEY.HKEY_LOCAL_MACHINE,
            subKey: "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\{37771A20-7167-44C0-B322-FD3E54C56156}_is1"
          }, {
            key: wo.HKEY.HKEY_LOCAL_MACHINE,
            subKey: "SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\{37771A20-7167-44C0-B322-FD3E54C56156}_is1"
          }];
        case yo.SlickEdit:
          return [{
            key: wo.HKEY.HKEY_LOCAL_MACHINE,
            subKey: "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\{18406187-F49E-4822-CAF2-1D25C0C83BA2}"
          }, {
            key: wo.HKEY.HKEY_LOCAL_MACHINE,
            subKey: "SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\{18006187-F49E-4822-CAF2-1D25C0C83BA2}"
          }, {
            key: wo.HKEY.HKEY_LOCAL_MACHINE,
            subKey: "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\{18606187-F49E-4822-CAF2-1D25C0C83BA2}"
          }, {
            key: wo.HKEY.HKEY_LOCAL_MACHINE,
            subKey: "SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\{18206187-F49E-4822-CAF2-1D25C0C83BA2}"
          }, {
            key: wo.HKEY.HKEY_LOCAL_MACHINE,
            subKey: "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\{15406187-F49E-4822-CAF2-1D25C0C83BA2}"
          }, {
            key: wo.HKEY.HKEY_LOCAL_MACHINE,
            subKey: "SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\{15006187-F49E-4822-CAF2-1D25C0C83BA2}"
          }, {
            key: wo.HKEY.HKEY_LOCAL_MACHINE,
            subKey: "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\{10C06187-F49E-4822-CAF2-1D25C0C83BA2}"
          }, {
            key: wo.HKEY.HKEY_LOCAL_MACHINE,
            subKey: "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\{10406187-F49E-4822-CAF2-1D25C0C83BA2}"
          }, {
            key: wo.HKEY.HKEY_LOCAL_MACHINE,
            subKey: "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\{0DC06187-F49E-4822-CAF2-1D25C0C83BA2}"
          }, {
            key: wo.HKEY.HKEY_LOCAL_MACHINE,
            subKey: "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\{0D406187-F49E-4822-CAF2-1D25C0C83BA2}"
          }, {
            key: wo.HKEY.HKEY_LOCAL_MACHINE,
            subKey: "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\{7CC0E567-ACD6-41E8-95DA-154CEEDB0A18}"
          }];
        case yo.Webstorm:
          return [{
            key: wo.HKEY.HKEY_LOCAL_MACHINE,
            subKey: "SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\WebStorm 2018.3"
          }, {
            key: wo.HKEY.HKEY_LOCAL_MACHINE,
            subKey: "SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\WebStorm 2019.2"
          }, {
            key: wo.HKEY.HKEY_LOCAL_MACHINE,
            subKey: "SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\WebStorm 2019.2.4"
          }, {
            key: wo.HKEY.HKEY_LOCAL_MACHINE,
            subKey: "SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\WebStorm 2019.3"
          }, {
            key: wo.HKEY.HKEY_LOCAL_MACHINE,
            subKey: "SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\WebStorm 2020.1"
          }];
        case yo.Phpstorm:
          return [{
            key: wo.HKEY.HKEY_LOCAL_MACHINE,
            subKey: "SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\PhpStorm 2019.2"
          }, {
            key: wo.HKEY.HKEY_LOCAL_MACHINE,
            subKey: "SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\PhpStorm 2019.2.4"
          }, {
            key: wo.HKEY.HKEY_LOCAL_MACHINE,
            subKey: "SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\PhpStorm 2019.3"
          }, {
            key: wo.HKEY.HKEY_LOCAL_MACHINE,
            subKey: "SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\PhpStorm 2020.1"
          }];
        case yo.NotepadPlusPlus:
          return [{
            key: wo.HKEY.HKEY_LOCAL_MACHINE,
            subKey: "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\Notepad++"
          }, {
            key: wo.HKEY.HKEY_LOCAL_MACHINE,
            subKey: "SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\Notepad++"
          }];
        case yo.Rider:
          return [{
            key: wo.HKEY.HKEY_LOCAL_MACHINE,
            subKey: "SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\JetBrains Rider 2019.3.4"
          }];
        default:
          return X(0, "Unknown external editor: " + e)
      }
    }(e);
    let n = [];
    for (const {
        key: e,
        subKey: r
      } of t)
      if (n = Object(wo.enumerateValues)(e, r), n.length > 0) break;
    if (0 === n.length) return null;
    const {
      displayName: r,
      publisher: o,
      installLocation: s
    } = function (e, t) {
      if (e === yo.Atom || e === yo.AtomBeta || e === yo.AtomNightly) {
        return {
          displayName: bo(t, "DisplayName"),
          publisher: bo(t, "Publisher"),
          installLocation: bo(t, "InstallLocation")
        }
      }
      if (e === yo.VSCode || e === yo.VSCodeInsiders) {
        return {
          displayName: bo(t, "DisplayName"),
          publisher: bo(t, "Publisher"),
          installLocation: bo(t, "InstallLocation")
        }
      }
      if (e === yo.VSCodium) {
        return {
          displayName: bo(t, "DisplayName"),
          publisher: bo(t, "Publisher"),
          installLocation: bo(t, "InstallLocation")
        }
      }
      if (e === yo.SublimeText) {
        let e = "",
          n = "",
          r = "";
        for (const i of t) "DisplayName" === i.name && i.type === wo.RegistryValueType.REG_SZ && i.data.startsWith("Sublime Text") ? e = "Sublime Text" : "Publisher" === i.name && i.type === wo.RegistryValueType.REG_SZ ? n = i.data : "InstallLocation" === i.name && i.type === wo.RegistryValueType.REG_SZ && (r = i.data);
        return {
          displayName: e,
          publisher: n,
          installLocation: r
        }
      }
      if (e === yo.CFBuilder) {
        return {
          displayName: bo(t, "DisplayName"),
          publisher: bo(t, "Publisher"),
          installLocation: bo(t, "InstallLocation")
        }
      }
      if (e === yo.Typora) {
        return {
          displayName: bo(t, "DisplayName"),
          publisher: bo(t, "Publisher"),
          installLocation: bo(t, "InstallLocation")
        }
      }
      if (e === yo.SlickEdit) {
        return {
          displayName: bo(t, "DisplayName"),
          publisher: bo(t, "Publisher"),
          installLocation: bo(t, "InstallLocation")
        }
      }
      if (e === yo.Webstorm) {
        let e = "",
          n = "",
          r = "";
        for (const i of t) "DisplayName" === i.name && i.type === wo.RegistryValueType.REG_SZ && i.data.startsWith("WebStorm ") ? e = "WebStorm" : "Publisher" === i.name && i.type === wo.RegistryValueType.REG_SZ ? n = i.data : "InstallLocation" === i.name && i.type === wo.RegistryValueType.REG_SZ && (r = i.data);
        return {
          displayName: e,
          publisher: n,
          installLocation: r
        }
      }
      if (e === yo.Phpstorm) {
        let e = "",
          n = "",
          r = "";
        for (const i of t) "DisplayName" === i.name && i.type === wo.RegistryValueType.REG_SZ && i.data.startsWith("PhpStorm ") ? e = "PhpStorm" : "Publisher" === i.name && i.type === wo.RegistryValueType.REG_SZ ? n = i.data : "InstallLocation" === i.name && i.type === wo.RegistryValueType.REG_SZ && (r = i.data);
        return {
          displayName: e,
          publisher: n,
          installLocation: r
        }
      }
      if (e === yo.NotepadPlusPlus) {
        return {
          displayName: bo(t, "DisplayName"),
          publisher: bo(t, "Publisher"),
          installLocation: bo(t, "DisplayIcon")
        }
      }
      if (e === yo.Rider) {
        let e = "",
          n = "",
          r = "";
        for (const i of t) "DisplayName" === i.name && i.type === wo.RegistryValueType.REG_SZ && i.data.startsWith("JetBrains Rider ") ? e = "JetBrains Rider" : "Publisher" === i.name && i.type === wo.RegistryValueType.REG_SZ ? n = i.data : "InstallLocation" === i.name && i.type === wo.RegistryValueType.REG_SZ && (r = i.data);
        return {
          displayName: e,
          publisher: n,
          installLocation: r
        }
      }
      return X(0, "Unknown external editor: " + e)
    }(e, n);
    if (! function (e, t, n) {
        switch (e) {
          case yo.Atom:
            return "Atom" === t && "GitHub Inc." === n;
          case yo.AtomBeta:
            return "Atom Beta" === t && "GitHub Inc." === n;
          case yo.AtomNightly:
            return "Atom Nightly" === t && "GitHub Inc." === n;
          case yo.VSCode:
            return t.startsWith("Microsoft Visual Studio Code") && "Microsoft Corporation" === n;
          case yo.VSCodeInsiders:
            return t.startsWith("Microsoft Visual Studio Code Insiders") && "Microsoft Corporation" === n;
          case yo.VSCodium:
            return "Visual Source Codium" === t && "VSCodium" === n;
          case yo.SublimeText:
            return "Sublime Text" === t && "Sublime HQ Pty Ltd" === n;
          case yo.CFBuilder:
            return ("Adobe ColdFusion Builder 3" === t || "Adobe ColdFusion Builder 2016" === t) && "Adobe Systems Incorporated" === n;
          case yo.Typora:
            return t.startsWith("Typora") && "typora.io" === n;
          case yo.SlickEdit:
            return t.startsWith("SlickEdit") && "SlickEdit Inc." === n;
          case yo.Webstorm:
            return t.startsWith("WebStorm") && "JetBrains s.r.o." === n;
          case yo.Phpstorm:
            return t.startsWith("PhpStorm") && "JetBrains s.r.o." === n;
          case yo.NotepadPlusPlus:
            return t.startsWith("Notepad++") && "Notepad++ Team" === n;
          case yo.Rider:
            return t.startsWith("JetBrains Rider") && "JetBrains s.r.o." === n;
          default:
            return X(0, "Unknown external editor: " + e)
        }
      }(e, r, o)) return log.debug(`Registry entry for ${e} did not match expected publisher settings`), null;
    const a = function (e, t) {
      switch (e) {
        case yo.Atom:
          return i.join(t, "bin", "atom.cmd");
        case yo.AtomBeta:
          return i.join(t, "bin", "atom-beta.cmd");
        case yo.AtomNightly:
          return i.join(t, "bin", "atom-nightly.cmd");
        case yo.VSCode:
          return i.join(t, "bin", "code.cmd");
        case yo.VSCodeInsiders:
          return i.join(t, "bin", "code-insiders.cmd");
        case yo.VSCodium:
          return i.join(t, "bin", "codium.cmd");
        case yo.SublimeText:
          return i.join(t, "subl.exe");
        case yo.CFBuilder:
          return i.join(t, "CFBuilder.exe");
        case yo.Typora:
          return i.join(t, "typora.exe");
        case yo.SlickEdit:
          return i.join(t, "win", "vs.exe");
        case yo.Webstorm:
          return i.join(t, "bin", "webstorm.exe");
        case yo.Phpstorm:
          return i.join(t, "bin", "phpstorm.exe");
        case yo.NotepadPlusPlus:
          return i.join(t);
        case yo.Rider:
          return i.join(t, "bin", "rider64.exe");
        default:
          return X(0, "Unknown external editor: " + e)
      }
    }(e, s);
    return await Object(Ci.pathExists)(a) ? a : (log.debug(`Command line interface for ${e} not found at '${a}'`), null)
  }

  function Co(e) {
    return function (e) {
      return e === yo.Atom ? yo.Atom : e === yo.AtomBeta ? yo.AtomBeta : e === yo.AtomNightly ? yo.AtomNightly : e === yo.VSCode ? yo.VSCode : e === yo.VSCodeInsiders ? yo.VSCodeInsiders : e === yo.VSCodium ? yo.VSCodium : e === yo.SublimeText ? yo.SublimeText : e === yo.CFBuilder ? yo.CFBuilder : e === yo.Typora ? yo.Typora : e === yo.SlickEdit ? yo.SlickEdit : e === yo.Webstorm ? yo.Webstorm : e === yo.Phpstorm ? yo.Phpstorm : e === yo.NotepadPlusPlus ? yo.NotepadPlusPlus : e === yo.Rider ? yo.Rider : null
    }(e)
  }! function (e) {
    e.Atom = "Atom", e.AtomBeta = "Atom Beta", e.AtomNightly = "Atom Nightly", e.VSCode = "Visual Studio Code", e.VSCodeInsiders = "Visual Studio Code (Insiders)", e.VSCodium = "Visual Studio Codium", e.SublimeText = "Sublime Text", e.CFBuilder = "ColdFusion Builder", e.Typora = "Typora", e.SlickEdit = "SlickEdit", e.Webstorm = "JetBrains Webstorm", e.Phpstorm = "JetBrains Phpstorm", e.NotepadPlusPlus = "Notepad++", e.Rider = "JetBrains Rider"
  }(yo || (yo = {})),
  function (e) {
    e.Atom = "Atom", e.VSCode = "Visual Studio Code", e.VSCodeInsiders = "Visual Studio Code (Insiders)", e.VSCodium = "VSCodium", e.SublimeText = "Sublime Text", e.Typora = "Typora", e.SlickEdit = "SlickEdit"
  }(vo || (vo = {}));
  class Eo extends Error {
    constructor(e, t = {}) {
      super(e), this.metadata = t
    }
  }
  let ko = null;
  async function xo() {
    return ko && ko.length > 0 || (ko = await async function () {
      const e = [],
        [t, n, r, i, o, s, a, l, c, u, h, p, d, f] = await Promise.all([So(yo.Atom), So(yo.AtomBeta), So(yo.AtomNightly), So(yo.VSCode), So(yo.VSCodeInsiders), So(yo.VSCodium), So(yo.SublimeText), So(yo.CFBuilder), So(yo.Typora), So(yo.SlickEdit), So(yo.Webstorm), So(yo.Phpstorm), So(yo.NotepadPlusPlus), So(yo.Rider)]);
      return t && e.push({
        editor: yo.Atom,
        path: t,
        usesShell: !0
      }), n && e.push({
        editor: yo.AtomBeta,
        path: n,
        usesShell: !0
      }), r && e.push({
        editor: yo.AtomNightly,
        path: r,
        usesShell: !0
      }), i && e.push({
        editor: yo.VSCode,
        path: i,
        usesShell: !0
      }), o && e.push({
        editor: yo.VSCodeInsiders,
        path: o,
        usesShell: !0
      }), s && e.push({
        editor: yo.VSCodium,
        path: s,
        usesShell: !0
      }), a && e.push({
        editor: yo.SublimeText,
        path: a,
        usesShell: !1
      }), l && e.push({
        editor: yo.CFBuilder,
        path: l,
        usesShell: !1
      }), c && e.push({
        editor: yo.Typora,
        path: c,
        usesShell: !1
      }), u && e.push({
        editor: yo.SlickEdit,
        path: u
      }), h && e.push({
        editor: yo.Webstorm,
        path: h
      }), p && e.push({
        editor: yo.Phpstorm,
        path: p
      }), d && e.push({
        editor: yo.NotepadPlusPlus,
        path: d
      }), f && e.push({
        editor: yo.Rider,
        path: f
      }), e
    }()), ko
  }
  async function To(e) {
    const t = await xo();
    if (0 === t.length) return null;
    if (e) {
      const n = t.find(t => t.editor === e) || null;
      if (!n) {
        throw new Eo(`The editor '${e}' could not be found. Please open ${"Options"} and choose an available editor.`, {
          openPreferences: !0
        })
      }
      return n
    }
    return t[0]
  }
  var Ro = n(8);
  async function Do(e, t, n) {
    const r = at.fromAccount(e);
    return !!await r.fetchRepository(t, n)
  }
  async function _o(e, t, n = Do) {
    const r = [...t, De.anonymous()],
      i = gt(e);
    if (i) {
      const e = r.find(e => {
        const t = ht(e.endpoint),
          n = Te.parse(t);
        return i.hostname === n.hostname
      }) || null;
      if (e) return e
    }
    const o = yt(e);
    if (o) {
      const {
        owner: e,
        name: t,
        hostname: i
      } = o, s = Array.from(r).sort((e, t) => e.endpoint === pt() ? e.token.length ? -1 : 1 : t.endpoint === pt() ? t.token.length ? 1 : -1 : 0);
      for (const r of s) {
        if (null != i) {
          if (Te.parse(ht(r.endpoint)).hostname !== i) continue
        }
        if (await n(r, e, t)) return r
      }
    }
    return null
  }
  var Ao = n(2),
    Mo = n(40);

  function Po(e, t) {
    return Lo(t, e.path)
  }

  function Io(e, t) {
    return Lo(e, null, void 0, t)
  }
  async function Oo(e, t, n) {
    const r = n ? {
      env: n
    } : void 0;
    await Bo(["config", "--global", "--replace-all", e, t], __dirname, "setGlobalConfigValue", r)
  }
  async function Lo(e, t, n, r) {
    const i = ["config", "-z"];
    t || i.push("--global"), void 0 !== n && i.push("--type", n), i.push(e);
    const o = await Bo(i, t || __dirname, "getConfigValueInPath", {
      successExitCodes: new Set([0, 1]),
      env: r
    });
    if (1 === o.exitCode) return null;
    return o.stdout.split("\0")[0]
  }

  function No(e) {
    return e instanceof Error && "string" == typeof e.code && "string" == typeof e.syscall
  }
  class Fo extends Error {
    constructor(e, t) {
      super(function (e) {
        const t = e.gitErrorDescription;
        return t || (e.stderr.length ? e.stderr : e.stdout.length ? e.stdout : "Unknown error")
      }(e)), this.name = "GitError", this.result = e, this.args = t
    }
  }
  async function Bo(e, t, n, r) {
    const i = {
        successExitCodes: new Set([0]),
        expectedErrors: new Set
      },
      o = Object.assign(Object.assign({}, i), r);
    o.env = Object.assign({
      TERM: "dumb"
    }, o.env);
    const s = `${n}: git ${e.join(" ")}`,
      a = await Mo.measure(s, () => Ao.GitProcess.exec(e, t, o)).catch(e => {
        if (No(e)) throw new Error(`Failed to execute ${n}: ${e.code}`);
        throw e
      }),
      l = a.exitCode;
    let c = null;
    const u = !!o.successExitCodes && o.successExitCodes.has(l);
    u || (c = Ao.GitProcess.parseError(a.stderr), c || (c = Ao.GitProcess.parseError(a.stdout)));
    const h = c ? function (e) {
        if (Ho(e)) {
          return `Authentication failed. Some common reasons include:\n\n- You are not logged in to your account: see ${"File > Options."}\n- You may need to log out and log back in to refresh your token.\n- You do not have permission to access this repository.\n- The repository is archived on GitHub. Check the repository settings to confirm you are still permitted to push commits.\n- If you use SSH authentication, check that your key is added to the ssh-agent and associated with your account.`
        }
        switch (e) {
          case Ao.GitError.SSHKeyAuditUnverified:
            return "The SSH key is unverified.";
          case Ao.GitError.RemoteDisconnection:
            return "The remote disconnected. Check your Internet connection and try again.";
          case Ao.GitError.HostDown:
            return "The host is down. Check your Internet connection and try again.";
          case Ao.GitError.RebaseConflicts:
            return "We found some conflicts while trying to rebase. Please resolve the conflicts before continuing.";
          case Ao.GitError.MergeConflicts:
            return "We found some conflicts while trying to merge. Please resolve the conflicts and commit the changes.";
          case Ao.GitError.HTTPSRepositoryNotFound:
          case Ao.GitError.SSHRepositoryNotFound:
            return "The repository does not seem to exist anymore. You may not have access, or it may have been deleted or renamed.";
          case Ao.GitError.PushNotFastForward:
            return "The repository has been updated since you last pulled. Try pulling before pushing.";
          case Ao.GitError.BranchDeletionFailed:
            return "Could not delete the branch. It was probably already deleted.";
          case Ao.GitError.DefaultBranchDeletionFailed:
            return "The branch is the repository's default branch and cannot be deleted.";
          case Ao.GitError.RevertConflicts:
            return "To finish reverting, please merge and commit the changes.";
          case Ao.GitError.EmptyRebasePatch:
            return "There aren’t any changes left to apply.";
          case Ao.GitError.NoMatchingRemoteBranch:
            return "There aren’t any remote branches that match the current branch.";
          case Ao.GitError.NothingToCommit:
            return "There are no changes to commit.";
          case Ao.GitError.NoSubmoduleMapping:
            return "A submodule was removed from .gitmodules, but the folder still exists in the repository. Delete the folder, commit the change, then try again.";
          case Ao.GitError.SubmoduleRepositoryDoesNotExist:
            return "A submodule points to a location which does not exist.";
          case Ao.GitError.InvalidSubmoduleSHA:
            return "A submodule points to a commit which does not exist.";
          case Ao.GitError.LocalPermissionDenied:
            return "Permission denied.";
          case Ao.GitError.InvalidMerge:
            return "This is not something we can merge.";
          case Ao.GitError.InvalidRebase:
            return "This is not something we can rebase.";
          case Ao.GitError.NonFastForwardMergeIntoEmptyHead:
            return "The merge you attempted is not a fast-forward, so it cannot be performed on an empty branch.";
          case Ao.GitError.PatchDoesNotApply:
            return "The requested changes conflict with one or more files in the repository.";
          case Ao.GitError.BranchAlreadyExists:
            return "A branch with that name already exists.";
          case Ao.GitError.BadRevision:
            return "Bad revision.";
          case Ao.GitError.NotAGitRepository:
            return "This is not a git repository.";
          case Ao.GitError.ProtectedBranchForcePush:
            return "This branch is protected from force-push operations.";
          case Ao.GitError.ProtectedBranchRequiresReview:
            return "This branch is protected and any changes requires an approved review. Open a pull request with changes targeting this branch instead.";
          case Ao.GitError.PushWithFileSizeExceedingLimit:
            return "The push operation includes a file which exceeds GitHub's file size restriction of 100MB. Please remove the file from history and try again.";
          case Ao.GitError.HexBranchNameRejected:
            return "The branch name cannot be a 40-character string of hexadecimal characters, as this is the format that Git uses for representing objects.";
          case Ao.GitError.ForcePushRejected:
            return "The force push has been rejected for the current branch.";
          case Ao.GitError.InvalidRefLength:
            return "A ref cannot be longer than 255 characters.";
          case Ao.GitError.CannotMergeUnrelatedHistories:
            return "Unable to merge unrelated histories in this repository.";
          case Ao.GitError.PushWithPrivateEmail:
            return "Cannot push these commits as they contain an email address marked as private on GitHub.";
          case Ao.GitError.LFSAttributeDoesNotMatch:
            return "Git LFS attribute found in global Git configuration does not match expected value.";
          case Ao.GitError.ProtectedBranchDeleteRejected:
            return "This branch cannot be deleted from the remote repository because it is marked as protected.";
          case Ao.GitError.ProtectedBranchRequiredStatus:
            return "The push was rejected by the remote server because a required status check has not been satisfied.";
          case Ao.GitError.BranchRenameFailed:
            return "The branch could not be renamed.";
          case Ao.GitError.PathDoesNotExist:
            return "The path does not exist on disk.";
          case Ao.GitError.InvalidObjectName:
            return "The object was not found in the Git repository.";
          case Ao.GitError.OutsideRepository:
            return "This path is not a valid path inside the repository.";
          case Ao.GitError.LockFileAlreadyExists:
            return "A lock file already exists in the repository, which blocks this operation from completing.";
          case Ao.GitError.NoMergeToAbort:
            return "There is no merge in progress, so there is nothing to abort.";
          case Ao.GitError.NoExistingRemoteBranch:
            return "The remote branch does not exist.";
          case Ao.GitError.LocalChangesOverwritten:
            return "Unable to switch branches as there are working directory changes which would be overwritten. Please commit or stash your changes.";
          case Ao.GitError.UnresolvedConflicts:
            return "There are unresolved conflicts in the working directory.";
          case Ao.GitError.ConfigLockFileAlreadyExists:
          case Ao.GitError.RemoteAlreadyExists:
            return null;
          case Ao.GitError.TagAlreadyExists:
            return "A tag with that name already exists";
          case Ao.GitError.MergeWithLocalChanges:
          case Ao.GitError.RebaseWithLocalChanges:
            return null;
          default:
            return X(0, "Unknown error: " + e)
        }
      }(c) : null,
      p = Object.assign(Object.assign({}, a), {
        gitError: c,
        gitErrorDescription: h,
        path: t
      });
    let d = !0;
    if (c && o.expectedErrors && (d = o.expectedErrors.has(c)), c && d || u) return p;
    const f = new Array;
    throw f.push(`\`git ${e.join(" ")}\` exited with an unexpected code: ${l}.`), a.stdout && (f.push("stdout:"), f.push(a.stdout)), a.stderr && (f.push("stderr:"), f.push(a.stderr)), c && f.push(`(The error was parsed as ${c}: ${h})`), log.error(f.join("\n")), new Fo(p, e)
  }

  function Ho(e) {
    switch (e) {
      case Ao.GitError.SSHAuthenticationFailed:
      case Ao.GitError.SSHPermissionDenied:
      case Ao.GitError.HTTPSAuthenticationFailed:
        return !0
    }
    return !1
  }

  function zo(e) {
    return e instanceof Fo && e.result.gitError === Ao.GitError.ConfigLockFileAlreadyExists
  }
  const Uo = /^error: could not lock config file (.+?): File exists$/m;

  function Wo(e) {
    const t = Uo.exec(e.stderr);
    if (null === t) return null;
    const n = t[1].replace("/", "\\");
    return i.resolve(e.path, n + ".lock")
  }
  async function Vo(e, t) {
    const n = ["-c", "credential.helper="];
    if (null === t) return n;
    if (!(t.endpoint === pt())) return n;
    const r = "protocol.version";
    return null !== (null != e ? await Po(e, r) : await Io(r)) ? n : [...n, "-c", "protocol.version=2"]
  }

  function jo(e) {
    return e.stdout.split("]")[0].split(" ")[1]
  }

  function Go(e) {
    return "co-authored-by" === e.token.toLowerCase()
  }

  function $o(e, t) {
    const n = e.split("\n"),
      r = new Array;
    for (const e of n) {
      const n = qo(e, t);
      n && r.push(n)
    }
    return r
  }

  function qo(e, t) {
    for (const n of t) {
      const t = e.indexOf(n);
      if (t > 0) return {
        token: e.substring(0, t).trim(),
        value: e.substring(t + 1).trim()
      }
    }
    return null
  }
  async function Ko(e) {
    return await Po(e, "trailer.separators") || ":"
  }
  async function Yo(e, t, n, r = !1) {
    const i = ["interpret-trailers"];
    r && i.push("--unfold");
    for (const e of n) i.push("--trailer", `${e.token}=${e.value}`);
    return (await Bo(i, e.path, "mergeTrailers", {
      stdin: t
    })).stdout
  }
  async function Qo(e, t) {
    const {
      summary: n,
      description: r,
      trailers: i
    } = t, o = `${n}\n\n${r||""}\n`.replace(/\s+$/, "\n");
    return void 0 !== i && i.length > 0 ? Yo(e, o, i) : o
  }
  var Zo = n(57);
  const Xo = {
    setItem: function (e, t, n) {
      return Zo.setPassword(e, t, n)
    },
    getItem: function (e, t) {
      return Zo.getPassword(e, t)
    },
    deleteItem: function (e, t) {
      return Zo.deletePassword(e, t)
    }
  };

  function Jo(e) {
    const t = gt(e);
    if (t) return t.hostname;
    const n = Te.parse(e).hostname;
    return n || e
  }

  function es(e) {
    return "genericGitAuth/username/" + e
  }

  function ts(e) {
    const t = es(e);
    return localStorage.getItem(t)
  }

  function ns(e, t) {
    const n = t.gitHubRepository;
    return n ? dt(e, n.endpoint) : null
  }
  class rs {
    constructor(e) {
      this.emitter = new ne.Emitter, this.state = null, this.onWatchEvent = e => {
        "change" === e && this.state && o.stat(this.path, (e, t) => {
          if (e) return;
          const n = this.state;
          n && (t.size <= n.position || (this.state = Object.assign(Object.assign({}, n), {
            position: t.size
          }), this.readChunk(t, n.position)))
        })
      }, this.path = e
    }
    onDataAvailable(e) {
      return this.emitter.on("data", e)
    }
    onError(e) {
      return this.emitter.on("error", e)
    }
    handleError(e) {
      this.state = null, this.emitter.emit("error", e)
    }
    start() {
      if (this.state) throw new Error("Tailer already running");
      try {
        const e = o.watch(this.path, this.onWatchEvent);
        e.on("error", e => {
          this.handleError(e)
        }), this.state = {
          watcher: e,
          position: 0
        }
      } catch (e) {
        this.handleError(e)
      }
    }
    readChunk(e, t) {
      const n = o.createReadStream(this.path, {
        start: t,
        end: e.size
      });
      this.emitter.emit("data", n)
    }
    stop() {
      const e = this.state;
      e && (e.watcher.close(), this.state = null)
    }
  }
  var is = n(33),
    os = n.n(is);

  function ss(e, t, n, r, i) {
    const o = `${n}: git ${e.join(" ")}`;
    return Mo.measure(o, () => new Promise((o, s) => {
      const a = Ao.GitProcess.spawn(e, t);
      a.on("error", e => {
        No(e) ? s(new Error(`Failed to execute ${n}: ${e.code}`)) : s(e)
      });
      let l = 0,
        c = !1;
      const u = new Array;
      a.stdout && a.stdout.on("data", e => {
        (!i || l < i) && (u.push(e), l += e.length), i && l >= i && !c && (a.kill(), c = !0)
      });
      const h = new Array;
      a.stderr && a.stderr.on("data", e => {
        h.push(e)
      }), a.on("close", (e, t) => {
        const n = Buffer.concat(u, i ? Math.min(i, l) : l),
          a = Buffer.concat(h);
        (r || new Set([0])).has(e) || t ? o({
          output: n,
          error: a,
          exitCode: e
        }) : s(new Error(`Git returned an unexpected exit code '${e}' which should be handled by the caller.'`))
      })
    }))
  }
  async function as(e, t, n, r) {
    const i = new Set([0, 1]),
      o = ["show", `${t}:${n}`],
      {
        output: s
      } = await ss(o, e.path, "getPartialBlobContents", i, r);
    return s
  }
  const ls = /^@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/,
    cs = new Set(["+", "-", " ", "\\"]);
  class us {
    constructor() {
      this.reset()
    }
    reset() {
      this.ls = 0, this.le = -1, this.text = ""
    }
    nextLine() {
      return this.ls = this.le + 1, !(this.ls >= this.text.length) && (this.le = this.text.indexOf("\n", this.ls), -1 === this.le && (this.le = this.text.length), this.ls !== this.le)
    }
    readLine() {
      return this.nextLine() ? this.text.substring(this.ls, this.le) : null
    }
    lineStartsWith(e) {
      return this.text.startsWith(e, this.ls)
    }
    lineEndsWith(e) {
      return this.text.endsWith(e, this.le)
    }
    peek() {
      const e = this.le + 1;
      return e < this.text.length ? this.text[e] : null
    }
    parseDiffHeader() {
      for (; this.nextLine();) {
        if (this.lineStartsWith("Binary files ") && this.lineEndsWith("differ")) return {
          isBinary: !0
        };
        if (this.lineStartsWith("+++")) return {
          isBinary: !1
        }
      }
      return null
    }
    numberFromGroup(e, t, n = null) {
      const r = e[t];
      if (!r) {
        if (!n) throw new Error(`Group ${t} missing from regexp match and no defaultValue was provided`);
        return n
      }
      const i = parseInt(r, 10);
      if (isNaN(i)) throw new Error(`Could not parse capture group ${t} into number: ${r}`);
      return i
    }
    parseHunkHeader(e) {
      const t = ls.exec(e);
      if (!t) throw new Error("Invalid hunk header format");
      const n = this.numberFromGroup(t, 1),
        r = this.numberFromGroup(t, 2, 1),
        i = this.numberFromGroup(t, 3),
        o = this.numberFromGroup(t, 4, 1);
      return new Wi(n, r, i, o)
    }
    parseLinePrefix(e) {
      return e && e.length && cs.has(e[0]) ? e[0] : null
    }
    parseHunk(e) {
      const t = this.readLine();
      if (!t) throw new Error("Expected hunk header but reached end of diff");
      const n = this.parseHunkHeader(t),
        r = new Array;
      let i;
      r.push(new Fi(t, Pi.Hunk, null, null));
      let o = n.oldStartLine,
        s = n.newStartLine;
      for (; i = this.parseLinePrefix(this.peek());) {
        const e = this.readLine();
        if (!e) throw new Error("Expected unified diff line but reached end of diff");
        if ("\\" === i) {
          if (e.length < 12) throw new Error('Expected "no newline at end of file" marker to be at least 12 bytes long');
          const t = r.length - 1,
            n = r[t];
          r[t] = n.withNoTrailingNewLine(!0);
          continue
        }
        let t;
        if ("+" === i) t = new Fi(e, Pi.Add, null, s++);
        else if ("-" === i) t = new Fi(e, Pi.Delete, o++, null);
        else {
          if (" " !== i) return X(0, "Unknown DiffLinePrefix: " + i);
          t = new Fi(e, Pi.Context, o++, s++)
        }
        r.push(t)
      }
      if (1 === r.length) throw new Error("Malformed diff, empty hunk");
      return new Ui(n, r, e, e + r.length - 1)
    }
    parse(e) {
      this.text = e;
      try {
        const e = this.parseDiffHeader(),
          t = this.le,
          n = this.text.substring(0, t);
        if (!e) return {
          header: n,
          contents: "",
          hunks: [],
          isBinary: !1
        };
        if (e.isBinary) return {
          header: n,
          contents: "",
          hunks: [],
          isBinary: !0
        };
        const r = new Array;
        let i = 0;
        do {
          const e = this.parseHunk(i);
          r.push(e), i += e.lines.length
        } while (this.peek());
        return {
          header: n,
          contents: this.text.substring(t + 1, this.le).replace(/\n\\ No newline at end of file/g, ""),
          hunks: r,
          isBinary: e.isBinary
        }
      } finally {
        this.reset()
      }
    }
  }

  function hs(e) {
    return e.status.kind === Ki.Renamed || e.status.kind === Ki.Copied ? e.status.oldPath : e.path
  }

  function ps(e, t) {
    return ds(e, t).reduce((e, t) => e.concat([t.slice(1)]), new Array)
  }

  function ds(e, t) {
    if (!1 === t.global) throw new Error("A regex has been provided that is not marked as global, and has the potential to execute forever if it finds a match");
    const n = new Array;
    let r = t.exec(e);
    for (; null !== r;) n.push(r), r = t.exec(e);
    return n
  }
  const fs = new Set([".png", ".jpg", ".jpeg", ".gif", ".ico", ".webp", ".bmp"]);
  async function ms(e, t, n, r = !1) {
    const i = ["log", n, ...r ? ["-w"] : [], "-m", "-1", "--first-parent", "--patch-with-raw", "-z", "--no-color", "--", t.path];
    t.status.kind !== Ki.Renamed && t.status.kind !== Ki.Copied || i.push(t.status.oldPath);
    const {
      output: o
    } = await ss(i, e.path, "getCommitDiff");
    return bs(o, e, t, n)
  }
  async function gs(e, t) {
    let n, r;
    t.status.kind === Ki.New || t.status.kind === Ki.Untracked ? (n = new Set([0, 1]), r = ["diff", "--no-ext-diff", "--no-index", "--patch-with-raw", "-z", "--no-color", "--", "/dev/null", t.path]) : r = t.status.kind === Ki.Renamed ? ["diff", "--no-ext-diff", "--patch-with-raw", "-z", "--no-color", "--", t.path] : ["diff", "HEAD", "--no-ext-diff", "--patch-with-raw", "-z", "--no-color", "--", t.path];
    const {
      output: i,
      error: o
    } = await ss(r, e.path, "getWorkingDirectoryDiff", n);
    return bs(i, e, t, "HEAD", function (e) {
      if (0 === e.length) return;
      const t = e.toString("utf-8"),
        n = ws.exec(t);
      if (n) {
        const e = Ni(n[1]),
          t = Ni(n[2]);
        if (e && t) return {
          from: e,
          to: t
        }
      }
      return
    }(o))
  }
  async function ys(e, t, n) {
    let r = void 0,
      o = void 0;
    if (t instanceof co) {
      if (t.status.kind === Ki.Conflicted) return {
        kind: Mi.Image
      };
      t.status.kind !== Ki.Deleted && (r = await async function (e, t) {
        const n = await async function (e, t) {
          return new Promise((n, r) => {
            t = t || {
              flag: "r"
            }, Ci.readFile(e, t, (e, t) => {
              e ? r(e) : n(t)
            })
          })
        }(i.join(e.path, t.path));
        return new zi(n.toString("base64"), vs(i.extname(t.path)), n.length)
      }(e, t)), t.status.kind !== Ki.New && t.status.kind !== Ki.Untracked && (o = await Ss(e, hs(t), "HEAD"))
    } else t.status.kind !== Ki.Deleted && (r = await Ss(e, t.path, n)), t.status.kind !== Ki.New && t.status.kind !== Ki.Untracked && (o = await Ss(e, hs(t), n + "^"));
    return {
      kind: Mi.Image,
      previous: o,
      current: r
    }
  }

  function vs(e) {
    return ".png" === e ? "image/png" : ".jpg" === e || ".jpeg" === e ? "image/jpg" : ".gif" === e ? "image/gif" : ".ico" === e ? "image/x-icon" : ".webp" === e ? "image/webp" : ".bmp" === e ? "image/bmp" : "text/plain"
  }
  const ws = /warning: (CRLF|CR|LF) will be replaced by (CRLF|CR|LF) in .*/;

  function bs(e, t, n, r, o) {
    if (! function (e) {
        return e.length <= 7e7
      }(e)) return Promise.resolve({
      kind: Mi.Unrenderable
    });
    const s = function (e) {
      const t = e.toString("utf-8").split("\0");
      return (new us).parse(t[t.length - 1])
    }(e);
    if (function (e) {
        return e.length >= 4375e3
      }(e) || function (e) {
        for (const t of e.hunks)
          for (const e of t.lines)
            if (e.text.length > 5e3) return !0;
        return !1
      }(s)) {
      const e = {
        kind: Mi.LargeText,
        text: s.contents,
        hunks: s.hunks,
        lineEndingsChange: o
      };
      return Promise.resolve(e)
    }
    return async function (e, t, n, r, o) {
      const s = i.extname(t.path).toLowerCase();
      return n.isBinary ? fs.has(s) ? ys(e, t, r) : {
        kind: Mi.Binary
      } : {
        kind: Mi.Text,
        text: n.contents,
        hunks: n.hunks,
        lineEndingsChange: o
      }
    }(t, n, s, r, o)
  }
  async function Ss(e, t, n) {
    const r = i.extname(t),
      o = await async function (e, t, n) {
        const r = ["show", `${t}:${n}`],
          i = {
            successExitCodes: new Set([0, 1]),
            processCallback: e => {
              e.stdout && e.stdout.setEncoding("binary")
            }
          },
          o = await Bo(r, e.path, "getBlobContents", i);
        return Buffer.from(o.stdout, "binary")
      }(e, n, t);
    return new zi(o.toString("base64"), vs(r), o.length)
  }
  async function Cs(e, t) {
    const {
      output: n
    } = await ss(["diff", "--numstat", "-z", t], e.path, "getBinaryPaths"), r = ps(n.toString("utf8"), Es);
    if (0 === r.length) return [];
    return r.reduce((e, t) => e.concat(t))
  }
  const Es = /-\t-\t(?:\0.+\0)?([^\0]*)/gi;

  function ks(e, t) {
    return `--- ${e?"a/"+e:"/dev/null"}\n+++ ${t?"b/"+t:"/dev/null"}\n`
  }

  function xs(e, t, n, r, i) {
    return `@@ -${1===t?""+e:`${e},${t}`} +${1===r?""+n:`${n},${r}`} @@${i=i?" "+i:""}\n`
  }

  function Ts(e, t) {
    let n = "";
    if (t.hunks.forEach((t, r) => {
        let i = "",
          o = 0,
          s = 0,
          a = !1;
        t.lines.forEach((n, r) => {
          const l = t.unifiedDiffStart + r;
          if (n.type !== Pi.Hunk) {
            if (n.type === Pi.Context) i += n.text + "\n", o++, s++;
            else if (e.selection.isSelected(l)) i += n.text + "\n", n.type === Pi.Add && s++, n.type === Pi.Delete && o++, a = !0;
            else {
              if (e.status.kind === Ki.New || e.status.kind === Ki.Untracked) return;
              if (n.type === Pi.Add) return;
              n.type === Pi.Delete ? (i += ` ${n.text.substr(1)}\n`, o++, s++) : X(n.type, "Unsupported line type " + n.type)
            }
            n.noTrailingNewLine && (i += "\\ No newline at end of file\n")
          }
        }), a && (n += xs(t.header.oldStartLine, o, t.header.newStartLine, s), n += i)
      }), !n.length) throw log.debug("formatPatch: empty path for " + e.path), new Error("Could not generate a patch, no changes");
    return n = function (e) {
      switch (e.status.kind) {
        case Ki.New:
        case Ki.Untracked:
          return ks(null, e.path);
        case Ki.Renamed:
        case Ki.Deleted:
        case Ki.Modified:
        case Ki.Copied:
        case Ki.Conflicted:
          return ks(e.path, e.path);
        default:
          return X(e.status, "Unknown file status " + e.status)
      }
    }(e) + n, n
  }
  async function Rs(e, t) {
    if (t.status.kind === Ki.Renamed) {
      await Bo(["add", "--u", "--", t.status.oldPath], e.path, "applyPatchToIndex");
      const n = await Bo(["ls-tree", "HEAD", "--", t.status.oldPath], e.path, "applyPatchToIndex"),
        [r] = n.stdout.split("\t", 1),
        [i, , o] = r.split(" ", 3);
      await Bo(["update-index", "--add", "--cacheinfo", i, o, t.path], e.path, "applyPatchToIndex")
    }
    const n = await gs(e, t);
    if (n.kind !== Mi.Text) throw new Error(`Unexpected diff result returned: '${n.kind}'`);
    const r = await Ts(t, n);
    return await Bo(["apply", "--cached", "--unidiff-zero", "--whitespace=nowarn", "-"], e.path, "applyPatchToIndex", {
      stdin: r
    }), Promise.resolve()
  }
  async function Ds(e, t, n, r) {
    const i = function (e, t, n) {
      let r = "";
      return t.hunks.forEach((e, t) => {
        let i = "",
          o = 0,
          s = 0,
          a = !1;
        e.lines.forEach((t, r) => {
          const l = e.unifiedDiffStart + r;
          if (t.type !== Pi.Hunk) {
            if (t.type === Pi.Context) i += t.text + "\n", o++, s++;
            else if (n.isSelected(l)) t.type === Pi.Add ? (i += `-${t.text.substr(1)}\n`, s++) : t.type === Pi.Delete ? (i += `+${t.text.substr(1)}\n`, o++) : X(t.type, "Unsupported line type " + t.type), a = !0;
            else if (t.type === Pi.Add) o++, s++, i += ` ${t.text.substr(1)}\n`;
            else {
              if (t.type === Pi.Delete) return;
              X(t.type, "Unsupported line type " + t.type)
            }
            t.noTrailingNewLine && (i += "\\ No newline at end of file\n")
          }
        }), a && (r += xs(e.header.newStartLine, s, e.header.oldStartLine, o), r += i)
      }), 0 === r.length ? null : ks(e, e) + r
    }(t, n, r);
    if (null === i) return;
    await Bo(["apply", "--unidiff-zero", "--whitespace=nowarn", "-"], e.path, "discardChangesFromSelection", {
      stdin: i
    })
  }

  function _s(e) {
    const t = e.match(/.*?\/(.*)/);
    return !t || t.length < 2 ? null : t[1]
  }
  var As, Ms;

  function Ps(e, t) {
    return e.type === As.Local && e.name !== t && null != e.upstream
  }! function (e) {
    e[e.Local = 0] = "Local", e[e.Remote = 1] = "Remote"
  }(As || (As = {})),
  function (e) {
    e.CurrentBranch = "CurrentBranch", e.DefaultBranch = "DefaultBranch", e.Head = "Head", e.UpstreamDefaultBranch = "UpstreamDefaultBranch"
  }(Ms || (Ms = {}));
  class Is {
    constructor(e, t, n, r) {
      this.name = e, this.upstream = t, this.tip = n, this.type = r
    }
    get remote() {
      const e = this.upstream;
      if (!e) return null;
      const t = e.match(/(.*?)\/.*/);
      return !t || t.length < 2 ? null : t[1]
    }
    get upstreamWithoutRemote() {
      return this.upstream ? _s(this.upstream) : null
    }
    get nameWithoutRemote() {
      if (this.type === As.Local) return this.name;
      return _s(this.name) || this.name
    }
  }
  class Os {
    constructor(e, t, n, r = (new Date).getTimezoneOffset()) {
      this.name = e, this.email = t, this.date = n, this.tzOffset = r
    }
    static parseIdentity(e) {
      const t = e.match(/^(.*?) <(.*?)> (\d+) (\+|-)?(\d{2})(\d{2})/);
      if (!t) return null;
      const n = t[1],
        r = t[2],
        i = new Date(1e3 * parseInt(t[3], 10)),
        o = "-" === t[4] ? "-" : "+",
        s = t[5],
        a = t[6],
        l = 60 * parseInt(s, 10) + parseInt(a, 10);
      return new Os(n, r, i, l * ("-" === o ? -1 : 1))
    }
  }
  async function Ls(e, ...t) {
    const n = String.fromCharCode(parseInt("1F", 16)),
      r = ["%(refname)", "%(refname:short)", "%(upstream:short)", "%(objectname)", "%(objectname:short)", "%(author)", "%(committer)", "%(symref)", "%1F"].join("%00");
    t && t.length || (t = ["refs/heads", "refs/remotes"]);
    const i = await Bo(["for-each-ref", "--format=" + r, ...t], e.path, "getBranches", {
      expectedErrors: new Set([Ao.GitError.NotAGitRepository])
    });
    if (i.gitError === Ao.GitError.NotAGitRepository) return [];
    const o = i.stdout.split(n);
    if (o.splice(-1, 1), 0 === o.length) return [];
    const s = [];
    for (const [e, t] of o.entries()) {
      const n = (e > 0 ? t.substr(1) : t).split("\0"),
        r = n[0],
        i = n[1],
        o = n[2],
        a = n[3],
        l = n[4],
        c = n[5],
        u = Os.parseIdentity(c);
      if (!u) throw new Error(`Couldn't parse author identity for '${l}'`);
      const h = n[6];
      if (!Os.parseIdentity(h)) throw new Error(`Couldn't parse committer identity for '${l}'`);
      const p = n[7],
        d = {
          sha: a,
          author: u
        },
        f = r.startsWith("refs/head") ? As.Local : As.Remote;
      p.length > 0 || (r.startsWith("refs/remotes/github-desktop-") || s.push(new Is(i, o.length > 0 ? o : null, d, f)))
    }
    return s
  }

  function Ns(e) {
    return e.startsWith("heads/") ? "refs/" + e : e.startsWith("refs/heads/") ? e : "refs/heads/" + e
  }
  async function Fs(e, t) {
    const n = await Bo(["symbolic-ref", "-q", t], e.path, "getSymbolicRef", {
      successExitCodes: new Set([0, 1, 128])
    });
    return 1 === n.exitCode || 128 === n.exitCode ? null : n.stdout.trim()
  }
  async function Bs(e, t, n, r, i) {
    await Bo(["update-ref", t, r, n, "-m", i], e.path, "updateRef")
  }
  async function Hs(e, t, n) {
    const r = ["update-ref", "-d", t];
    void 0 !== n && r.push("-m", n), await Bo(r, e.path, "deleteRef")
  }
  async function zs(e) {
    const t = await Bo(["remote", "-v"], e.path, "getRemotes", {
      expectedErrors: new Set([Ao.GitError.NotAGitRepository])
    });
    if (t.gitError === Ao.GitError.NotAGitRepository) return [];
    return t.stdout.split("\n").filter(e => e.endsWith("(fetch)")).map(e => e.split(/\s+/)).map(e => ({
      name: e[0],
      url: e[1]
    }))
  }
  async function Us(e, t, n) {
    return await Bo(["remote", "add", t, n], e.path, "addRemote"), {
      url: n,
      name: t
    }
  }
  async function Ws(e, t) {
    const n = {
      successExitCodes: new Set([0, 128])
    };
    await Bo(["remote", "remove", t], e.path, "removeRemote", n)
  }
  async function Vs(e, t, n) {
    return await Bo(["remote", "set-url", t, n], e.path, "setRemoteURL"), !0
  }
  const js = new Set([Ao.GitError.HTTPSAuthenticationFailed, Ao.GitError.SSHAuthenticationFailed, Ao.GitError.HTTPSRepositoryNotFound, Ao.GitError.SSHRepositoryNotFound]);

  function Gs() {
    return i.resolve(__dirname, "static", "ask-pass-trampoline.bat")
  }

  function $s() {
    return "1" === process.env.GITHUB_DESKTOP_PREVIEW_FEATURES || !1
  }

  function qs() {
    return $s()
  }

  function Ks() {
    return $s()
  }

  function Ys() {
    return $s()
  }

  function Qs(e, t) {
    switch (e.toLowerCase()) {
      case "proxy":
      case "http":
        return "http://" + t;
      case "https":
        return "https://" + t;
      case "socks":
      case "socks4":
        return "socks4://" + t;
      case "socks5":
        return "socks5://" + t
    }
    return null
  }
  async function Zs(e) {
    const t = function (e) {
      if ("DIRECT" === e) return null;
      const t = e.trim().split(/\s*;\s*/),
        n = new Array;
      for (const e of t) {
        if (e.match(/^direct/i)) break;
        const [t, r] = e.split(/\s+/, 2);
        if (void 0 !== r) {
          const i = Qs(t, r);
          null !== i ? n.push(i) : log.warn("Skipping proxy spec: " + e)
        }
      }
      return n.length > 0 ? n : null
    }(await r.remote.session.defaultSession.resolveProxy(e).catch(t => (log.error(`Failed resolving proxy for '${e}'`, t), "DIRECT")));
    if (null !== t)
      for (const e of t) {
        if (!e.startsWith("https://")) return e;
        log.warn("ignoring https proxy, not supported in cURL/schannel")
      }
  }

  function Xs(e, t) {
    return null !== e ? e.endpoint === pt() ? "https://github.com" : e.endpoint : null !== t.gitHubRepository && null !== t.gitHubRepository.cloneURL ? t.gitHubRepository.cloneURL : "https://github.com"
  }
  async function Js(e, t) {
    return Object.assign(Object.assign({}, function (e) {
      const t = {
        DESKTOP_PATH: process.execPath,
        DESKTOP_ASKPASS_SCRIPT: i.resolve(__dirname, "ask-pass.js"),
        GIT_ASKPASS: Gs(),
        GIT_TERMINAL_PROMPT: "0",
        GIT_TRACE: localStorage.getItem("git-trace") || "0"
      };
      return e ? Object.assign(Object.assign({}, t), {
        DESKTOP_USERNAME: e.login,
        DESKTOP_ENDPOINT: e.endpoint
      }) : t
    }(e)), await async function (e, t = process.env, n = Zs) {
      0;
      if ("ALL_PROXY" in t || "all_proxy" in t) return void log.info("proxy url not resolved, ALL_PROXY already set");
      const r = /^(https?):\/\//i.exec(e);
      if (null === r) return void log.info("proxy url not resolved, protocol not supported");
      const i = r[1].toLowerCase(),
        o = i + "_proxy";
      if (o in t || "https" === i && "HTTPS_PROXY" in t) return void log.info(`proxy url not resolved, ${o} already set`);
      const s = await n(e).catch(e => {
        log.error("Failed resolving Git proxy", e)
      });
      return void 0 === s ? void 0 : {
        [o]: s
      }
    }(t))
  }
  async function ea(e, t) {
    return await Bo(["branch", "-D", t], e.path, "deleteLocalBranch"), !0
  }
  async function ta(e, t, n, r) {
    t.type === As.Local && await ea(e, t.name);
    const i = t.remote;
    if (r && i) {
      const r = await Vo(e, n),
        o = await async function (e, t) {
          const n = await Bo(["remote", "get-url", t], e.path, "getRemoteURL", {
            successExitCodes: new Set([0, 128])
          });
          return 0 !== n.exitCode ? null : n.stdout
        }(e, i).catch(e => (log.error("Could not resolve remote url for remote " + i, e), null)) || Xs(n, e), s = [...r, "push", i, ":" + t.nameWithoutRemote];
      if ((await Bo(s, e.path, "deleteRemoteBranch", {
          env: await Js(n, o),
          expectedErrors: new Set([Ao.GitError.BranchDeletionFailed])
        })).gitError === Ao.GitError.BranchDeletionFailed) {
        const n = `refs/remotes/${i}/${t.nameWithoutRemote}`;
        await Hs(e, n)
      }
    }
    return !0
  }
  class na {
    constructor(e) {
      if (this.stepIndex = 0, this.lastPercent = 0, !e.length) throw new Error("must specify at least one step");
      const t = e.reduce((e, t) => e + t.weight, 0);
      this.steps = e.map(e => ({
        title: e.title,
        weight: e.weight / t
      }))
    }
    parse(e) {
      const t = function (e) {
        const t = e.lastIndexOf(": ");
        if (0 === t) return null;
        if (t - 2 >= e.length) return null;
        const n = e.substr(0, t),
          r = e.substr(n.length + 2).trim();
        if (!r.length) return null;
        const i = r.split(", ");
        if (!i.length) return null;
        let o, s = void 0,
          a = void 0;
        if (ia.test(i[0])) {
          if (o = parseInt(i[0], 10), isNaN(o)) return null
        } else {
          const e = ra.exec(i[0]);
          if (!e || 4 !== e.length) return null;
          if (a = parseInt(e[1], 10), o = parseInt(e[2], 10), s = parseInt(e[3], 10), isNaN(a) || isNaN(o) || isNaN(s)) return null
        }
        let l = !1;
        for (let e = 1; e < i.length; e++)
          if ("done." === i[e]) {
            l = !0;
            break
          } return {
          title: n,
          value: o,
          percent: a,
          total: s,
          done: l,
          text: e
        }
      }(e);
      if (!t) return {
        kind: "context",
        text: e,
        percent: this.lastPercent
      };
      let n = 0;
      for (let e = 0; e < this.steps.length; e++) {
        const r = this.steps[e];
        if (e >= this.stepIndex && t.title === r.title) return t.total && (n += r.weight * (t.value / t.total)), this.stepIndex = e, this.lastPercent = n, {
          kind: "progress",
          percent: n,
          details: t
        };
        n += r.weight
      }
      return {
        kind: "context",
        text: e,
        percent: this.lastPercent
      }
    }
  }
  const ra = /^(\d{1,3})% \((\d+)\/(\d+)\)$/,
    ia = /^\d+$/;
  const oa = [{
    title: "Checking out files",
    weight: 1
  }];
  class sa extends na {
    constructor() {
      super(oa)
    }
  }
  const aa = [{
    title: "remote: Compressing objects",
    weight: .1
  }, {
    title: "Receiving objects",
    weight: .6
  }, {
    title: "Resolving deltas",
    weight: .1
  }, {
    title: "Checking out files",
    weight: .2
  }];
  class la extends na {
    constructor() {
      super(aa)
    }
  }
  const ca = [{
    title: "Compressing objects",
    weight: .2
  }, {
    title: "Writing objects",
    weight: .7
  }, {
    title: "remote: Resolving deltas",
    weight: .1
  }];
  class ua extends na {
    constructor() {
      super(ca)
    }
  }
  const ha = [{
    title: "remote: Compressing objects",
    weight: .1
  }, {
    title: "Receiving objects",
    weight: .7
  }, {
    title: "Resolving deltas",
    weight: .2
  }];
  class pa extends na {
    constructor() {
      super(ha)
    }
  }
  const da = [{
    title: "remote: Compressing objects",
    weight: .1
  }, {
    title: "Receiving objects",
    weight: .7
  }, {
    title: "Resolving deltas",
    weight: .15
  }, {
    title: "Checking out files",
    weight: .15
  }];
  class fa extends na {
    constructor() {
      super(da)
    }
  }
  const ma = ["B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"];

  function ga(e, t = 0, n = !0) {
    if (!Number.isFinite(e)) return "" + e;
    const r = Math.floor(Math.log(Math.abs(e)) / Math.log(1024)),
      i = function (e, t) {
        if (t <= 0) return Math.round(e);
        const n = Math.pow(10, t);
        return Math.round((e + Number.EPSILON) * n) / n
      }(e / Math.pow(1024, r), t);
    return `${n?i.toFixed(t):i} ${ma[r]}`
  }
  async function ya() {
    const e = await async function (e) {
      const t = i.join(Re.tmpdir(), e + "-"),
        n = await Ci.mkdtemp(t);
      return i.join(n, e)
    }("GitHubDesktop-lfs-progress");
    return await Ci.ensureFile(e), e
  }
  const va = /^(.+?)\s{1}(\d+)\/(\d+)\s{1}(\d+)\/(\d+)\s{1}(.+)$/;
  class wa {
    constructor() {
      this.files = new Map
    }
    parse(e) {
      const t = e.match(va);
      if (!t || 7 !== t.length) return {
        kind: "context",
        percent: 0,
        text: e
      };
      const n = t[1],
        r = parseInt(t[3], 10),
        i = parseInt(t[4], 10),
        o = parseInt(t[5], 10),
        s = t[6];
      if (isNaN(r) || isNaN(i) || isNaN(o)) return {
        kind: "context",
        percent: 0,
        text: e
      };
      this.files.set(s, {
        transferred: i,
        size: o,
        done: i === o
      });
      let a = 0,
        l = 0,
        c = 0;
      const u = Math.max(r, this.files.size);
      for (const e of this.files.values()) a += e.transferred, l += e.size, c += e.done ? 1 : 0;
      const h = `${ga(a,1)} / ${ga(l,1)}`,
        p = this.directionToHumanFacingVerb(n);
      return {
        kind: "progress",
        percent: 0,
        details: {
          title: `${p} "${s}"`,
          value: a,
          total: l,
          percent: 0,
          done: !1,
          text: `${p} ${s} (${c} out of an estimated ${u} completed, ${h})`
        }
      }
    }
    directionToHumanFacingVerb(e) {
      switch (e) {
        case "download":
          return "Downloading";
        case "upload":
          return "Uploading";
        case "checkout":
          return "Checking out";
        default:
          return "Downloading"
      }
    }
  }
  async function ba(e, t, n) {
    let r = null,
      i = {};
    if (e.trackLFSProgress) try {
      r = await ya(), i = {
        GIT_LFS_PROGRESS: r
      }
    } catch (e) {
      log.error("Error writing LFS progress file", e), i = {
        GIT_LFS_PROGRESS: null
      }
    }
    return hi(e, {
      processCallback: Sa(t, r, n),
      env: hi(e.env, i)
    })
  }

  function Sa(e, t, n) {
    return r => {
      let s = !1;
      if (t) {
        const e = new wa,
          a = function (e, t) {
            const n = new rs(e),
              r = n.onError(t => {
                log.warn("Unable to tail path: " + e, t)
              }),
              i = n.onDataAvailable(e => {
                os()(e).on("data", e => {
                  if (i.disposed) return;
                  const n = e.toString();
                  t(n)
                })
              });
            return n.start(), new ne.Disposable(() => {
              i.dispose(), r.dispose(), n.stop()
            })
          }(t, t => {
            const r = e.parse(t);
            "progress" === r.kind && (s = !0, n(r))
          });
        r.on("close", () => {
          a.dispose(), o.unlink(t, e => {
            if (null == e) {
              const e = i.dirname(t);
              o.rmdir(e, () => {})
            }
          })
        })
      }
      r.stderr && os()(r.stderr).on("data", t => {
        const r = e.parse(t);
        if (s) {
          if ("context" === r.kind) return;
          const {
            title: e,
            done: t
          } = r.details;
          if ("Filtering content" === e) return void(t && (s = !1))
        }
        n(r)
      })
    }
  }
  async function Ca(e, t, n, r) {
    let i = {
      env: await Js(t, Xs(t, e)),
      expectedErrors: js
    };
    if (r) {
      const e = "Checking out branch " + n.name,
        t = "checkout",
        o = n.name;
      i = await ba(Object.assign(Object.assign({}, i), {
        trackLFSProgress: !0
      }), new sa, n => {
        if ("progress" === n.kind) {
          const i = n.details.text,
            s = n.percent;
          r({
            kind: t,
            title: e,
            description: i,
            value: s,
            targetBranch: o
          })
        }
      }), r({
        kind: t,
        title: e,
        value: 0,
        targetBranch: o
      })
    }
    const o = await async function (e, t, n, r) {
      const i = await Vo(e, n),
        o = null != r ? [...i, "checkout", "--progress"] : [...i, "checkout"];
      return qs() ? t.type === As.Remote ? o.concat(t.name, "-b", t.nameWithoutRemote, "--recurse-submodules", "--") : o.concat(t.name, "--recurse-submodules", "--") : t.type === As.Remote ? o.concat(t.name, "-b", t.nameWithoutRemote, "--") : o.concat(t.name, "--")
    }(e, n, t, r);
    return await Bo(o, e.path, "checkoutBranch", i), !0
  }
  async function Ea(e, t, n = {}) {
    if (!t.length) return;
    const r = ["update-index"];
    !1 !== n.add && r.push("--add"), !1 === n.remove && !0 !== n.forceRemove || r.push("--remove"), n.forceRemove && r.push("--force-remove"), !1 !== n.replace && r.push("--replace"), r.push("-z", "--stdin"), await Bo(r, e.path, "updateIndex", {
      stdin: t.join("\0")
    })
  }
  async function ka(e, t) {
    const n = [],
      r = [],
      i = [],
      o = [];
    for (const e of t) e.selection.getSelectionType() === Ii.All ? (n.push(e.path), e.status.kind === Ki.Renamed && r.push(e.status.oldPath), e.status.kind === Ki.Deleted && o.push(e.path)) : i.push(e);
    if (await Ea(e, r, {
        forceRemove: !0
      }), await Ea(e, n), o.length > 0 && await Ea(e, o, {
        forceRemove: !0
      }), i.length)
      for (const t of i) await Rs(e, t)
  }

  function xa(e, t) {
    switch (e) {
      case 0:
        return ["reset", "--hard", t];
      case 2:
        return ["reset", t];
      case 1:
        return ["reset", "--soft", t];
      default:
        return X(0, "Unknown reset mode: " + e)
    }
  }
  var Ta;
  async function Ra(e, t, n) {
    const {
      status: r
    } = t;
    if (!oo(r)) return void log.error(`tried to manually resolve unconflicted file (${t.path})`);
    if (so(r) && 0 === r.conflictMarkerCount) return;
    const i = n === Ta.theirs ? r.entry.them : r.entry.us;
    switch (i) {
      case qi.Deleted:
        await Bo(["rm", t.path], e.path, "removeConflictedFile");
        break;
      case qi.Added:
        await Bo(["add", t.path], e.path, "addConflictedFile");
        break;
      case qi.UpdatedButUnmerged: {
        const r = n === Ta.theirs ? "theirs" : "ours";
        await Bo(["checkout", "--" + r, "--", t.path], e.path, "checkoutConflictedFile"), await Bo(["add", t.path], e.path, "addConflictedFile");
        break
      }
      default:
        X(0, "unnacounted for git status entry possibility")
    }
  }
  async function Da(e, t, n) {
    await async function (e) {
      return await Bo(["reset", "--", "."], e.path, "unstageAll"), !0
    }(e), await ka(e, n);
    try {
      return jo(await Bo(["commit", "-F", "-"], e.path, "createCommit", {
        stdin: t
      }))
    } catch (e) {
      return void _a(e)
    }
  }

  function _a(e) {
    if (e instanceof Fo) {
      const t = e.result.stderr.trim(),
        n = t.length > 0 ? `, with output: '${t}'` : "",
        {
          exitCode: r
        } = e.result,
        i = new Error(`Commit failed - exit code ${r} received${n}`);
      throw i.name = "commit-failed", i
    }
    throw e
  }! function (e) {
    e.theirs = "theirs", e.ours = "ours"
  }(Ta || (Ta = {}));
  async function Aa(e, t, n, r) {
    let i = {
      successExitCodes: new Set([0]),
      env: await Js(t, n.url)
    };
    if (r) {
      const e = "Fetching " + n.name,
        t = "fetch";
      i = await ba(Object.assign(Object.assign({}, i), {
        trackLFSProgress: !0
      }), new pa, i => {
        if ("context" === i.kind && !i.text.startsWith("remote: Counting objects")) return;
        const o = "progress" === i.kind ? i.details.text : i.text,
          s = i.percent;
        r({
          kind: t,
          title: e,
          description: o,
          value: s,
          remote: n.name
        })
      }), r({
        kind: t,
        title: e,
        value: 0,
        remote: n.name
      })
    }
    const o = await async function (e, t, n, r) {
      const i = await Vo(e, n);
      return qs() ? null != r ? [...i, "fetch", "--progress", "--prune", "--recurse-submodules=on-demand", t] : [...i, "fetch", "--prune", "--recurse-submodules=on-demand", t] : null != r ? [...i, "fetch", "--progress", "--prune", t] : [...i, "fetch", "--prune", t]
    }(e, n.name, t, r);
    await Bo(o, e.path, "fetch", i)
  }
  async function Ma(e, t, n, r) {
    const i = {
        successExitCodes: new Set([0, 128]),
        env: await Js(t, n.url)
      },
      o = [...await Vo(e, t), "fetch", n.name, r];
    await Bo(o, e.path, "fetchRefspec", i)
  }
  class Pa {
    constructor(e, t) {
      this.name = e, this.email = t
    }
    static parse(e) {
      const t = e.match(/^(.*?)\s+<(.*?)>/);
      return null === t ? null : new Pa(t[1], t[2])
    }
    toString() {
      return `${this.name} <${this.email}>`
    }
  }
  class Ia {
    constructor(e, t, n, r, i, o, s, a, l) {
      this.sha = e, this.shortSha = t, this.summary = n, this.body = r, this.author = i, this.committer = o, this.parentSHAs = s, this.trailers = a, this.tags = l, this.coAuthors = function (e) {
        const t = [];
        for (const n of e)
          if (Go(n)) {
            const e = Pa.parse(n.value);
            e && t.push(e)
          } return t
      }(a), this.authoredByCommitter = this.author.name === this.committer.name && this.author.email === this.committer.email
    }
  }

  function Oa(e, t) {
    const n = e.trim();
    return "M" === n ? {
      kind: Ki.Modified
    } : "A" === n ? {
      kind: Ki.New
    } : "?" === n ? {
      kind: Ki.Untracked
    } : "D" === n ? {
      kind: Ki.Deleted
    } : "R" === n && null != t ? {
      kind: Ki.Renamed,
      oldPath: t
    } : "C" === n && null != t ? {
      kind: Ki.Copied,
      oldPath: t
    } : n.match(/R[0-9]+/) && null != t ? {
      kind: Ki.Renamed,
      oldPath: t
    } : n.match(/C[0-9]+/) && null != t ? {
      kind: Ki.Copied,
      oldPath: t
    } : {
      kind: Ki.Modified
    }
  }
  async function La(e, t, n, r = []) {
    const i = String.fromCharCode(parseInt("1F", 16)),
      o = ["%H", "%h", "%s", "%b", "%an <%ae> %ad", "%cn <%ce> %cd", "%P", "%(trailers:unfold,only)", "%D"].join("%x1F"),
      s = await Bo(["log", t, "--date=raw", "--max-count=" + n, "--pretty=" + o, "-z", "--no-show-signature", "--no-color", ...r, "--"], e.path, "getCommits", {
        successExitCodes: new Set([0, 128])
      });
    if (128 === s.exitCode) return new Array;
    const a = s.stdout.split("\0");
    if (a.splice(-1, 1), 0 === a.length) return [];
    const l = await Ko(e);
    return a.map(e => {
      const t = e.split(i),
        n = t[0],
        r = t[1],
        o = t[2],
        s = t[3],
        a = t[4],
        c = t[5],
        u = t[6],
        h = u.length ? u.split(" ") : [],
        p = $o(t[7], l),
        d = ps(t[8], /tag: ([^\s,]+)/g).filter(e => void 0 !== e[0]).map(e => e[0]),
        f = Os.parseIdentity(a);
      if (!f) throw new Error(`Couldn't parse author identity for '${r}'`);
      const m = Os.parseIdentity(c);
      if (!m) throw new Error(`Couldn't parse committer identity for '${r}'`);
      return new Ia(n, r, o, s, f, m, h, p, d)
    })
  }

  function Na(e, t) {
    const n = e.split("\0");
    n.splice(-1, 1);
    const r = [];
    for (let e = 0; e < n.length; e++) {
      const i = n[e];
      let o = void 0;
      i.length > 0 && ("R" === i[0] || "C" === i[0]) && (o = n[++e]);
      const s = Oa(i, o),
        a = n[++e];
      r.push(new uo(a, s, t))
    }
    return r
  }
  async function Fa(e, t) {
    const n = await La(e, t, 1);
    return n.length < 1 ? null : n[0]
  }
  async function Ba(e, t, n, r) {
    let i = {
      env: await Js(t, n.url),
      expectedErrors: js
    };
    if (r) {
      const e = "Pulling " + n.name,
        t = "pull";
      i = await ba(Object.assign(Object.assign({}, i), {
        trackLFSProgress: !0
      }), new fa, i => {
        if ("context" === i.kind && !i.text.startsWith("remote: Counting objects")) return;
        const o = "progress" === i.kind ? i.details.text : i.text,
          s = i.percent;
        r({
          kind: t,
          title: e,
          description: o,
          value: s,
          remote: n.name
        })
      }), r({
        kind: t,
        title: e,
        value: 0,
        remote: n.name
      })
    }
    const o = await async function (e, t, n, r) {
      const i = [...await Vo(e, n), "-c", "rebase.backend=merge", "pull"];
      return qs() && i.push("--recurse-submodules"), null != r && i.push("--progress"), i.push(t), i
    }(e, n.name, t, r), s = await Bo(o, e.path, "pull", i);
    if (s.gitErrorDescription) throw new Fo(s, o)
  }
  const Ha = new RegExp("fatal: your current branch '.*' does not have any commits yet");

  function za(e, t) {
    return `${e}..${t}`
  }

  function Ua(e, t) {
    return `${e}...${t}`
  }
  async function Wa(e, t) {
    const n = ["rev-list", "--left-right", "--count", t, "--"],
      r = await Bo(n, e.path, "getAheadBehind", {
        expectedErrors: new Set([Ao.GitError.BadRevision])
      });
    if (r.gitError === Ao.GitError.BadRevision) return null;
    const i = r.stdout.split("\t");
    if (2 !== i.length) return null;
    const o = parseInt(i[0], 10);
    if (isNaN(o)) return null;
    const s = parseInt(i[1], 10);
    return isNaN(s) ? null : {
      ahead: o,
      behind: s
    }
  }
  async function Va(e, t) {
    if (t.type === As.Remote) return null;
    const n = t.upstream;
    if (!n) return null;
    return Wa(e, Ua(t.name, n))
  }
  async function ja(e, t, n) {
    const r = ["rev-list", za(t, n), "--reverse", "--oneline", "--no-abbrev-commit", "--"],
      i = {
        expectedErrors: new Set([Ao.GitError.BadRevision])
      },
      o = await Bo(r, e.path, "getCommitsInRange", i);
    if (o.gitError === Ao.GitError.BadRevision) return log.warn("Unable to rebase these branches because one or both of the refs do not exist in the repository"), null;
    const s = o.stdout.split("\n"),
      a = new Array,
      l = /^([a-z0-9]{40}) (.*)$/;
    for (const e of s) {
      const t = l.exec(e);
      if (null !== t && 3 === t.length) {
        const e = t[1],
          n = t[2];
        a.push({
          sha: e,
          summary: n
        })
      }
    }
    return a
  }
  async function Ga(e) {
    let t;
    try {
      t = await Bo(["rev-parse", "--show-cdup"], e, "getTopLevelWorkingDirectory", {
        successExitCodes: new Set([0, 128])
      })
    } catch (e) {
      if (e.code === Ao.RepositoryDoesNotExistErrorCode) return null;
      throw e
    }
    if (128 === t.exitCode) return null;
    const n = t.stdout.trim();
    return n ? i.resolve(e, n) : e
  }
  async function $a(e) {
    try {
      return "true" === (await Bo(["rev-parse", "--is-bare-repository"], e, "isBareRepository")).stdout.trim()
    } catch (e) {
      if (e.message.includes("not a git repository")) return !1;
      throw e
    }
  }
  async function qa(e) {
    return null !== await Ga(e)
  }
  async function Ka(e) {
    const {
      output: t
    } = await ss(["diff", "--check"], e, "getFilesWithConflictMarkers", new Set([0, 2])), n = ps(t.toString("utf8"), Ya);
    if (0 === n.length) return new Map;
    return n.reduce((e, t) => e.concat(t)).reduce((e, t) => e.set(t, (e.get(t) || 0) + 1), new Map)
  }
  const Ya = /(.+):\d+: leftover conflict marker/gi;
  var Qa = n(126),
    Za = n.n(Qa);

  function Xa(e) {
    return "header" === e.kind
  }

  function Ja(e) {
    return "entry" === e.kind
  }
  const el = /^1 ([MADRCUTX?!.]{2}) (N\.\.\.|S[C.][M.][U.]) (\d+) (\d+) (\d+) ([a-f0-9]+) ([a-f0-9]+) ([\s\S]*?)$/;

  function tl(e) {
    const t = el.exec(e);
    if (!t) throw log.debug("parseChangedEntry parse error: " + e), new Error("Failed to parse status line for changed entry");
    return {
      kind: "entry",
      statusCode: t[1],
      path: t[8]
    }
  }
  const nl = /^2 ([MADRCUTX?!.]{2}) (N\.\.\.|S[C.][M.][U.]) (\d+) (\d+) (\d+) ([a-f0-9]+) ([a-f0-9]+) ([RC]\d+) ([\s\S]*?)$/;

  function rl(e, t) {
    const n = nl.exec(e);
    if (!n) throw log.debug("parsedRenamedOrCopiedEntry parse error: " + e), new Error("Failed to parse status line for renamed or copied entry");
    if (!t) throw new Error("Failed to parse renamed or copied entry, could not parse old path");
    return {
      kind: "entry",
      statusCode: n[1],
      oldPath: t,
      path: n[9]
    }
  }
  const il = /^u ([DAU]{2}) (N\.\.\.|S[C.][M.][U.]) (\d+) (\d+) (\d+) (\d+) ([a-f0-9]+) ([a-f0-9]+) ([a-f0-9]+) ([\s\S]*?)$/;

  function ol(e) {
    const t = il.exec(e);
    if (!t) throw log.debug("parseUnmergedEntry parse error: " + e), new Error("Failed to parse status line for unmerged entry");
    return {
      kind: "entry",
      statusCode: t[1],
      path: t[10]
    }
  }

  function sl(e) {
    return {
      kind: "entry",
      statusCode: "??",
      path: e.substr(2)
    }
  }
  var al;

  function ll(e, t, n) {
    const r = e || {
        context: t,
        diff: ""
      },
      i = {
        sha: n.sha,
        mode: n.mode,
        path: n.path
      };
    switch (n.type) {
      case "base":
        return Object.assign(Object.assign({}, r), {
          base: i
        });
      case "result":
        return Object.assign(Object.assign({}, r), {
          result: i
        });
      case "our":
        return Object.assign(Object.assign({}, r), {
          our: i
        });
      case "their":
        return Object.assign(Object.assign({}, r), {
          their: i
        });
      default:
        return r
    }
  }! function (e) {
    e.Loading = "loading", e.Clean = "clean", e.Conflicts = "conflicts", e.Invalid = "invalid"
  }(al || (al = {}));
  const cl = /^(merged|added in remote|removed in remote|changed in both|removed in local|added in both)$/,
    ul = /^\s{2}(result|our|their|base)\s+(\d{6})\s([0-9a-f]{40})\s(.+)$/;
  const hl = "Already up to date.\n";
  async function pl(e, t, n) {
    const r = await Bo(["merge-base", t, n], e.path, "merge-base", {
      successExitCodes: new Set([0, 1, 128])
    });
    return 1 === r.exitCode || 128 === r.exitCode ? null : r.stdout.trim()
  }
  async function dl(e, t, n) {
    const r = await pl(e, t.tip.sha, n.tip.sha);
    if (null === r) return {
      kind: al.Invalid
    };
    if (r === t.tip.sha || r === n.tip.sha) return {
      kind: al.Clean,
      entries: []
    };
    const i = (await ss(["merge-tree", r, t.tip.sha, n.tip.sha], e.path, "mergeTree")).output.toString();
    return 0 === i.length ? {
      kind: al.Clean,
      entries: []
    } : function (e) {
      const t = new Array,
        n = e.split("\n");
      let r, i;
      for (let e = 0; e < n.length; e++) {
        const o = n[e],
          s = cl.exec(o);
        if (null != s) {
          r = s[1], null != i && (t.push(i), i = void 0);
          continue
        }
        const a = ul.exec(o);
        if (null == a) {
          if (null == i) throw new Error("invalid state - trying to append the diff to a merge entry that isn't defined on line " + e); {
            const e = i.diff + o + "\n";
            i = Object.assign(Object.assign({}, i), {
              diff: e
            });
            (o.startsWith("+<<<<<<<") || o.startsWith("+=======") || o.startsWith("+>>>>>>>")) && (i = Object.assign(Object.assign({}, i), {
              hasConflicts: !0
            }))
          }
        } else {
          const t = a[1],
            n = {
              type: t,
              mode: a[2],
              sha: a[3],
              path: a[4]
            };
          if (null == r) {
            log.warn("An unknown header was set while trying to parse the blob on line " + e);
            continue
          }
          switch (t) {
            case "base":
            case "result":
            case "our":
            case "their":
              i = ll(i, r, n);
              break;
            default:
              throw new Error(`invalid state - unexpected entry ${t} found when parsing rows`)
          }
        }
      }
      null != i && (t.push(i), i = void 0);
      const o = t.filter(e => e.hasConflicts || !1);
      return o.length > 0 ? {
        kind: al.Conflicts,
        conflictedFiles: o.length
      } : {
        kind: al.Clean,
        entries: t
      }
    }(i)
  }

  function fl(e, t, n) {
    return e < t ? t : e > n ? n : e
  }

  function ml(e) {
    return {
      kind: "ShowConflicts",
      conflictState: e
    }
  }

  function gl(e) {
    return Math.round(100 * fl(e, 0, 1)) / 100
  }

  function yl(e, t) {
    if (null === t) return !1;
    const {
      tip: n,
      rebasedBranches: r
    } = e, {
      ahead: i,
      behind: o
    } = t;
    let s = !1;
    if (n.kind === Qi.Valid) {
      const e = n.branch.nameWithoutRemote,
        {
          sha: t
        } = n.branch.tip;
      s = r.get(e) === t
    }
    return s && o > 0 && i > 0
  }
  var vl;

  function wl(e) {
    const t = i.join(e.path, ".git", "REBASE_HEAD");
    return Ci.pathExists(t)
  }
  async function bl(e) {
    if (!await wl(e)) return null;
    let t = -1,
      n = -1,
      r = null,
      o = null;
    try {
      const s = await Ci.readFile(i.join(e.path, ".git", "rebase-merge", "msgnum"), "utf8");
      t = parseInt(s, 10), isNaN(t) && (log.warn(`[getCurrentProgress] found '${s}' in .git/rebase-merge/msgnum which could not be parsed to a valid number`), t = -1);
      const a = await Ci.readFile(i.join(e.path, ".git", "rebase-merge", "end"), "utf8");
      n = parseInt(a, 10), isNaN(n) && (log.warn(`[getCurrentProgress] found '${a}' in .git/rebase-merge/last which could not be parsed to a valid number`), n = -1), r = await Ci.readFile(i.join(e.path, ".git", "rebase-merge", "orig-head"), "utf8"), r = r.trim(), o = await Ci.readFile(i.join(e.path, ".git", "rebase-merge", "onto"), "utf8"), o = o.trim()
    } catch (e) {}
    if (t > 0 && n > 0 && null !== r && null !== o) {
      const i = gl(t / n),
        s = await ja(e, o, r);
      if (null === s || 0 === s.length) return null;
      const a = t - 1;
      return {
        progress: {
          value: i,
          rebasedCommitCount: t,
          totalCommitCount: n,
          currentCommitSummary: s.length > 0 && a >= 0 && a <= s.length ? s[a].summary : null
        },
        commits: s
      }
    }
    return null
  }! function (e) {
    e.CompletedWithoutError = "CompletedWithoutError", e.ConflictsEncountered = "ConflictsEncountered", e.OutstandingFilesNotStaged = "OutstandingFilesNotStaged", e.Aborted = "Aborted", e.Error = "Error"
  }(vl || (vl = {}));
  const Sl = /^Applying: (.*)/;
  class Cl {
    constructor(e, t) {
      this.rebasedCommitCount = e, this.totalCommitCount = t
    }
    parse(e) {
      const t = Sl.exec(e);
      if (null === t || 2 !== t.length) return null;
      const n = t[1];
      this.rebasedCommitCount++;
      const r = gl(this.rebasedCommitCount / this.totalCommitCount);
      return this.rebasedCommitCount > this.totalCommitCount && (this.rebasedCommitCount = this.totalCommitCount), {
        kind: "rebase",
        title: `Rebasing commit ${this.rebasedCommitCount} of ${this.totalCommitCount} commits`,
        value: r,
        rebasedCommitCount: this.rebasedCommitCount,
        totalCommitCount: this.totalCommitCount,
        currentCommitSummary: n
      }
    }
  }

  function El(e, t) {
    if (void 0 === t) return e;
    const {
      rebasedCommitCount: n,
      totalCommitCount: r,
      progressCallback: i
    } = t;
    return hi(e, {
      processCallback: e => {
        if (!e.stdout) return;
        const t = new Cl(n, r);
        os()(e.stdout).on("data", e => {
          const n = t.parse(e);
          null != n && i(n)
        })
      }
    })
  }

  function kl(e) {
    if (0 === e.exitCode) return vl.CompletedWithoutError;
    if (e.gitError === Ao.GitError.RebaseConflicts) return vl.ConflictsEncountered;
    if (e.gitError === Ao.GitError.UnresolvedConflicts) return vl.OutstandingFilesNotStaged;
    throw new Error(`Unhandled result found: '${JSON.stringify(e)}'`)
  }
  async function xl(e, t, n = new Map, r) {
    const o = t.filter(e => e.status.kind !== Ki.Untracked);
    for (const [r, i] of n) {
      const n = t.find(e => e.path === r);
      void 0 !== n ? await Ra(e, n, i) : log.error(`[continueRebase] couldn't find file ${r} even though there's a manual resolution for it`)
    }
    const s = o.filter(e => !n.has(e.path));
    await ka(e, s);
    const a = await Dl(e);
    if (null == a) return log.warn("[continueRebase] unable to get status after staging changes, skipping any other steps"), vl.Aborted;
    const l = await async function (e) {
      try {
        const t = i.join(e.path, ".git", "REBASE_HEAD");
        return (await Ci.readFile(t, "utf8")).trim()
      } catch (e) {
        return log.warn("[rebase] a problem was encountered reading .git/REBASE_HEAD, so it is unsafe to continue rebasing", e), null
      }
    }(e);
    if (null === l) return vl.Aborted;
    const c = a.workingDirectory.files.filter(e => e.status.kind !== Ki.Untracked),
      u = {
        expectedErrors: new Set([Ao.GitError.RebaseConflicts, Ao.GitError.UnresolvedConflicts]),
        env: {
          GIT_EDITOR: ":"
        }
      };
    let h = u;
    if (void 0 !== r) {
      const t = await bl(e);
      if (null === t) return log.warn("[continueRebase] unable to get rebase status, skipping any other steps"), vl.Aborted;
      const {
        progress: n
      } = t, {
        rebasedCommitCount: i,
        totalCommitCount: o
      } = n;
      h = El(u, {
        rebasedCommitCount: i,
        totalCommitCount: o,
        progressCallback: r
      })
    }
    if (0 === c.length) {
      log.warn(`[rebase] no tracked changes to commit for ${l}, continuing rebase but skipping this commit`);
      return kl(await Bo(["rebase", "--skip"], e.path, "continueRebaseSkipCurrentCommit", h))
    }
    return kl(await Bo(["rebase", "--continue"], e.path, "continueRebase", h))
  }

  function Tl(e, t, n, r) {
    if ("ordinary" === t.kind) switch (t.type) {
      case "added":
        return {
          kind: Ki.New
        };
      case "modified":
        return {
          kind: Ki.Modified
        };
      case "deleted":
        return {
          kind: Ki.Deleted
        }
    } else {
      if ("copied" === t.kind && null != r) return {
        kind: Ki.Copied,
        oldPath: r
      };
      if ("renamed" === t.kind && null != r) return {
        kind: Ki.Renamed,
        oldPath: r
      };
      if ("untracked" === t.kind) return {
        kind: Ki.Untracked
      };
      if ("conflicted" === t.kind) return function (e, t, n) {
        switch (e.action) {
          case Yi.BothAdded:
            return n.binaryFilePaths.includes(t) ? {
              kind: Ki.Conflicted,
              entry: e
            } : {
              kind: Ki.Conflicted,
              entry: e,
              conflictMarkerCount: n.conflictCountsByPath.get(t) || 0
            };
          case Yi.BothModified:
            return n.binaryFilePaths.includes(t) ? {
              kind: Ki.Conflicted,
              entry: e
            } : {
              kind: Ki.Conflicted,
              entry: e,
              conflictMarkerCount: n.conflictCountsByPath.get(t) || 0
            };
          default:
            return {
              kind: Ki.Conflicted, entry: e
            }
        }
      }(t, e, n)
    }
    return Z("Unknown file status " + status)
  }
  const Rl = ["DD", "AU", "UD", "UA", "DU", "AA", "UU"];
  async function Dl(e) {
    const t = await ss(["--no-optional-locks", "status", "--untracked-files=all", "--branch", "--porcelain=2", "-z"], e.path, "getStatus", new Set([0, 128]));
    if (128 === t.exitCode) return log.debug(`'git status' returned 128 for '${e.path}' and is likely missing its .git directory`), null;
    if (t.output.length > 2e7) return log.error(`'git status' emitted ${t.output.length} bytes, which is beyond the supported threshold of 20000000 bytes`), null;
    const n = function (e) {
        const t = new Array,
          n = e.split("\0"),
          r = new Za.a(n);
        let i;
        for (; i = r.shift();) {
          if (i.startsWith("# ") && i.length > 2) {
            t.push({
              kind: "header",
              value: i.substr(2)
            });
            continue
          }
          const e = i.substr(0, 1);
          "1" === e ? t.push(tl(i)) : "2" === e ? t.push(rl(i, r.shift())) : "u" === e ? t.push(ol(i)) : "?" === e && t.push(sl(i))
        }
        return t
      }(t.output.toString("utf8")),
      r = n.filter(Xa),
      o = n.filter(Ja),
      s = await async function (e) {
        const t = i.join(e.path, ".git", "MERGE_HEAD");
        return Ci.pathExists(t)
      }(e), a = o.some(e => Rl.indexOf(e.statusCode) > -1), l = await async function (e) {
        if (!await wl(e)) return null;
        let t = null,
          n = null,
          r = null;
        try {
          t = await Ci.readFile(i.join(e.path, ".git", "rebase-merge", "orig-head"), "utf8"), t = t.trim(), n = await Ci.readFile(i.join(e.path, ".git", "rebase-merge", "head-name"), "utf8"), n.startsWith("refs/heads/") && (n = n.substr(11).trim()), r = await Ci.readFile(i.join(e.path, ".git", "rebase-merge", "onto"), "utf8"), r = r.trim()
        } catch (e) {}
        return null != t && null != n && null != r ? {
          originalBranchTip: t,
          targetBranch: n,
          baseBranchTip: r
        } : null
      }(e), c = await async function (e, t, n, r) {
        try {
          if (t) return await async function (e) {
            const t = await Ka(e.path),
              n = await Cs(e, "MERGE_HEAD");
            return {
              conflictCountsByPath: t,
              binaryFilePaths: n
            }
          }(e);
          if (null !== r) return await async function (e) {
            const t = await Ka(e.path),
              n = await Cs(e, "REBASE_HEAD");
            return {
              conflictCountsByPath: t,
              binaryFilePaths: n
            }
          }(e);
          if (n) return await async function (e) {
            const t = await Ka(e.path);
            let n = [];
            try {
              n = await Cs(e, "HEAD")
            } catch (e) {}
            return {
              conflictCountsByPath: t,
              binaryFilePaths: n
            }
          }(e)
        } catch (e) {
          log.error("Unexpected error from git operations in getConflictDetails", e)
        }
        return {
          conflictCountsByPath: new Map,
          binaryFilePaths: new Array
        }
      }(e, s, a, l), u = o.reduce((e, t) => function (e, t, n) {
        const r = function (e) {
          return "??" === e ? {
            kind: "untracked"
          } : ".M" === e ? {
            kind: "ordinary",
            type: "modified",
            index: qi.Unchanged,
            workingTree: qi.Modified
          } : "M." === e ? {
            kind: "ordinary",
            type: "modified",
            index: qi.Modified,
            workingTree: qi.Unchanged
          } : ".A" === e ? {
            kind: "ordinary",
            type: "added",
            index: qi.Unchanged,
            workingTree: qi.Added
          } : "A." === e ? {
            kind: "ordinary",
            type: "added",
            index: qi.Added,
            workingTree: qi.Unchanged
          } : ".D" === e ? {
            kind: "ordinary",
            type: "deleted",
            index: qi.Unchanged,
            workingTree: qi.Deleted
          } : "D." === e ? {
            kind: "ordinary",
            type: "deleted",
            index: qi.Deleted,
            workingTree: qi.Unchanged
          } : "R." === e ? {
            kind: "renamed",
            index: qi.Renamed,
            workingTree: qi.Unchanged
          } : ".R" === e ? {
            kind: "renamed",
            index: qi.Unchanged,
            workingTree: qi.Renamed
          } : "C." === e ? {
            kind: "copied",
            index: qi.Copied,
            workingTree: qi.Unchanged
          } : ".C" === e ? {
            kind: "copied",
            index: qi.Unchanged,
            workingTree: qi.Copied
          } : "AD" === e ? {
            kind: "ordinary",
            type: "added",
            index: qi.Added,
            workingTree: qi.Deleted
          } : "AM" === e ? {
            kind: "ordinary",
            type: "added",
            index: qi.Added,
            workingTree: qi.Modified
          } : "RM" === e ? {
            kind: "renamed",
            index: qi.Renamed,
            workingTree: qi.Modified
          } : "RD" === e ? {
            kind: "renamed",
            index: qi.Renamed,
            workingTree: qi.Deleted
          } : "DD" === e ? {
            kind: "conflicted",
            action: Yi.BothDeleted,
            us: qi.Deleted,
            them: qi.Deleted
          } : "AU" === e ? {
            kind: "conflicted",
            action: Yi.AddedByUs,
            us: qi.Added,
            them: qi.UpdatedButUnmerged
          } : "UD" === e ? {
            kind: "conflicted",
            action: Yi.DeletedByThem,
            us: qi.UpdatedButUnmerged,
            them: qi.Deleted
          } : "UA" === e ? {
            kind: "conflicted",
            action: Yi.AddedByThem,
            us: qi.UpdatedButUnmerged,
            them: qi.Added
          } : "DU" === e ? {
            kind: "conflicted",
            action: Yi.DeletedByUs,
            us: qi.Deleted,
            them: qi.UpdatedButUnmerged
          } : "AA" === e ? {
            kind: "conflicted",
            action: Yi.BothAdded,
            us: qi.Added,
            them: qi.Added
          } : "UU" === e ? {
            kind: "conflicted",
            action: Yi.BothModified,
            us: qi.UpdatedButUnmerged,
            them: qi.UpdatedButUnmerged
          } : {
            kind: "ordinary",
            type: "modified"
          }
        }(t.statusCode);
        if ("ordinary" === r.kind && r.index === qi.Added && r.workingTree === qi.Deleted) return e;
        "untracked" === r.kind && e.delete(t.path);
        const i = Tl(t.path, r, n, t.oldPath),
          o = Hi.fromInitialSelection(Ii.All);
        return e.set(t.path, new co(t.path, i, o)), e
      }(e, t, c), new Map), {
        currentBranch: h,
        currentUpstreamBranch: p,
        currentTip: d,
        branchAheadBehind: f
      } = r.reduce(_l, {
        currentBranch: void 0,
        currentUpstreamBranch: void 0,
        currentTip: void 0,
        branchAheadBehind: void 0,
        match: null
      });
    return {
      currentBranch: h,
      currentTip: d,
      currentUpstreamBranch: p,
      branchAheadBehind: f,
      exists: !0,
      mergeHeadFound: s,
      rebaseInternalState: l,
      workingDirectory: ho.fromFiles([...u.values()])
    }
  }

  function _l(e, t) {
    let {
      currentBranch: n,
      currentUpstreamBranch: r,
      currentTip: i,
      branchAheadBehind: o,
      match: s
    } = e;
    const a = t.value;
    if (s = a.match(/^branch\.oid ([a-f0-9]+)$/)) i = s[1];
    else if (s = a.match(/^branch.head (.*)/)) "(detached)" !== s[1] && (n = s[1]);
    else if (s = a.match(/^branch.upstream (.*)/)) r = s[1];
    else if (s = a.match(/^branch.ab \+(\d+) -(\d+)$/)) {
      const e = parseInt(s[1], 10),
        t = parseInt(s[2], 10);
      isNaN(e) || isNaN(t) || (o = {
        ahead: e,
        behind: t
      })
    }
    return {
      currentBranch: n,
      currentUpstreamBranch: r,
      currentTip: i,
      branchAheadBehind: o,
      match: s
    }
  }
  async function Al(e) {
    const t = await Bo(["var", "GIT_AUTHOR_IDENT"], e.path, "getAuthorIdentity", {
      successExitCodes: new Set([0, 128])
    });
    return 128 === t.exitCode ? null : Os.parseIdentity(t.stdout)
  }
  var Ml;

  function Pl(e) {
    const t = function (e) {
      switch (e[0]) {
        case "A":
          return Ml.Added;
        case "C":
          return Ml.Copied;
        case "D":
          return Ml.Deleted;
        case "M":
          return Ml.Modified;
        case "R":
          return Ml.Renamed;
        case "T":
          return Ml.TypeChanged;
        case "U":
          return Ml.Unmerged;
        case "X":
          return Ml.Unknown;
        default:
          throw new Error("Unknown index status: " + e)
      }
    }(e);
    switch (t) {
      case Ml.Copied:
      case Ml.Renamed:
        throw new Error("Invalid index status for no-rename index status: " + t)
    }
    return t
  }! function (e) {
    e[e.Unknown = 0] = "Unknown", e[e.Added = 1] = "Added", e[e.Copied = 2] = "Copied", e[e.Deleted = 3] = "Deleted", e[e.Modified = 4] = "Modified", e[e.Renamed = 5] = "Renamed", e[e.TypeChanged = 6] = "TypeChanged", e[e.Unmerged = 7] = "Unmerged"
  }(Ml || (Ml = {}));
  const Il = [{
    title: "",
    weight: 0
  }];
  class Ol extends na {
    constructor() {
      super(Il)
    }
  }
  class Ll {
    constructor(e, t, n) {
      this.sha = e, this.path = t, this.describe = n
    }
  }
  async function Nl(e) {
    const t = i.join(e.path, ".gitignore");
    return new Promise((e, n) => {
      o.readFile(t, "utf8", (t, r) => {
        t ? "ENOENT" === t.code ? e(null) : n(t) : e(r)
      })
    })
  }
  async function Fl(e, t) {
    const n = i.join(e.path, ".gitignore");
    if ("" === t) return new Promise((e, t) => {
      o.unlink(n, n => {
        n ? t(n) : e()
      })
    });
    const r = await Bl(t, e);
    return new Promise((e, t) => {
      o.writeFile(n, r, n => {
        n ? t(n) : e()
      })
    })
  }
  async function Bl(e, t) {
    const n = await Po(t, "core.autocrlf"),
      r = await Po(t, "core.safecrlf");
    return new Promise((t, i) => {
      if ("true" !== n || "true" !== r)
        if (e.endsWith("\n")) t(e);
        else if (null == n) t(e + "\n");
      else {
        t("true" === n ? e + "\n" : e + "\r\n")
      } else {
        t(e.replace(/\r\n|\n\r|\n|\r/g, "\r\n"))
      }
    })
  }
  n(127);
  async function Hl(e, t) {
    const n = ["lfs", "install"];
    t && n.push("--force"), await Bo(n, e.path, "installLFSHooks")
  }
  async function zl(e, t) {
    const {
      stdout: n
    } = await Bo(["check-attr", "filter", t], e.path, "checkAttrForLFS");
    return null !== /: filter: lfs/.exec(n)
  }

  function Ul(e) {
    switch (e.kind) {
      case Ki.New:
      case Ki.Untracked:
        return "New";
      case Ki.Modified:
        return "Modified";
      case Ki.Deleted:
        return "Deleted";
      case Ki.Renamed:
        return "Renamed";
      case Ki.Conflicted:
        if (so(e)) {
          return e.conflictMarkerCount > 0 ? "Conflicted" : "Resolved"
        }
        return "Conflicted";
      case Ki.Copied:
        return "Copied";
      default:
        return X(0, "Unknown file status " + e)
    }
  }

  function Wl(e) {
    return e.kind === Ki.Conflicted
  }

  function Vl(e) {
    return e.files.some(e => Wl(e.status))
  }

  function jl(e, t) {
    return void 0 === t && (!so(e) || e.conflictMarkerCount > 0)
  }

  function Gl(e, t) {
    const n = t ? " from " + t : "";
    switch (e) {
      case qi.Added:
        return "Using the added file" + n;
      case qi.UpdatedButUnmerged:
        return "Using the modified file" + n;
      case qi.Deleted:
        return "Using the deleted file" + n;
      default:
        return X(0, "Unknown status entry to format")
    }
  }

  function $l(e, t) {
    const n = t ? " from " + t : "";
    switch (e) {
      case qi.Added:
        return "Use the added file" + n;
      case qi.UpdatedButUnmerged:
        return "Use the modified file" + n;
      case qi.Deleted:
        return "Use the deleted file" + n;
      default:
        return X(0, "Unknown status entry to format")
    }
  }

  function ql(e) {
    return e.files.filter(e => Wl(e.status))
  }

  function Kl(e) {
    return e.files.filter(e => e.status.kind === Ki.Untracked)
  }

  function Yl(e, t) {
    return e.files.filter(e => oo(e.status) && !jl(e.status, t.get(e.path)))
  }

  function Ql(e, t) {
    return e.files.filter(e => oo(e.status) && jl(e.status, t.get(e.path)))
  }
  class Zl {
    constructor(e = new Map) {
      this._state = e
    }
    get state() {
      return new Map(this._state)
    }
    updateMenuItem(e, t) {
      const n = this._state.get(e) || {};
      this._state.set(e, hi(n, t))
    }
    enable(e) {
      return this.updateMenuItem(e, {
        enabled: !0
      }), this
    }
    disable(e) {
      return this.updateMenuItem(e, {
        enabled: !1
      }), this
    }
    setEnabled(e, t) {
      return this.updateMenuItem(e, {
        enabled: t
      }), this
    }
    merge(e) {
      const t = new Map(this._state);
      for (const [n, r] of e._state) t.set(n, r);
      return new Zl(t)
    }
  }

  function Xl(e, t) {
    return void 0 === e.enabled || "separator" === t.type || t.enabled === e.enabled
  }
  const Jl = ["rename-branch", "delete-branch", "discard-all-changes", "stash-all-changes", "preferences", "update-branch", "compare-to-branch", "merge-branch", "rebase-branch", "view-repository-on-github", "compare-on-github", "open-in-shell", "push", "pull", "branch", "repository", "go-to-commit-message", "create-branch", "show-changes", "show-history", "show-repository-list", "show-branches-list", "open-working-directory", "show-repository-settings", "open-external-editor", "remove-repository", "new-repository", "add-local-repository", "clone-repository", "about", "create-pull-request"];

  function ec(e) {
    const t = e.selectedState,
      n = !!t && (!(!(r = t.repository) || r instanceof Ai || !r.gitHubRepository) && null !== r.gitHubRepository.htmlURL);
    var r;
    let i = !1,
      o = !1,
      s = !1,
      a = !1,
      l = !1,
      c = !1,
      u = !1,
      h = !1,
      p = !1,
      d = !1,
      f = !1,
      m = !1,
      g = !1;
    const y = null !== t && t.repository instanceof Xi && function (e) {
      if (Ji(e)) {
        const t = e.gitHubRepository;
        return t.parent ? !1 !== t.parent.issuesEnabled && !0 !== t.parent.isArchived : !1 !== t.issuesEnabled && !0 !== t.isArchived
      }
      return !1
    }(t.repository);
    if (t && t.type === W.Repository) {
      i = !0;
      const {
        branchesState: e,
        changesState: n
      } = t.state, r = e.tip, y = e.defaultBranch;
      u = Boolean(y), s = r.kind === Qi.Valid, a = r.kind === Qi.Detached, d = r.kind === Qi.Unknown, f = r.kind === Qi.Unborn, r.kind === Qi.Valid ? (null !== y && (o = r.branch.name !== y.name), h = !!r.branch.upstream, g = null !== n.stashEntry) : o = !0, p = t.state.isPushPullFetchInProgress;
      const {
        conflictState: v,
        workingDirectory: w
      } = t.state.changesState;
      m = null !== v && "rebase" === v.kind, c = null !== n.conflictState || Vl(w), l = w.files.length > 0
    }
    const v = ["branch", "repository", "remove-repository", "open-in-shell", "open-working-directory", "show-repository-settings", "go-to-commit-message", "show-changes", "show-history", "show-branches-list", "open-external-editor", "compare-to-branch"],
      w = new Zl,
      b = "hidden" !== e.windowState,
      S = e.showWelcomeFlow,
      C = b && i && !S;
    if (C) {
      for (const e of v) w.enable(e);
      w.setEnabled("rename-branch", o && !f && !a), w.setEnabled("delete-branch", o && !f && !a), w.setEnabled("update-branch", o && u && !a), w.setEnabled("merge-branch", s), w.setEnabled("rebase-branch", s), w.setEnabled("compare-on-github", n && h), w.setEnabled("view-repository-on-github", n), w.setEnabled("create-issue-in-repository-on-github", y), w.setEnabled("create-pull-request", n && !f && !a), w.setEnabled("push", !f && !a && !p), w.setEnabled("pull", h && !p), w.setEnabled("create-branch", !d && !f && !m), w.setEnabled("discard-all-changes", C && l && !m), w.setEnabled("stash-all-changes", l && s && !m && !c), w.setEnabled("compare-to-branch", !a), w.setEnabled("toggle-stashed-changes", g), t && t.type === W.MissingRepository && w.disable("open-external-editor")
    } else {
      for (const e of v) w.disable(e);
      w.disable("view-repository-on-github"), w.disable("create-pull-request"), t && t.type === W.MissingRepository && (t.repository.gitHubRepository && w.enable("view-repository-on-github"), w.enable("remove-repository")), w.disable("create-branch"), w.disable("rename-branch"), w.disable("delete-branch"), w.disable("discard-all-changes"), w.disable("stash-all-changes"), w.disable("update-branch"), w.disable("merge-branch"), w.disable("rebase-branch"), w.disable("push"), w.disable("pull"), w.disable("compare-to-branch"), w.disable("compare-on-github"), w.disable("toggle-stashed-changes")
    }
    return w
  }

  function tc(e) {
    return e.currentPopup ? function () {
      const e = new Zl;
      for (const t of Jl) e.disable(t);
      return e
    }().state : function () {
      const e = new Zl;
      for (const t of Jl) e.enable(t);
      return e
    }().merge(ec(e)).merge(function (e) {
      const t = ["new-repository", "add-local-repository", "clone-repository", "preferences", "about"],
        n = new Zl;
      if (e)
        for (const e of t) n.disable(e);
      else
        for (const e of t) n.enable(e);
      return n
    }(e.showWelcomeFlow)).merge(function (e) {
      const t = ["show-repository-list"],
        n = new Zl;
      if (0 === e.repositories.length)
        for (const e of t) n.disable(e);
      return n
    }(e)).state
  }

  function nc(e, t) {
    const n = tc(e);
    if (t)
      for (const [e, r] of n.entries()) {
        const i = t.getItemById(e);
        i && Xl(r, i) && n.delete(e)
      }
    if (0 === n.size) return;
    const i = new Array;
    n.forEach((e, t) => i.push({
        id: t,
        state: e
      })),
      function (e) {
        r.ipcRenderer.send("update-menu-state", e)
      }(i)
  }
  var rc, ic;
  ! function (e) {
    e[e.Push = 1] = "Push", e[e.Pull = 2] = "Pull", e[e.Fetch = 3] = "Fetch", e[e.Clone = 4] = "Clone", e[e.Checkout = 5] = "Checkout", e[e.Merge = 6] = "Merge", e[e.Rebase = 7] = "Rebase"
  }(rc || (rc = {})),
  function (e) {
    e.Terminal = "Terminal", e.Hyper = "Hyper", e.iTerm2 = "iTerm2", e.PowerShellCore = "PowerShell Core", e.Kitty = "Kitty", e.Alacritty = "Alacritty"
  }(ic || (ic = {}));
  ic.Terminal;

  function oc() {
    {
      const e = process.env.SystemRoot || "C:\\Windows",
        t = i.join(e, "System32", "where.exe");
      return log.info("calling captureCommandOutput(where git)"),
        function (e, t, n = {}) {
          return new Promise((r, i) => {
            const o = Object(Ro.spawn)(e, t, n);
            o.on("error", t => {
              log.warn("Unable to spawn " + e, t), r(void 0)
            });
            const s = new Array;
            let a = 0;
            o.stdout.on("data", e => {
              s.push(e), a += e.length
            }), o.on("close", (function (e) {
              r(0 !== e ? void 0 : Buffer.concat(s, a).toString().replace(/\r?\n[^]*/m, ""))
            }))
          })
        }(t, ["git"], {
          cwd: e
        })
    }
  }
  var sc;
  ! function (e) {
    e.Cmd = "Command Prompt", e.PowerShell = "PowerShell", e.PowerShellCore = "PowerShell Core", e.Hyper = "Hyper", e.GitBash = "Git Bash", e.Cygwin = "Cygwin", e.WSL = "WSL", e.WindowTerminal = "Windows Terminal", e.Alacritty = "Alacritty"
  }(sc || (sc = {}));
  const ac = sc.Cmd;
  async function lc() {
    const e = await oc(),
      t = [{
        shell: sc.Cmd,
        path: process.env.comspec || "C:\\Windows\\System32\\cmd.exe",
        extraArgs: e ? ["/K", `"doskey git=^"${e}^" $*"`] : []
      }],
      n = await async function () {
        const e = Object(wo.enumerateValues)(wo.HKEY.HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\PowerShell.exe");
        if (0 === e.length) return null;
        const t = e[0];
        if (t.type === wo.RegistryValueType.REG_EXPAND_SZ || t.type === wo.RegistryValueType.REG_SZ) {
          const e = t.data.replace(/^%SystemRoot%/i, process.env.SystemRoot || "C:\\Windows");
          if (await Object(Ci.pathExists)(e)) return e;
          log.debug(`[PowerShell] registry entry found but does not exist at '${e}'`)
        }
        return null
      }();
    null != n && t.push({
      shell: sc.PowerShell,
      path: n
    });
    const r = await async function () {
      const e = Object(wo.enumerateValues)(wo.HKEY.HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\pwsh.exe");
      if (0 === e.length) return null;
      const t = e[0];
      if (t.type === wo.RegistryValueType.REG_SZ) {
        const e = t.data;
        if (await Object(Ci.pathExists)(e)) return e;
        log.debug(`[PowerShellCore] registry entry found but does not exist at '${e}'`)
      }
      return null
    }();
    null != r && t.push({
      shell: sc.PowerShellCore,
      path: r
    });
    const o = await async function () {
      const e = Object(wo.enumerateValues)(wo.HKEY.HKEY_CURRENT_USER, "Software\\Classes\\Directory\\Background\\shell\\Hyper\\command");
      if (0 === e.length) return null;
      const t = e[0];
      if (t.type === wo.RegistryValueType.REG_SZ) {
        const e = t.data.match(/(["'])(.*?)\1/),
          n = process.env.LocalAppData,
          r = e ? e[2] : null != n ? n.concat("\\hyper\\Hyper.exe") : null;
        if (null == r) log.debug("[Hyper] LOCALAPPDATA environment variable is unset, aborting fallback behavior");
        else {
          if (await Object(Ci.pathExists)(r)) return r;
          log.debug(`[Hyper] registry entry found but does not exist at '${r}'`)
        }
      }
      return null
    }();
    null != o && t.push({
      shell: sc.Hyper,
      path: o
    });
    const s = await async function () {
      const e = Object(wo.enumerateValues)(wo.HKEY.HKEY_LOCAL_MACHINE, "SOFTWARE\\GitForWindows");
      if (0 === e.length) return null;
      const t = e.find(e => "InstallPath" === e.name);
      if (t && t.type === wo.RegistryValueType.REG_SZ) {
        const e = i.join(t.data, "git-bash.exe");
        if (await Object(Ci.pathExists)(e)) return e;
        log.debug(`[Git Bash] registry entry found but does not exist at '${e}'`)
      }
      return null
    }();
    null != s && t.push({
      shell: sc.GitBash,
      path: s
    });
    const a = await async function () {
      const e = Object(wo.enumerateValues)(wo.HKEY.HKEY_LOCAL_MACHINE, "SOFTWARE\\Cygwin\\setup"),
        t = Object(wo.enumerateValues)(wo.HKEY.HKEY_LOCAL_MACHINE, "SOFTWARE\\WOW6432Node\\Cygwin\\setup");
      if (null == e || null == t) return null;
      const n = e.find(e => "rootdir" === e.name),
        r = t.find(e => "rootdir" === e.name);
      if (n && n.type === wo.RegistryValueType.REG_SZ) {
        const e = i.join(n.data, "bin\\mintty.exe");
        if (await Object(Ci.pathExists)(e)) return e;
        if (r && r.type === wo.RegistryValueType.REG_SZ) {
          const e = i.join(r.data, "bin\\mintty.exe");
          if (await Object(Ci.pathExists)(e)) return e
        } else log.debug(`[Cygwin] registry entry found but does not exist at '${e}'`)
      }
      return null
    }();
    if (null != a && t.push({
        shell: sc.Cygwin,
        path: a
      }), $s()) {
      const e = await async function () {
        const e = i.join(process.env.SystemRoot || "C:\\Windows", "System32"),
          t = i.join(e, "wsl.exe"),
          n = i.join(e, "wslconfig.exe");
        if (!await Object(Ci.pathExists)(t)) return log.debug(`[WSL] wsl.exe does not exist at '${t}'`), null;
        if (!await Object(Ci.pathExists)(n)) return log.debug(`[WSL] found wsl.exe, but wslconfig.exe does not exist at '${n}'`), null;
        const r = new Promise((e, t) => {
          const r = Object(Ro.spawn)(n, ["/list"]);
          r.on("error", t), r.on("exit", e)
        });
        try {
          const e = await r;
          return 0 !== e ? (log.debug("[WSL] found wsl.exe and wslconfig.exe, but no distros are installed. Error Code: " + e), null) : t
        } catch (e) {
          log.error("[WSL] unhandled error when invoking 'wsl /list'", e)
        }
        return null
      }();
      null != e && t.push({
        shell: sc.WSL,
        path: e
      })
    }
    const l = await async function () {
      const e = Object(wo.enumerateValues)(wo.HKEY.HKEY_CLASSES_ROOT, "Directory\\Background\\shell\\Open Alacritty here");
      if (0 === e.length) return null;
      const t = e.find(e => "Icon" === e.name);
      if (t && t.type === wo.RegistryValueType.REG_SZ) {
        const e = t.data;
        if (await Object(Ci.pathExists)(e)) return e;
        log.debug(`[Alacritty] registry entry found but does not exist at '${e}'`)
      }
      return null
    }();
    null != l && t.push({
      shell: sc.Alacritty,
      path: l
    });
    const c = await async function () {
      const e = process.env.LocalAppData;
      if (null != e) {
        const t = i.join(e, "\\Microsoft\\WindowsApps\\wt.exe");
        if (await Object(Ci.pathExists)(t)) return t;
        log.debug(`[Windows Terminal] wt.exe doest not exist at '${t}'`)
      }
      return null
    }();
    return null != c && t.push({
      shell: sc.WindowTerminal,
      path: c
    }), t
  }
  var cc;
  ! function (e) {
    e.Gnome = "GNOME Terminal", e.Mate = "MATE Terminal", e.Tilix = "Tilix", e.Terminator = "Terminator", e.Urxvt = "URxvt", e.Konsole = "Konsole", e.Xterm = "XTerm", e.Terminology = "Terminology"
  }(cc || (cc = {}));
  cc.Gnome;
  class uc extends Error {}
  const hc = ac;
  let pc = null;

  function dc(e) {
    return function (e) {
      return e === sc.Cmd ? sc.Cmd : e === sc.PowerShell ? sc.PowerShell : e === sc.PowerShellCore ? sc.PowerShellCore : e === sc.Hyper ? sc.Hyper : e === sc.GitBash ? sc.GitBash : e === sc.Cygwin ? sc.Cygwin : e === sc.WSL ? sc.WSL : e === sc.WindowTerminal ? sc.WindowTerminal : e === sc.Alacritty ? sc.Alacritty : ac
    }(e)
  }
  async function fc() {
    return pc || (pc = await lc(), pc)
  }
  async function mc(e, t, n) {
    if (!await Object(Ci.pathExists)(e.path)) {
      const t = "Options";
      throw new uc(`Could not find executable for '${e.shell}' at path '${e.path}'.  Please open ${t} and select an available shell.`)
    }
    let r = null;
    return r = function (e, t) {
      const n = e.shell;
      switch (n) {
        case sc.PowerShell:
          const r = `"Set-Location -LiteralPath '${t}'"`;
          return Object(Ro.spawn)("START", ['"PowerShell"', `"${e.path}"`, "-NoExit", "-Command", r], {
            shell: !0,
            cwd: t
          });
        case sc.PowerShellCore:
          const i = `"Set-Location -LiteralPath '${t}'"`;
          return Object(Ro.spawn)("START", ['"PowerShell Core"', `"${e.path}"`, "-NoExit", "-Command", i], {
            shell: !0,
            cwd: t
          });
        case sc.Hyper:
          const o = `"${e.path}"`;
          return log.info(`launching ${n} at path: ${o}`), Object(Ro.spawn)(o, [`"${t}"`], {
            shell: !0,
            cwd: t
          });
        case sc.Alacritty:
          const s = `"${e.path}"`;
          return log.info(`launching ${n} at path: ${s}`), Object(Ro.spawn)(s, [`--working-directory "${t}"`], {
            shell: !0,
            cwd: t
          });
        case sc.GitBash:
          const a = `"${e.path}"`;
          return log.info(`launching ${n} at path: ${a}`), Object(Ro.spawn)(a, [`--cd="${t}"`], {
            shell: !0,
            cwd: t
          });
        case sc.Cygwin:
          const l = `"${e.path}"`;
          return log.info(`launching ${n} at path: ${l}`), Object(Ro.spawn)(l, [`/bin/sh -lc 'cd "$(cygpath "${t}")"; exec bash`], {
            shell: !0,
            cwd: t
          });
        case sc.WSL:
          return Object(Ro.spawn)("START", ['"WSL"', `"${e.path}"`], {
            shell: !0,
            cwd: t
          });
        case sc.Cmd:
          return Object(Ro.spawn)("START", ['"Command Prompt"', `"${e.path}"`, ...e.extraArgs], {
            shell: !0,
            cwd: t
          });
        case sc.WindowTerminal:
          const c = `"${e.path}"`;
          return log.info(`launching ${n} at path: ${c}`), Object(Ro.spawn)(c, ["-d ."], {
            shell: !0,
            cwd: t
          });
        default:
          return X(0, "Unknown shell: " + n)
      }
    }(e, t), null != r ? (function (e, t, n) {
      null !== t.stderr && t.stderr.on("data", t => {
        const n = t instanceof Buffer ? t.toString() : t;
        log.debug(`[${e}] stderr: '${n}'`)
      });
      t.on("error", t => {
        log.debug(`[${e}] an error was encountered`, t), n(t)
      }), t.on("exit", t => {
        0 !== t && log.debug(`[${e}] exit code: ${t}`)
      })
    }(e.shell, r, n), Promise.resolve()) : Promise.reject("Platform not currently supported for launching shells: win32")
  }

  function gc(e) {
    return e.isFullScreen() ? "full-screen" : e.isMaximized() ? "maximized" : e.isMinimized() ? "minimized" : e.isVisible() ? "normal" : "hidden"
  }
  var yc = n(128),
    vc = n.n(yc);
  class wc {
    constructor() {
      this.backingStore = new Map
    }
    set(e, t, n) {
      const r = Ua(e, t);
      this.backingStore.set(r, n)
    }
    get(e, t) {
      const n = Ua(e, t);
      return this.backingStore.get(n) || null
    }
    has(e, t) {
      const n = Ua(e, t);
      return this.backingStore.has(n)
    }
    get size() {
      return this.backingStore.size
    }
    clear() {
      this.backingStore.clear()
    }
  }
  class bc {
    constructor(e, t) {
      this.repository = e, this.onCacheUpdate = t, this.comparisonCache = new wc, this.aheadBehindQueue = vc()({
        concurrency: 1,
        autostart: !0
      })
    }
    start() {
      this.aheadBehindQueue.on("success", e => {
        null != e && this.onCacheUpdate(this.comparisonCache)
      }), this.aheadBehindQueue.on("error", e => {
        log.debug("[AheadBehindUpdater] an error with the queue was reported", e)
      }), this.aheadBehindQueue.on("end", e => {
        null != e && log.debug("[AheadBehindUpdater] ended with an error", e)
      }), this.aheadBehindQueue.start()
    }
    stop() {
      this.aheadBehindQueue.end()
    }
    async executeAsyncTask(e, t) {
      if (this.comparisonCache.has(e, t)) return this.comparisonCache.get(e, t);
      const n = Ua(e, t),
        r = await Wa(this.repository, n);
      return null !== r ? this.comparisonCache.set(e, t, r) : log.debug(`[AheadBehindUpdater] unable to cache '${n}' as no result returned`), r
    }
    insert(e, t, n) {
      this.comparisonCache.has(e, t) || this.comparisonCache.set(e, t, n)
    }
    clear() {
      this.aheadBehindQueue.end()
    }
    schedule(e, t, n, r) {
      this.clear();
      const i = e.tip.sha,
        o = [...n, ...r],
        s = null !== t ? [t, ...o] : o,
        a = new Set((e => e.map(e => e.tip.sha).filter(e => !this.comparisonCache.has(i, e)))(s));
      log.debug(`[AheadBehindUpdater] - found ${a.size} comparisons to perform`);
      for (const e of a) this.aheadBehindQueue.push(() => new Promise((t, n) => {
        requestIdleCallback(() => {
          this.executeAsyncTask(i, e).then(t, n)
        })
      }))
    }
  }

  function Sc(e, t) {
    return Promise.all([e(), Cc(t)]).then(e => e[0])
  }
  async function Cc(e) {
    return new Promise(t => window.setTimeout(t, e))
  }
  class Ec {
    constructor(e, t, n, r) {
      this.timeoutHandle = null, this.stopped = !1, this.repository = e, this.account = t, this.fetch = n, this.shouldPerformFetch = r
    }
    start(e) {
      this.stopped && Z("Cannot start a background fetcher that has been stopped.");
      const t = this.repository.gitHubRepository;
      t && (e ? this.timeoutHandle = window.setTimeout(() => this.performAndScheduleFetch(t), xc()) : this.performAndScheduleFetch(t))
    }
    stop() {
      this.stopped = !0;
      const e = this.timeoutHandle;
      e && (window.clearTimeout(e), this.timeoutHandle = null)
    }
    async performAndScheduleFetch(e) {
      if (this.stopped) return;
      if (this.shouldPerformFetch(this.repository)) try {
        await this.fetch(this.repository)
      } catch (e) {
        const t = this.repository.gitHubRepository,
          n = null !== t ? t.fullName : this.repository.name;
        log.error(`Error performing periodic fetch for '${n}'`, e)
      }
      if (this.stopped) return;
      const t = await this.getFetchInterval(e);
      this.stopped || (this.timeoutHandle = window.setTimeout(() => this.performAndScheduleFetch(e), t))
    }
    async getFetchInterval(e) {
      const t = at.fromAccount(this.account);
      let n = 36e5;
      try {
        const r = await t.getFetchPollInterval(e.owner.login, e.name);
        n = r ? Math.max(r, 3e5) : 36e5
      } catch (e) {
        log.error("Error fetching poll interval", e)
      }
      return n + xc()
    }
  }
  let kc = null;

  function xc() {
    if (null !== kc) return kc;
    const e = Math.ceil(3e4 * Math.random());
    return kc = e, e
  }
  async function Tc(e, t, n, r) {
    if (null !== n) {
      const e = function (e, t) {
        return Rc(e, t.base.ref)
      }(t, n);
      if (null !== e) return e
    }
    if (Ji(e)) {
      if (e.gitHubRepository.fork) {
        const n = await async function (e, t, n) {
          const r = ro(e),
            i = (await n(e)).find(e => Rt(e.url, r));
          if (void 0 === i) return log.warn(`Could not find remote with URL ${r.cloneURL}.`), null;
          const o = `${i.name}/${r.defaultBranch}`;
          return Rc(t, o)
        }(e, t, r);
        if (null !== n) return n
      }
      const n = function (e, t) {
        if (null === t.defaultBranch) return null;
        return Rc(e, t.defaultBranch)
      }(t, e.gitHubRepository);
      if (null !== n) return n
    }
    return function (e) {
      return Rc(e, "master")
    }(t)
  }

  function Rc(e, t) {
    return e.find(e => e.name === t) || null
  }
  async function Dc(e) {
    try {
      return await Ga(e)
    } catch (e) {
      return null
    }
  }
  var _c = n(129),
    Ac = n.n(_c);

  function Mc(...e) {
    const t = i.resolve(...e);
    return Ac()(t)
  }
  async function Pc(e, t, n = i) {
    if (0 === e.length) return null;
    const {
      join: r,
      normalize: o,
      resolve: s
    } = n, a = o(e), l = o(r(...t));
    if (-1 !== a.indexOf("\0") || -1 !== l.indexOf("\0")) return null;
    const c = s(a, l),
      u = await Object(Ci.realpath)(a);
    return (await Object(Ci.realpath)(c)).startsWith(u) ? c : null
  }

  function Ic(e) {
    return Mc(__dirname, "emoji", e)
  }

  function Oc(e) {
    const t = e.toString(16);
    return t.length >= 4 ? t : ("0000" + t).substring(t.length)
  }

  function Lc(e) {
    return new Promise((t, n) => {
      const r = i.join(e, "emoji.json");
      o.readFile(r, "utf8", (e, r) => {
        if (e) return void n(e);
        const i = new Map;
        try {
          JSON.parse(r).forEach(e => {
            const t = e.emoji ? function (e) {
              const t = e.codePointAt(0);
              if (!t) return null;
              let n = Oc(t);
              if (e.length > 2) {
                const t = e.codePointAt(2);
                t && 65039 !== t && (n = `${n}-${Oc(t)}`)
              }
              return Ic(`unicode/${n}.png`)
            }(e.emoji) : Ic(e.aliases[0] + ".png");
            t ? e.aliases.forEach(e => {
              i.set(`:${e}:`, t)
            }) : log.error("Could not calculate location of emoji: " + e)
          })
        } catch (e) {
          n(e)
        }
        const o = new Map;
        Array.from(i.keys()).sort().forEach(e => {
          const t = i.get(e);
          t && o.set(e, t)
        }), t(o)
      })
    })
  }
  const Nc = {
    summary: "",
    description: ""
  };
  async function Fc() {
    return new Promise((e, t) => {
      requestAnimationFrame(e)
    })
  }
  class Bc extends Error {
    constructor(e, t) {
      super(`The remote '${t.name}' already exists`), this.repository = e, this.existingRemote = t
    }
  }

  function Hc(e, t) {
    const n = t.find(e => "upstream" === e.name);
    return n && xt(e, n) ? n : null
  }
  var zc;
  ! function (e) {
    e.NotLoaded = "NotLoaded", e.Loading = "Loading", e.Loaded = "Loaded"
  }(zc || (zc = {}));
  const Uc = /!!GitHub_Desktop<(.+)>$/;
  async function Wc(e) {
    const t = String.fromCharCode(parseInt("1F", 16)),
      n = ["%gD", "%H", "%gs"].join("%x1F"),
      r = await Bo(["log", "-g", "-z", "--pretty=" + n, "refs/stash"], e.path, "getStashEntries", {
        successExitCodes: new Set([0, 128])
      });
    if (128 === r.exitCode) return {
      desktopEntries: [],
      stashEntryCount: 0
    };
    const i = [],
      o = {
        kind: zc.NotLoaded
      },
      s = r.stdout.split("\0").filter(e => "" !== e);
    for (const e of s) {
      const n = e.split(t);
      if (3 === n.length) {
        const [e, t, r] = n, s = Kc(r);
        null !== s && i.push({
          name: e,
          branchName: s,
          stashSha: t,
          files: o
        })
      }
    }
    return {
      desktopEntries: i,
      stashEntryCount: s.length - 1
    }
  }
  async function Vc(e, t) {
    return (await Wc(e)).desktopEntries.find(e => e.branchName === t) || null
  }
  async function jc(e, t, n) {
    const r = n.map(e => e.withIncludeAll(!0));
    await ka(e, r);
    const i = ["stash", "push", "-m", function (e) {
        return `!!GitHub_Desktop<${e}>`
      }(t)],
      o = await Bo(i, e.path, "createStashEntry", {
        successExitCodes: new Set([0, 1])
      });
    if (1 === o.exitCode) {
      const e = /^error: /m.exec(o.stderr);
      if (null !== e && e.length > 0) throw new Fo(o, i);
      log.info(`[createDesktopStashEntry] a stash was created successfully but exit code ${o.exitCode} reported. stderr: ${o.stderr}`)
    }
    return !0
  }
  async function Gc(e, t) {
    return (await Wc(e)).desktopEntries.find(e => e.stashSha === t) || null
  }
  async function $c(e, t) {
    const n = await Gc(e, t);
    if (null !== n) {
      const t = ["stash", "drop", n.name];
      await Bo(t, e.path, "dropStashEntry")
    }
  }
  async function qc(e, t) {
    const n = new Set([Ao.GitError.MergeConflicts]),
      r = new Set([0, 1]),
      i = await Gc(e, t);
    if (null !== i) {
      const o = ["stash", "pop", "--quiet", "" + i.name],
        s = await Bo(o, e.path, "popStashEntry", {
          expectedErrors: n,
          successExitCodes: r
        });
      if (1 === s.exitCode) {
        if (s.stderr.length > 0) throw new Fo(s, o);
        log.info(`[popStashEntry] a stash was popped successfully but exit code ${s.exitCode} reported.`), await $c(e, t)
      }
    }
  }

  function Kc(e) {
    const t = Uc.exec(e);
    return null === t || 0 === t[1].length ? null : t[1]
  }
  async function Yc(e, t) {
    const n = ["log", t, "-C", "-M", "-m", "-1", "--no-show-signature", "--first-parent", "--name-status", "--format=format:", "-z", "--"],
      r = await Bo(n, e.path, "getChangedFilesForStash", {
        successExitCodes: new Set([0, 128])
      });
    return 0 === r.exitCode && r.stdout.length > 0 ? Na(r.stdout, t) : []
  }

  function Qc(e, t) {
    0 === t.length ? Xc(e) : function (e, t) {
      const n = JSON.stringify(t);
      localStorage.setItem(e, n)
    }(Jc(e), t)
  }

  function Zc(e) {
    return function (e) {
      const t = localStorage.getItem(e) || "[]";
      try {
        const e = JSON.parse(t);
        return e instanceof Array ? e.some(e => "string" != typeof e) ? [] : e : []
      } catch (e) {
        return []
      }
    }(Jc(e))
  }

  function Xc(e) {
    localStorage.removeItem(Jc(e))
  }

  function Jc(e) {
    return "tags-to-push-" + e.id
  }
  const eu = ["master", "main"];
  async function tu() {
    var e;
    return null !== (e = await async function () {
      return Ys() ? Io("init.defaultBranch") : null
    }()) && void 0 !== e ? e : "master"
  }
  class nu extends vi {
    constructor(e, t, n) {
      super(), this.repository = e, this.shell = t, this.statsStore = n, this.commitLookup = new Map, this._history = [], this.requestsInFight = new Set, this._tip = {
        kind: Qi.Unknown
      }, this._defaultBranch = null, this._localTags = null, this._allBranches = [], this._recentBranches = [], this._localCommitSHAs = [], this._commitMessage = Nc, this._showCoAuthoredBy = !1, this._coAuthors = [], this._aheadBehind = null, this._tagsToPush = [], this._defaultRemote = null, this._currentRemote = null, this._upstreamRemote = null, this._lastFetched = null, this._desktopStashEntries = new Map, this._stashEntryCount = 0, this._tagsToPush = Zc(e)
    }
    async reconcileHistory(e) {
      if (0 === this._history.length) return;
      if (this.requestsInFight.has("history")) return;
      this.requestsInFight.add("history");
      const t = za("HEAD", e),
        n = await this.performFailableOperation(() => La(this.repository, t, 100));
      if (null == n) return;
      const r = this._history,
        i = r.findIndex(t => t === e);
      if (i > -1) {
        log.debug(`reconciling history - adding ${n.length} commits before merge base ${e.substr(0,8)}`);
        const t = r.slice(i);
        this._history = [...n.map(e => e.sha), ...t]
      }
      this.storeCommits(n), this.requestsInFight.delete("history"), this.emitUpdate()
    }
    async loadNextHistoryBatch() {
      if (this.requestsInFight.has("history")) return;
      if (!this.history.length) return;
      const e = this.history[this.history.length - 1],
        t = "history/" + e;
      if (this.requestsInFight.has(t)) return;
      this.requestsInFight.add(t);
      const n = await this.performFailableOperation(() => La(this.repository, e + "^", 100));
      n && (this._history = this._history.concat(n.map(e => e.sha)), this.storeCommits(n), this.requestsInFight.delete(t), this.emitUpdate())
    }
    async loadCommitBatch(e) {
      if (this.requestsInFight.has("history")) return null;
      const t = "history/compare/" + e;
      if (this.requestsInFight.has(t)) return null;
      this.requestsInFight.add(t);
      const n = await this.performFailableOperation(() => La(this.repository, e, 100));
      return this.requestsInFight.delete(t), n ? (this.storeCommits(n), n.map(e => e.sha)) : null
    }
    async refreshTags() {
      const e = this._localTags,
        t = await this.performFailableOperation(() => async function (e) {
          const t = (await Bo(["show-ref", "--tags", "-d"], e.path, "getAllTags", {
            successExitCodes: new Set([0, 1])
          })).stdout.split("\n").filter(e => "" !== e).map(e => {
            const [t, n] = e.split(" ");
            return [n.replace(/^refs\/tags\//, "").replace(/\^\{\}$/, ""), t]
          });
          return new Map(t)
        }(this.repository));
      if (void 0 !== t) {
        this._localTags = t;
        for (const e of this._tagsToPush) this._localTags.has(e) || this.removeTagToPush(e);
        null !== e && this.emitUpdatesForChangedTags(e, this._localTags)
      }
    }
    async emitUpdatesForChangedTags(e, t) {
      const n = new Set;
      let r = 0;
      for (const [r, i] of e) {
        const e = t.get(r);
        e ? e !== i && (n.add(i), n.add(e)) : n.add(i)
      }
      for (const [i, o] of t) e.has(i) || (n.add(o), r++);
      r > 0 && this.statsStore.recordTagCreated(r);
      const i = [];
      for (const e of n) {
        const t = await Fa(this.repository, e);
        null !== t && i.push(t)
      }
      this.storeCommits(i)
    }
    async createTag(e, t) {
      void 0 !== await this.performFailableOperation(async () => (await async function (e, t, n) {
        const r = ["tag", "-a", "-m", "", t, n];
        await Bo(r, e.path, "createTag")
      }(this.repository, e, t), !0)) && (await this.refreshTags(), this.addTagToPush(e), this.statsStore.recordTagCreatedInDesktop())
    }
    async deleteTag(e) {
      void 0 !== await this.performFailableOperation(async () => (await async function (e, t) {
        const n = ["tag", "-d", t];
        await Bo(n, e.path, "deleteTag")
      }(this.repository, e), !0)) && (await this.refreshTags(), this.removeTagToPush(e), this.statsStore.recordTagDeleted())
    }
    get history() {
      return this._history
    }
    get tagsToPush() {
      return this._tagsToPush
    }
    get localTags() {
      return this._localTags
    }
    async loadBranches() {
      const [e, t] = await Promise.all([this.performFailableOperation(() => Ls(this.repository)) || [], this.performFailableOperation(() => async function (e, t) {
        const n = new RegExp(/.*? (renamed|checkout)(?:: moving from|\s*) (?:refs\/heads\/|\s*)(.*?) to (?:refs\/heads\/|\s*)(.*?)$/i),
          r = await Bo(["log", "-g", "--no-abbrev-commit", "--pretty=oneline", "HEAD", "-n", "2500", "--"], e.path, "getRecentBranches", {
            successExitCodes: new Set([0, 128])
          });
        if (128 === r.exitCode) return [];
        const i = r.stdout.split("\n"),
          o = new Set,
          s = new Set(["master"]);
        for (const e of i) {
          const r = n.exec(e);
          if (r && 4 === r.length) {
            const e = r[1],
              t = r[2],
              n = r[3];
            "renamed" === e && s.add(t), s.has(n) || o.add(n)
          }
          if (o.size === t) break
        }
        return [...o]
      }(this.repository, 5))]);
      e && (this._allBranches = this.mergeRemoteAndLocalBranches(e), this.refreshDefaultBranch(), this.refreshRecentBranches(t), this.checkPullWithRebase(), this.emitUpdate())
    }
    mergeRemoteAndLocalBranches(e) {
      const t = new Array,
        n = new Array;
      for (const r of e) r.type === As.Local ? t.push(r) : r.type === As.Remote && n.push(r);
      const r = new Set,
        i = new Array;
      for (const e of t) i.push(e), e.upstream && r.add(e.upstream);
      for (const e of n) r.has(e.name) || i.push(e);
      return i
    }
    async checkPullWithRebase() {
      const e = await Po(this.repository, "pull.rebase");
      null === e || "" === e ? this.pullWithRebase = void 0 : "true" === e ? this.pullWithRebase = !0 : "false" === e ? this.pullWithRebase = !1 : (log.warn(`Unexpected value found for pull.rebase in config: '${e}'`), this.pullWithRebase = void 0)
    }
    async refreshDefaultBranch() {
      const e = await this.resolveDefaultBranch();
      this._defaultBranch = this._allBranches.filter(t => t.name === e).sort((e, t) => vt(e.type, t.type)).shift() || null
    }
    addTagToPush(e) {
      this._tagsToPush = [...this._tagsToPush, e], Qc(this.repository, this._tagsToPush), this.emitUpdate()
    }
    removeTagToPush(e) {
      this._tagsToPush = this._tagsToPush.filter(t => t !== e), Qc(this.repository, this._tagsToPush), this.emitUpdate()
    }
    clearTagsToPush() {
      this._tagsToPush = [], Qc(this.repository, this._tagsToPush), this.emitUpdate()
    }
    async resolveDefaultBranch() {
      const {
        gitHubRepository: e
      } = this.repository;
      if (e && null != e.defaultBranch) return e.defaultBranch;
      if (null !== this.currentRemote) {
        const e = `refs/remotes/${this.currentRemote.name}/`,
          t = await Fs(this.repository, e + "HEAD");
        if (null != t && t.length > e.length && t.startsWith(e)) return t.substr(e.length)
      }
      return tu()
    }
    refreshRecentBranches(e) {
      if (!e || !e.length) return void(this._recentBranches = []);
      const t = this._allBranches.reduce((e, t) => e.set(t.name, t), new Map),
        n = new Array;
      for (const r of e) {
        const e = t.get(r);
        e && n.push(e)
      }
      this._recentBranches = n
    }
    get tip() {
      return this._tip
    }
    get defaultBranch() {
      return this._defaultBranch
    }
    get allBranches() {
      return this._allBranches
    }
    get recentBranches() {
      return this._recentBranches
    }
    async loadLocalCommits(e) {
      if (null === e) return void(this._localCommitSHAs = []);
      let t;
      if (e.upstream) {
        const n = za(e.upstream, e.name);
        t = await this.performFailableOperation(() => La(this.repository, n, 100))
      } else t = await this.performFailableOperation(() => La(this.repository, "HEAD", 100, ["--not", "--remotes"]));
      t && (this.storeCommits(t), this._localCommitSHAs = t.map(e => e.sha), this.emitUpdate())
    }
    get localCommitSHAs() {
      return this._localCommitSHAs
    }
    storeCommits(e) {
      for (const t of e) this.commitLookup.set(t.sha, t)
    }
    async undoFirstCommit(e) {
      const t = await this.performFailableOperation(() => Dl(this.repository));
      if (null == t) throw new Error("Unable to undo commit because there are too many files in your repository's working directory.");
      const n = t.workingDirectory.files.filter(e => e.status.kind === Ki.Deleted).map(e => e.path);
      return await async function (e, t) {
        await Bo(["checkout", "HEAD", "--", ...t], e.path, "checkoutPaths")
      }(e, n), await Hs(e, "HEAD", "Reverting first commit"), await async function (e) {
        await Bo(["rm", "--cached", "-r", "-f", "."], e.path, "unstageAllFiles")
      }(e), !0
    }
    async undoCommit(e) {
      if (void 0 !== await this.performFailableOperation(() => 0 === e.parentSHAs.length ? this.undoFirstCommit(this.repository) : async function (e, t, n) {
          const r = xa(t, n);
          return await Bo(r, e.path, "reset"), !0
        }(this.repository, 2, e.parentSHAs[0]))) {
        if (this.repository.gitHubRepository) try {
          return await this.loadCommitAndCoAuthors(e), void this.emitUpdate()
        } catch (e) {
          log.error("Failed to restore commit and co-authors, falling back", e)
        }
        this._commitMessage = {
          summary: e.summary,
          description: e.body
        }, this.emitUpdate()
      }
    }
    async loadCommitAndCoAuthors(e) {
      const t = this.repository,
        n = await Qo(t, {
          summary: e.summary,
          description: e.body
        }),
        r = (await async function (e, t) {
          const n = await Bo(["interpret-trailers", "--parse"], e.path, "parseTrailers", {
            stdin: t
          });
          if (0 === n.stdout.length) return [];
          const r = await Ko(e);
          return $o(n.stdout, r)
        }(t, n)).filter(Go);
      if (0 === r.length) return void(this._commitMessage = {
        summary: e.summary,
        description: e.body
      });
      const i = (await Yo(t, n, [], !0)).split("\n"),
        o = await Ko(this.repository),
        s = /^co-authored-by(.)\s(.*)/i,
        a = [];
      for (let e = i.length - 1; e >= 0; e--) {
        const t = i[e],
          n = s.exec(t);
        if (!n || -1 === o.indexOf(n[1])) continue;
        const l = qo(t, n[1]);
        if (!l) continue;
        const c = r.findIndex(e => e.value === l.value); - 1 !== c && (a.unshift(r[c]), r.splice(c, 1), i.splice(e, 1))
      }
      i.splice(0, 2);
      const l = i.join("\n").trim();
      this._commitMessage = {
        summary: e.summary,
        description: l
      };
      const c = a.map(e => Pa.parse(e.value)),
        u = new Array;
      for (let e = 0; e < c.length; e++) {
        const t = c[e];
        if (null === t) continue;
        const {
          name: n,
          email: r
        } = t, i = this.coAuthors.find(e => e.name === n && e.email === r && null !== e.username);
        u.push(i || {
          name: n,
          email: r,
          username: null
        })
      }
      this._coAuthors = u, this._coAuthors.length > 0 && !1 === this._showCoAuthoredBy && (this._showCoAuthoredBy = !0)
    }
    async performFailableOperation(e, t) {
      try {
        return await e()
      } catch (e) {
        return e = new ae(e, Object.assign({
          repository: this.repository
        }, t)), void this.emitError(e)
      }
    }
    get commitMessage() {
      return this._commitMessage
    }
    get showCoAuthoredBy() {
      return this._showCoAuthoredBy
    }
    get coAuthors() {
      return this._coAuthors
    }
    async fetch(e, t, n) {
      const r = new Map;
      if (null !== this.currentRemote && r.set(this.currentRemote.name, this.currentRemote), null !== this.defaultRemote && r.set(this.defaultRemote.name, this.defaultRemote), null !== this.upstreamRemote && r.set(this.upstreamRemote.name, this.upstreamRemote), r.size > 0 && await this.fetchRemotes(e, [...r.values()], t, n), this.tip.kind === Qi.Valid) {
        const e = this.tip.branch;
        if (null !== e.remote && null !== e.upstream) {
          const t = Ua(e.name, e.upstream);
          this._aheadBehind = await Wa(this.repository, t), this.emitUpdate()
        }
      }
    }
    async fetchRemotes(e, t, n, r) {
      if (!t.length) return;
      const i = 1 / t.length;
      for (let o = 0; o < t.length; o++) {
        const s = t[o],
          a = o * i;
        await this.fetchRemote(e, s, n, e => {
          e && r && r(Object.assign(Object.assign({}, e), {
            value: a + e.value * i
          }))
        })
      }
    }
    async fetchRemote(e, t, n, r) {
      const i = {
        type: rc.Fetch,
        repository: this.repository
      };
      await this.performFailableOperation(() => Aa(this.repository, e, t, r), {
        backgroundTask: n,
        retryAction: i
      })
    }
    async fetchRefspec(e, t) {
      const n = await zs(this.repository);
      for (const r of n) await this.performFailableOperation(() => Ma(this.repository, e, r, t))
    }
    async loadStatus() {
      const e = await this.performFailableOperation(() => Dl(this.repository));
      if (!e) return null;
      this._aheadBehind = e.branchAheadBehind || null;
      const {
        currentBranch: t,
        currentTip: n
      } = e;
      if (t || n)
        if (n && t) {
          const r = await this.lookupCommit(n),
            i = new Is(t, e.currentUpstreamBranch || null, r, As.Local);
          this._tip = {
            kind: Qi.Valid,
            branch: i
          }
        } else n ? this._tip = {
          kind: Qi.Detached,
          currentSha: n
        } : t && (this._tip = {
          kind: Qi.Unborn,
          ref: t
        });
      else this._tip = {
        kind: Qi.Unknown
      };
      return this.emitUpdate(), e
    }
    async lookupCommit(e) {
      const t = this.commitLookup.get(e);
      if (null != t) return Promise.resolve(t);
      const n = await this.performFailableOperation(() => Fa(this.repository, e));
      if (null != n) return this.commitLookup.set(e, n), n;
      throw new Error(`Could not load commit: '${e}'`)
    }
    async loadStashEntries() {
      const e = new Map,
        t = await Wc(this.repository);
      for (const n of t.desktopEntries)
        if (!e.has(n.branchName)) {
          const t = this._desktopStashEntries.get(n.branchName);
          void 0 !== t && t.stashSha === n.stashSha ? e.set(n.branchName, Object.assign(Object.assign({}, n), {
            files: t.files
          })) : e.set(n.branchName, n)
        } this._desktopStashEntries = e, this._stashEntryCount = t.stashEntryCount, this.emitUpdate(), this.loadFilesForCurrentStashEntry()
    }
    get currentBranchStashEntry() {
      return this._tip && this._tip.kind === Qi.Valid && this._desktopStashEntries.get(this._tip.branch.name) || null
    }
    get stashEntryCount() {
      return this._stashEntryCount
    }
    get desktopStashEntryCount() {
      return this._desktopStashEntries.size
    }
    async loadFilesForCurrentStashEntry() {
      const e = this.currentBranchStashEntry;
      if (!e || e.files.kind !== zc.NotLoaded) return;
      const {
        branchName: t
      } = e;
      this._desktopStashEntries.set(t, Object.assign(Object.assign({}, e), {
        files: {
          kind: zc.Loading
        }
      })), this.emitUpdate();
      const n = await async function (e, t) {
        const [n, r] = await Promise.all([Yc(e, t), Yc(e, t + "^3")]), i = new Map;
        return n.forEach(e => i.set(e.path, e)), r.forEach(e => i.set(e.path, e)), [...i.values()].sort((e, t) => e.path.localeCompare(t.path))
      }(this.repository, e.stashSha), r = this._desktopStashEntries.get(t);
      r && r.stashSha === e.stashSha && (this._desktopStashEntries.set(t, Object.assign(Object.assign({}, r), {
        files: {
          kind: zc.Loaded,
          files: n
        }
      })), this.emitUpdate())
    }
    async loadRemotes() {
      const e = await zs(this.repository);
      this._defaultRemote = function (e) {
        return e.find(e => "origin" === e.name) || e[0] || null
      }(e);
      const t = this.tip.kind === Qi.Valid && null !== this.tip.branch.remote ? this.tip.branch.remote : null;
      this._currentRemote = null !== t && e.find(e => e.name === t) || this._defaultRemote;
      const n = this.repository.gitHubRepository && this.repository.gitHubRepository.parent;
      this._upstreamRemote = n ? Hc(n, e) : null, this.emitUpdate()
    }
    async addUpstreamRemoteIfNeeded() {
      const e = this.repository.gitHubRepository && this.repository.gitHubRepository.parent;
      if (!e) return;
      const t = await zs(this.repository);
      if (Hc(e, t)) return;
      const n = t.find(e => "upstream" === e.name);
      if (n) {
        const e = new Bc(this.repository, n);
        return void this.emitError(e)
      }
      const r = J("Parent repositories are fully loaded", e.cloneURL);
      await this.performFailableOperation(() => Us(this.repository, "upstream", r)), this._upstreamRemote = {
        name: "upstream",
        url: r
      }
    }
    async ensureUpstreamRemoteURL(e) {
      await this.performFailableOperation(async () => {
        try {
          await Us(this.repository, "upstream", e)
        } catch (t) {
          if (!(t instanceof Fo && t.result.gitError === Ao.GitError.RemoteAlreadyExists)) throw t;
          await Vs(this.repository, "upstream", e)
        }
      })
    }
    get aheadBehind() {
      return this._aheadBehind
    }
    get defaultRemote() {
      return this._defaultRemote
    }
    get currentRemote() {
      return this._currentRemote
    }
    get upstreamRemote() {
      return this._upstreamRemote
    }
    setShowCoAuthoredBy(e) {
      this._showCoAuthoredBy = e, e || (this._coAuthors = []), this.emitUpdate()
    }
    setCoAuthors(e) {
      this._coAuthors = e, this.emitUpdate()
    }
    setCommitMessage(e) {
      return this._commitMessage = e, this.emitUpdate(), Promise.resolve()
    }
    get lastFetched() {
      return this._lastFetched
    }
    updateLastFetched() {
      const e = i.join(this.repository.path, ".git", "FETCH_HEAD");
      return new Promise((t, n) => {
        o.stat(e, (e, n) => {
          e ? this._lastFetched = null : n.size > 0 && (this._lastFetched = n.mtime), t(), this.emitUpdate()
        })
      })
    }
    merge(e) {
      if (this.tip.kind !== Qi.Valid) throw new Error(`unable to merge as tip state is '${this.tip.kind}' and the application expects the repository to be on a branch currently`);
      const t = this.tip.branch.name;
      return this.performFailableOperation(() => async function (e, t) {
        const {
          exitCode: n,
          stdout: r
        } = await Bo(["merge", t], e.path, "merge", {
          expectedErrors: new Set([Ao.GitError.MergeConflicts])
        });
        return 0 === n && r !== hl
      }(this.repository, e), {
        gitContext: {
          kind: "merge",
          currentBranch: t,
          theirBranch: e
        },
        retryAction: {
          type: rc.Merge,
          currentBranch: t,
          theirBranch: e,
          repository: this.repository
        }
      })
    }
    async setRemoteURL(e, t) {
      const n = !0 === await this.performFailableOperation(() => Vs(this.repository, e, t));
      return await this.loadRemotes(), this.emitUpdate(), n
    }
    async discardChanges(e) {
      const t = new Array,
        n = new Array,
        r = await async function (e) {
          const [t, n] = await Promise.all([Object(Ci.pathExists)(i.join(e.path, ".gitmodules")), Object(Ci.pathExists)(i.join(e.path, ".git", "modules"))]);
          if (!t && !n) return log.info('No submodules found. Skipping "git submodule status"'), [];
          const r = await Bo(["submodule", "status", "--"], e.path, "listSubmodules", {
            successExitCodes: new Set([0, 128])
          });
          if (128 === r.exitCode) return [];
          const o = new Array;
          for (const e of r.stdout.split("\n")) {
            if (0 === e.length) continue;
            const t = e.substr(1, 40),
              [n, r] = e.substr(42).split(/\s+/);
            if (null != r) {
              const e = r.substr(1, r.length - 2);
              o.push(new Ll(t, n, e))
            }
          }
          return o
        }(this.repository);
      await async function (e, t) {
        const n = e[Symbol.iterator]();
        let r = n.next();
        for (; !r.done;) {
          const e = await Fc();
          do {
            await Promise.resolve(t(r.value)), r = n.next()
          } while (!r.done && performance.now() - e < 10)
        }
      }(e, async e => {
        const o = r.some(t => t.path === e.path);
        e.status.kind === Ki.Deleted || o || this.shell.moveItemToTrash(i.resolve(this.repository.path, e.path)), e.status.kind === Ki.Copied || e.status.kind === Ki.Renamed ? (n.push(e.path), t.push(e.status.oldPath), n.push(e.status.oldPath)) : (t.push(e.path), n.push(e.path))
      });
      const o = await async function (e) {
        const t = ["diff-index", "--cached", "--name-status", "--no-renames", "-z"];
        let n = await Bo([...t, "HEAD", "--"], e.path, "getIndexChanges", {
          successExitCodes: new Set([0, 128])
        });
        128 === n.exitCode && (n = await Bo([...t, "4b825dc642cb6eb9a060e54bf8d69288fbee4904"], e.path, "getIndexChanges"));
        const r = new Map,
          i = n.stdout.split("\0");
        for (let e = 0; e < i.length - 1; e += 2) {
          const t = Pl(i[e]),
            n = i[e + 1];
          r.set(n, t)
        }
        return r
      }(this.repository), s = n.filter(e => o.has(e)), a = t.filter(e => r.find(t => t.path === e)), l = t.filter(e => -1 === a.indexOf(e) || o.get(e) !== Ml.Added);
      await this.performFailableOperation(async () => {
        await async function (e, t) {
          await Bo(["submodule", "update", "--recursive", "--force", "--", ...t], e.path, "updateSubmodule")
        }(this.repository, a), await async function (e, t, n, r) {
          if (!r.length) return;
          const i = xa(t, n);
          if (2 === t) {
            const t = [...i, "--stdin", "-z", "--"];
            await Bo(t, e.path, "resetPaths", {
              stdin: r.join("\0")
            })
          } else {
            const t = [...i, "--", ...r];
            await Bo(t, e.path, "resetPaths")
          }
        }(this.repository, 2, "HEAD", s), await async function (e, t) {
          t.length && await Bo(["checkout-index", "-f", "-u", "-q", "--stdin", "-z"], e.path, "checkoutIndex", {
            stdin: t.join("\0")
          })
        }(this.repository, l)
      })
    }
    async discardChangesFromSelection(e, t, n) {
      await this.performFailableOperation(() => Ds(this.repository, e, t, n))
    }
    async revertCommit(e, t, n, r) {
      await this.performFailableOperation(() => async function (e, t, n, r) {
        const i = [...await Vo(e, n), "revert"];
        t.parentSHAs.length > 1 && i.push("-m", "1"), i.push(t.sha);
        let o = {};
        if (r) {
          const t = await Js(n, Xs(n, e));
          o = await ba({
            env: t,
            trackLFSProgress: !0
          }, new Ol, e => {
            const t = "progress" === e.kind ? e.details.text : e.text,
              n = "progress" === e.kind ? e.details.title : "",
              i = e.percent;
            r({
              kind: "revert",
              description: t,
              value: i,
              title: n
            })
          })
        }
        await Bo(i, e.path, "revert", o)
      }(e, t, n, r)), this.emitUpdate()
    }
    async updateExistingUpstreamRemote() {
      const e = J("To update an upstream remote, the repository must be a GitHub repository", this.repository.gitHubRepository),
        t = J("To update an upstream remote, the repository must have a parent", e.parent),
        n = J("Parent repositories are always fully loaded", t.cloneURL);
      await this.performFailableOperation(() => Vs(this.repository, "upstream", n))
    }
    async getCompareCommits(e, t) {
      if (this.tip.kind !== Qi.Valid) return null;
      const n = this.tip.branch,
        r = await Wa(this.repository, Ua(n.name, e.name));
      if (null == r) return null;
      const i = t === q.Ahead ? za(e.name, n.name) : za(n.name, e.name),
        o = t === q.Ahead ? r.ahead : r.behind,
        s = await La(this.repository, i, o);
      return s.length > 0 && this.storeCommits(s), {
        commits: s,
        ahead: r.ahead,
        behind: r.behind
      }
    }
    async pruneForkedRemotes(e) {
      const t = await zs(this.repository),
        n = new Set;
      for (const t of e) null !== t.head.gitHubRepository.cloneURL && n.add(t.head.gitHubRepository.cloneURL);
      for (const e of t) e.name.startsWith("github-desktop-") && !n.has(e.url) && await Ws(this.repository, e.name)
    }
  }
  class ru {
    constructor(e, t, n, r) {
      this.shell = e, this.statsStore = t, this.onGitStoreUpdated = n, this.onDidError = r, this.gitStores = new Map
    }
    remove(e) {
      this.gitStores.has(e.hash) && this.gitStores.delete(e.hash)
    }
    get(e) {
      let t = this.gitStores.get(e.hash);
      return void 0 === t && (t = new nu(e, this.shell, this.statsStore), t.onDidUpdate(() => this.onGitStoreUpdated(e, t)), t.onDidError(e => this.onDidError(e)), this.gitStores.set(e.hash, t)), t
    }
  }

  function iu(e, t, n) {
    const r = e.conflictState,
      i = function (e, t) {
        if (e.mergeHeadFound) {
          const {
            currentBranch: n,
            currentTip: r
          } = e;
          return null == n || null == r ? null : {
            kind: "merge",
            currentBranch: n,
            currentTip: r,
            manualResolutions: t
          }
        }
        if (null !== e.rebaseInternalState) {
          const {
            currentTip: n
          } = e;
          if (null == n) return null;
          const {
            targetBranch: r,
            originalBranchTip: i,
            baseBranchTip: o
          } = e.rebaseInternalState;
          return {
            kind: "rebase",
            currentTip: n,
            manualResolutions: t,
            targetBranch: r,
            originalBranchTip: i,
            baseBranchTip: o
          }
        }
        return null
      }(t, null !== r ? r.manualResolutions : new Map);
    return null == r && null == i ? null : null != r && !Y(r) || null != i && !Y(i) ? (null != r && !Q(r) || null != i && !Q(i) || function (e, t, n, r) {
      const i = null != e ? e.targetBranch : null,
        o = null != t ? t.targetBranch : null;
      if (null != i && null != o && i !== o) return void r.recordRebaseAbortedAfterConflicts();
      const {
        currentTip: s,
        currentBranch: a
      } = n;
      if (null != e && null == t && null != s && null != a) {
        e.originalBranchTip !== s && a === e.targetBranch || r.recordRebaseAbortedAfterConflicts()
      }
    }(r, i, t, n), i) : (function (e, t, n, r) {
      const i = null != e ? e.currentBranch : null,
        o = null != t ? t.currentBranch : null;
      if (null != i && null != o && i !== o) return void r.recordMergeAbortedAfterConflicts();
      const {
        currentTip: s
      } = n;
      if (null != e && null == t && null != s) {
        e.currentTip !== s ? r.recordMergeSuccessAfterConflicts() : r.recordMergeAbortedAfterConflicts()
      }
    }(r, i, t, n), i)
  }
  const ou = ["HEAD", "refs/heads/master", "refs/heads/gh-pages", "refs/heads/develop", "refs/heads/dev", "refs/heads/development", "refs/heads/trunk", "refs/heads/devel", "refs/heads/release"],
    su = {
      enforcePruneThreshold: !0,
      deleteBranch: !0
    };
  class au {
    constructor(e, t, n, r, i) {
      this.repository = e, this.gitStoreCache = t, this.repositoriesStore = n, this.repositoriesStateCache = r, this.onPruneCompleted = i, this.timer = null
    }
    async start() {
      null !== this.timer && Z("A background prune task is already active and cannot begin pruning on " + this.repository.name), await this.pruneLocalBranches(su), this.timer = window.setInterval(() => this.pruneLocalBranches(su), 144e5)
    }
    stop() {
      null !== this.timer && (clearInterval(this.timer), this.timer = null)
    }
    async testPrune() {
      return this.pruneLocalBranches({
        enforcePruneThreshold: !1,
        deleteBranch: !1
      })
    }
    async findBranchesMergedIntoDefaultBranch(e, t) {
      const n = this.gitStoreCache.get(e),
        r = await n.performFailableOperation(() => async function (e, t) {
          const n = Ns(t),
            r = ["branch", "--format=%(objectname)%00%(refname)", "--merged", t],
            {
              stdout: i
            } = await Bo(r, e.path, "mergedBranches"),
            o = i.split("\n");
          o.splice(-1, 1);
          const s = new Map;
          for (const e of o) {
            const [t, r] = e.split("\0");
            void 0 !== t && void 0 !== r && (r !== n && s.set(r, t))
          }
          return s
        }(e, t.name));
      if (void 0 === r) return new Map;
      const i = await Fs(e, "HEAD");
      return i && r.delete(i), r
    }
    async pruneLocalBranches(e) {
      const {
        gitHubRepository: t
      } = this.repository;
      if (null === t) return;
      const n = await this.repositoriesStore.getLastPruneDate(this.repository),
        r = k()(),
        i = r.subtract(24, "hours");
      if (e.enforcePruneThreshold && null != n && i.isBefore(n)) return void log.info(`[BranchPruner] Last prune took place ${k()(n).from(r)} - skipping`);
      await this.repositoriesStore.updateLastPruneDate(this.repository, Date.now());
      const {
        branchesState: o
      } = this.repositoriesStateCache.get(this.repository), {
        defaultBranch: s,
        allBranches: a
      } = o;
      if (null === s) return;
      const l = await this.findBranchesMergedIntoDefaultBranch(this.repository, s);
      if (0 === l.size) return void log.info("[BranchPruner] No branches to prune.");
      const c = k()().subtract(2, "weeks").toDate(),
        u = await async function (e, t) {
          const n = new RegExp(/^[a-z0-9]{40}\sHEAD@{(.*)}\scheckout: moving from\s.*\sto\s(.*)$/),
            r = await Bo(["reflog", "--date=iso", `--after="${t.toISOString()}"`, "--pretty=%H %gd %gs", "--grep-reflog=checkout: moving from .* to .*$", "--"], e.path, "getCheckoutsAfterDate", {
              successExitCodes: new Set([0, 128])
            }),
            i = new Map;
          if (128 === r.exitCode && Ha.test(r.stderr)) return i;
          const o = r.stdout.split("\n");
          for (const e of o) {
            const t = n.exec(e);
            if (null === t || 3 !== t.length) continue;
            const [, r, o] = t;
            i.has(o) || i.set(o, new Date(r))
          }
          return i
        }(this.repository, c), h = new Set([...u.keys()].map(Ns)), p = (await Ls(this.repository, "refs/remotes/")).map(e => Ns(e.name)), d = Array.from(l.keys()).filter(e => {
          if (ou.includes(e)) return !1;
          if (h.has(e)) return !1;
          const t = function (e, t) {
            const n = t.find(t => Ns(t.name) === e);
            if (void 0 === n) return;
            const {
              upstream: r
            } = n;
            if (null === r) return;
            return Ns(r)
          }(e, a);
          return void 0 !== t && !p.includes(t)
        });
      log.info(`[BranchPruner] Pruning ${d.length} branches that have been merged into the default branch, ${s.name} (${s.tip.sha}), from '${this.repository.name}`);
      const f = this.gitStoreCache.get(this.repository);
      for (const t of d) {
        if (!t.startsWith("refs/heads/")) continue;
        const n = t.substr("refs/heads/".length);
        if (e.deleteBranch) {
          await f.performFailableOperation(() => ea(this.repository, n)) && log.info(`[BranchPruner] Pruned branch ${n} ((was ${l.get(t)}))`)
        } else log.info(`[BranchPruner] Branch '${n}' marked for deletion`)
      }
      this.onPruneCompleted(this.repository)
    }
  }
  var lu, cu;
  ! function (e) {
    e.SuccessfulMerge = "SuccessfulMerge", e.MergeConflictsFound = "MergeConflictsFound", e.SuccessfulRebase = "SuccessfulRebase", e.RebaseConflictsFound = "RebaseConflictsFound"
  }(lu || (lu = {})),
  function (e) {
    e.AskForConfirmation = "AskForConfirmation", e.StashOnCurrentBranch = "StashOnCurrentBranch", e.MoveToNewBranch = "MoveToNewBranch"
  }(cu || (cu = {}));
  const uu = cu.AskForConfirmation,
    hu = {
      kind: cu.AskForConfirmation
    },
    pu = {
      kind: cu.StashOnCurrentBranch
    },
    du = {
      kind: cu.MoveToNewBranch,
      transientStashEntry: null
    };

  function fu(e) {
    switch (e) {
      case cu.AskForConfirmation:
        return hu;
      case cu.MoveToNewBranch:
        return du;
      case cu.StashOnCurrentBranch:
        return pu;
      default:
        return X(0, "Unknown UncommittedChangesStrategyKind: " + e)
    }
  }
  var mu = n(130),
    gu = n.n(mu);

  function yu(e, t) {
    return gu()(e, t, {
      strict: !0
    })
  }

  function vu(e, t) {
    if (Object.is(e, t)) return !0;
    if (null === e || null === t || "object" != typeof e || "object" != typeof t) return !1;
    const n = Object.keys(e),
      r = Object.keys(t);
    if (n.length !== r.length) return !1;
    for (let r = 0; r < n.length; r++) {
      const i = n[r];
      if (!Object.prototype.hasOwnProperty.call(t, i) || !Object.is(e[i], t[i])) return !1
    }
    return !0
  }

  function wu(e, t) {
    if (e === t) return !0;
    if (e.length !== t.length) return !1;
    for (let n = 0; n < e.length; n++)
      if (e[n] !== t[n]) return !1;
    return !0
  }

  function bu(e, t, n) {
    return e.kind !== Qi.Valid ? null : null !== e.branch.upstreamWithoutRemote && null !== t && Rt(t.url, n) ? e.branch.upstreamWithoutRemote : e.branch.nameWithoutRemote
  }
  var Su;

  function Cu(e) {
    return e !== Su.NotApplicable && e !== Su.Paused
  }! function (e) {
    e.NotApplicable = "NotApplicable", e.PickEditor = "PickEditor", e.CreateBranch = "CreateBranch", e.EditFile = "EditFile", e.MakeCommit = "MakeCommit", e.PushBranch = "PushBranch", e.OpenPullRequest = "OpenPullRequest", e.AllDone = "AllDone", e.Paused = "Paused"
  }(Su || (Su = {}));
  const Eu = [Su.PickEditor, Su.CreateBranch, Su.EditFile, Su.MakeCommit, Su.PushBranch, Su.OpenPullRequest, Su.AllDone];
  class ku {
    constructor(e) {
      this.getResolvedExternalEditor = e, this.installEditorSkipped = me("tutorial-install-editor-skipped", !1), this.prStepComplete = me("tutorial-pull-request-step-complete", !1), this.tutorialPaused = me("tutorial-paused", !1), this.skipPickEditor = () => {
        this.installEditorSkipped = !0, ge("tutorial-install-editor-skipped", this.installEditorSkipped)
      }, this.markPullRequestTutorialStepAsComplete = () => {
        this.prStepComplete = !0, ge("tutorial-pull-request-step-complete", this.prStepComplete)
      }, this.onNewTutorialRepository = () => {
        this.installEditorSkipped = !1, localStorage.removeItem("tutorial-install-editor-skipped"), this.prStepComplete = !1, localStorage.removeItem("tutorial-pull-request-step-complete"), this.tutorialPaused = !1, localStorage.removeItem("tutorial-paused")
      }
    }
    async getCurrentStep(e, t) {
      return e ? this.tutorialPaused ? Su.Paused : await this.isEditorInstalled() ? this.isBranchCheckedOut(t) ? this.hasChangedFile(t) ? this.hasMultipleCommits(t) ? this.commitPushed(t) ? this.pullRequestCreated(t) ? Su.AllDone : Su.OpenPullRequest : Su.PushBranch : Su.MakeCommit : Su.EditFile : Su.CreateBranch : Su.PickEditor : (this.tutorialPaused && this.resumeTutorial(), Su.NotApplicable)
    }
    async isEditorInstalled() {
      return this.installEditorSkipped || null !== this.getResolvedExternalEditor()
    }
    isBranchCheckedOut(e) {
      const {
        branchesState: t
      } = e, {
        tip: n
      } = t, r = n.kind === Qi.Valid ? n.branch.name : null, i = null !== t.defaultBranch ? t.defaultBranch.name : null;
      return null !== r && null !== i && r !== i
    }
    hasChangedFile(e) {
      if (this.hasMultipleCommits(e)) return !0;
      const {
        changesState: t
      } = e;
      return t.workingDirectory.files.length > 0
    }
    hasMultipleCommits(e) {
      const {
        branchesState: t
      } = e, {
        tip: n
      } = t;
      if (n.kind === Qi.Valid) {
        const t = e.commitLookup.get(n.branch.tip.sha);
        return void 0 !== t && t.parentSHAs.some(e => e.length > 0)
      }
      return !1
    }
    commitPushed(e) {
      const {
        aheadBehind: t
      } = e;
      return null !== t && 0 === t.ahead
    }
    pullRequestCreated(e) {
      return null !== e.branchesState.currentPullRequest && this.markPullRequestTutorialStepAsComplete(), this.prStepComplete
    }
    pauseTutorial() {
      this.tutorialPaused = !0, ge("tutorial-paused", this.tutorialPaused)
    }
    resumeTutorial() {
      this.tutorialPaused = !1, ge("tutorial-paused", this.tutorialPaused)
    }
  }

  function xu(e, t, n) {
    return null == e.upstreamWithoutRemote ? null : t.find(t => Tu(e, t, n)) || null
  }

  function Tu(e, t, n) {
    return t.head.ref === e.upstreamWithoutRemote && xt(t.head.gitHubRepository, n)
  }

  function Ru(e) {
    return e.endpoint === pt() ? "GitHub.com" : Te.parse(e.endpoint).hostname || e.endpoint
  }
  async function Du(e, t, n, r) {
    const o = Ru(e);
    if (r("Creating repository on " + o, 0), await Object(Ci.pathExists)(n)) throw new Error(`The path '${n}' already exists. Please move it out of the way, or remove it, and then try again.`);
    const s = await async function (e, t) {
      const n = new at(e.endpoint, e.token);
      try {
        return await n.createRepository(null, t, "GitHub Desktop tutorial repository", !0)
      } catch (n) {
        if (n instanceof Fe && 422 === n.responseStatus && null !== n.apiError && "Repository creation failed." === n.apiError.message && n.apiError.errors && n.apiError.errors.some(e => "name already exists on this account" === e.message)) throw new Error(`You already have a repository named "${t}" on your account at ${Ru(e)}.\n\nPlease delete the repository and try again.`);
        throw n
      }
    }(e, t);
    r("Initializing local repository", .2), await Object(Ci.ensureDir)(n), await Bo(["init"], n, "tutorial:init"), await Object(Ci.writeFile)(i.join(n, "README.md"), "# Welcome to GitHub Desktop!\r\n\r\nThis is your README. READMEs are where you can communicate what your project is and how to use it.\r\n\r\nWrite your name on line 6, save it, and then head back to GitHub Desktop.\r\n"), await Bo(["add", "--", "README.md"], n, "tutorial:add"), await Bo(["commit", "-m", "Initial commit", "--", "README.md"], n, "tutorial:commit");
    const a = {
      name: "origin",
      url: s.clone_url
    };
    return await Bo(["remote", "add", a.name, a.url], n, "tutorial:add-remote"), await async function (e, t, n, r) {
      const i = "Pushing repository to " + Ru(t);
      r(i, 0);
      const o = await ba({
          env: await Js(t, n.url)
        }, new ua, e => {
          "progress" === e.kind && r(i, e.percent, e.details.text)
        }),
        s = ["push", "-u", n.name, "master"];
      await Bo(s, e, "tutorial:push", o)
    }(n, e, a, (e, t, n) => {
      r(e, .3 + .6 * t, n)
    }), r("Finalizing tutorial repository", .9), s
  }

  function _u(e, t) {
    process.emit("send-non-fatal-exception", t, {
      kind: e
    })
  }

  function Au() {
    return localStorage.getItem("last-clone-location") || i.join(function () {
      if (!Ie) {
        const e = Oe();
        try {
          Ie = e.getPath("documents")
        } catch (t) {
          Ie = e.getPath("home")
        }
      }
      return Ie
    }(), "GitHub")
  }

  function Mu(e) {
    localStorage.setItem("last-clone-location", e)
  }

  function Pu(e) {
    const t = e.emails;
    if (0 === t.length) return Lu(e.id, e.login, e.endpoint);
    const n = t.find(e => e.primary);
    if (n && ("public" === (r = n).visibility || !r.visibility)) return n.email;
    var r;
    const i = "@" + Iu(e.endpoint),
      o = t.find(e => e.email.toLowerCase().endsWith(i));
    return o ? o.email : t[0].email
  }

  function Iu(e) {
    return pt() !== e ? "users.noreply." + Te.parse(e).hostname : "users.noreply.github.com"
  }

  function Ou(e, t) {
    return `${e}@${Iu(t)}`
  }

  function Lu(e, t, n) {
    return `${e}+${t}@${Iu(n)}`
  }
  const Nu = Oi.TwoUp;

  function Fu(e) {
    return null === e ? 0 : e.behind
  }

  function Bu(e) {
    if (null === e.dbID) throw new Error("Need a GitHubRepository that's been inserted into the database")
  }

  function Hu(e) {
    if (null === e.dbID) throw new Error("Need a GitHubRepository that's been inserted into the database")
  }

  function zu(e, t) {
    return `${Uu(e)}${t}`
  }

  function Uu(e) {
    return e + "-"
  }
  let Wu = null;

  function Vu(e) {
    return new Promise((t, n) => {
      Wu = {
        state: Ye(),
        endpoint: e,
        resolve: t,
        reject: n
      };
      const r = function (e, t) {
        const n = ht(e),
          r = ft(e),
          i = encodeURIComponent(r.join(" "));
        return `${n}/login/oauth/authorize?client_id=${Je}&scope=${i}&state=${t}`
      }(e, Wu.state);
      ee.openExternal(r)
    })
  }
  async function ju(e, t) {
    if (!Wu || t !== Wu.state) return void log.warn("requestAuthenticatedUser was not called with valid OAuth state. This is likely due to a browser reloading the callback URL. Contact GitHub Support if you believe this is an error");
    const n = await async function (e, t) {
      try {
        const n = ht(e),
          r = await He(n, null, "POST", "login/oauth/access_token", {
            client_id: Je,
            client_secret: et,
            code: t
          });
        return (await Ue(r)).access_token
      } catch (t) {
        return log.warn("requestOAuthToken: failed with endpoint " + e, t), null
      }
    }(Wu.endpoint, e);
    return n ? ut(Wu.endpoint, n) : null
  }

  function Gu(e) {
    Wu || Z("`askUserToOAuth` must be called before rejecting an auth request."), Wu.reject(e), Wu = null
  }
  const $u = new Set(["https:", "http:"]);

  function qu(e) {
    return `Unable to authenticate. The account ${e} is lacking a verified email address. Please sign in to GitHub.com, confirm your email address in the Emails section under Personal settings, and try again.`
  }
  const Ku = "The GitHub Enterprise Server version does not support GitHub Desktop. Talk to your server's administrator about upgrading to the latest version of GitHub Enterprise Server.";
  var Yu, Qu;
  ! function (e) {
    e.EndpointEntry = "EndpointEntry", e.Authentication = "Authentication", e.TwoFactorAuthentication = "TwoFactorAuthentication", e.Success = "Success"
  }(Yu || (Yu = {})),
  function (e) {
    e.Basic = "basic", e.Web = "web"
  }(Qu || (Qu = {}));
  const Zu = Date.parse("2020-11-13T16:00:00.000Z");

  function Xu() {
    return Date.now() < Zu
  }
  var Ju = n(82),
    eh = n.n(Ju);
  class th extends oi {
    constructor(e, t) {
      super(e), this.schemaVersion = t
    }
    async conditionalVersion(e, t, n) {
      if (null != this.schemaVersion && this.schemaVersion < e) return;
      const r = this.version(e).stores(t);
      null != n && await r.upgrade(n)
    }
  }

  function nh(e, t) {
    return [J("Can get key for PR, repository not inserted in database.", e.dbID), t]
  }
  class rh {
    constructor(e, t, n) {
      this.ref = e, this.sha = t, this.gitHubRepository = n
    }
  }
  class ih {
    constructor(e, t, n, r, i, o) {
      this.created = e, this.title = t, this.pullRequestNumber = n, this.head = r, this.base = i, this.author = o
    }
  }

  function oh(e) {
    const t = e.owner.login;
    return {
      name: e.name,
      owner: t
    }
  }
  class sh {
    constructor(e, t, n) {
      this.repository = e, this.account = t, this.coordinator = n, this.timeoutId = null, this.running = !1
    }
    start() {
      this.running || (this.running = !0, this.scheduleTick(12e4))
    }
    getTimeSinceLastRefresh() {
      const e = this.coordinator.getLastRefreshed(this.repository);
      return void 0 === e ? 1 / 0 : Date.now() - e
    }
    scheduleTick(e = 18e5) {
      if (this.running) {
        const t = Math.max(e - this.getTimeSinceLastRefresh(), 0);
        this.timeoutId = window.setTimeout(() => this.tick(), t)
      }
    }
    tick() {
      this.running && (this.timeoutId = null, this.getTimeSinceLastRefresh() < 12e4 && this.scheduleTick(), this.coordinator.refreshPullRequests(this.repository, this.account).catch(() => {}).then(() => this.scheduleTick()))
    }
    stop() {
      this.running && (null !== this.timeoutId && (window.clearTimeout(this.timeoutId), this.timeoutId = null), this.running = !1)
    }
  }

  function ah(e, t) {
    const {
      dbID: n
    } = e;
    return t.filter(e => ro(e).dbID === n)
  }
  const lh = "https://desktop.github.com/usage-data/",
    ch = {
      commits: 0,
      partialCommits: 0,
      openShellCount: 0,
      coAuthoredCommits: 0,
      branchComparisons: 0,
      defaultBranchComparisons: 0,
      mergesInitiatedFromComparison: 0,
      updateFromDefaultBranchMenuCount: 0,
      mergeIntoCurrentBranchMenuCount: 0,
      prBranchCheckouts: 0,
      repoWithIndicatorClicked: 0,
      repoWithoutIndicatorClicked: 0,
      divergingBranchBannerDismissal: 0,
      divergingBranchBannerInitatedMerge: 0,
      divergingBranchBannerInitiatedCompare: 0,
      divergingBranchBannerInfluencedMerge: 0,
      divergingBranchBannerDisplayed: 0,
      dotcomPushCount: 0,
      dotcomForcePushCount: 0,
      enterprisePushCount: 0,
      enterpriseForcePushCount: 0,
      externalPushCount: 0,
      externalForcePushCount: 0,
      active: !1,
      mergeConflictFromPullCount: 0,
      mergeConflictFromExplicitMergeCount: 0,
      mergedWithLoadingHintCount: 0,
      mergedWithCleanMergeHintCount: 0,
      mergedWithConflictWarningHintCount: 0,
      mergeSuccessAfterConflictsCount: 0,
      mergeAbortedAfterConflictsCount: 0,
      unattributedCommits: 0,
      enterpriseCommits: 0,
      dotcomCommits: 0,
      mergeConflictsDialogDismissalCount: 0,
      anyConflictsLeftOnMergeConflictsDialogDismissalCount: 0,
      mergeConflictsDialogReopenedCount: 0,
      guidedConflictedMergeCompletionCount: 0,
      unguidedConflictedMergeCompletionCount: 0,
      createPullRequestCount: 0,
      rebaseConflictsDialogDismissalCount: 0,
      rebaseConflictsDialogReopenedCount: 0,
      rebaseAbortedAfterConflictsCount: 0,
      rebaseSuccessAfterConflictsCount: 0,
      rebaseSuccessWithoutConflictsCount: 0,
      pullWithRebaseCount: 0,
      pullWithDefaultSettingCount: 0,
      stashEntriesCreatedOutsideDesktop: 0,
      errorWhenSwitchingBranchesWithUncommmittedChanges: 0,
      rebaseCurrentBranchMenuCount: 0,
      stashViewedAfterCheckoutCount: 0,
      stashCreatedOnCurrentBranchCount: 0,
      stashNotViewedAfterCheckoutCount: 0,
      changesTakenToNewBranchCount: 0,
      stashRestoreCount: 0,
      stashDiscardCount: 0,
      stashViewCount: 0,
      noActionTakenOnStashCount: 0,
      suggestedStepOpenInExternalEditor: 0,
      suggestedStepOpenWorkingDirectory: 0,
      suggestedStepViewOnGitHub: 0,
      suggestedStepPublishRepository: 0,
      suggestedStepPublishBranch: 0,
      suggestedStepCreatePullRequest: 0,
      suggestedStepViewStash: 0,
      commitsToProtectedBranch: 0,
      commitsToRepositoryWithBranchProtections: 0,
      tutorialStarted: !1,
      tutorialRepoCreated: !1,
      tutorialEditorInstalled: !1,
      tutorialBranchCreated: !1,
      tutorialFileEdited: !1,
      tutorialCommitCreated: !1,
      tutorialBranchPushed: !1,
      tutorialPrCreated: !1,
      tutorialCompleted: !1,
      highestTutorialStepCompleted: -1,
      commitsToRepositoryWithoutWriteAccess: 0,
      forksCreated: 0,
      issueCreationWebpageOpenedCount: 0,
      tagsCreatedInDesktop: 0,
      tagsCreated: 0,
      tagsDeleted: 0
    };

  function uh(e) {
    null === localStorage.getItem(e) && ve(e, Date.now())
  }

  function hh(e) {
    const t = ye(e);
    return void 0 === t ? null : t
  }

  function ph(e) {
    const t = hh("welcome-wizard-initiated-at");
    if (null === t) return;
    const n = hh(e);
    return null === n || n <= t ? -1 : Math.round((n - t) / 1e3)
  }
  var dh;
  ! function (e) {
    e[e.Accounts = 0] = "Accounts", e[e.Integrations = 1] = "Integrations", e[e.Git = 2] = "Git", e[e.Appearance = 3] = "Appearance", e[e.Advanced = 4] = "Advanced"
  }(dh || (dh = {}));
  var fh = n(5),
    mh = n.n(fh);
  class gh extends w.Component {
    constructor() {
      super(...arguments), this.onWindowStateChanged = (e, t) => {
        this.setState({
          windowState: t
        })
      }, this.onMinimize = () => {
        r.remote.getCurrentWindow().minimize()
      }, this.onMaximize = () => {
        r.remote.getCurrentWindow().maximize()
      }, this.onRestore = () => {
        r.remote.getCurrentWindow().unmaximize()
      }, this.onClose = () => {
        r.remote.getCurrentWindow().close()
      }
    }
    componentWillMount() {
      this.setState({
        windowState: gc(r.remote.getCurrentWindow())
      }), r.ipcRenderer.on("window-state-changed", this.onWindowStateChanged)
    }
    componentWillUnmount() {
      r.ipcRenderer.removeListener("window-state-changed", this.onWindowStateChanged)
    }
    shouldComponentUpdate(e, t) {
      return t.windowState !== this.state.windowState
    }
    renderButton(e, t, n) {
      const r = mh()("window-control", e),
        i = e[0].toUpperCase() + e.substring(1);
      return w.createElement("button", {
        "aria-label": e,
        title: i,
        tabIndex: -1,
        className: r,
        onClick: t
      }, w.createElement("svg", {
        "aria-hidden": "true",
        version: "1.1",
        width: "10",
        height: "10"
      }, w.createElement("path", {
        d: n
      })))
    }
    render() {
      const e = this.renderButton("minimize", this.onMinimize, "M 0,5 10,5 10,6 0,6 Z"),
        t = "maximized" === this.state.windowState ? this.renderButton("restore", this.onRestore, "m 2,1e-5 0,2 -2,0 0,8 8,0 0,-2 2,0 0,-8 z m 1,1 6,0 0,6 -1,0 0,-5 -5,0 z m -2,2 6,0 0,6 -6,0 z") : this.renderButton("maximize", this.onMaximize, "M 0,0 0,10 10,10 10,0 Z M 1,1 9,1 9,9 1,9 Z"),
        n = this.renderButton("close", this.onClose, "M 0,0 0,0.7 4.3,5 0,9.3 0,10 0.7,10 5,5.7 9.3,10 10,10 10,9.3 5.7,5 10,0.7 10,0 9.3,0 5,4.3 0.7,0 Z");
      return w.createElement("div", {
        className: "window-controls"
      }, e, t, n)
    }
  }
  const yh = new Set;

  function vh(e) {
    const t = ("__" + e).replace(/[^a-z0-9\-_:.]+/gi, "_");
    for (let e = 0; e < 100; e++) {
      const n = e > 0 ? `${t}_${e}` : t;
      if (!yh.has(n)) return yh.add(n), n
    }
    return Ye()
  }

  function wh(e) {
    yh.delete(e)
  }
  class bh extends w.Component {
    constructor() {
      super(...arguments), this.titleId = null
    }
    componentWillUnmount() {
      null !== this.titleId && wh(this.titleId)
    }
    render() {
      const {
        symbol: e,
        title: t
      } = this.props, n = `0 0 ${e.w} ${e.h}`, r = mh()("octicon", this.props.className);
      let i = void 0,
        o = null;
      t && t.length > 0 && (null === this.titleId && (this.titleId = vh("Octicon_Title")), i = this.titleId, o = w.createElement("title", {
        id: this.titleId
      }, t));
      const s = void 0 === i ? "true" : void 0;
      return w.createElement("svg", {
        "aria-labelledby": i,
        "aria-hidden": s,
        className: r,
        version: "1.1",
        viewBox: n
      }, o, w.createElement("path", {
        d: e.d
      }))
    }
  }
  class Sh {
    constructor(e, t, n) {
      this.w = e, this.h = t, this.d = n
    }
    static get alert() {
      return new Sh(16, 16, "M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z")
    }
    static get archive() {
      return new Sh(14, 16, "M13 2H1v2h12V2zM0 4a1 1 0 0 0 1 1v9a1 1 0 0 0 1 1h10a1 1 0 0 0 1-1V5a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1H1a1 1 0 0 0-1 1v2zm2 1h10v9H2V5zm2 3h6V7H4v1z")
    }
    static get arrowBoth() {
      return new Sh(20, 16, "M0 8l6-5v3h8V3l6 5-6 5v-3H6v3L0 8z")
    }
    static get arrowDown() {
      return new Sh(10, 16, "M7 7V3H3v4H0l5 6 5-6H7z")
    }
    static get arrowLeft() {
      return new Sh(10, 16, "M6 3L0 8l6 5v-3h4V6H6V3z")
    }
    static get arrowRight() {
      return new Sh(10, 16, "M10 8L4 3v3H0v4h4v3l6-5z")
    }
    static get arrowSmallDown() {
      return new Sh(6, 16, "M4 7V5H2v2H0l3 4 3-4H4z")
    }
    static get arrowSmallLeft() {
      return new Sh(6, 16, "M4 7V5L0 8l4 3V9h2V7H4z")
    }
    static get arrowSmallRight() {
      return new Sh(6, 16, "M6 8L2 5v2H0v2h2v2l4-3z")
    }
    static get arrowSmallUp() {
      return new Sh(6, 16, "M3 5L0 9h2v2h2V9h2L3 5z")
    }
    static get arrowUp() {
      return new Sh(10, 16, "M5 3L0 9h3v4h4V9h3L5 3z")
    }
    static get beaker() {
      return new Sh(16, 16, "M14.38 14.59L11 7V3h1V2H3v1h1v4L.63 14.59A1 1 0 0 0 1.54 16h11.94c.72 0 1.2-.75.91-1.41h-.01zM3.75 10L5 7V3h5v4l1.25 3h-7.5zM8 8h1v1H8V8zM7 7H6V6h1v1zm0-3h1v1H7V4zm0-3H6V0h1v1z")
    }
    static get bell() {
      return new Sh(14, 16, "M14 12v1H0v-1l.73-.58c.77-.77.81-2.55 1.19-4.42C2.69 3.23 6 2 6 2c0-.55.45-1 1-1s1 .45 1 1c0 0 3.39 1.23 4.16 5 .38 1.88.42 3.66 1.19 4.42l.66.58H14zm-7 4c1.11 0 2-.89 2-2H5c0 1.11.89 2 2 2z")
    }
    static get bold() {
      return new Sh(10, 16, "M1 2h3.83c2.48 0 4.3.75 4.3 2.95 0 1.14-.63 2.23-1.67 2.61v.06c1.33.3 2.3 1.23 2.3 2.86 0 2.39-1.97 3.52-4.61 3.52H1V2zm3.66 4.95c1.67 0 2.38-.66 2.38-1.69 0-1.17-.78-1.61-2.34-1.61H3.13v3.3h1.53zm.27 5.39c1.77 0 2.75-.64 2.75-1.98 0-1.27-.95-1.81-2.75-1.81h-1.8v3.8h1.8v-.01z")
    }
    static get book() {
      return new Sh(16, 16, "M3 5h4v1H3V5zm0 3h4V7H3v1zm0 2h4V9H3v1zm11-5h-4v1h4V5zm0 2h-4v1h4V7zm0 2h-4v1h4V9zm2-6v9c0 .55-.45 1-1 1H9.5l-1 1-1-1H2c-.55 0-1-.45-1-1V3c0-.55.45-1 1-1h5.5l1 1 1-1H15c.55 0 1 .45 1 1zm-8 .5L7.5 3H2v9h6V3.5zm7-.5H9.5l-.5.5V12h6V3z")
    }
    static get bookmark() {
      return new Sh(10, 16, "M9 0H1C.27 0 0 .27 0 1v15l5-3.09L10 16V1c0-.73-.27-1-1-1zm-.78 4.25L6.36 5.61l.72 2.16c.06.22-.02.28-.2.17L5 6.6 3.12 7.94c-.19.11-.25.05-.2-.17l.72-2.16-1.86-1.36c-.17-.16-.14-.23.09-.23l2.3-.03.7-2.16h.25l.7 2.16 2.3.03c.23 0 .27.08.09.23h.01z")
    }
    static get briefcase() {
      return new Sh(14, 16, "M9 4V3c0-.55-.45-1-1-1H6c-.55 0-1 .45-1 1v1H1c-.55 0-1 .45-1 1v8c0 .55.45 1 1 1h12c.55 0 1-.45 1-1V5c0-.55-.45-1-1-1H9zM6 3h2v1H6V3zm7 6H8v1H6V9H1V5h1v3h10V5h1v4z")
    }
    static get broadcast() {
      return new Sh(16, 16, "M9 9H8c.55 0 1-.45 1-1V7c0-.55-.45-1-1-1H7c-.55 0-1 .45-1 1v1c0 .55.45 1 1 1H6c-.55 0-1 .45-1 1v2h1v3c0 .55.45 1 1 1h1c.55 0 1-.45 1-1v-3h1v-2c0-.55-.45-1-1-1zM7 7h1v1H7V7zm2 4H8v4H7v-4H6v-1h3v1zm2.09-3.5c0-1.98-1.61-3.59-3.59-3.59A3.593 3.593 0 0 0 4 8.31v1.98c-.61-.77-1-1.73-1-2.8 0-2.48 2.02-4.5 4.5-4.5S12 5.01 12 7.49c0 1.06-.39 2.03-1 2.8V8.31c.06-.27.09-.53.09-.81zm3.91 0c0 2.88-1.63 5.38-4 6.63v-1.05a6.553 6.553 0 0 0 3.09-5.58A6.59 6.59 0 0 0 7.5.91 6.59 6.59 0 0 0 .91 7.5c0 2.36 1.23 4.42 3.09 5.58v1.05A7.497 7.497 0 0 1 7.5 0C11.64 0 15 3.36 15 7.5z")
    }
    static get browser() {
      return new Sh(14, 16, "M5 3h1v1H5V3zM3 3h1v1H3V3zM1 3h1v1H1V3zm12 10H1V5h12v8zm0-9H7V3h6v1zm1-1c0-.55-.45-1-1-1H1c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1V3z")
    }
    static get bug() {
      return new Sh(16, 16, "M11 10h3V9h-3V8l3.17-1.03-.34-.94L11 7V6c0-.55-.45-1-1-1V4c0-.48-.36-.88-.83-.97L10.2 2H12V1H9.8l-2 2h-.59L5.2 1H3v1h1.8l1.03 1.03C5.36 3.12 5 3.51 5 4v1c-.55 0-1 .45-1 1v1l-2.83-.97-.34.94L4 8v1H1v1h3v1L.83 12.03l.34.94L4 12v1c0 .55.45 1 1 1h1l1-1V6h1v7l1 1h1c.55 0 1-.45 1-1v-1l2.83.97.34-.94L11 11v-1zM9 5H6V4h3v1z")
    }
    static get calendar() {
      return new Sh(14, 16, "M13 2h-1v1.5c0 .28-.22.5-.5.5h-2c-.28 0-.5-.22-.5-.5V2H6v1.5c0 .28-.22.5-.5.5h-2c-.28 0-.5-.22-.5-.5V2H2c-.55 0-1 .45-1 1v11c0 .55.45 1 1 1h11c.55 0 1-.45 1-1V3c0-.55-.45-1-1-1zm0 12H2V5h11v9zM5 3H4V1h1v2zm6 0h-1V1h1v2zM6 7H5V6h1v1zm2 0H7V6h1v1zm2 0H9V6h1v1zm2 0h-1V6h1v1zM4 9H3V8h1v1zm2 0H5V8h1v1zm2 0H7V8h1v1zm2 0H9V8h1v1zm2 0h-1V8h1v1zm-8 2H3v-1h1v1zm2 0H5v-1h1v1zm2 0H7v-1h1v1zm2 0H9v-1h1v1zm2 0h-1v-1h1v1zm-8 2H3v-1h1v1zm2 0H5v-1h1v1zm2 0H7v-1h1v1zm2 0H9v-1h1v1z")
    }
    static get check() {
      return new Sh(12, 16, "M12 5l-8 8-4-4 1.5-1.5L4 10l6.5-6.5L12 5z")
    }
    static get checklist() {
      return new Sh(16, 16, "M16 8.5l-6 6-3-3L8.5 10l1.5 1.5L14.5 7 16 8.5zM5.7 12.2l.8.8H2c-.55 0-1-.45-1-1V3c0-.55.45-1 1-1h7c.55 0 1 .45 1 1v6.5l-.8-.8c-.39-.39-1.03-.39-1.42 0L5.7 10.8a.996.996 0 0 0 0 1.41v-.01zM4 4h5V3H4v1zm0 2h5V5H4v1zm0 2h3V7H4v1zM3 9H2v1h1V9zm0-2H2v1h1V7zm0-2H2v1h1V5zm0-2H2v1h1V3z")
    }
    static get chevronDown() {
      return new Sh(10, 16, "M5 11L0 6l1.5-1.5L5 8.25 8.5 4.5 10 6l-5 5z")
    }
    static get chevronLeft() {
      return new Sh(8, 16, "M5.5 3L7 4.5 3.25 8 7 11.5 5.5 13l-5-5 5-5z")
    }
    static get chevronRight() {
      return new Sh(8, 16, "M7.5 8l-5 5L1 11.5 4.75 8 1 4.5 2.5 3l5 5z")
    }
    static get chevronUp() {
      return new Sh(10, 16, "M10 10l-1.5 1.5L5 7.75 1.5 11.5 0 10l5-5 5 5z")
    }
    static get circleSlash() {
      return new Sh(14, 16, "M7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm0 1.3c1.3 0 2.5.44 3.47 1.17l-8 8A5.755 5.755 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zm0 11.41c-1.3 0-2.5-.44-3.47-1.17l8-8c.73.97 1.17 2.17 1.17 3.47 0 3.14-2.56 5.7-5.7 5.7z")
    }
    static get circuitBoard() {
      return new Sh(14, 16, "M3 5c0-.55.45-1 1-1s1 .45 1 1-.45 1-1 1-1-.45-1-1zm8 0c0-.55-.45-1-1-1s-1 .45-1 1 .45 1 1 1 1-.45 1-1zm0 6c0-.55-.45-1-1-1s-1 .45-1 1 .45 1 1 1 1-.45 1-1zm2-10H5v2.17c.36.19.64.47.83.83h2.34c.42-.78 1.33-1.28 2.34-1.05.75.19 1.36.8 1.53 1.55.31 1.38-.72 2.59-2.05 2.59-.8 0-1.48-.44-1.83-1.09H5.83c-.42.8-1.33 1.28-2.34 1.03-.73-.17-1.34-.78-1.52-1.52C1.72 4.49 2.2 3.59 3 3.17V1H1c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1l5-5h2.17c.42-.78 1.33-1.28 2.34-1.05.75.19 1.36.8 1.53 1.55.31 1.38-.72 2.59-2.05 2.59-.8 0-1.48-.44-1.83-1.09H6.99L4 15h9c.55 0 1-.45 1-1V2c0-.55-.45-1-1-1z")
    }
    static get clippy() {
      return new Sh(14, 16, "M2 13h4v1H2v-1zm5-6H2v1h5V7zm2 3V8l-3 3 3 3v-2h5v-2H9zM4.5 9H2v1h2.5V9zM2 12h2.5v-1H2v1zm9 1h1v2c-.02.28-.11.52-.3.7-.19.18-.42.28-.7.3H1c-.55 0-1-.45-1-1V4c0-.55.45-1 1-1h3c0-1.11.89-2 2-2 1.11 0 2 .89 2 2h3c.55 0 1 .45 1 1v5h-1V6H1v9h10v-2zM2 5h8c0-.55-.45-1-1-1H8c-.55 0-1-.45-1-1s-.45-1-1-1-1 .45-1 1-.45 1-1 1H3c-.55 0-1 .45-1 1z")
    }
    static get clock() {
      return new Sh(14, 16, "M8 8h3v2H7c-.55 0-1-.45-1-1V4h2v4zM7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7z")
    }
    static get cloudDownload() {
      return new Sh(16, 16, "M9 12h2l-3 3-3-3h2V7h2v5zm3-8c0-.44-.91-3-4.5-3C5.08 1 3 2.92 3 5 1.02 5 0 6.52 0 8c0 1.53 1 3 3 3h3V9.7H3C1.38 9.7 1.3 8.28 1.3 8c0-.17.05-1.7 1.7-1.7h1.3V5c0-1.39 1.56-2.7 3.2-2.7 2.55 0 3.13 1.55 3.2 1.8v1.2H12c.81 0 2.7.22 2.7 2.2 0 2.09-2.25 2.2-2.7 2.2h-2V11h2c2.08 0 4-1.16 4-3.5C16 5.06 14.08 4 12 4z")
    }
    static get cloudUpload() {
      return new Sh(16, 16, "M7 9H5l3-3 3 3H9v5H7V9zm5-4c0-.44-.91-3-4.5-3C5.08 2 3 3.92 3 6 1.02 6 0 7.52 0 9c0 1.53 1 3 3 3h3v-1.3H3c-1.62 0-1.7-1.42-1.7-1.7 0-.17.05-1.7 1.7-1.7h1.3V6c0-1.39 1.56-2.7 3.2-2.7 2.55 0 3.13 1.55 3.2 1.8v1.2H12c.81 0 2.7.22 2.7 2.2 0 2.09-2.25 2.2-2.7 2.2h-2V12h2c2.08 0 4-1.16 4-3.5C16 6.06 14.08 5 12 5z")
    }
    static get code() {
      return new Sh(14, 16, "M9.5 3L8 4.5 11.5 8 8 11.5 9.5 13 14 8 9.5 3zm-5 0L0 8l4.5 5L6 11.5 2.5 8 6 4.5 4.5 3z")
    }
    static get comment() {
      return new Sh(16, 16, "M14 1H2c-.55 0-1 .45-1 1v8c0 .55.45 1 1 1h2v3.5L7.5 11H14c.55 0 1-.45 1-1V2c0-.55-.45-1-1-1zm0 9H7l-2 2v-2H2V2h12v8z")
    }
    static get commentDiscussion() {
      return new Sh(16, 16, "M15 1H6c-.55 0-1 .45-1 1v2H1c-.55 0-1 .45-1 1v6c0 .55.45 1 1 1h1v3l3-3h4c.55 0 1-.45 1-1V9h1l3 3V9h1c.55 0 1-.45 1-1V2c0-.55-.45-1-1-1zM9 11H4.5L3 12.5V11H1V5h4v3c0 .55.45 1 1 1h3v2zm6-3h-2v1.5L11.5 8H6V2h9v6z")
    }
    static get creditCard() {
      return new Sh(16, 16, "M12 9H2V8h10v1zm4-6v9c0 .55-.45 1-1 1H1c-.55 0-1-.45-1-1V3c0-.55.45-1 1-1h14c.55 0 1 .45 1 1zm-1 3H1v6h14V6zm0-3H1v1h14V3zm-9 7H2v1h4v-1z")
    }
    static get dash() {
      return new Sh(8, 16, "M0 7v2h8V7H0z")
    }
    static get dashboard() {
      return new Sh(16, 16, "M9 5H8V4h1v1zm4 3h-1v1h1V8zM6 5H5v1h1V5zM5 8H4v1h1V8zm11-5.5l-.5-.5L9 7c-.06-.02-1 0-1 0-.55 0-1 .45-1 1v1c0 .55.45 1 1 1h1c.55 0 1-.45 1-1v-.92l6-5.58zm-1.59 4.09c.19.61.3 1.25.3 1.91 0 3.42-2.78 6.2-6.2 6.2-3.42 0-6.21-2.78-6.21-6.2 0-3.42 2.78-6.2 6.2-6.2 1.2 0 2.31.34 3.27.94l.94-.94A7.459 7.459 0 0 0 8.51 1C4.36 1 1 4.36 1 8.5 1 12.64 4.36 16 8.5 16c4.14 0 7.5-3.36 7.5-7.5 0-1.03-.2-2.02-.59-2.91l-1 1z")
    }
    static get database() {
      return new Sh(12, 16, "M6 15c-3.31 0-6-.9-6-2v-2c0-.17.09-.34.21-.5.67.86 3 1.5 5.79 1.5s5.12-.64 5.79-1.5c.13.16.21.33.21.5v2c0 1.1-2.69 2-6 2zm0-4c-3.31 0-6-.9-6-2V7c0-.11.04-.21.09-.31.03-.06.07-.13.12-.19C.88 7.36 3.21 8 6 8s5.12-.64 5.79-1.5c.05.06.09.13.12.19.05.1.09.21.09.31v2c0 1.1-2.69 2-6 2zm0-4c-3.31 0-6-.9-6-2V3c0-1.1 2.69-2 6-2s6 .9 6 2v2c0 1.1-2.69 2-6 2zm0-5c-2.21 0-4 .45-4 1s1.79 1 4 1 4-.45 4-1-1.79-1-4-1z")
    }
    static get dependent() {
      return new Sh(16, 16, "M1 1h7.5l2 2H9L8 2H1v12h10v-1h1v1c0 .55-.45 1-1 1H1c-.55 0-1-.45-1-1V2c0-.55.45-1 1-1zm9 6h3v1h-3V7zm2 2h-2v1h2V9zM8.583 4h4.375L15 6v5.429a.58.58 0 0 1-.583.571H8.583A.58.58 0 0 1 8 11.429V10h1v1h5V6.5L12.5 5H9v1H8V4.571A.58.58 0 0 1 8.583 4zM9.5 7H6.667V5l-4 3 4 3V9H9.5V7z")
    }
    static get desktopDownload() {
      return new Sh(16, 16, "M4 6h3V0h2v6h3l-4 4-4-4zm11-4h-4v1h4v8H1V3h4V2H1c-.55 0-1 .45-1 1v9c0 .55.45 1 1 1h5.34c-.25.61-.86 1.39-2.34 2h8c-1.48-.61-2.09-1.39-2.34-2H15c.55 0 1-.45 1-1V3c0-.55-.45-1-1-1z")
    }
    static get deviceCamera() {
      return new Sh(16, 16, "M15 3H7c0-.55-.45-1-1-1H2c-.55 0-1 .45-1 1-.55 0-1 .45-1 1v9c0 .55.45 1 1 1h14c.55 0 1-.45 1-1V4c0-.55-.45-1-1-1zM6 5H2V4h4v1zm4.5 7C8.56 12 7 10.44 7 8.5S8.56 5 10.5 5 14 6.56 14 8.5 12.44 12 10.5 12zM13 8.5c0 1.38-1.13 2.5-2.5 2.5S8 9.87 8 8.5 9.13 6 10.5 6 13 7.13 13 8.5z")
    }
    static get deviceCameraVideo() {
      return new Sh(16, 16, "M15.2 2.09L10 5.72V3c0-.55-.45-1-1-1H1c-.55 0-1 .45-1 1v9c0 .55.45 1 1 1h8c.55 0 1-.45 1-1V9.28l5.2 3.63c.33.23.8 0 .8-.41v-10c0-.41-.47-.64-.8-.41z")
    }
    static get deviceDesktop() {
      return new Sh(16, 16, "M15 2H1c-.55 0-1 .45-1 1v9c0 .55.45 1 1 1h5.34c-.25.61-.86 1.39-2.34 2h8c-1.48-.61-2.09-1.39-2.34-2H15c.55 0 1-.45 1-1V3c0-.55-.45-1-1-1zm0 9H1V3h14v8z")
    }
    static get deviceMobile() {
      return new Sh(10, 16, "M9 0H1C.45 0 0 .45 0 1v14c0 .55.45 1 1 1h8c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1zM5 15.3c-.72 0-1.3-.58-1.3-1.3 0-.72.58-1.3 1.3-1.3.72 0 1.3.58 1.3 1.3 0 .72-.58 1.3-1.3 1.3zM9 12H1V2h8v10z")
    }
    static get diff() {
      return new Sh(13, 16, "M6 7h2v1H6v2H5V8H3V7h2V5h1v2zm-3 6h5v-1H3v1zM7.5 2L11 5.5V15c0 .55-.45 1-1 1H1c-.55 0-1-.45-1-1V3c0-.55.45-1 1-1h6.5zM10 6L7 3H1v12h9V6zM8.5 0H3v1h5l4 4v8h1V4.5L8.5 0z")
    }
    static get diffAdded() {
      return new Sh(14, 16, "M13 1H1c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h12c.55 0 1-.45 1-1V2c0-.55-.45-1-1-1zm0 13H1V2h12v12zM6 9H3V7h3V4h2v3h3v2H8v3H6V9z")
    }
    static get diffIgnored() {
      return new Sh(14, 16, "M13 1H1c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h12c.55 0 1-.45 1-1V2c0-.55-.45-1-1-1zm0 13H1V2h12v12zm-8.5-2H3v-1.5L9.5 4H11v1.5L4.5 12z")
    }
    static get diffModified() {
      return new Sh(14, 16, "M13 1H1c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h12c.55 0 1-.45 1-1V2c0-.55-.45-1-1-1zm0 13H1V2h12v12zM4 8c0-1.66 1.34-3 3-3s3 1.34 3 3-1.34 3-3 3-3-1.34-3-3z")
    }
    static get diffRemoved() {
      return new Sh(14, 16, "M13 1H1c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h12c.55 0 1-.45 1-1V2c0-.55-.45-1-1-1zm0 13H1V2h12v12zm-2-5H3V7h8v2z")
    }
    static get diffRenamed() {
      return new Sh(14, 16, "M6 9H3V7h3V4l5 4-5 4V9zm8-7v12c0 .55-.45 1-1 1H1c-.55 0-1-.45-1-1V2c0-.55.45-1 1-1h12c.55 0 1 .45 1 1zm-1 0H1v12h12V2z")
    }
    static get ellipsis() {
      return new Sh(12, 16, "M11 5H1c-.55 0-1 .45-1 1v4c0 .55.45 1 1 1h10c.55 0 1-.45 1-1V6c0-.55-.45-1-1-1zM4 9H2V7h2v2zm3 0H5V7h2v2zm3 0H8V7h2v2z")
    }
    static get eye() {
      return new Sh(16, 16, "M8.06 2C3 2 0 8 0 8s3 6 8.06 6C13 14 16 8 16 8s-3-6-7.94-6zM8 12c-2.2 0-4-1.78-4-4 0-2.2 1.8-4 4-4 2.22 0 4 1.8 4 4 0 2.22-1.78 4-4 4zm2-4c0 1.11-.89 2-2 2-1.11 0-2-.89-2-2 0-1.11.89-2 2-2 1.11 0 2 .89 2 2z")
    }
    static get eyeClosed() {
      return new Sh(16, 13, "M14.822.854a.5.5 0 1 0-.707-.708l-2.11 2.11C10.89 1.483 9.565.926 8.06.926c-5.06 0-8.06 6-8.06 6s1.162 2.323 3.258 4.078l-2.064 2.065a.5.5 0 1 0 .707.707L14.822.854zM4.86 9.403L6.292 7.97A1.999 1.999 0 0 1 6 6.925c0-1.11.89-2 2-2 .384 0 .741.106 1.045.292l1.433-1.433A3.98 3.98 0 0 0 8 2.925c-2.2 0-4 1.8-4 4 0 .938.321 1.798.859 2.478zm7.005-3.514l1.993-1.992A14.873 14.873 0 0 1 16 6.925s-3 6-7.94 6a6.609 6.609 0 0 1-2.661-.57l1.565-1.566c.33.089.678.136 1.036.136 2.22 0 4-1.78 4-4 0-.358-.047-.705-.136-1.036zM9.338 8.415l.152-.151a1.996 1.996 0 0 1-.152.151z")
    }
    static get file() {
      return new Sh(12, 16, "M6 5H2V4h4v1zM2 8h7V7H2v1zm0 2h7V9H2v1zm0 2h7v-1H2v1zm10-7.5V14c0 .55-.45 1-1 1H1c-.55 0-1-.45-1-1V2c0-.55.45-1 1-1h7.5L12 4.5zM11 5L8 2H1v12h10V5z")
    }
    static get fileBinary() {
      return new Sh(12, 16, "M4 12h1v1H2v-1h1v-2H2V9h2v3zm8-7.5V14c0 .55-.45 1-1 1H1c-.55 0-1-.45-1-1V2c0-.55.45-1 1-1h7.5L12 4.5zM11 5L8 2H1v12h10V5zM8 4H6v1h1v2H6v1h3V7H8V4zM2 4h3v4H2V4zm1 3h1V5H3v2zm3 2h3v4H6V9zm1 3h1v-2H7v2z")
    }
    static get fileCode() {
      return new Sh(12, 16, "M8.5 1H1c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h10c.55 0 1-.45 1-1V4.5L8.5 1zM11 14H1V2h7l3 3v9zM5 6.98L3.5 8.5 5 10l-.5 1L2 8.5 4.5 6l.5.98zM7.5 6L10 8.5 7.5 11l-.5-.98L8.5 8.5 7 7l.5-1z")
    }
    static get fileDirectory() {
      return new Sh(14, 16, "M13 4H7V3c0-.66-.31-1-1-1H1c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1V5c0-.55-.45-1-1-1zM6 4H1V3h5v1z")
    }
    static get fileMedia() {
      return new Sh(12, 16, "M6 5h2v2H6V5zm6-.5V14c0 .55-.45 1-1 1H1c-.55 0-1-.45-1-1V2c0-.55.45-1 1-1h7.5L12 4.5zM11 5L8 2H1v11l3-5 2 4 2-2 3 3V5z")
    }
    static get filePdf() {
      return new Sh(12, 16, "M8.5 1H1a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h10a1 1 0 0 0 1-1V4.5L8.5 1zM1 2h4a.68.68 0 0 0-.31.2 1.08 1.08 0 0 0-.23.47 4.22 4.22 0 0 0-.09 1.47c.06.609.173 1.211.34 1.8A21.78 21.78 0 0 1 3.6 8.6c-.5 1-.8 1.66-.91 1.84a7.156 7.156 0 0 0-.69.3c-.362.165-.699.38-1 .64V2zm4.42 4.8a5.65 5.65 0 0 0 1.17 2.09c.275.237.595.417.94.53-.64.09-1.23.2-1.81.33-.618.15-1.223.347-1.81.59s.22-.44.61-1.25c.365-.74.67-1.51.91-2.3l-.01.01zM11 14H1.5a.743.743 0 0 1-.17 0 2.12 2.12 0 0 0 .73-.44 10.14 10.14 0 0 0 1.78-2.38c.31-.13.58-.23.81-.31l.42-.14c.45-.13.94-.23 1.44-.33s1-.16 1.48-.2c.447.216.912.394 1.39.53.403.11.814.188 1.23.23h.38V14H11zm0-4.86a3.743 3.743 0 0 0-.64-.28 4.221 4.221 0 0 0-.75-.11c-.411.003-.822.03-1.23.08a3 3 0 0 1-1-.64 6.07 6.07 0 0 1-1.29-2.33c.111-.661.178-1.33.2-2 .02-.25.02-.5 0-.75a1.05 1.05 0 0 0-.2-.88.82.82 0 0 0-.61-.23H8l3 3v4.14z")
    }
    static get fileSubmodule() {
      return new Sh(14, 16, "M10 7H4v7h9c.55 0 1-.45 1-1V8h-4V7zM9 9H5V8h4v1zm4-5H7V3c0-.66-.31-1-1-1H1c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h2V7c0-.55.45-1 1-1h6c.55 0 1 .45 1 1h3V5c0-.55-.45-1-1-1zM6 4H1V3h5v1z")
    }
    static get fileSymlinkDirectory() {
      return new Sh(14, 16, "M13 4H7V3c0-.66-.31-1-1-1H1c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1V5c0-.55-.45-1-1-1zM1 3h5v1H1V3zm6 9v-2c-.98-.02-1.84.22-2.55.7-.71.48-1.19 1.25-1.45 2.3.02-1.64.39-2.88 1.13-3.73C4.86 8.43 5.82 8 7.01 8V6l4 3-4 3H7z")
    }
    static get fileSymlinkFile() {
      return new Sh(12, 16, "M8.5 1H1c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h10c.55 0 1-.45 1-1V4.5L8.5 1zM11 14H1V2h7l3 3v9zM6 4.5l4 3-4 3v-2c-.98-.02-1.84.22-2.55.7-.71.48-1.19 1.25-1.45 2.3.02-1.64.39-2.88 1.13-3.73.73-.84 1.69-1.27 2.88-1.27v-2H6z")
    }
    static get fileZip() {
      return new Sh(12, 16, "M8.5 1H1a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h10a1 1 0 0 0 1-1V4.5L8.5 1zM11 14H1V2h3v1h1V2h3l3 3v9zM5 4V3h1v1H5zM4 4h1v1H4V4zm1 2V5h1v1H5zM4 6h1v1H4V6zm1 2V7h1v1H5zM4 9.28A2 2 0 0 0 3 11v1h4v-1a2 2 0 0 0-2-2V8H4v1.28zM6 10v1H4v-1h2z")
    }
    static get flame() {
      return new Sh(12, 16, "M5.05.31c.81 2.17.41 3.38-.52 4.31C3.55 5.67 1.98 6.45.9 7.98c-1.45 2.05-1.7 6.53 3.53 7.7-2.2-1.16-2.67-4.52-.3-6.61-.61 2.03.53 3.33 1.94 2.86 1.39-.47 2.3.53 2.27 1.67-.02.78-.31 1.44-1.13 1.81 3.42-.59 4.78-3.42 4.78-5.56 0-2.84-2.53-3.22-1.25-5.61-1.52.13-2.03 1.13-1.89 2.75.09 1.08-1.02 1.8-1.86 1.33-.67-.41-.66-1.19-.06-1.78C8.18 5.31 8.68 2.45 5.05.32L5.03.3l.02.01z")
    }
    static get fold() {
      return new Sh(14, 16, "M7 9l3 3H8v3H6v-3H4l3-3zm3-6H8V0H6v3H4l3 3 3-3zm4 2c0-.55-.45-1-1-1h-2.5l-1 1h3l-2 2h-7l-2-2h3l-1-1H1c-.55 0-1 .45-1 1l2.5 2.5L0 10c0 .55.45 1 1 1h2.5l1-1h-3l2-2h7l2 2h-3l1 1H13c.55 0 1-.45 1-1l-2.5-2.5L14 5z")
    }
    static get foldDown() {
      return new Sh(14, 16, "M4 11l3 3 3-3H8V5H6v6H4zm-4 0c0 .55.45 1 1 1h2.5l-1-1h-1l2-2H5V8H3.5l-2-2H5V5H1c-.55 0-1 .45-1 1l2.5 2.5L0 11zm10.5-2H9V8h1.5l2-2H9V5h4c.55 0 1 .45 1 1l-2.5 2.5L14 11c0 .55-.45 1-1 1h-2.5l1-1h1l-2-2z")
    }
    static get foldUp() {
      return new Sh(14, 16, "M10 6L7 3 4 6h2v6h2V6h2zm4 0c0-.55-.45-1-1-1h-2.5l1 1h1l-2 2H9v1h1.5l2 2H9v1h4c.55 0 1-.45 1-1l-2.5-2.5L14 6zM3.5 8H5v1H3.5l-2 2H5v1H1c-.55 0-1-.45-1-1l2.5-2.5L0 6c0-.55.45-1 1-1h2.5l-1 1h-1l2 2z")
    }
    static get gear() {
      return new Sh(14, 16, "M14 8.77v-1.6l-1.94-.64-.45-1.09.88-1.84-1.13-1.13-1.81.91-1.09-.45-.69-1.92h-1.6l-.63 1.94-1.11.45-1.84-.88-1.13 1.13.91 1.81-.45 1.09L0 7.23v1.59l1.94.64.45 1.09-.88 1.84 1.13 1.13 1.81-.91 1.09.45.69 1.92h1.59l.63-1.94 1.11-.45 1.84.88 1.13-1.13-.92-1.81.47-1.09L14 8.75v.02zM7 11c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3z")
    }
    static get gift() {
      return new Sh(14, 16, "M13 4h-1.38c.19-.33.33-.67.36-.91.06-.67-.11-1.22-.52-1.61C11.1 1.1 10.65 1 10.1 1h-.11c-.53.02-1.11.25-1.53.58-.42.33-.73.72-.97 1.2-.23-.48-.55-.88-.97-1.2-.42-.32-1-.58-1.53-.58h-.03c-.56 0-1.06.09-1.44.48-.41.39-.58.94-.52 1.61.03.23.17.58.36.91H1.98c-.55 0-1 .45-1 1v3h1v5c0 .55.45 1 1 1h9c.55 0 1-.45 1-1V8h1V5c0-.55-.45-1-1-1H13zm-4.78-.88c.17-.36.42-.67.75-.92.3-.23.72-.39 1.05-.41h.09c.45 0 .66.11.8.25s.33.39.3.95c-.05.19-.25.61-.5 1h-2.9l.41-.88v.01zM4.09 2.04c.13-.13.31-.25.91-.25.31 0 .72.17 1.03.41.33.25.58.55.75.92L7.2 4H4.3c-.25-.39-.45-.81-.5-1-.03-.56.16-.81.3-.95l-.01-.01zM7 12.99H3V8h4v5-.01zm0-6H2V5h5v2-.01zm5 6H8V8h4v5-.01zm1-6H8V5h5v2-.01z")
    }
    static get gist() {
      return new Sh(12, 16, "M7.5 5L10 7.5 7.5 10l-.75-.75L8.5 7.5 6.75 5.75 7.5 5zm-3 0L2 7.5 4.5 10l.75-.75L3.5 7.5l1.75-1.75L4.5 5zM0 13V2c0-.55.45-1 1-1h10c.55 0 1 .45 1 1v11c0 .55-.45 1-1 1H1c-.55 0-1-.45-1-1zm1 0h10V2H1v11z")
    }
    static get gistSecret() {
      return new Sh(14, 16, "M8 10.5L9 14H5l1-3.5L5.25 9h3.5L8 10.5zM10 6H4L2 7h10l-2-1zM9 2L7 3 5 2 4 5h6L9 2zm4.03 7.75L10 9l1 2-2 3h3.22c.45 0 .86-.31.97-.75l.56-2.28c.14-.53-.19-1.08-.72-1.22zM4 9l-3.03.75c-.53.14-.86.69-.72 1.22l.56 2.28c.11.44.52.75.97.75H5l-2-3 1-2z")
    }
    static get gitBranch() {
      return new Sh(10, 16, "M10 5c0-1.11-.89-2-2-2a1.993 1.993 0 0 0-1 3.72v.3c-.02.52-.23.98-.63 1.38-.4.4-.86.61-1.38.63-.83.02-1.48.16-2 .45V4.72a1.993 1.993 0 0 0-1-3.72C.88 1 0 1.89 0 3a2 2 0 0 0 1 1.72v6.56c-.59.35-1 .99-1 1.72 0 1.11.89 2 2 2 1.11 0 2-.89 2-2 0-.53-.2-1-.53-1.36.09-.06.48-.41.59-.47.25-.11.56-.17.94-.17 1.05-.05 1.95-.45 2.75-1.25S8.95 7.77 9 6.73h-.02C9.59 6.37 10 5.73 10 5zM2 1.8c.66 0 1.2.55 1.2 1.2 0 .65-.55 1.2-1.2 1.2C1.35 4.2.8 3.65.8 3c0-.65.55-1.2 1.2-1.2zm0 12.41c-.66 0-1.2-.55-1.2-1.2 0-.65.55-1.2 1.2-1.2.65 0 1.2.55 1.2 1.2 0 .65-.55 1.2-1.2 1.2zm6-8c-.66 0-1.2-.55-1.2-1.2 0-.65.55-1.2 1.2-1.2.65 0 1.2.55 1.2 1.2 0 .65-.55 1.2-1.2 1.2z")
    }
    static get gitCommit() {
      return new Sh(14, 16, "M10.86 7c-.45-1.72-2-3-3.86-3-1.86 0-3.41 1.28-3.86 3H0v2h3.14c.45 1.72 2 3 3.86 3 1.86 0 3.41-1.28 3.86-3H14V7h-3.14zM7 10.2c-1.22 0-2.2-.98-2.2-2.2 0-1.22.98-2.2 2.2-2.2 1.22 0 2.2.98 2.2 2.2 0 1.22-.98 2.2-2.2 2.2z")
    }
    static get gitCompare() {
      return new Sh(14, 16, "M5 12H4c-.27-.02-.48-.11-.69-.31-.21-.2-.3-.42-.31-.69V4.72A1.993 1.993 0 0 0 2 1a1.993 1.993 0 0 0-1 3.72V11c.03.78.34 1.47.94 2.06.6.59 1.28.91 2.06.94h1v2l3-3-3-3v2zM2 1.8c.66 0 1.2.55 1.2 1.2 0 .65-.55 1.2-1.2 1.2C1.35 4.2.8 3.65.8 3c0-.65.55-1.2 1.2-1.2zm11 9.48V5c-.03-.78-.34-1.47-.94-2.06-.6-.59-1.28-.91-2.06-.94H9V0L6 3l3 3V4h1c.27.02.48.11.69.31.21.2.3.42.31.69v6.28A1.993 1.993 0 0 0 12 15a1.993 1.993 0 0 0 1-3.72zm-1 2.92c-.66 0-1.2-.55-1.2-1.2 0-.65.55-1.2 1.2-1.2.65 0 1.2.55 1.2 1.2 0 .65-.55 1.2-1.2 1.2z")
    }
    static get gitMerge() {
      return new Sh(12, 16, "M10 7c-.73 0-1.38.41-1.73 1.02V8C7.22 7.98 6 7.64 5.14 6.98c-.75-.58-1.5-1.61-1.89-2.44A1.993 1.993 0 0 0 2 .99C.89.99 0 1.89 0 3a2 2 0 0 0 1 1.72v6.56c-.59.35-1 .99-1 1.72 0 1.11.89 2 2 2a1.993 1.993 0 0 0 1-3.72V7.67c.67.7 1.44 1.27 2.3 1.69.86.42 2.03.63 2.97.64v-.02c.36.61 1 1.02 1.73 1.02 1.11 0 2-.89 2-2 0-1.11-.89-2-2-2zm-6.8 6c0 .66-.55 1.2-1.2 1.2-.65 0-1.2-.55-1.2-1.2 0-.65.55-1.2 1.2-1.2.65 0 1.2.55 1.2 1.2zM2 4.2C1.34 4.2.8 3.65.8 3c0-.65.55-1.2 1.2-1.2.65 0 1.2.55 1.2 1.2 0 .65-.55 1.2-1.2 1.2zm8 6c-.66 0-1.2-.55-1.2-1.2 0-.65.55-1.2 1.2-1.2.65 0 1.2.55 1.2 1.2 0 .65-.55 1.2-1.2 1.2z")
    }
    static get gitPullRequest() {
      return new Sh(12, 16, "M11 11.28V5c-.03-.78-.34-1.47-.94-2.06C9.46 2.35 8.78 2.03 8 2H7V0L4 3l3 3V4h1c.27.02.48.11.69.31.21.2.3.42.31.69v6.28A1.993 1.993 0 0 0 10 15a1.993 1.993 0 0 0 1-3.72zm-1 2.92c-.66 0-1.2-.55-1.2-1.2 0-.65.55-1.2 1.2-1.2.65 0 1.2.55 1.2 1.2 0 .65-.55 1.2-1.2 1.2zM4 3c0-1.11-.89-2-2-2a1.993 1.993 0 0 0-1 3.72v6.56A1.993 1.993 0 0 0 2 15a1.993 1.993 0 0 0 1-3.72V4.72c.59-.34 1-.98 1-1.72zm-.8 10c0 .66-.55 1.2-1.2 1.2-.65 0-1.2-.55-1.2-1.2 0-.65.55-1.2 1.2-1.2.65 0 1.2.55 1.2 1.2zM2 4.2C1.34 4.2.8 3.65.8 3c0-.65.55-1.2 1.2-1.2.65 0 1.2.55 1.2 1.2 0 .65-.55 1.2-1.2 1.2z")
    }
    static get githubAction() {
      return new Sh(16, 16, "M9 2h6c.55 0 1 .45 1 1v10c0 .55-.45 1-1 1H9a1 1 0 1 1-2 0H1c-.55 0-1-.45-1-1V3c0-.55.45-1 1-1h6a1 1 0 1 1 2 0zm6 1v10H1V3h14zm-2.5 4a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3z")
    }
    static get globe() {
      return new Sh(14, 16, "M7 1C3.14 1 0 4.14 0 8s3.14 7 7 7c.48 0 .94-.05 1.38-.14-.17-.08-.2-.73-.02-1.09.19-.41.81-1.45.2-1.8-.61-.35-.44-.5-.81-.91-.37-.41-.22-.47-.25-.58-.08-.34.36-.89.39-.94.02-.06.02-.27 0-.33 0-.08-.27-.22-.34-.23-.06 0-.11.11-.2.13-.09.02-.5-.25-.59-.33-.09-.08-.14-.23-.27-.34-.13-.13-.14-.03-.33-.11s-.8-.31-1.28-.48c-.48-.19-.52-.47-.52-.66-.02-.2-.3-.47-.42-.67-.14-.2-.16-.47-.2-.41-.04.06.25.78.2.81-.05.02-.16-.2-.3-.38-.14-.19.14-.09-.3-.95s.14-1.3.17-1.75c.03-.45.38.17.19-.13-.19-.3 0-.89-.14-1.11-.13-.22-.88.25-.88.25.02-.22.69-.58 1.16-.92.47-.34.78-.06 1.16.05.39.13.41.09.28-.05-.13-.13.06-.17.36-.13.28.05.38.41.83.36.47-.03.05.09.11.22s-.06.11-.38.3c-.3.2.02.22.55.61s.38-.25.31-.55c-.07-.3.39-.06.39-.06.33.22.27.02.5.08.23.06.91.64.91.64-.83.44-.31.48-.17.59.14.11-.28.3-.28.3-.17-.17-.19.02-.3.08-.11.06-.02.22-.02.22-.56.09-.44.69-.42.83 0 .14-.38.36-.47.58-.09.2.25.64.06.66-.19.03-.34-.66-1.31-.41-.3.08-.94.41-.59 1.08.36.69.92-.19 1.11-.09.19.1-.06.53-.02.55.04.02.53.02.56.61.03.59.77.53.92.55.17 0 .7-.44.77-.45.06-.03.38-.28 1.03.09.66.36.98.31 1.2.47.22.16.08.47.28.58.2.11 1.06-.03 1.28.31.22.34-.88 2.09-1.22 2.28-.34.19-.48.64-.84.92s-.81.64-1.27.91c-.41.23-.47.66-.66.8 3.14-.7 5.48-3.5 5.48-6.84 0-3.86-3.14-7-7-7L7 1zm1.64 6.56c-.09.03-.28.22-.78-.08-.48-.3-.81-.23-.86-.28 0 0-.05-.11.17-.14.44-.05.98.41 1.11.41.13 0 .19-.13.41-.05.22.08.05.13-.05.14zM6.34 1.7c-.05-.03.03-.08.09-.14.03-.03.02-.11.05-.14.11-.11.61-.25.52.03-.11.27-.58.3-.66.25zm1.23.89c-.19-.02-.58-.05-.52-.14.3-.28-.09-.38-.34-.38-.25-.02-.34-.16-.22-.19.12-.03.61.02.7.08.08.06.52.25.55.38.02.13 0 .25-.17.25zm1.47-.05c-.14.09-.83-.41-.95-.52-.56-.48-.89-.31-1-.41-.11-.1-.08-.19.11-.34.19-.15.69.06 1 .09.3.03.66.27.66.55.02.25.33.5.19.63h-.01z")
    }
    static get grabber() {
      return new Sh(8, 16, "M8 4v1H0V4h8zM0 8h8V7H0v1zm0 3h8v-1H0v1z")
    }
    static get graph() {
      return new Sh(16, 16, "M16 14v1H0V0h1v14h15zM5 13H3V8h2v5zm4 0H7V3h2v10zm4 0h-2V6h2v7z")
    }
    static get heart() {
      return new Sh(12, 16, "M9 2c-.97 0-1.69.42-2.2 1-.51.58-.78.92-.8 1-.02-.08-.28-.42-.8-1-.52-.58-1.17-1-2.2-1-1.632.086-2.954 1.333-3 3 0 .52.09 1.52.67 2.67C1.25 8.82 3.01 10.61 6 13c2.98-2.39 4.77-4.17 5.34-5.33C11.91 6.51 12 5.5 12 5c-.047-1.69-1.342-2.913-3-3z")
    }
    static get history() {
      return new Sh(14, 16, "M8 13H6V6h5v2H8v5zM7 1C4.81 1 2.87 2.02 1.59 3.59L0 2v4h4L2.5 4.5C3.55 3.17 5.17 2.3 7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-.34.03-.67.09-1H.08C.03 7.33 0 7.66 0 8c0 3.86 3.14 7 7 7s7-3.14 7-7-3.14-7-7-7z")
    }
    static get home() {
      return new Sh(16, 16, "M16 9l-3-3V2h-2v2L8 1 0 9h2l1 5c0 .55.45 1 1 1h8c.55 0 1-.45 1-1l1-5h2zm-4 5H9v-4H7v4H4L2.81 7.69 8 2.5l5.19 5.19L12 14z")
    }
    static get horizontalRule() {
      return new Sh(10, 16, "M1 7h2v2h1V3H3v3H1V3H0v6h1V7zm9 2V7H9v2h1zm0-3V4H9v2h1zM7 6V4h2V3H6v6h1V7h2V6H7zm-7 7h10v-2H0v2z")
    }
    static get hubot() {
      return new Sh(14, 16, "M3 6c-.55 0-1 .45-1 1v2c0 .55.45 1 1 1h8c.55 0 1-.45 1-1V7c0-.55-.45-1-1-1H3zm8 1.75L9.75 9h-1.5L7 7.75 5.75 9h-1.5L3 7.75V7h.75L5 8.25 6.25 7h1.5L9 8.25 10.25 7H11v.75zM5 11h4v1H5v-1zm2-9C3.14 2 0 4.91 0 8.5V13c0 .55.45 1 1 1h12c.55 0 1-.45 1-1V8.5C14 4.91 10.86 2 7 2zm6 11H1V8.5c0-3.09 2.64-5.59 6-5.59s6 2.5 6 5.59V13z")
    }
    static get inbox() {
      return new Sh(14, 16, "M14 9l-1.13-7.14c-.08-.48-.5-.86-1-.86H2.13c-.5 0-.92.38-1 .86L0 9v5c0 .55.45 1 1 1h12c.55 0 1-.45 1-1V9zm-3.28.55l-.44.89c-.17.34-.52.56-.91.56H4.61c-.38 0-.72-.22-.89-.55l-.44-.91c-.17-.33-.52-.55-.89-.55H1l1-7h10l1 7h-1.38c-.39 0-.73.22-.91.55l.01.01z")
    }
    static get info() {
      return new Sh(14, 16, "M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z")
    }
    static get issueClosed() {
      return new Sh(16, 16, "M7 10h2v2H7v-2zm2-6H7v5h2V4zm1.5 1.5l-1 1L12 9l4-4.5-1-1L12 7l-1.5-1.5zM8 13.7A5.71 5.71 0 0 1 2.3 8c0-3.14 2.56-5.7 5.7-5.7 1.83 0 3.45.88 4.5 2.2l.92-.92A6.947 6.947 0 0 0 8 1C4.14 1 1 4.14 1 8s3.14 7 7 7 7-3.14 7-7l-1.52 1.52c-.66 2.41-2.86 4.19-5.48 4.19v-.01z")
    }
    static get issueOpened() {
      return new Sh(14, 16, "M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z")
    }
    static get issueReopened() {
      return new Sh(14, 16, "M8 9H6V4h2v5zm-2 3h2v-2H6v2zm6.33-2H10l1.5 1.5c-1.05 1.33-2.67 2.2-4.5 2.2A5.71 5.71 0 0 1 1.3 8c0-.34.03-.67.09-1H.08C.03 7.33 0 7.66 0 8c0 3.86 3.14 7 7 7 2.19 0 4.13-1.02 5.41-2.59L14 14v-4h-1.67zM1.67 6H4L2.5 4.5C3.55 3.17 5.17 2.3 7 2.3c3.14 0 5.7 2.56 5.7 5.7 0 .34-.03.67-.09 1h1.31c.05-.33.08-.66.08-1 0-3.86-3.14-7-7-7-2.19 0-4.13 1.02-5.41 2.59L0 2v4h1.67z")
    }
    static get italic() {
      return new Sh(6, 16, "M2.81 5h1.98L3 14H1l1.81-9zm.36-2.7c0-.7.58-1.3 1.33-1.3.56 0 1.13.38 1.13 1.03 0 .75-.59 1.3-1.33 1.3-.58 0-1.13-.38-1.13-1.03z")
    }
    static get jersey() {
      return new Sh(14, 16, "M4.5 6l-.5.5v5l.5.5h2l.5-.5v-5L6.5 6h-2zM6 11H5V7h1v4zm6.27-7.25C12.05 2.37 11.96 1.12 12 0H9.02c0 .27-.13.48-.39.69-.25.2-.63.3-1.13.3-.5 0-.88-.09-1.13-.3-.23-.2-.36-.42-.36-.69H3c.05 1.13-.03 2.38-.25 3.75C2.55 5.13 1.95 5.88 1 6v9c.02.27.11.48.31.69.2.21.42.3.69.31h11c.27-.02.48-.11.69-.31.21-.2.3-.42.31-.69V6c-.95-.13-1.53-.88-1.75-2.25h.02zM13 15H2V7c.89-.5 1.48-1.25 1.72-2.25S4.03 2.5 4 1h1c-.02.78.16 1.47.52 2.06.36.58 1.02.89 2 .94.98-.02 1.64-.33 2-.94.36-.59.5-1.28.48-2.06h1c.02 1.42.13 2.55.33 3.38.2.81.69 2 1.67 2.63v8V15zM8.5 6l-.5.5v5l.5.5h2l.5-.5v-5l-.5-.5h-2zm1.5 5H9V7h1v4z")
    }
    static get kebabHorizontal() {
      return new Sh(13, 16, "M1.5 9a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3zm5 0a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3zM13 7.5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0z")
    }
    static get kebabVertical() {
      return new Sh(3, 16, "M0 2.5a1.5 1.5 0 1 0 3 0 1.5 1.5 0 0 0-3 0zm0 5a1.5 1.5 0 1 0 3 0 1.5 1.5 0 0 0-3 0zM1.5 14a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3z")
    }
    static get key() {
      return new Sh(14, 16, "M12.83 2.17C12.08 1.42 11.14 1.03 10 1c-1.13.03-2.08.42-2.83 1.17S6.04 3.86 6.01 5c0 .3.03.59.09.89L0 12v1l1 1h2l1-1v-1h1v-1h1v-1h2l1.09-1.11c.3.08.59.11.91.11 1.14-.03 2.08-.42 2.83-1.17S13.97 6.14 14 5c-.03-1.14-.42-2.08-1.17-2.83zM11 5.38c-.77 0-1.38-.61-1.38-1.38 0-.77.61-1.38 1.38-1.38.77 0 1.38.61 1.38 1.38 0 .77-.61 1.38-1.38 1.38z")
    }
    static get keyboard() {
      return new Sh(16, 16, "M10 5H9V4h1v1zM3 6H2v1h1V6zm5-2H7v1h1V4zM4 4H2v1h2V4zm8 7h2v-1h-2v1zM8 7h1V6H8v1zm-4 3H2v1h2v-1zm8-6h-1v1h1V4zm2 0h-1v1h1V4zm-2 5h2V6h-2v3zm4-6v9c0 .55-.45 1-1 1H1c-.55 0-1-.45-1-1V3c0-.55.45-1 1-1h14c.55 0 1 .45 1 1zm-1 0H1v9h14V3zM6 7h1V6H6v1zm0-3H5v1h1V4zM4 7h1V6H4v1zm1 4h6v-1H5v1zm5-4h1V6h-1v1zM3 8H2v1h1V8zm5 0v1h1V8H8zM6 8v1h1V8H6zM5 8H4v1h1V8zm5 1h1V8h-1v1z")
    }
    static get law() {
      return new Sh(14, 16, "M7 4c-.83 0-1.5-.67-1.5-1.5S6.17 1 7 1s1.5.67 1.5 1.5S7.83 4 7 4zm7 6c0 1.11-.89 2-2 2h-1c-1.11 0-2-.89-2-2l2-4h-1c-.55 0-1-.45-1-1H8v8c.42 0 1 .45 1 1h1c.42 0 1 .45 1 1H3c0-.55.58-1 1-1h1c0-.55.58-1 1-1h.03L6 5H5c0 .55-.45 1-1 1H3l2 4c0 1.11-.89 2-2 2H2c-1.11 0-2-.89-2-2l2-4H1V5h3c0-.55.45-1 1-1h4c.55 0 1 .45 1 1h3v1h-1l2 4zM2.5 7L1 10h3L2.5 7zM13 10l-1.5-3-1.5 3h3z")
    }
    static get lightBulb() {
      return new Sh(12, 16, "M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z")
    }
    static get link() {
      return new Sh(16, 16, "M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z")
    }
    static get linkExternal() {
      return new Sh(12, 16, "M11 10h1v3c0 .55-.45 1-1 1H1c-.55 0-1-.45-1-1V3c0-.55.45-1 1-1h3v1H1v10h10v-3zM6 2l2.25 2.25L5 7.5 6.5 9l3.25-3.25L12 8V2H6z")
    }
    static get listOrdered() {
      return new Sh(12, 16, "M12.01 13c0 .59 0 1-.59 1H4.6c-.59 0-.59-.41-.59-1 0-.59 0-1 .59-1h6.81c.59 0 .59.41.59 1h.01zM4.6 4h6.81C12 4 12 3.59 12 3c0-.59 0-1-.59-1H4.6c-.59 0-.59.41-.59 1 0 .59 0 1 .59 1zm6.81 3H4.6c-.59 0-.59.41-.59 1 0 .59 0 1 .59 1h6.81C12 9 12 8.59 12 8c0-.59 0-1-.59-1zm-9.4-6h-.72c-.3.19-.58.25-1.03.34V2h.75v2.14H.17V5h2.84v-.86h-1V1zm.392 8.12c-.129 0-.592.04-.802.07.53-.56 1.14-1.25 1.14-1.89C2.72 6.52 2.18 6 1.38 6c-.59 0-.97.2-1.38.64l.58.58c.19-.19.38-.38.64-.38.28 0 .48.16.48.52 0 .53-.77 1.2-1.7 2.06V10h3v-.88h-.598zm-.222 3.79v-.03c.44-.19.64-.47.64-.86 0-.7-.56-1.11-1.44-1.11-.48 0-.89.19-1.28.52l.55.64c.25-.2.44-.31.69-.31.27 0 .42.13.42.36 0 .27-.2.44-.86.44v.75c.83 0 .98.17.98.47 0 .25-.23.38-.58.38-.28 0-.56-.14-.81-.38l-.48.66c.3.36.77.56 1.41.56.83 0 1.53-.41 1.53-1.16 0-.5-.31-.81-.77-.94v.01z")
    }
    static get listUnordered() {
      return new Sh(12, 16, "M2 13c0 .59 0 1-.59 1H.59C0 14 0 13.59 0 13c0-.59 0-1 .59-1h.81c.59 0 .59.41.59 1H2zm2.59-9h6.81c.59 0 .59-.41.59-1 0-.59 0-1-.59-1H4.59C4 2 4 2.41 4 3c0 .59 0 1 .59 1zM1.41 7H.59C0 7 0 7.41 0 8c0 .59 0 1 .59 1h.81c.59 0 .59-.41.59-1 0-.59 0-1-.59-1h.01zm0-5H.59C0 2 0 2.41 0 3c0 .59 0 1 .59 1h.81c.59 0 .59-.41.59-1 0-.59 0-1-.59-1h.01zm10 5H4.59C4 7 4 7.41 4 8c0 .59 0 1 .59 1h6.81c.59 0 .59-.41.59-1 0-.59 0-1-.59-1h.01zm0 5H4.59C4 12 4 12.41 4 13c0 .59 0 1 .59 1h6.81c.59 0 .59-.41.59-1 0-.59 0-1-.59-1h.01z")
    }
    static get location() {
      return new Sh(12, 16, "M6 0C2.69 0 0 2.5 0 5.5 0 10.02 6 16 6 16s6-5.98 6-10.5C12 2.5 9.31 0 6 0zm0 14.55C4.14 12.52 1 8.44 1 5.5 1 3.02 3.25 1 6 1c1.34 0 2.61.48 3.56 1.36.92.86 1.44 1.97 1.44 3.14 0 2.94-3.14 7.02-5 9.05zM8 5.5c0 1.11-.89 2-2 2-1.11 0-2-.89-2-2 0-1.11.89-2 2-2 1.11 0 2 .89 2 2z")
    }
    static get lock() {
      return new Sh(12, 16, "M4 13H3v-1h1v1zm8-6v7c0 .55-.45 1-1 1H1c-.55 0-1-.45-1-1V7c0-.55.45-1 1-1h1V4c0-2.2 1.8-4 4-4s4 1.8 4 4v2h1c.55 0 1 .45 1 1zM3.8 6h4.41V4c0-1.22-.98-2.2-2.2-2.2-1.22 0-2.2.98-2.2 2.2v2H3.8zM11 7H2v7h9V7zM4 8H3v1h1V8zm0 2H3v1h1v-1z")
    }
    static get logoGist() {
      return new Sh(25, 16, "M4.7 8.73h2.45v4.02c-.55.27-1.64.34-2.53.34-2.56 0-3.47-2.2-3.47-5.05 0-2.85.91-5.06 3.48-5.06 1.28 0 2.06.23 3.28.73V2.66C7.27 2.33 6.25 2 4.63 2 1.13 2 0 4.69 0 8.03c0 3.34 1.11 6.03 4.63 6.03 1.64 0 2.81-.27 3.59-.64V7.73H4.7v1zm6.39 3.72V6.06h-1.05v6.28c0 1.25.58 1.72 1.72 1.72v-.89c-.48 0-.67-.16-.67-.7v-.02zm.25-8.72c0-.44-.33-.78-.78-.78s-.77.34-.77.78.33.78.77.78.78-.34.78-.78zm4.34 5.69c-1.5-.13-1.78-.48-1.78-1.17 0-.77.33-1.34 1.88-1.34 1.05 0 1.66.16 2.27.36v-.94c-.69-.3-1.52-.39-2.25-.39-2.2 0-2.92 1.2-2.92 2.31 0 1.08.47 1.88 2.73 2.08 1.55.13 1.77.63 1.77 1.34 0 .73-.44 1.42-2.06 1.42-1.11 0-1.86-.19-2.33-.36v.94c.5.2 1.58.39 2.33.39 2.38 0 3.14-1.2 3.14-2.41 0-1.28-.53-2.03-2.75-2.23h-.03zm8.58-2.47v-.86h-2.42v-2.5l-1.08.31v2.11l-1.56.44v.48h1.56v5c0 1.53 1.19 2.13 2.5 2.13.19 0 .52-.02.69-.05v-.89c-.19.03-.41.03-.61.03-.97 0-1.5-.39-1.5-1.34V6.94h2.42v.02-.01z")
    }
    static get logoGithub() {
      return new Sh(45, 16, "M18.53 12.03h-.02c.009 0 .015.01.024.011h.006l-.01-.01zm.004.011c-.093.001-.327.05-.574.05-.78 0-1.05-.36-1.05-.83V8.13h1.59c.09 0 .16-.08.16-.19v-1.7c0-.09-.08-.17-.16-.17h-1.59V3.96c0-.08-.05-.13-.14-.13h-2.16c-.09 0-.14.05-.14.13v2.17s-1.09.27-1.16.28c-.08.02-.13.09-.13.17v1.36c0 .11.08.19.17.19h1.11v3.28c0 2.44 1.7 2.69 2.86 2.69.53 0 1.17-.17 1.27-.22.06-.02.09-.09.09-.16v-1.5a.177.177 0 0 0-.146-.18zM42.23 9.84c0-1.81-.73-2.05-1.5-1.97-.6.04-1.08.34-1.08.34v3.52s.49.34 1.22.36c1.03.03 1.36-.34 1.36-2.25zm2.43-.16c0 3.43-1.11 4.41-3.05 4.41-1.64 0-2.52-.83-2.52-.83s-.04.46-.09.52c-.03.06-.08.08-.14.08h-1.48c-.1 0-.19-.08-.19-.17l.02-11.11c0-.09.08-.17.17-.17h2.13c.09 0 .17.08.17.17v3.77s.82-.53 2.02-.53l-.01-.02c1.2 0 2.97.45 2.97 3.88zm-8.72-3.61h-2.1c-.11 0-.17.08-.17.19v5.44s-.55.39-1.3.39-.97-.34-.97-1.09V6.25c0-.09-.08-.17-.17-.17h-2.14c-.09 0-.17.08-.17.17v5.11c0 2.2 1.23 2.75 2.92 2.75 1.39 0 2.52-.77 2.52-.77s.05.39.08.45c.02.05.09.09.16.09h1.34c.11 0 .17-.08.17-.17l.02-7.47c0-.09-.08-.17-.19-.17zm-23.7-.01h-2.13c-.09 0-.17.09-.17.2v7.34c0 .2.13.27.3.27h1.92c.2 0 .25-.09.25-.27V6.23c0-.09-.08-.17-.17-.17zm-1.05-3.38c-.77 0-1.38.61-1.38 1.38 0 .77.61 1.38 1.38 1.38.75 0 1.36-.61 1.36-1.38 0-.77-.61-1.38-1.36-1.38zm16.49-.25h-2.11c-.09 0-.17.08-.17.17v4.09h-3.31V2.6c0-.09-.08-.17-.17-.17h-2.13c-.09 0-.17.08-.17.17v11.11c0 .09.09.17.17.17h2.13c.09 0 .17-.08.17-.17V8.96h3.31l-.02 4.75c0 .09.08.17.17.17h2.13c.09 0 .17-.08.17-.17V2.6c0-.09-.08-.17-.17-.17zM8.81 7.35v5.74c0 .04-.01.11-.06.13 0 0-1.25.89-3.31.89-2.49 0-5.44-.78-5.44-5.92S2.58 1.99 5.1 2c2.18 0 3.06.49 3.2.58.04.05.06.09.06.14L7.94 4.5c0 .09-.09.2-.2.17-.36-.11-.9-.33-2.17-.33-1.47 0-3.05.42-3.05 3.73s1.5 3.7 2.58 3.7c.92 0 1.25-.11 1.25-.11v-2.3H4.88c-.11 0-.19-.08-.19-.17V7.35c0-.09.08-.17.19-.17h3.74c.11 0 .19.08.19.17z")
    }
    static get mail() {
      return new Sh(14, 16, "M0 4v8c0 .55.45 1 1 1h12c.55 0 1-.45 1-1V4c0-.55-.45-1-1-1H1c-.55 0-1 .45-1 1zm13 0L7 9 1 4h12zM1 5.5l4 3-4 3v-6zM2 12l3.5-3L7 10.5 8.5 9l3.5 3H2zm11-.5l-4-3 4-3v6z")
    }
    static get mailRead() {
      return new Sh(14, 16, "M6 5H4V4h2v1zm3 1H4v1h5V6zm5-.48V14c0 .55-.45 1-1 1H1c-.55 0-1-.45-1-1V5.52c0-.33.16-.63.42-.81L2 3.58V3c0-.55.45-1 1-1h1.2L7 0l2.8 2H11c.55 0 1 .45 1 1v.58l1.58 1.13c.27.19.42.48.42.81zM3 7.5L7 10l4-2.5V3H3v4.5zm-2 6l4.5-3-4.5-3v6zm11 .5l-5-3-5 3h10zm1-6.5l-4.5 3 4.5 3v-6z")
    }
    static get markGithub() {
      return new Sh(16, 16, "M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z")
    }
    static get markdown() {
      return new Sh(16, 16, "M14.85 3H1.15C.52 3 0 3.52 0 4.15v7.69C0 12.48.52 13 1.15 13h13.69c.64 0 1.15-.52 1.15-1.15v-7.7C16 3.52 15.48 3 14.85 3zM9 11H7V8L5.5 9.92 4 8v3H2V5h2l1.5 2L7 5h2v6zm2.99.5L9.5 8H11V5h2v3h1.5l-2.51 3.5z")
    }
    static get megaphone() {
      return new Sh(16, 16, "M10 1c-.17 0-.36.05-.52.14C8.04 2.02 4.5 4.58 3 5c-1.38 0-3 .67-3 2.5S1.63 10 3 10c.3.08.64.23 1 .41V15h2v-3.45c1.34.86 2.69 1.83 3.48 2.31.16.09.34.14.52.14.52 0 1-.42 1-1V2c0-.58-.48-1-1-1zm0 12c-.38-.23-.89-.58-1.5-1-.16-.11-.33-.22-.5-.34V3.31c.16-.11.31-.2.47-.31.61-.41 1.16-.77 1.53-1v11zm2-6h4v1h-4V7zm0 2l4 2v1l-4-2V9zm4-6v1l-4 2V5l4-2z")
    }
    static get mention() {
      return new Sh(14, 16, "M6.58 15c1.25 0 2.52-.31 3.56-.94l-.42-.94c-.84.52-1.89.83-3.03.83-3.23 0-5.64-2.08-5.64-5.72 0-4.37 3.23-7.18 6.58-7.18 3.45 0 5.22 2.19 5.22 5.2 0 2.39-1.34 3.86-2.5 3.86-1.05 0-1.36-.73-1.05-2.19l.73-3.75H8.98l-.11.72c-.41-.63-.94-.83-1.56-.83-2.19 0-3.66 2.39-3.66 4.38 0 1.67.94 2.61 2.3 2.61.84 0 1.67-.53 2.3-1.25.11.94.94 1.45 1.98 1.45 1.67 0 3.77-1.67 3.77-5C14 2.61 11.59 0 7.83 0 3.66 0 0 3.33 0 8.33 0 12.71 2.92 15 6.58 15zm-.31-5c-.73 0-1.36-.52-1.36-1.67 0-1.45.94-3.22 2.41-3.22.52 0 .84.2 1.25.83l-.52 3.02c-.63.73-1.25 1.05-1.78 1.05V10z")
    }
    static get milestone() {
      return new Sh(14, 16, "M8 2H6V0h2v2zm4 5H2c-.55 0-1-.45-1-1V4c0-.55.45-1 1-1h10l2 2-2 2zM8 4H6v2h2V4zM6 16h2V8H6v8z")
    }
    static get mirror() {
      return new Sh(16, 16, "M15.5 4.7L8.5 0l-7 4.7c-.3.19-.5.45-.5.8V16l7.5-4 7.5 4V5.5c0-.34-.2-.61-.5-.8zm-.5 9.8l-6-3.25V10H8v1.25L2 14.5v-9l6-4V6h1V1.5l6 4v9zM6 7h5V5l3 3-3 3V9H6v2L3 8l3-3v2z")
    }
    static get mortarBoard() {
      return new Sh(16, 16, "M8.11 2.8a.34.34 0 0 0-.2 0L.27 5.18a.35.35 0 0 0 0 .67L2 6.4v1.77c-.3.17-.5.5-.5.86 0 .19.05.36.14.5-.08.14-.14.31-.14.5v2.58c0 .55 2 .55 2 0v-2.58c0-.19-.05-.36-.14-.5.08-.14.14-.31.14-.5 0-.38-.2-.69-.5-.86V6.72l4.89 1.53c.06.02.14.02.2 0l7.64-2.38a.35.35 0 0 0 0-.67L8.1 2.81l.01-.01zM4 8l3.83 1.19h-.02c.13.03.25.03.36 0L12 8v2.5c0 1-1.8 1.5-4 1.5s-4-.5-4-1.5V8zm3.02-2.5c0 .28.45.5 1 .5s1-.22 1-.5-.45-.5-1-.5-1 .22-1 .5z")
    }
    static get mute() {
      return new Sh(16, 16, "M8 2.81v10.38c0 .67-.81 1-1.28.53L3 10H1c-.55 0-1-.45-1-1V7c0-.55.45-1 1-1h2l3.72-3.72C7.19 1.81 8 2.14 8 2.81zm7.53 3.22l-1.06-1.06-1.97 1.97-1.97-1.97-1.06 1.06L11.44 8 9.47 9.97l1.06 1.06 1.97-1.97 1.97 1.97 1.06-1.06L13.56 8l1.97-1.97z")
    }
    static get noNewline() {
      return new Sh(16, 16, "M16 5v3c0 .55-.45 1-1 1h-3v2L9 8l3-3v2h2V5h2zM8 8c0 2.2-1.8 4-4 4s-4-1.8-4-4 1.8-4 4-4 4 1.8 4 4zM1.5 9.66L5.66 5.5C5.18 5.19 4.61 5 4 5 2.34 5 1 6.34 1 8c0 .61.19 1.17.5 1.66zM7 8c0-.61-.19-1.17-.5-1.66L2.34 10.5c.48.31 1.05.5 1.66.5 1.66 0 3-1.34 3-3z")
    }
    static get note() {
      return new Sh(14, 16, "M3 10h4V9H3v1zm0-2h6V7H3v1zm0-2h8V5H3v1zm10 6H1V3h12v9zM1 2c-.55 0-1 .45-1 1v9c0 .55.45 1 1 1h12c.55 0 1-.45 1-1V3c0-.55-.45-1-1-1H1z")
    }
    static get octoface() {
      return new Sh(16, 16, "M14.7 5.34c.13-.32.55-1.59-.13-3.31 0 0-1.05-.33-3.44 1.3-1-.28-2.07-.32-3.13-.32s-2.13.04-3.13.32c-2.39-1.64-3.44-1.3-3.44-1.3-.68 1.72-.26 2.99-.13 3.31C.49 6.21 0 7.33 0 8.69 0 13.84 3.33 15 7.98 15S16 13.84 16 8.69c0-1.36-.49-2.48-1.3-3.35zM8 14.02c-3.3 0-5.98-.15-5.98-3.35 0-.76.38-1.48 1.02-2.07 1.07-.98 2.9-.46 4.96-.46 2.07 0 3.88-.52 4.96.46.65.59 1.02 1.3 1.02 2.07 0 3.19-2.68 3.35-5.98 3.35zM5.49 9.01c-.66 0-1.2.8-1.2 1.78s.54 1.79 1.2 1.79c.66 0 1.2-.8 1.2-1.79s-.54-1.78-1.2-1.78zm5.02 0c-.66 0-1.2.79-1.2 1.78s.54 1.79 1.2 1.79c.66 0 1.2-.8 1.2-1.79s-.53-1.78-1.2-1.78z")
    }
    static get organization() {
      return new Sh(16, 16, "M16 12.999c0 .439-.45 1-1 1H7.995c-.539 0-.994-.447-.995-.999H1c-.54 0-1-.561-1-1 0-2.634 3-4 3-4s.229-.409 0-1c-.841-.621-1.058-.59-1-3 .058-2.419 1.367-3 2.5-3s2.442.58 2.5 3c.058 2.41-.159 2.379-1 3-.229.59 0 1 0 1s1.549.711 2.42 2.088C9.196 9.369 10 8.999 10 8.999s.229-.409 0-1c-.841-.62-1.058-.59-1-3 .058-2.419 1.367-3 2.5-3s2.437.581 2.495 3c.059 2.41-.158 2.38-1 3-.229.59 0 1 0 1s3.005 1.366 3.005 4z")
    }
    static get package() {
      return new Sh(16, 16, "M1 4.27v7.47c0 .45.3.84.75.97l6.5 1.73c.16.05.34.05.5 0l6.5-1.73c.45-.13.75-.52.75-.97V4.27c0-.45-.3-.84-.75-.97l-6.5-1.74a1.4 1.4 0 0 0-.5 0L1.75 3.3c-.45.13-.75.52-.75.97zm7 9.09l-6-1.59V5l6 1.61v6.75zM2 4l2.5-.67L11 5.06l-2.5.67L2 4zm13 7.77l-6 1.59V6.61l2-.55V8.5l2-.53V5.53L15 5v6.77zm-2-7.24L6.5 2.8l2-.53L15 4l-2 .53z")
    }
    static get paintcan() {
      return new Sh(12, 16, "M6 0C2.69 0 0 2.69 0 6v1c0 .55.45 1 1 1v5c0 1.1 2.24 2 5 2s5-.9 5-2V8c.55 0 1-.45 1-1V6c0-3.31-2.69-6-6-6zm3 10v.5c0 .28-.22.5-.5.5s-.5-.22-.5-.5V10c0-.28-.22-.5-.5-.5s-.5.22-.5.5v2.5c0 .28-.22.5-.5.5s-.5-.22-.5-.5v-2c0-.28-.22-.5-.5-.5s-.5.22-.5.5v.5c0 .55-.45 1-1 1s-1-.45-1-1v-1c-.55 0-1-.45-1-1V7.2c.91.49 2.36.8 4 .8 1.64 0 3.09-.31 4-.8V9c0 .55-.45 1-1 1zM6 7c-1.68 0-3.12-.41-3.71-1C2.88 5.41 4.32 5 6 5c1.68 0 3.12.41 3.71 1-.59.59-2.03 1-3.71 1zm0-3c-2.76 0-5 .89-5 2 0-2.76 2.24-5 5-5s5 2.24 5 5c0-1.1-2.24-2-5-2z")
    }
    static get pencil() {
      return new Sh(14, 16, "M0 12v3h3l8-8-3-3-8 8zm3 2H1v-2h1v1h1v1zm10.3-9.3L12 6 9 3l1.3-1.3a.996.996 0 0 1 1.41 0l1.59 1.59c.39.39.39 1.02 0 1.41z")
    }
    static get person() {
      return new Sh(12, 16, "M12 14.002a.998.998 0 0 1-.998.998H1.001A1 1 0 0 1 0 13.999V13c0-2.633 4-4 4-4s.229-.409 0-1c-.841-.62-.944-1.59-1-4 .173-2.413 1.867-3 3-3s2.827.586 3 3c-.056 2.41-.159 3.38-1 4-.229.59 0 1 0 1s4 1.367 4 4v1.002z")
    }
    static get pin() {
      return new Sh(16, 16, "M10 1.2V2l.5 1L6 6H2.2c-.44 0-.67.53-.34.86L5 10l-4 5 5-4 3.14 3.14a.5.5 0 0 0 .86-.34V10l3-4.5 1 .5h.8c.44 0 .67-.53.34-.86L10.86.86a.5.5 0 0 0-.86.34z")
    }
    static get play() {
      return new Sh(14, 16, "M14 8A7 7 0 1 1 0 8a7 7 0 0 1 14 0zm-8.223 3.482l4.599-3.066a.5.5 0 0 0 0-.832L5.777 4.518A.5.5 0 0 0 5 4.934v6.132a.5.5 0 0 0 .777.416z")
    }
    static get plug() {
      return new Sh(14, 16, "M14 6V5h-4V3H8v1H6c-1.03 0-1.77.81-2 2L3 7c-1.66 0-3 1.34-3 3v2h1v-2c0-1.11.89-2 2-2l1 1c.25 1.16.98 2 2 2h2v1h2v-2h4V9h-4V6h4z")
    }
    static get plus() {
      return new Sh(12, 16, "M12 9H7v5H5V9H0V7h5V2h2v5h5v2z")
    }
    static get plusSmall() {
      return new Sh(7, 16, "M4 4H3v3H0v1h3v3h1V8h3V7H4V4z")
    }
    static get primitiveDot() {
      return new Sh(8, 16, "M0 8c0-2.2 1.8-4 4-4s4 1.8 4 4-1.8 4-4 4-4-1.8-4-4z")
    }
    static get primitiveSquare() {
      return new Sh(8, 16, "M8 12H0V4h8v8z")
    }
    static get project() {
      return new Sh(15, 16, "M10 12h3V2h-3v10zm-4-2h3V2H6v8zm-4 4h3V2H2v12zm-1 1h13V1H1v14zM14 0H1a1 1 0 0 0-1 1v14a1 1 0 0 0 1 1h13a1 1 0 0 0 1-1V1a1 1 0 0 0-1-1z")
    }
    static get pulse() {
      return new Sh(14, 16, "M11.5 8L8.8 5.4 6.6 8.5 5.5 1.6 2.38 8H0v2h3.6l.9-1.8.9 5.4L9 8.5l1.6 1.5H14V8h-2.5z")
    }
    static get question() {
      return new Sh(14, 16, "M6 10h2v2H6v-2zm4-3.5C10 8.64 8 9 8 9H6c0-.55.45-1 1-1h.5c.28 0 .5-.22.5-.5v-1c0-.28-.22-.5-.5-.5h-1c-.28 0-.5.22-.5.5V7H4c0-1.5 1.5-3 3-3s3 1 3 2.5zM7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7z")
    }
    static get quote() {
      return new Sh(14, 16, "M6.16 3.5C3.73 5.06 2.55 6.67 2.55 9.36c.16-.05.3-.05.44-.05 1.27 0 2.5.86 2.5 2.41 0 1.61-1.03 2.61-2.5 2.61-1.9 0-2.99-1.52-2.99-4.25 0-3.8 1.75-6.53 5.02-8.42L6.16 3.5zm7 0c-2.43 1.56-3.61 3.17-3.61 5.86.16-.05.3-.05.44-.05 1.27 0 2.5.86 2.5 2.41 0 1.61-1.03 2.61-2.5 2.61-1.89 0-2.98-1.52-2.98-4.25 0-3.8 1.75-6.53 5.02-8.42l1.14 1.84h-.01z")
    }
    static get radioTower() {
      return new Sh(16, 16, "M4.79 6.11c.25-.25.25-.67 0-.92-.32-.33-.48-.76-.48-1.19 0-.43.16-.86.48-1.19.25-.26.25-.67 0-.92a.613.613 0 0 0-.45-.19c-.16 0-.33.06-.45.19-.57.58-.85 1.35-.85 2.11 0 .76.29 1.53.85 2.11.25.25.66.25.9 0zM2.33.52a.651.651 0 0 0-.92 0C.48 1.48.01 2.74.01 3.99c0 1.26.47 2.52 1.4 3.48.25.26.66.26.91 0s.25-.68 0-.94c-.68-.7-1.02-1.62-1.02-2.54 0-.92.34-1.84 1.02-2.54a.66.66 0 0 0 .01-.93zm5.69 5.1A1.62 1.62 0 1 0 6.4 4c-.01.89.72 1.62 1.62 1.62zM14.59.53a.628.628 0 0 0-.91 0c-.25.26-.25.68 0 .94.68.7 1.02 1.62 1.02 2.54 0 .92-.34 1.83-1.02 2.54-.25.26-.25.68 0 .94a.651.651 0 0 0 .92 0c.93-.96 1.4-2.22 1.4-3.48A5.048 5.048 0 0 0 14.59.53zM8.02 6.92c-.41 0-.83-.1-1.2-.3l-3.15 8.37h1.49l.86-1h4l.84 1h1.49L9.21 6.62c-.38.2-.78.3-1.19.3zm-.01.48L9.02 11h-2l.99-3.6zm-1.99 5.59l1-1h2l1 1h-4zm5.19-11.1c-.25.25-.25.67 0 .92.32.33.48.76.48 1.19 0 .43-.16.86-.48 1.19-.25.26-.25.67 0 .92a.63.63 0 0 0 .9 0c.57-.58.85-1.35.85-2.11 0-.76-.28-1.53-.85-2.11a.634.634 0 0 0-.9 0z")
    }
    static get reply() {
      return new Sh(14, 16, "M6 3.5c3.92.44 8 3.125 8 10-2.312-5.062-4.75-6-8-6V11L.5 5.5 6 0v3.5z")
    }
    static get repo() {
      return new Sh(12, 16, "M4 9H3V8h1v1zm0-3H3v1h1V6zm0-2H3v1h1V4zm0-2H3v1h1V2zm8-1v12c0 .55-.45 1-1 1H6v2l-1.5-1.5L3 16v-2H1c-.55 0-1-.45-1-1V1c0-.55.45-1 1-1h10c.55 0 1 .45 1 1zm-1 10H1v2h2v-1h3v1h5v-2zm0-10H2v9h9V1z")
    }
    static get repoClone() {
      return new Sh(16, 16, "M15 0H9v7c0 .55.45 1 1 1h1v1h1V8h3c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1zm-4 7h-1V6h1v1zm4 0h-3V6h3v1zm0-2h-4V1h4v4zM4 5H3V4h1v1zm0-2H3V2h1v1zM2 1h6V0H1C.45 0 0 .45 0 1v12c0 .55.45 1 1 1h2v2l1.5-1.5L6 16v-2h5c.55 0 1-.45 1-1v-3H2V1zm9 10v2H6v-1H3v1H1v-2h10zM3 8h1v1H3V8zm1-1H3V6h1v1z")
    }
    static get repoForcePush() {
      return new Sh(12, 16, "M10 9H8v7H6V9H4l2.25-3H4l3-4 3 4H7.75L10 9zm1-9H1C.45 0 0 .45 0 1v12c0 .55.45 1 1 1h4v-1H1v-2h4v-1H2V1h9v9H9v1h2v2H9v1h2c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1z")
    }
    static get repoForked() {
      return new Sh(10, 16, "M8 1a1.993 1.993 0 0 0-1 3.72V6L5 8 3 6V4.72A1.993 1.993 0 0 0 2 1a1.993 1.993 0 0 0-1 3.72V6.5l3 3v1.78A1.993 1.993 0 0 0 5 15a1.993 1.993 0 0 0 1-3.72V9.5l3-3V4.72A1.993 1.993 0 0 0 8 1zM2 4.2C1.34 4.2.8 3.65.8 3c0-.65.55-1.2 1.2-1.2.65 0 1.2.55 1.2 1.2 0 .65-.55 1.2-1.2 1.2zm3 10c-.66 0-1.2-.55-1.2-1.2 0-.65.55-1.2 1.2-1.2.65 0 1.2.55 1.2 1.2 0 .65-.55 1.2-1.2 1.2zm3-10c-.66 0-1.2-.55-1.2-1.2 0-.65.55-1.2 1.2-1.2.65 0 1.2.55 1.2 1.2 0 .65-.55 1.2-1.2 1.2z")
    }
    static get repoPull() {
      return new Sh(16, 16, "M13 8V6H7V4h6V2l3 3-3 3zM4 2H3v1h1V2zm7 5h1v6c0 .55-.45 1-1 1H6v2l-1.5-1.5L3 16v-2H1c-.55 0-1-.45-1-1V1c0-.55.45-1 1-1h10c.55 0 1 .45 1 1v2h-1V1H2v9h9V7zm0 4H1v2h2v-1h3v1h5v-2zM4 6H3v1h1V6zm0-2H3v1h1V4zM3 9h1V8H3v1z")
    }
    static get repoPush() {
      return new Sh(12, 16, "M4 3H3V2h1v1zM3 5h1V4H3v1zm4 0L4 9h2v7h2V9h2L7 5zm4-5H1C.45 0 0 .45 0 1v12c0 .55.45 1 1 1h4v-1H1v-2h4v-1H2V1h9.02L11 10H9v1h2v2H9v1h2c.55 0 1-.45 1-1V1c0-.55-.45-1-1-1z")
    }
    static get repoTemplate() {
      return new Sh(14, 16, "M12 8V1c0-.55-.45-1-1-1H1C.45 0 0 .45 0 1v12c0 .55.45 1 1 1h2v2l1.5-1.5L6 16v-4H3v1H1v-2h7v-1H2V1h9v7h1zM4 2H3v1h1V2zM3 4h1v1H3V4zm1 2H3v1h1V6zm0 3H3V8h1v1zm6 3H8v2h2v2h2v-2h2v-2h-2v-2h-2v2z")
    }
    static get repoTemplatePrivate() {
      return new Sh(14, 16, "M12 6c0-.55-.45-1-1-1h-1V4c0-2.2-1.8-4-4-4S2 1.8 2 4v1H1c-.55 0-1 .45-1 1v7c0 .55.45 1 1 1h5v-1H2V6h9v2h1V6zM8.21 5V4c0-1.22-.98-2.2-2.2-2.2-1.22 0-2.2.98-2.2 2.2v1h4.4zM12 12h2v2h-2v2h-2v-2H8v-2h2v-2h2v2zm-9 0h1v-1H3v1zm0-5h1v1H3V7zm1 2H3v1h1V9z")
    }
    static get report() {
      return new Sh(16, 16, "M0 2a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1v9a1 1 0 0 1-1 1H7l-4 4v-4H1a1 1 0 0 1-1-1V2zm1 0h14v9H6.5L4 13.5V11H1V2zm6 6h2v2H7V8zm0-5h2v4H7V3z")
    }
    static get requestChanges() {
      return new Sh(16, 15, "M0 1a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1v10a1 1 0 0 1-1 1H7.5L4 15.5V12H1a1 1 0 0 1-1-1V1zm1 0v10h4v2l2-2h8V1H1zm7.5 3h2v1h-2v2h-1V5h-2V4h2V2h1v2zm2 5h-5V8h5v1z")
    }
    static get rocket() {
      return new Sh(16, 16, "M12.17 3.83c-.27-.27-.47-.55-.63-.88-.16-.31-.27-.66-.34-1.02-.58.33-1.16.7-1.73 1.13-.58.44-1.14.94-1.69 1.48-.7.7-1.33 1.81-1.78 2.45H3L0 10h3l2-2c-.34.77-1.02 2.98-1 3l1 1c.02.02 2.23-.64 3-1l-2 2v3l3-3v-3c.64-.45 1.75-1.09 2.45-1.78.55-.55 1.05-1.13 1.47-1.7.44-.58.81-1.16 1.14-1.72-.36-.08-.7-.19-1.03-.34a3.39 3.39 0 0 1-.86-.63zM16 0s-.09.38-.3 1.06c-.2.7-.55 1.58-1.06 2.66-.7-.08-1.27-.33-1.66-.72-.39-.39-.63-.94-.7-1.64C13.36.84 14.23.48 14.92.28 15.62.08 16 0 16 0z")
    }
    static get rss() {
      return new Sh(10, 16, "M2 13H0v-2c1.11 0 2 .89 2 2zM0 3v1a9 9 0 0 1 9 9h1C10 7.48 5.52 3 0 3zm0 4v1c2.75 0 5 2.25 5 5h1c0-3.31-2.69-6-6-6z")
    }
    static get ruby() {
      return new Sh(16, 16, "M13 6l-5 5V4h3l2 2zm3 0l-8 8-8-8 4-4h8l4 4zm-8 6.5L14.5 6l-3-3h-7l-3 3L8 12.5z")
    }
    static get screenFull() {
      return new Sh(14, 16, "M13 10h1v3c0 .547-.453 1-1 1h-3v-1h3v-3zM1 10H0v3c0 .547.453 1 1 1h3v-1H1v-3zm0-7h3V2H1c-.547 0-1 .453-1 1v3h1V3zm1 1h10v8H2V4zm2 6h6V6H4v4zm6-8v1h3v3h1V3c0-.547-.453-1-1-1h-3z")
    }
    static get screenNormal() {
      return new Sh(14, 16, "M2 4H0V3h2V1h1v2c0 .547-.453 1-1 1zm0 8H0v1h2v2h1v-2c0-.547-.453-1-1-1zm9-2c0 .547-.453 1-1 1H4c-.547 0-1-.453-1-1V6c0-.547.453-1 1-1h6c.547 0 1 .453 1 1v4zM9 7H5v2h4V7zm2 6v2h1v-2h2v-1h-2c-.547 0-1 .453-1 1zm1-10V1h-1v2c0 .547.453 1 1 1h2V3h-2z")
    }
    static get search() {
      return new Sh(16, 16, "M15.7 13.3l-3.81-3.83A5.93 5.93 0 0 0 13 6c0-3.31-2.69-6-6-6S1 2.69 1 6s2.69 6 6 6c1.3 0 2.48-.41 3.47-1.11l3.83 3.81c.19.2.45.3.7.3.25 0 .52-.09.7-.3a.996.996 0 0 0 0-1.41v.01zM7 10.7c-2.59 0-4.7-2.11-4.7-4.7 0-2.59 2.11-4.7 4.7-4.7 2.59 0 4.7 2.11 4.7 4.7 0 2.59-2.11 4.7-4.7 4.7z")
    }
    static get server() {
      return new Sh(12, 16, "M11 6H1c-.55 0-1 .45-1 1v2c0 .55.45 1 1 1h10c.55 0 1-.45 1-1V7c0-.55-.45-1-1-1zM2 9H1V7h1v2zm2 0H3V7h1v2zm2 0H5V7h1v2zm2 0H7V7h1v2zm3-8H1c-.55 0-1 .45-1 1v2c0 .55.45 1 1 1h10c.55 0 1-.45 1-1V2c0-.55-.45-1-1-1zM2 4H1V2h1v2zm2 0H3V2h1v2zm2 0H5V2h1v2zm2 0H7V2h1v2zm3-1h-1V2h1v1zm0 8H1c-.55 0-1 .45-1 1v2c0 .55.45 1 1 1h10c.55 0 1-.45 1-1v-2c0-.55-.45-1-1-1zm-9 3H1v-2h1v2zm2 0H3v-2h1v2zm2 0H5v-2h1v2zm2 0H7v-2h1v2z")
    }
    static get settings() {
      return new Sh(16, 16, "M4 7H3V2h1v5zm-1 7h1v-3H3v3zm5 0h1V8H8v6zm5 0h1v-2h-1v2zm1-12h-1v6h1V2zM9 2H8v2h1V2zM5 8H2c-.55 0-1 .45-1 1s.45 1 1 1h3c.55 0 1-.45 1-1s-.45-1-1-1zm5-3H7c-.55 0-1 .45-1 1s.45 1 1 1h3c.55 0 1-.45 1-1s-.45-1-1-1zm5 4h-3c-.55 0-1 .45-1 1s.45 1 1 1h3c.55 0 1-.45 1-1s-.45-1-1-1z")
    }
    static get shield() {
      return new Sh(14, 16, "M0 2l7-2 7 2v6.02C14 12.69 8.69 16 7 16c-1.69 0-7-3.31-7-7.98V2zm1 .75L7 1l6 1.75v5.268C13 12.104 8.449 15 7 15c-1.449 0-6-2.896-6-6.982V2.75zm1 .75L7 2v12c-1.207 0-5-2.482-5-5.985V3.5z")
    }
    static get shieldCheck() {
      return new Sh(16, 16, "M6.5 0L0 1.875v5.644C0 11.897 4.93 15 6.5 15c.741 0 2.232-.692 3.6-1.884l-.713-.61C8.275 13.453 7.099 14 6.5 14 5.172 14 1 11.31 1 7.516V2.625L6.5 1 12 2.625v4.891c0 .128-.005.255-.014.38L13 6.713V1.875L6.5 0zm5 10l-2-1.5L8 10l3.5 3L16 8l-1.5-1.5-3 3.5zM2 3.375L6.5 2v11C5.414 13 2 10.724 2 7.514V3.375z")
    }
    static get shieldLock() {
      return new Sh(14, 16, "M7 0L0 2v6.02C0 12.69 5.31 16 7 16c1.69 0 7-3.31 7-7.98V2L7 0zM5 11l1.14-2.8a.568.568 0 0 0-.25-.59C5.33 7.25 5 6.66 5 6c0-1.09.89-2 1.98-2C8.06 4 9 4.91 9 6c0 .66-.33 1.25-.89 1.61-.19.13-.3.36-.25.59L9 11H5z")
    }
    static get shieldX() {
      return new Sh(16, 16, "M6.5 0L0 1.875v5.644C0 11.897 4.93 15 6.5 15c.63 0 1.8-.5 2.976-1.38l-.663-.663C7.889 13.625 6.996 14 6.5 14 5.172 14 1 11.31 1 7.516V2.625L6.5 1 12 2.625v4.23l.48.48.52-.52v-4.94L6.5 0zm5.98 8.75L10.73 7 9.25 8.48 11 10.23l-1.75 1.75 1.48 1.48 1.75-1.75 1.75 1.75 1.48-1.48-1.75-1.75 1.75-1.75L14.23 7l-1.75 1.75zM2 3.375L6.5 2v11C5.414 13 2 10.724 2 7.514V3.375z")
    }
    static get signIn() {
      return new Sh(14, 16, "M7 6.75V12h4V8h1v4c0 .55-.45 1-1 1H7v3l-5.45-2.72c-.33-.17-.55-.52-.55-.91V1c0-.55.45-1 1-1h9c.55 0 1 .45 1 1v3h-1V1H3l4 2v2.25L10 3v2h4v2h-4v2L7 6.75z")
    }
    static get signOut() {
      return new Sh(16, 16, "M12 9V7H8V5h4V3l4 3-4 3zm-2 3H6V3L2 1h8v3h1V1c0-.55-.45-1-1-1H1C.45 0 0 .45 0 1v11.38c0 .39.22.73.55.91L6 16.01V13h4c.55 0 1-.45 1-1V8h-1v4z")
    }
    static get skip() {
      return new Sh(16, 16, "M5.79 11.624l-1.326-.088-.088-1.326 5.834-5.834 1.326.088.088 1.326-5.834 5.834zM8 15A7 7 0 1 0 8 1a7 7 0 0 0 0 14zm5.5-7a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0z")
    }
    static get smiley() {
      return new Sh(16, 16, "M8 0C3.58 0 0 3.58 0 8s3.58 8 8 8 8-3.58 8-8-3.58-8-8-8zm4.81 12.81a6.72 6.72 0 0 1-2.17 1.45c-.83.36-1.72.53-2.64.53-.92 0-1.81-.17-2.64-.53-.81-.34-1.55-.83-2.17-1.45a6.773 6.773 0 0 1-1.45-2.17A6.59 6.59 0 0 1 1.21 8c0-.92.17-1.81.53-2.64.34-.81.83-1.55 1.45-2.17.62-.62 1.36-1.11 2.17-1.45A6.59 6.59 0 0 1 8 1.21c.92 0 1.81.17 2.64.53.81.34 1.55.83 2.17 1.45.62.62 1.11 1.36 1.45 2.17.36.83.53 1.72.53 2.64 0 .92-.17 1.81-.53 2.64-.34.81-.83 1.55-1.45 2.17zM4 6.8v-.59c0-.66.53-1.19 1.2-1.19h.59c.66 0 1.19.53 1.19 1.19v.59c0 .67-.53 1.2-1.19 1.2H5.2C4.53 8 4 7.47 4 6.8zm5 0v-.59c0-.66.53-1.19 1.2-1.19h.59c.66 0 1.19.53 1.19 1.19v.59c0 .67-.53 1.2-1.19 1.2h-.59C9.53 8 9 7.47 9 6.8zm4 3.2c-.72 1.88-2.91 3-5 3s-4.28-1.13-5-3c-.14-.39.23-1 .66-1h8.59c.41 0 .89.61.75 1z")
    }
    static get squirrel() {
      return new Sh(16, 16, "M12 1C9.79 1 8 2.31 8 3.92c0 1.94.5 3.03 0 6.08 0-4.5-2.77-6.34-4-6.34.05-.5-.48-.66-.48-.66s-.22.11-.3.34c-.27-.31-.56-.27-.56-.27l-.13.58S.7 4.29.68 6.87c.2.33 1.53.6 2.47.43.89.05.67.79.47.99C2.78 9.13 2 8 1 8S0 9 1 9s1 1 3 1c-3.09 1.2 0 4 0 4H3c-1 0-1 1-1 1h6c3 0 5-1 5-3.47 0-.85-.43-1.79-1-2.53-1.11-1.46.23-2.68 1-2 .77.68 3 1 3-2 0-2.21-1.79-4-4-4zM2.5 6c-.28 0-.5-.22-.5-.5s.22-.5.5-.5.5.22.5.5-.22.5-.5.5z")
    }
    static get star() {
      return new Sh(14, 16, "M14 6l-4.9-.64L7 1 4.9 5.36 0 6l3.6 3.26L2.67 14 7 11.67 11.33 14l-.93-4.74L14 6z")
    }
    static get stop() {
      return new Sh(14, 16, "M10 1H4L0 5v6l4 4h6l4-4V5l-4-4zm3 9.5L9.5 14h-5L1 10.5v-5L4.5 2h5L13 5.5v5zM6 4h2v5H6V4zm0 6h2v2H6v-2z")
    }
    static get sync() {
      return new Sh(12, 16, "M10.24 7.4a4.15 4.15 0 0 1-1.2 3.6 4.346 4.346 0 0 1-5.41.54L4.8 10.4.5 9.8l.6 4.2 1.31-1.26c2.36 1.74 5.7 1.57 7.84-.54a5.876 5.876 0 0 0 1.74-4.46l-1.75-.34zM2.96 5a4.346 4.346 0 0 1 5.41-.54L7.2 5.6l4.3.6-.6-4.2-1.31 1.26c-2.36-1.74-5.7-1.57-7.85.54C.5 5.03-.06 6.65.01 8.26l1.75.35A4.17 4.17 0 0 1 2.96 5z")
    }
    static get tag() {
      return new Sh(14, 16, "M7.73 1.73C7.26 1.26 6.62 1 5.96 1H3.5C2.13 1 1 2.13 1 3.5v2.47c0 .66.27 1.3.73 1.77l6.06 6.06c.39.39 1.02.39 1.41 0l4.59-4.59a.996.996 0 0 0 0-1.41L7.73 1.73zM2.38 7.09c-.31-.3-.47-.7-.47-1.13V3.5c0-.88.72-1.59 1.59-1.59h2.47c.42 0 .83.16 1.13.47l6.14 6.13-4.73 4.73-6.13-6.15zM3.01 3h2v2H3V3h.01z")
    }
    static get tasklist() {
      return new Sh(16, 16, "M15.41 9H7.59C7 9 7 8.59 7 8c0-.59 0-1 .59-1h7.81c.59 0 .59.41.59 1 0 .59 0 1-.59 1h.01zM9.59 4C9 4 9 3.59 9 3c0-.59 0-1 .59-1h5.81c.59 0 .59.41.59 1 0 .59 0 1-.59 1H9.59zM0 3.91l1.41-1.3L3 4.2 7.09 0 8.5 1.41 3 6.91l-3-3zM7.59 12h7.81c.59 0 .59.41.59 1 0 .59 0 1-.59 1H7.59C7 14 7 13.59 7 13c0-.59 0-1 .59-1z")
    }
    static get telescope() {
      return new Sh(14, 16, "M8 9l3 6h-1l-2-4v5H7v-6l-2 5H4l2-5 2-1zM7 0H6v1h1V0zM5 3H4v1h1V3zM2 1H1v1h1V1zM.63 9a.52.52 0 0 0-.16.67l.55.92c.13.23.41.31.64.2l1.39-.66-1.16-2-1.27.86.01.01zm7.89-5.39l-5.8 3.95L3.95 9.7l6.33-3.03-1.77-3.06h.01zm4.22 1.28l-1.47-2.52a.51.51 0 0 0-.72-.17l-1.2.83 1.84 3.2 1.33-.64c.27-.13.36-.44.22-.7z")
    }
    static get terminal() {
      return new Sh(14, 16, "M7 10h4v1H7v-1zm-3 1l3-3-3-3-.75.75L5.5 8l-2.25 2.25L4 11zm10-8v10c0 .55-.45 1-1 1H1c-.55 0-1-.45-1-1V3c0-.55.45-1 1-1h12c.55 0 1 .45 1 1zm-1 0H1v10h12V3z")
    }
    static get textSize() {
      return new Sh(18, 16, "M13.62 9.08L12.1 3.66h-.06l-1.5 5.42h3.08zM5.7 10.13S4.68 6.52 4.53 6.02h-.08l-1.13 4.11H5.7zM17.31 14h-2.25l-.95-3.25h-4.07L9.09 14H6.84l-.69-2.33H2.87L2.17 14H0l3.3-9.59h2.5l2.17 6.34L10.86 2h2.52l3.94 12h-.01z")
    }
    static get threeBars() {
      return new Sh(12, 16, "M11.41 9H.59C0 9 0 8.59 0 8c0-.59 0-1 .59-1H11.4c.59 0 .59.41.59 1 0 .59 0 1-.59 1h.01zm0-4H.59C0 5 0 4.59 0 4c0-.59 0-1 .59-1H11.4c.59 0 .59.41.59 1 0 .59 0 1-.59 1h.01zM.59 11H11.4c.59 0 .59.41.59 1 0 .59 0 1-.59 1H.59C0 13 0 12.59 0 12c0-.59 0-1 .59-1z")
    }
    static get thumbsdown() {
      return new Sh(16, 16, "M15.98 7.83l-.97-5.95C14.84.5 13.13 0 12 0H5.69c-.2 0-.38.05-.53.14L3.72 1H2C.94 1 0 1.94 0 3v4c0 1.06.94 2.02 2 2h2c.91 0 1.39.45 2.39 1.55.91 1 .88 1.8.63 3.27-.08.5.06 1 .42 1.42.39.47.98.76 1.56.76 1.83 0 3-3.71 3-5.01l-.02-.98h2.04c1.16 0 1.95-.8 1.98-1.97 0-.11-.02-.21-.02-.21zm-1.97 1.19h-1.99c-.7 0-1.03.28-1.03.97l.03 1.03c0 1.27-1.17 4-2 4-.5 0-1.08-.5-1-1 .25-1.58.34-2.78-.89-4.14C6.11 8.75 5.36 8 4 8V2l1.67-1H12c.73 0 1.95.31 2 1l.02.02 1 6c-.03.64-.38 1-1 1h-.01z")
    }
    static get thumbsup() {
      return new Sh(16, 16, "M15.98 8.17l-.97 5.95C14.84 15.5 13.13 16 12 16H5.69c-.2 0-.38-.05-.53-.14L3.72 15H2c-1.06 0-2-.94-2-2V9c0-1.06.94-2.02 2-2h2c.91 0 1.39-.45 2.39-1.55.91-1 .88-1.8.63-3.27-.08-.5.06-1 .42-1.42C7.83.29 8.42 0 9 0c1.83 0 3 3.71 3 5.01l-.02.98h2.04c1.16 0 1.95.8 1.98 1.97 0 .11-.02.21-.02.21zm-1.97-1.19h-1.99c-.7 0-1.03-.28-1.03-.97l.03-1.03c0-1.27-1.17-4-2-4-.5 0-1.08.5-1 1 .25 1.58.34 2.78-.89 4.14C6.11 7.25 5.36 8 4 8v6l1.67 1H12c.73 0 1.95-.31 2-1l.02-.02 1-6c-.03-.64-.38-1-1-1h-.01z")
    }
    static get tools() {
      return new Sh(16, 16, "M4.48 7.27c.26.26 1.28 1.33 1.28 1.33l.56-.58-.88-.91 1.69-1.8s-.76-.74-.43-.45c.32-1.19.03-2.51-.87-3.44C4.93.5 3.66.2 2.52.51l1.93 2-.51 1.96-1.89.52-1.93-2C-.19 4.17.1 5.48 1 6.4c.94.98 2.29 1.26 3.48.87zm6.44 1.94l-2.33 2.3 3.84 3.98c.31.33.73.49 1.14.49.41 0 .82-.16 1.14-.49.63-.65.63-1.7 0-2.35l-3.79-3.93zM16 2.53L13.55 0 6.33 7.46l.88.91-4.31 4.46-.99.53-1.39 2.27.35.37 2.2-1.44.51-1.02L7.9 9.08l.88.91L16 2.53z")
    }
    static get trashcan() {
      return new Sh(12, 16, "M11 2H9c0-.55-.45-1-1-1H5c-.55 0-1 .45-1 1H2c-.55 0-1 .45-1 1v1c0 .55.45 1 1 1v9c0 .55.45 1 1 1h7c.55 0 1-.45 1-1V5c.55 0 1-.45 1-1V3c0-.55-.45-1-1-1zm-1 12H3V5h1v8h1V5h1v8h1V5h1v8h1V5h1v9zm1-10H2V3h9v1z")
    }
    static get triangleDown() {
      return new Sh(12, 16, "M0 5l6 6 6-6H0z")
    }
    static get triangleLeft() {
      return new Sh(6, 16, "M6 2L0 8l6 6V2z")
    }
    static get triangleRight() {
      return new Sh(6, 16, "M0 14l6-6-6-6v12z")
    }
    static get triangleUp() {
      return new Sh(12, 16, "M12 11L6 5l-6 6h12z")
    }
    static get unfold() {
      return new Sh(14, 16, "M11.5 7.5L14 10c0 .55-.45 1-1 1H9v-1h3.5l-2-2h-7l-2 2H5v1H1c-.55 0-1-.45-1-1l2.5-2.5L0 5c0-.55.45-1 1-1h4v1H1.5l2 2h7l2-2H9V4h4c.55 0 1 .45 1 1l-2.5 2.5zM6 6h2V3h2L7 0 4 3h2v3zm2 3H6v3H4l3 3 3-3H8V9z")
    }
    static get unmute() {
      return new Sh(16, 16, "M12 8.02c0 1.09-.45 2.09-1.17 2.83l-.67-.67c.55-.56.89-1.31.89-2.16 0-.85-.34-1.61-.89-2.16l.67-.67A3.99 3.99 0 0 1 12 8.02zM7.72 2.28L4 6H2c-.55 0-1 .45-1 1v2c0 .55.45 1 1 1h2l3.72 3.72c.47.47 1.28.14 1.28-.53V2.81c0-.67-.81-1-1.28-.53zm5.94.08l-.67.67a6.996 6.996 0 0 1 2.06 4.98c0 1.94-.78 3.7-2.06 4.98l.67.67A7.973 7.973 0 0 0 16 8c0-2.22-.89-4.22-2.34-5.66v.02zm-1.41 1.41l-.69.67a5.05 5.05 0 0 1 1.48 3.58c0 1.39-.56 2.66-1.48 3.56l.69.67A5.971 5.971 0 0 0 14 8.02c0-1.65-.67-3.16-1.75-4.25z")
    }
    static get unverified() {
      return new Sh(16, 16, "M15.67 7.066l-1.08-1.34a1.5 1.5 0 0 1-.309-.77l-.19-1.698a1.51 1.51 0 0 0-1.329-1.33l-1.699-.19c-.3-.03-.56-.159-.78-.329L8.945.33a1.504 1.504 0 0 0-1.878 0l-1.34 1.08a1.5 1.5 0 0 1-.77.31l-1.698.19c-.7.08-1.25.63-1.33 1.329l-.19 1.699c-.03.3-.159.56-.329.78L.33 7.055a1.504 1.504 0 0 0 0 1.878l1.08 1.34c.17.22.28.48.31.77l.19 1.698c.08.7.63 1.25 1.329 1.33l1.699.19c.3.03.56.159.78.329l1.339 1.08c.55.439 1.329.439 1.878 0l1.34-1.08c.22-.17.48-.28.77-.31l1.698-.19c.7-.08 1.25-.63 1.33-1.329l.19-1.699c.03-.3.159-.56.329-.78l1.08-1.339a1.504 1.504 0 0 0 0-1.878zM9 11.5c0 .28-.22.5-.5.5h-1c-.27 0-.5-.22-.5-.5v-1c0-.28.23-.5.5-.5h1c.28 0 .5.22.5.5v1zm1.56-4.89c-.06.17-.17.33-.3.47-.13.16-.14.19-.33.38-.16.17-.31.3-.52.45-.11.09-.2.19-.28.27-.08.08-.14.17-.19.27-.05.1-.08.19-.11.3-.03.11-.03.13-.03.25H7.13c0-.22 0-.31.03-.48.03-.19.08-.36.14-.52.06-.14.14-.28.25-.42.11-.13.23-.25.41-.38.27-.19.36-.3.48-.52.12-.22.2-.38.2-.59 0-.27-.06-.45-.2-.58-.13-.13-.31-.19-.58-.19-.09 0-.19.02-.3.05-.11.03-.17.09-.25.16-.08.07-.14.11-.2.2a.41.41 0 0 0-.09.28h-2c0-.38.13-.56.27-.83.16-.27.36-.5.61-.67.25-.17.55-.3.88-.38.33-.08.7-.13 1.09-.13.44 0 .83.05 1.17.13.34.09.63.22.88.39.23.17.41.38.55.63.13.25.19.55.19.88 0 .22 0 .42-.08.59l-.02-.01z")
    }
    static get verified() {
      return new Sh(16, 16, "M15.67 7.066l-1.08-1.34a1.5 1.5 0 0 1-.309-.77l-.19-1.698a1.51 1.51 0 0 0-1.329-1.33l-1.699-.19c-.3-.03-.56-.159-.78-.329L8.945.33a1.504 1.504 0 0 0-1.878 0l-1.34 1.08a1.5 1.5 0 0 1-.77.31l-1.698.19c-.7.08-1.25.63-1.33 1.329l-.19 1.699c-.03.3-.159.56-.329.78L.33 7.055a1.504 1.504 0 0 0 0 1.878l1.08 1.34c.17.22.28.48.31.77l.19 1.698c.08.7.63 1.25 1.329 1.33l1.699.19c.3.03.56.159.78.329l1.339 1.08c.55.439 1.329.439 1.878 0l1.34-1.08c.22-.17.48-.28.77-.31l1.698-.19c.7-.08 1.25-.63 1.33-1.329l.19-1.699c.03-.3.159-.56.329-.78l1.08-1.339a1.504 1.504 0 0 0 0-1.878zM6.5 12.01L3 8.51l1.5-1.5 2 2 5-5L13 5.56l-6.5 6.45z")
    }
    static get versions() {
      return new Sh(14, 16, "M13 3H7c-.55 0-1 .45-1 1v8c0 .55.45 1 1 1h6c.55 0 1-.45 1-1V4c0-.55-.45-1-1-1zm-1 8H8V5h4v6zM4 4h1v1H4v6h1v1H4c-.55 0-1-.45-1-1V5c0-.55.45-1 1-1zM1 5h1v1H1v4h1v1H1c-.55 0-1-.45-1-1V6c0-.55.45-1 1-1z")
    }
    static get watch() {
      return new Sh(12, 16, "M6 8h2v1H5V5h1v3zm6 0c0 2.22-1.2 4.16-3 5.19V15c0 .55-.45 1-1 1H4c-.55 0-1-.45-1-1v-1.81C1.2 12.16 0 10.22 0 8s1.2-4.16 3-5.19V1c0-.55.45-1 1-1h4c.55 0 1 .45 1 1v1.81c1.8 1.03 3 2.97 3 5.19zm-1 0c0-2.77-2.23-5-5-5S1 5.23 1 8s2.23 5 5 5 5-2.23 5-5z")
    }
    static get x() {
      return new Sh(12, 16, "M7.48 8l3.75 3.75-1.48 1.48L6 9.48l-3.75 3.75-1.48-1.48L4.52 8 .77 4.25l1.48-1.48L6 6.52l3.75-3.75 1.48 1.48L7.48 8z")
    }
    static get zap() {
      return new Sh(10, 16, "M10 7H6l3-7-9 9h4l-3 7 9-9z")
    }
  }

  function Ch(e) {
    if (e instanceof Ai) return Sh.desktopDownload;
    if (e.missing) return Sh.alert;
    const t = e.gitHubRepository;
    return t ? t.isPrivate ? Sh.lock : t.fork ? Sh.repoForked : Sh.repo : Sh.deviceDesktop
  }

  function Eh(e) {
    switch (e.kind) {
      case Ki.New:
      case Ki.Untracked:
        return Sh.diffAdded;
      case Ki.Modified:
        return Sh.diffModified;
      case Ki.Deleted:
        return Sh.diffRemoved;
      case Ki.Renamed:
        return Sh.diffRenamed;
      case Ki.Conflicted:
        if (so(e)) {
          return e.conflictMarkerCount > 0 ? Sh.alert : Sh.check
        }
        return Sh.alert;
      case Ki.Copied:
        return Sh.diffAdded;
      default:
        return X(0, "Unknown file status " + e)
    }
  }
  class kh extends w.Component {
    constructor(e) {
      super(e), this.onTitlebarDoubleClickDarwin = () => {
        const e = r.remote.systemPreferences.getUserDefault("AppleActionOnDoubleClick", "string"),
          t = r.remote.getCurrentWindow();
        switch (e) {
          case "Maximize":
            t.isMaximized() ? t.unmaximize() : t.maximize();
            break;
          case "Minimize":
            t.minimize()
        }
      }, this.state = {
        style: void 0
      }
    }
    componentWillReceiveProps(e) {
      0
    }
    render() {
      const e = "full-screen" === this.props.windowState,
        t = "maximized" === this.props.windowState,
        n = e ? null : w.createElement(gh, null),
        r = t ? null : w.createElement("div", {
          className: "resize-handle top"
        }),
        i = t ? null : w.createElement("div", {
          className: "resize-handle left"
        }),
        o = "light" === this.props.titleBarStyle ? "light-title-bar" : "",
        s = this.props.showAppIcon ? w.createElement(bh, {
          className: "app-icon",
          symbol: Sh.markGithub
        }) : null;
      return w.createElement("div", {
        className: o,
        id: "desktop-app-title-bar",
        onDoubleClick: void 0,
        style: this.state.style
      }, r, i, s, this.props.children, n)
    }
  }
  class xh extends w.Component {
    constructor(e) {
      super(e), this.infoDisappearTimeoutId = null, this.transitionGroupDisappearTimeoutId = null, this.onInfoDisappearTimeout = () => {
        this.setState({
          renderInfo: !1
        })
      }, this.onTransitionGroupDisappearTimeout = () => {
        this.setState({
          renderTransitionGroup: !1
        })
      }, this.state = {
        windowZoomFactor: e.windowZoomFactor,
        renderTransitionGroup: !1,
        renderInfo: !1,
        transitionName: "zoom-in"
      }
    }
    componentWillReceiveProps(e) {
      const t = this.state.windowZoomFactor !== e.windowZoomFactor;
      if (!t) return;
      null !== this.infoDisappearTimeoutId && window.clearTimeout(this.infoDisappearTimeoutId), null !== this.transitionGroupDisappearTimeoutId && window.clearTimeout(this.transitionGroupDisappearTimeoutId), this.infoDisappearTimeoutId = window.setTimeout(this.onInfoDisappearTimeout, 750), this.transitionGroupDisappearTimeoutId = window.setTimeout(this.onTransitionGroupDisappearTimeout, 950);
      const n = e.windowZoomFactor > this.state.windowZoomFactor ? "zoom-in" : "zoom-out";
      this.setState({
        windowZoomFactor: e.windowZoomFactor,
        renderTransitionGroup: t,
        renderInfo: t,
        transitionName: n
      })
    }
    renderZoomInfo() {
      if (!this.state.renderInfo) return null;
      const e = (100 * this.state.windowZoomFactor).toFixed(0) + "%";
      return w.createElement(K, {
        classNames: this.state.transitionName,
        appear: !0,
        enter: !1,
        exit: !0,
        timeout: 100
      }, w.createElement("div", null, w.createElement("span", null, e)))
    }
    render() {
      return this.state.renderTransitionGroup ? w.createElement(O, {
        id: "window-zoom-info"
      }, this.renderZoomInfo()) : null
    }
  }
  const Th = {
    appear: 100,
    exit: 250
  };
  class Rh extends w.Component {
    constructor(e) {
      super(e), this.infoDisappearTimeoutId = null, this.transitionGroupDisappearTimeoutId = null, this.onInfoDisappearTimeout = () => {
        this.setState({
          renderInfo: !1
        })
      }, this.onTransitionGroupDisappearTimeout = () => {
        this.setState({
          renderTransitionGroup: !1
        })
      }, this.state = {
        renderInfo: !1,
        renderTransitionGroup: !1
      }
    }
    componentWillReceiveProps(e) {
      e.windowState !== this.props.windowState && (null !== this.infoDisappearTimeoutId && window.clearTimeout(this.infoDisappearTimeoutId), null !== this.transitionGroupDisappearTimeoutId && window.clearTimeout(this.transitionGroupDisappearTimeoutId), "full-screen" === e.windowState ? (this.infoDisappearTimeoutId = window.setTimeout(this.onInfoDisappearTimeout, 3e3), this.transitionGroupDisappearTimeoutId = window.setTimeout(this.onTransitionGroupDisappearTimeout, Th.appear + 3e3 + Th.exit), this.setState({
        renderTransitionGroup: !0,
        renderInfo: !0
      })) : (this.state.renderInfo || this.state.renderTransitionGroup) && this.setState({
        renderTransitionGroup: !1,
        renderInfo: !1
      }))
    }
    renderFullScreenNotification() {
      if (!this.state.renderInfo) return null;
      return w.createElement(K, {
        classNames: "toast-animation",
        appear: !0,
        enter: !1,
        exit: !0,
        timeout: Th
      }, w.createElement("div", {
        key: "notification",
        className: "toast-notification"
      }, "Press ", w.createElement("kbd", null, "F11"), " to exit fullscreen"))
    }
    render() {
      return this.state.renderTransitionGroup ? w.createElement(O, {
        className: "toast-notification-container"
      }, this.renderFullScreenNotification()) : null
    }
  }
  const Dh = ({
      text: e,
      highlight: t
    }) => w.createElement("span", null, e.split("").map((e, n) => [e, t.includes(n)]).concat([
      ["", !1]
    ]).reduce((e, [t, n], r, i) => {
      if (n === e.matched && r < i.length - 1) e.str += t;
      else {
        const i = e.matched ? "mark" : "span";
        e.result.push(w.createElement(i, {
          key: r
        }, e.str)), e.str = t, e.matched = n
      }
      return e
    }, {
      matched: !1,
      str: "",
      result: new Array
    }).result),
    _h = [".cmd", ".exe", ".bat", ".sh"];

  function Ah(e) {
    return -1 === _h.indexOf(e.toLowerCase())
  }
  class Mh extends w.Component {
    constructor() {
      super(...arguments), this.onContextMenu = e => {
        e.preventDefault();
        const t = this.props.repository,
          n = t instanceof Xi && t.missing,
          r = this.props.externalEditorLabel ? "用" + this.props.externalEditorLabel+"打开" : "在外部编辑器中打开";
        ie([{
          label: "用" + this.props.shellLabel+"打开",
          action: this.openInShell,
          enabled: !n
        }, {
          label: "在资源管理器中显示",
          action: this.showRepository,
          enabled: !n
        }, {
          label: r,
          action: this.openInExternalEditor,
          enabled: !n
        }, {
          type: "separator"
        }, {
          label: this.props.askForConfirmationOnRemoveRepository ? "删除…" : "删除",
          action: this.removeRepository
        }])
      }, this.removeRepository = () => {
        this.props.onRemoveRepository(this.props.repository)
      }, this.showRepository = () => {
        this.props.onShowRepository(this.props.repository)
      }, this.openInShell = () => {
        this.props.onOpenInShell(this.props.repository)
      }, this.openInExternalEditor = () => {
        this.props.onOpenInExternalEditor(this.props.repository)
      }
    }
    render() {
      const e = this.props.repository,
        t = e.path,
        n = e instanceof Xi ? e.gitHubRepository : null,
        r = this.props.changedFilesCount > 0,
        i = n ? n.fullName + "\n" + n.htmlURL + "\n" + t : t;
      let o = null;
      return this.props.needsDisambiguation && n && (o = n.owner.login + "/"), w.createElement("div", {
        onContextMenu: this.onContextMenu,
        className: "repository-list-item",
        title: i
      }, w.createElement(bh, {
        className: "icon-for-repository",
        symbol: Ch(e)
      }), w.createElement("div", {
        className: "name"
      }, o ? w.createElement("span", {
        className: "prefix"
      }, o) : null, w.createElement(Dh, {
        text: e.name,
        highlight: this.props.matches.title
      })), e instanceof Xi && Ph({
        aheadBehind: this.props.aheadBehind,
        hasChanges: r
      }))
    }
    shouldComponentUpdate(e) {
      return !(e.repository instanceof Xi && this.props.repository instanceof Xi) || (e.repository.id !== this.props.repository.id || e.matches !== this.props.matches)
    }
  }
  const Ph = e => w.createElement("div", {
      className: "repo-indicators"
    }, e.aheadBehind && Ih(e.aheadBehind), e.hasChanges && Oh()),
    Ih = e => {
      const {
        ahead: t,
        behind: n
      } = e;
      if (0 === t && 0 === n) return null;
      const r = "The currently checked out branch is" + (n ? ` ${Lh(n)} behind ` : "") + (n && t ? "and" : "") + (t ? ` ${Lh(t)} ahead of ` : "") + "its tracked branch.";
      return w.createElement("div", {
        className: "ahead-behind",
        title: r
      }, t > 0 && w.createElement(bh, {
        symbol: Sh.arrowSmallUp
      }), n > 0 && w.createElement(bh, {
        symbol: Sh.arrowSmallDown
      }))
    },
    Oh = () => w.createElement("div", {
      className: "change-indicator-wrapper",
      title: "此存储库中存在未提交的更改"
    }, w.createElement(bh, {
      symbol: Sh.primitiveDot
    })),
    Lh = e => `${e} commit${e>1?"s":""}`;
  var Nh;
  ! function (e) {
    e.Enterprise = "_Enterprise_", e.NonGitHub = "_Non-GitHub_"
  }(Nh || (Nh = {}));
  const Fh = {
    changedFilesCount: 0,
    aheadBehind: null
  };

  function Bh(e, t, n) {
    const r = new Map;
    for (const n of e) {
      const e = t.find(e => e.id === n);
      if (void 0 !== e) {
        const t = r.get(e.name) || 0;
        r.set(e.name, t + 1)
      }
    }
    const i = new Array;
    for (const o of e) {
      const e = t.find(e => e.id === o);
      if (void 0 === e) continue;
      const {
        aheadBehind: s,
        changedFilesCount: a
      } = n.get(o) || Fh, l = e instanceof Xi ? [e.name, to(e)] : [e.name], c = r.get(e.name) || 0;
      i.push({
        text: l,
        id: o.toString(),
        repository: e,
        needsDisambiguation: c > 1,
        aheadBehind: s,
        changedFilesCount: a
      })
    }
    return {
      identifier: "Recent",
      items: i
    }
  }
  var Hh = n(19),
    zh = n.n(Hh),
    Uh = n(55),
    Wh = n.n(Uh),
    Vh = n(23),
    jh = n.n(Vh),
    Gh = n(24),
    $h = n.n(Gh),
    qh = n(41),
    Kh = n.n(qh),
    Yh = n(56),
    Qh = n.n(Yh);

  function Zh(e) {
    var t;
    t = "undefined" != typeof window ? window : "undefined" != typeof self ? self : global;
    var n = "undefined" != typeof document && document.attachEvent;
    if (!n) {
      var r = function () {
          var e = t.requestAnimationFrame || t.mozRequestAnimationFrame || t.webkitRequestAnimationFrame || function (e) {
            return t.setTimeout(e, 20)
          };
          return function (t) {
            return e(t)
          }
        }(),
        i = function () {
          var e = t.cancelAnimationFrame || t.mozCancelAnimationFrame || t.webkitCancelAnimationFrame || t.clearTimeout;
          return function (t) {
            return e(t)
          }
        }(),
        o = function (e) {
          var t = e.__resizeTriggers__,
            n = t.firstElementChild,
            r = t.lastElementChild,
            i = n.firstElementChild;
          r.scrollLeft = r.scrollWidth, r.scrollTop = r.scrollHeight, i.style.width = n.offsetWidth + 1 + "px", i.style.height = n.offsetHeight + 1 + "px", n.scrollLeft = n.scrollWidth, n.scrollTop = n.scrollHeight
        },
        s = function (e) {
          if (!(e.target.className.indexOf("contract-trigger") < 0 && e.target.className.indexOf("expand-trigger") < 0)) {
            var t = this;
            o(this), this.__resizeRAF__ && i(this.__resizeRAF__), this.__resizeRAF__ = r((function () {
              (function (e) {
                return e.offsetWidth != e.__resizeLast__.width || e.offsetHeight != e.__resizeLast__.height
              })(t) && (t.__resizeLast__.width = t.offsetWidth, t.__resizeLast__.height = t.offsetHeight, t.__resizeListeners__.forEach((function (n) {
                n.call(t, e)
              })))
            }))
          }
        },
        a = !1,
        l = "",
        c = "animationstart",
        u = "Webkit Moz O ms".split(" "),
        h = "webkitAnimationStart animationstart oAnimationStart MSAnimationStart".split(" "),
        p = document.createElement("fakeelement");
      if (void 0 !== p.style.animationName && (a = !0), !1 === a)
        for (var d = 0; d < u.length; d++)
          if (void 0 !== p.style[u[d] + "AnimationName"]) {
            l = "-" + u[d].toLowerCase() + "-", c = h[d], a = !0;
            break
          } var f = "resizeanim",
        m = "@" + l + "keyframes " + f + " { from { opacity: 0; } to { opacity: 0; } } ",
        g = l + "animation: 1ms " + f + "; "
    }
    return {
      addResizeListener: function (r, i) {
        if (n) r.attachEvent("onresize", i);
        else {
          if (!r.__resizeTriggers__) {
            var a = r.ownerDocument,
              l = t.getComputedStyle(r);
            l && "static" == l.position && (r.style.position = "relative"),
              function (t) {
                if (!t.getElementById("detectElementResize")) {
                  var n = (m || "") + ".resize-triggers { " + (g || "") + 'visibility: hidden; opacity: 0; } .resize-triggers, .resize-triggers > div, .contract-trigger:before { content: " "; display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; z-index: -1; } .resize-triggers > div { background: #eee; overflow: auto; } .contract-trigger:before { width: 200%; height: 200%; }',
                    r = t.head || t.getElementsByTagName("head")[0],
                    i = t.createElement("style");
                  i.id = "detectElementResize", i.type = "text/css", null != e && i.setAttribute("nonce", e), i.styleSheet ? i.styleSheet.cssText = n : i.appendChild(t.createTextNode(n)), r.appendChild(i)
                }
              }(a), r.__resizeLast__ = {}, r.__resizeListeners__ = [], (r.__resizeTriggers__ = a.createElement("div")).className = "resize-triggers", r.__resizeTriggers__.innerHTML = '<div class="expand-trigger"><div></div></div><div class="contract-trigger"></div>', r.appendChild(r.__resizeTriggers__), o(r), r.addEventListener("scroll", s, !0), c && (r.__resizeTriggers__.__animationListener__ = function (e) {
                e.animationName == f && o(r)
              }, r.__resizeTriggers__.addEventListener(c, r.__resizeTriggers__.__animationListener__))
          }
          r.__resizeListeners__.push(i)
        }
      },
      removeResizeListener: function (e, t) {
        if (n) e.detachEvent("onresize", t);
        else if (e.__resizeListeners__.splice(e.__resizeListeners__.indexOf(t), 1), !e.__resizeListeners__.length) {
          e.removeEventListener("scroll", s, !0), e.__resizeTriggers__.__animationListener__ && (e.__resizeTriggers__.removeEventListener(c, e.__resizeTriggers__.__animationListener__), e.__resizeTriggers__.__animationListener__ = null);
          try {
            e.__resizeTriggers__ = !e.removeChild(e.__resizeTriggers__)
          } catch (e) {}
        }
      }
    }
  }
  n(77);
  var Xh = function (e) {
    function t() {
      var e, n, r, i;
      jh()(this, t);
      for (var o = arguments.length, s = Array(o), a = 0; a < o; a++) s[a] = arguments[a];
      return n = r = Kh()(this, (e = t.__proto__ || Wh()(t)).call.apply(e, [this].concat(s))), r.state = {
        height: r.props.defaultHeight || 0,
        width: r.props.defaultWidth || 0
      }, r._onResize = function () {
        var e = r.props,
          t = e.disableHeight,
          n = e.disableWidth,
          i = e.onResize;
        if (r._parentNode) {
          var o = r._parentNode.offsetHeight || 0,
            s = r._parentNode.offsetWidth || 0,
            a = window.getComputedStyle(r._parentNode) || {},
            l = parseInt(a.paddingLeft, 10) || 0,
            c = parseInt(a.paddingRight, 10) || 0,
            u = parseInt(a.paddingTop, 10) || 0,
            h = parseInt(a.paddingBottom, 10) || 0,
            p = o - u - h,
            d = s - l - c;
          (!t && r.state.height !== p || !n && r.state.width !== d) && (r.setState({
            height: o - u - h,
            width: s - l - c
          }), i({
            height: o,
            width: s
          }))
        }
      }, r._setRef = function (e) {
        r._autoSizer = e
      }, i = n, Kh()(r, i)
    }
    return Qh()(t, e), $h()(t, [{
      key: "componentDidMount",
      value: function () {
        var e = this.props.nonce;
        this._autoSizer && this._autoSizer.parentNode && this._autoSizer.parentNode.ownerDocument && this._autoSizer.parentNode.ownerDocument.defaultView && this._autoSizer.parentNode instanceof this._autoSizer.parentNode.ownerDocument.defaultView.HTMLElement && (this._parentNode = this._autoSizer.parentNode, this._detectElementResize = Zh(e), this._detectElementResize.addResizeListener(this._parentNode, this._onResize), this._onResize())
      }
    }, {
      key: "componentWillUnmount",
      value: function () {
        this._detectElementResize && this._parentNode && this._detectElementResize.removeResizeListener(this._parentNode, this._onResize)
      }
    }, {
      key: "render",
      value: function () {
        var e = this.props,
          t = e.children,
          n = e.className,
          r = e.disableHeight,
          i = e.disableWidth,
          o = e.style,
          s = this.state,
          a = s.height,
          l = s.width,
          c = {
            overflow: "visible"
          },
          u = {};
        return r || (c.height = 0, u.height = a), i || (c.width = 0, u.width = l), w.createElement("div", {
          className: n,
          ref: this._setRef,
          style: zh()({}, c, o)
        }, t(u))
      }
    }]), t
  }(w.PureComponent);
  Xh.defaultProps = {
    onResize: function () {},
    disableHeight: !1,
    disableWidth: !1,
    style: {}
  }, Xh.propTypes = null;
  var Jh = Xh,
    ep = n(54),
    tp = n.n(ep);

  function np(e) {
    var t = e.cellCount,
      n = e.cellSize,
      r = e.computeMetadataCallback,
      i = e.computeMetadataCallbackProps,
      o = e.nextCellsCount,
      s = e.nextCellSize,
      a = e.nextScrollToIndex,
      l = e.scrollToIndex,
      c = e.updateScrollOffsetForScrollToIndex;
    t === o && ("number" != typeof n && "number" != typeof s || n === s) || (r(i), l >= 0 && l === a && c())
  }
  var rp = n(132),
    ip = n.n(rp),
    op = function () {
      function e(t) {
        var n = t.cellCount,
          r = t.cellSizeGetter,
          i = t.estimatedCellSize;
        jh()(this, e), this._cellSizeAndPositionData = {}, this._lastMeasuredIndex = -1, this._lastBatchedIndex = -1, this._cellSizeGetter = r, this._cellCount = n, this._estimatedCellSize = i
      }
      return $h()(e, [{
        key: "areOffsetsAdjusted",
        value: function () {
          return !1
        }
      }, {
        key: "configure",
        value: function (e) {
          var t = e.cellCount,
            n = e.estimatedCellSize,
            r = e.cellSizeGetter;
          this._cellCount = t, this._estimatedCellSize = n, this._cellSizeGetter = r
        }
      }, {
        key: "getCellCount",
        value: function () {
          return this._cellCount
        }
      }, {
        key: "getEstimatedCellSize",
        value: function () {
          return this._estimatedCellSize
        }
      }, {
        key: "getLastMeasuredIndex",
        value: function () {
          return this._lastMeasuredIndex
        }
      }, {
        key: "getOffsetAdjustment",
        value: function () {
          return 0
        }
      }, {
        key: "getSizeAndPositionOfCell",
        value: function (e) {
          if (e < 0 || e >= this._cellCount) throw Error("Requested index " + e + " is outside of range 0.." + this._cellCount);
          if (e > this._lastMeasuredIndex)
            for (var t = this.getSizeAndPositionOfLastMeasuredCell(), n = t.offset + t.size, r = this._lastMeasuredIndex + 1; r <= e; r++) {
              var i = this._cellSizeGetter({
                index: r
              });
              if (void 0 === i || isNaN(i)) throw Error("Invalid size returned for cell " + r + " of value " + i);
              null === i ? (this._cellSizeAndPositionData[r] = {
                offset: n,
                size: 0
              }, this._lastBatchedIndex = e) : (this._cellSizeAndPositionData[r] = {
                offset: n,
                size: i
              }, n += i, this._lastMeasuredIndex = e)
            }
          return this._cellSizeAndPositionData[e]
        }
      }, {
        key: "getSizeAndPositionOfLastMeasuredCell",
        value: function () {
          return this._lastMeasuredIndex >= 0 ? this._cellSizeAndPositionData[this._lastMeasuredIndex] : {
            offset: 0,
            size: 0
          }
        }
      }, {
        key: "getTotalSize",
        value: function () {
          var e = this.getSizeAndPositionOfLastMeasuredCell();
          return e.offset + e.size + (this._cellCount - this._lastMeasuredIndex - 1) * this._estimatedCellSize
        }
      }, {
        key: "getUpdatedOffsetForIndex",
        value: function (e) {
          var t = e.align,
            n = void 0 === t ? "auto" : t,
            r = e.containerSize,
            i = e.currentOffset,
            o = e.targetIndex;
          if (r <= 0) return 0;
          var s = this.getSizeAndPositionOfCell(o),
            a = s.offset,
            l = a - r + s.size,
            c = void 0;
          switch (n) {
            case "start":
              c = a;
              break;
            case "end":
              c = l;
              break;
            case "center":
              c = a - (r - s.size) / 2;
              break;
            default:
              c = Math.max(l, Math.min(a, i))
          }
          var u = this.getTotalSize();
          return Math.max(0, Math.min(u - r, c))
        }
      }, {
        key: "getVisibleCellRange",
        value: function (e) {
          var t = e.containerSize,
            n = e.offset;
          if (0 === this.getTotalSize()) return {};
          var r = n + t,
            i = this._findNearestCell(n),
            o = this.getSizeAndPositionOfCell(i);
          n = o.offset + o.size;
          for (var s = i; n < r && s < this._cellCount - 1;) s++, n += this.getSizeAndPositionOfCell(s).size;
          return {
            start: i,
            stop: s
          }
        }
      }, {
        key: "resetCell",
        value: function (e) {
          this._lastMeasuredIndex = Math.min(this._lastMeasuredIndex, e - 1)
        }
      }, {
        key: "_binarySearch",
        value: function (e, t, n) {
          for (; t <= e;) {
            var r = t + Math.floor((e - t) / 2),
              i = this.getSizeAndPositionOfCell(r).offset;
            if (i === n) return r;
            i < n ? t = r + 1 : i > n && (e = r - 1)
          }
          return t > 0 ? t - 1 : 0
        }
      }, {
        key: "_exponentialSearch",
        value: function (e, t) {
          for (var n = 1; e < this._cellCount && this.getSizeAndPositionOfCell(e).offset < t;) e += n, n *= 2;
          return this._binarySearch(Math.min(e, this._cellCount - 1), Math.floor(e / 2), t)
        }
      }, {
        key: "_findNearestCell",
        value: function (e) {
          if (isNaN(e)) throw Error("Invalid offset " + e + " specified");
          e = Math.max(0, e);
          var t = this.getSizeAndPositionOfLastMeasuredCell(),
            n = Math.max(0, this._lastMeasuredIndex);
          return t.offset >= e ? this._binarySearch(n, 0, e) : this._exponentialSearch(n, e)
        }
      }]), e
    }(),
    sp = function () {
      return "undefined" != typeof window && window.chrome && window.chrome.webstore ? 16777100 : 15e5
    },
    ap = function () {
      function e(t) {
        var n = t.maxScrollSize,
          r = void 0 === n ? sp() : n,
          i = ip()(t, ["maxScrollSize"]);
        jh()(this, e), this._cellSizeAndPositionManager = new op(i), this._maxScrollSize = r
      }
      return $h()(e, [{
        key: "areOffsetsAdjusted",
        value: function () {
          return this._cellSizeAndPositionManager.getTotalSize() > this._maxScrollSize
        }
      }, {
        key: "configure",
        value: function (e) {
          this._cellSizeAndPositionManager.configure(e)
        }
      }, {
        key: "getCellCount",
        value: function () {
          return this._cellSizeAndPositionManager.getCellCount()
        }
      }, {
        key: "getEstimatedCellSize",
        value: function () {
          return this._cellSizeAndPositionManager.getEstimatedCellSize()
        }
      }, {
        key: "getLastMeasuredIndex",
        value: function () {
          return this._cellSizeAndPositionManager.getLastMeasuredIndex()
        }
      }, {
        key: "getOffsetAdjustment",
        value: function (e) {
          var t = e.containerSize,
            n = e.offset,
            r = this._cellSizeAndPositionManager.getTotalSize(),
            i = this.getTotalSize(),
            o = this._getOffsetPercentage({
              containerSize: t,
              offset: n,
              totalSize: i
            });
          return Math.round(o * (i - r))
        }
      }, {
        key: "getSizeAndPositionOfCell",
        value: function (e) {
          return this._cellSizeAndPositionManager.getSizeAndPositionOfCell(e)
        }
      }, {
        key: "getSizeAndPositionOfLastMeasuredCell",
        value: function () {
          return this._cellSizeAndPositionManager.getSizeAndPositionOfLastMeasuredCell()
        }
      }, {
        key: "getTotalSize",
        value: function () {
          return Math.min(this._maxScrollSize, this._cellSizeAndPositionManager.getTotalSize())
        }
      }, {
        key: "getUpdatedOffsetForIndex",
        value: function (e) {
          var t = e.align,
            n = void 0 === t ? "auto" : t,
            r = e.containerSize,
            i = e.currentOffset,
            o = e.targetIndex;
          i = this._safeOffsetToOffset({
            containerSize: r,
            offset: i
          });
          var s = this._cellSizeAndPositionManager.getUpdatedOffsetForIndex({
            align: n,
            containerSize: r,
            currentOffset: i,
            targetIndex: o
          });
          return this._offsetToSafeOffset({
            containerSize: r,
            offset: s
          })
        }
      }, {
        key: "getVisibleCellRange",
        value: function (e) {
          var t = e.containerSize,
            n = e.offset;
          return n = this._safeOffsetToOffset({
            containerSize: t,
            offset: n
          }), this._cellSizeAndPositionManager.getVisibleCellRange({
            containerSize: t,
            offset: n
          })
        }
      }, {
        key: "resetCell",
        value: function (e) {
          this._cellSizeAndPositionManager.resetCell(e)
        }
      }, {
        key: "_getOffsetPercentage",
        value: function (e) {
          var t = e.containerSize,
            n = e.offset,
            r = e.totalSize;
          return r <= t ? 0 : n / (r - t)
        }
      }, {
        key: "_offsetToSafeOffset",
        value: function (e) {
          var t = e.containerSize,
            n = e.offset,
            r = this._cellSizeAndPositionManager.getTotalSize(),
            i = this.getTotalSize();
          if (r === i) return n;
          var o = this._getOffsetPercentage({
            containerSize: t,
            offset: n,
            totalSize: r
          });
          return Math.round(o * (i - t))
        }
      }, {
        key: "_safeOffsetToOffset",
        value: function (e) {
          var t = e.containerSize,
            n = e.offset,
            r = this._cellSizeAndPositionManager.getTotalSize(),
            i = this.getTotalSize();
          if (r === i) return n;
          var o = this._getOffsetPercentage({
            containerSize: t,
            offset: n,
            totalSize: i
          });
          return Math.round(o * (r - t))
        }
      }]), e
    }(),
    lp = n(83),
    cp = n.n(lp);

  function up() {
    var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],
      t = {};
    return function (n) {
      var r = n.callback,
        i = n.indices,
        o = cp()(i),
        s = !e || o.every((function (e) {
          var t = i[e];
          return Array.isArray(t) ? t.length > 0 : t >= 0
        })),
        a = o.length !== cp()(t).length || o.some((function (e) {
          var n = t[e],
            r = i[e];
          return Array.isArray(r) ? n.join(",") !== r.join(",") : n !== r
        }));
      t = i, s && a && r(i)
    }
  }

  function hp(e) {
    var t = e.cellSize,
      n = e.cellSizeAndPositionManager,
      r = e.previousCellsCount,
      i = e.previousCellSize,
      o = e.previousScrollToAlignment,
      s = e.previousScrollToIndex,
      a = e.previousSize,
      l = e.scrollOffset,
      c = e.scrollToAlignment,
      u = e.scrollToIndex,
      h = e.size,
      p = e.sizeJustIncreasedFromZero,
      d = e.updateScrollIndexCallback,
      f = n.getCellCount(),
      m = u >= 0 && u < f;
    m && (h !== a || p || !i || "number" == typeof t && t !== i || c !== o || u !== s) ? d(u) : !m && f > 0 && (h < a || f < r) && l > n.getTotalSize() - h && d(f - 1)
  }
  var pp = n(131),
    dp = n.n(pp);

  function fp() {
    var e = this.constructor.getDerivedStateFromProps(this.props, this.state);
    null != e && this.setState(e)
  }

  function mp(e) {
    this.setState(function (t) {
      var n = this.constructor.getDerivedStateFromProps(e, t);
      return null != n ? n : null
    }.bind(this))
  }

  function gp(e, t) {
    try {
      var n = this.props,
        r = this.state;
      this.props = e, this.state = t, this.__reactInternalSnapshotFlag = !0, this.__reactInternalSnapshot = this.getSnapshotBeforeUpdate(n, r)
    } finally {
      this.props = n, this.state = r
    }
  }
  fp.__suppressDeprecationWarning = !0, mp.__suppressDeprecationWarning = !0, gp.__suppressDeprecationWarning = !0;
  var yp = void 0,
    vp = (yp = "undefined" != typeof window ? window : "undefined" != typeof self ? self : {}).requestAnimationFrame || yp.webkitRequestAnimationFrame || yp.mozRequestAnimationFrame || yp.oRequestAnimationFrame || yp.msRequestAnimationFrame || function (e) {
      return yp.setTimeout(e, 1e3 / 60)
    },
    wp = yp.cancelAnimationFrame || yp.webkitCancelAnimationFrame || yp.mozCancelAnimationFrame || yp.oCancelAnimationFrame || yp.msCancelAnimationFrame || function (e) {
      yp.clearTimeout(e)
    },
    bp = vp,
    Sp = wp,
    Cp = function (e) {
      return Sp(e.id)
    },
    Ep = "observed",
    kp = "requested",
    xp = function (e) {
      function t(e) {
        jh()(this, t);
        var n = Kh()(this, (t.__proto__ || Wh()(t)).call(this, e));
        n._onGridRenderedMemoizer = up(), n._onScrollMemoizer = up(!1), n._deferredInvalidateColumnIndex = null, n._deferredInvalidateRowIndex = null, n._recomputeScrollLeftFlag = !1, n._recomputeScrollTopFlag = !1, n._horizontalScrollBarSize = 0, n._verticalScrollBarSize = 0, n._scrollbarPresenceChanged = !1, n._renderedColumnStartIndex = 0, n._renderedColumnStopIndex = 0, n._renderedRowStartIndex = 0, n._renderedRowStopIndex = 0, n._styleCache = {}, n._cellCache = {}, n._debounceScrollEndedCallback = function () {
          n._disablePointerEventsTimeoutId = null, n.setState({
            isScrolling: !1,
            needToResetStyleCache: !1
          })
        }, n._invokeOnGridRenderedHelper = function () {
          var e = n.props.onSectionRendered;
          n._onGridRenderedMemoizer({
            callback: e,
            indices: {
              columnOverscanStartIndex: n._columnStartIndex,
              columnOverscanStopIndex: n._columnStopIndex,
              columnStartIndex: n._renderedColumnStartIndex,
              columnStopIndex: n._renderedColumnStopIndex,
              rowOverscanStartIndex: n._rowStartIndex,
              rowOverscanStopIndex: n._rowStopIndex,
              rowStartIndex: n._renderedRowStartIndex,
              rowStopIndex: n._renderedRowStopIndex
            }
          })
        }, n._setScrollingContainerRef = function (e) {
          n._scrollingContainer = e
        }, n._onScroll = function (e) {
          e.target === n._scrollingContainer && n.handleScrollEvent(e.target)
        };
        var r = new ap({
            cellCount: e.columnCount,
            cellSizeGetter: function (n) {
              return t._wrapSizeGetter(e.columnWidth)(n)
            },
            estimatedCellSize: t._getEstimatedColumnSize(e)
          }),
          i = new ap({
            cellCount: e.rowCount,
            cellSizeGetter: function (n) {
              return t._wrapSizeGetter(e.rowHeight)(n)
            },
            estimatedCellSize: t._getEstimatedRowSize(e)
          });
        return n.state = {
          instanceProps: {
            columnSizeAndPositionManager: r,
            rowSizeAndPositionManager: i,
            prevColumnWidth: e.columnWidth,
            prevRowHeight: e.rowHeight,
            prevColumnCount: e.columnCount,
            prevRowCount: e.rowCount,
            prevIsScrolling: !0 === e.isScrolling,
            prevScrollToColumn: e.scrollToColumn,
            prevScrollToRow: e.scrollToRow,
            scrollbarSize: 0,
            scrollbarSizeMeasured: !1
          },
          isScrolling: !1,
          scrollDirectionHorizontal: 1,
          scrollDirectionVertical: 1,
          scrollLeft: 0,
          scrollTop: 0,
          scrollPositionChangeReason: null,
          needToResetStyleCache: !1
        }, e.scrollToRow > 0 && (n._initialScrollTop = n._getCalculatedScrollTop(e, n.state)), e.scrollToColumn > 0 && (n._initialScrollLeft = n._getCalculatedScrollLeft(e, n.state)), n
      }
      return Qh()(t, e), $h()(t, [{
        key: "getOffsetForCell",
        value: function () {
          var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
            t = e.alignment,
            n = void 0 === t ? this.props.scrollToAlignment : t,
            r = e.columnIndex,
            i = void 0 === r ? this.props.scrollToColumn : r,
            o = e.rowIndex,
            s = void 0 === o ? this.props.scrollToRow : o,
            a = zh()({}, this.props, {
              scrollToAlignment: n,
              scrollToColumn: i,
              scrollToRow: s
            });
          return {
            scrollLeft: this._getCalculatedScrollLeft(a),
            scrollTop: this._getCalculatedScrollTop(a)
          }
        }
      }, {
        key: "getTotalRowsHeight",
        value: function () {
          return this.state.instanceProps.rowSizeAndPositionManager.getTotalSize()
        }
      }, {
        key: "getTotalColumnsWidth",
        value: function () {
          return this.state.instanceProps.columnSizeAndPositionManager.getTotalSize()
        }
      }, {
        key: "handleScrollEvent",
        value: function (e) {
          var t = e.scrollLeft,
            n = void 0 === t ? 0 : t,
            r = e.scrollTop,
            i = void 0 === r ? 0 : r;
          if (!(i < 0)) {
            this._debounceScrollEnded();
            var o = this.props,
              s = o.autoHeight,
              a = o.autoWidth,
              l = o.height,
              c = o.width,
              u = this.state.instanceProps,
              h = u.scrollbarSize,
              p = u.rowSizeAndPositionManager.getTotalSize(),
              d = u.columnSizeAndPositionManager.getTotalSize(),
              f = Math.min(Math.max(0, d - c + h), n),
              m = Math.min(Math.max(0, p - l + h), i);
            if (this.state.scrollLeft !== f || this.state.scrollTop !== m) {
              var g = {
                isScrolling: !0,
                scrollDirectionHorizontal: f !== this.state.scrollLeft ? f > this.state.scrollLeft ? 1 : -1 : this.state.scrollDirectionHorizontal,
                scrollDirectionVertical: m !== this.state.scrollTop ? m > this.state.scrollTop ? 1 : -1 : this.state.scrollDirectionVertical,
                scrollPositionChangeReason: Ep
              };
              s || (g.scrollTop = m), a || (g.scrollLeft = f), g.needToResetStyleCache = !1, this.setState(g)
            }
            this._invokeOnScrollMemoizer({
              scrollLeft: f,
              scrollTop: m,
              totalColumnsWidth: d,
              totalRowsHeight: p
            })
          }
        }
      }, {
        key: "invalidateCellSizeAfterRender",
        value: function (e) {
          var t = e.columnIndex,
            n = e.rowIndex;
          this._deferredInvalidateColumnIndex = "number" == typeof this._deferredInvalidateColumnIndex ? Math.min(this._deferredInvalidateColumnIndex, t) : t, this._deferredInvalidateRowIndex = "number" == typeof this._deferredInvalidateRowIndex ? Math.min(this._deferredInvalidateRowIndex, n) : n
        }
      }, {
        key: "measureAllCells",
        value: function () {
          var e = this.props,
            t = e.columnCount,
            n = e.rowCount,
            r = this.state.instanceProps;
          r.columnSizeAndPositionManager.getSizeAndPositionOfCell(t - 1), r.rowSizeAndPositionManager.getSizeAndPositionOfCell(n - 1)
        }
      }, {
        key: "recomputeGridSize",
        value: function () {
          var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
            t = e.columnIndex,
            n = void 0 === t ? 0 : t,
            r = e.rowIndex,
            i = void 0 === r ? 0 : r,
            o = this.props,
            s = o.scrollToColumn,
            a = o.scrollToRow,
            l = this.state.instanceProps;
          l.columnSizeAndPositionManager.resetCell(n), l.rowSizeAndPositionManager.resetCell(i), this._recomputeScrollLeftFlag = s >= 0 && n <= s, this._recomputeScrollTopFlag = a >= 0 && i <= a, this._styleCache = {}, this._cellCache = {}, this.forceUpdate()
        }
      }, {
        key: "scrollToCell",
        value: function (e) {
          var t = e.columnIndex,
            n = e.rowIndex,
            r = this.props.columnCount,
            i = this.props;
          r > 1 && void 0 !== t && this._updateScrollLeftForScrollToColumn(zh()({}, i, {
            scrollToColumn: t
          })), void 0 !== n && this._updateScrollTopForScrollToRow(zh()({}, i, {
            scrollToRow: n
          }))
        }
      }, {
        key: "componentDidMount",
        value: function () {
          var e = this.props,
            n = e.getScrollbarSize,
            r = e.height,
            i = e.scrollLeft,
            o = e.scrollToColumn,
            s = e.scrollTop,
            a = e.scrollToRow,
            l = e.width,
            c = this.state.instanceProps;
          if (this._initialScrollTop = 0, this._initialScrollLeft = 0, this._handleInvalidatedGridSize(), c.scrollbarSizeMeasured || this.setState((function (e) {
              var t = zh()({}, e, {
                needToResetStyleCache: !1
              });
              return t.instanceProps.scrollbarSize = n(), t.instanceProps.scrollbarSizeMeasured = !0, t
            })), "number" == typeof i && i >= 0 || "number" == typeof s && s >= 0) {
            var u = t._getScrollToPositionStateUpdate({
              prevState: this.state,
              scrollLeft: i,
              scrollTop: s
            });
            u && (u.needToResetStyleCache = !1, this.setState(u))
          }
          this._scrollingContainer && (this._scrollingContainer.scrollLeft !== this.state.scrollLeft && (this._scrollingContainer.scrollLeft = this.state.scrollLeft), this._scrollingContainer.scrollTop !== this.state.scrollTop && (this._scrollingContainer.scrollTop = this.state.scrollTop));
          var h = r > 0 && l > 0;
          o >= 0 && h && this._updateScrollLeftForScrollToColumn(), a >= 0 && h && this._updateScrollTopForScrollToRow(), this._invokeOnGridRenderedHelper(), this._invokeOnScrollMemoizer({
            scrollLeft: i || 0,
            scrollTop: s || 0,
            totalColumnsWidth: c.columnSizeAndPositionManager.getTotalSize(),
            totalRowsHeight: c.rowSizeAndPositionManager.getTotalSize()
          }), this._maybeCallOnScrollbarPresenceChange()
        }
      }, {
        key: "componentDidUpdate",
        value: function (e, t) {
          var n = this,
            r = this.props,
            i = r.autoHeight,
            o = r.autoWidth,
            s = r.columnCount,
            a = r.height,
            l = r.rowCount,
            c = r.scrollToAlignment,
            u = r.scrollToColumn,
            h = r.scrollToRow,
            p = r.width,
            d = this.state,
            f = d.scrollLeft,
            m = d.scrollPositionChangeReason,
            g = d.scrollTop,
            y = d.instanceProps;
          this._handleInvalidatedGridSize();
          var v = s > 0 && 0 === e.columnCount || l > 0 && 0 === e.rowCount;
          m === kp && (!o && f >= 0 && (f !== this._scrollingContainer.scrollLeft || v) && (this._scrollingContainer.scrollLeft = f), !i && g >= 0 && (g !== this._scrollingContainer.scrollTop || v) && (this._scrollingContainer.scrollTop = g));
          var w = (0 === e.width || 0 === e.height) && a > 0 && p > 0;
          if (this._recomputeScrollLeftFlag ? (this._recomputeScrollLeftFlag = !1, this._updateScrollLeftForScrollToColumn(this.props)) : hp({
              cellSizeAndPositionManager: y.columnSizeAndPositionManager,
              previousCellsCount: e.columnCount,
              previousCellSize: e.columnWidth,
              previousScrollToAlignment: e.scrollToAlignment,
              previousScrollToIndex: e.scrollToColumn,
              previousSize: e.width,
              scrollOffset: f,
              scrollToAlignment: c,
              scrollToIndex: u,
              size: p,
              sizeJustIncreasedFromZero: w,
              updateScrollIndexCallback: function () {
                return n._updateScrollLeftForScrollToColumn(n.props)
              }
            }), this._recomputeScrollTopFlag ? (this._recomputeScrollTopFlag = !1, this._updateScrollTopForScrollToRow(this.props)) : hp({
              cellSizeAndPositionManager: y.rowSizeAndPositionManager,
              previousCellsCount: e.rowCount,
              previousCellSize: e.rowHeight,
              previousScrollToAlignment: e.scrollToAlignment,
              previousScrollToIndex: e.scrollToRow,
              previousSize: e.height,
              scrollOffset: g,
              scrollToAlignment: c,
              scrollToIndex: h,
              size: a,
              sizeJustIncreasedFromZero: w,
              updateScrollIndexCallback: function () {
                return n._updateScrollTopForScrollToRow(n.props)
              }
            }), this._invokeOnGridRenderedHelper(), f !== t.scrollLeft || g !== t.scrollTop) {
            var b = y.rowSizeAndPositionManager.getTotalSize(),
              S = y.columnSizeAndPositionManager.getTotalSize();
            this._invokeOnScrollMemoizer({
              scrollLeft: f,
              scrollTop: g,
              totalColumnsWidth: S,
              totalRowsHeight: b
            })
          }
          this._maybeCallOnScrollbarPresenceChange()
        }
      }, {
        key: "componentWillUnmount",
        value: function () {
          this._disablePointerEventsTimeoutId && Cp(this._disablePointerEventsTimeoutId)
        }
      }, {
        key: "render",
        value: function () {
          var e = this.props,
            t = e.autoContainerWidth,
            n = e.autoHeight,
            r = e.autoWidth,
            i = e.className,
            o = e.containerProps,
            s = e.containerRole,
            a = e.containerStyle,
            l = e.height,
            c = e.id,
            u = e.noContentRenderer,
            h = e.role,
            p = e.style,
            d = e.tabIndex,
            f = e.width,
            m = this.state,
            g = m.instanceProps,
            y = m.needToResetStyleCache,
            v = this._isScrolling(),
            b = {
              boxSizing: "border-box",
              direction: "ltr",
              height: n ? "auto" : l,
              position: "relative",
              width: r ? "auto" : f,
              WebkitOverflowScrolling: "touch",
              willChange: "transform"
            };
          y && (this._styleCache = {}), this.state.isScrolling || this._resetStyleCache(), this._calculateChildrenToRender(this.props, this.state);
          var S = g.columnSizeAndPositionManager.getTotalSize(),
            C = g.rowSizeAndPositionManager.getTotalSize(),
            E = C > l ? g.scrollbarSize : 0,
            k = S > f ? g.scrollbarSize : 0;
          k === this._horizontalScrollBarSize && E === this._verticalScrollBarSize || (this._horizontalScrollBarSize = k, this._verticalScrollBarSize = E, this._scrollbarPresenceChanged = !0), b.overflowX = S + E <= f ? "hidden" : "auto", b.overflowY = C + k <= l ? "hidden" : "auto";
          var x = this._childrenToDisplay,
            T = 0 === x.length && l > 0 && f > 0;
          return w.createElement("div", zh()({
            ref: this._setScrollingContainerRef
          }, o, {
            "aria-label": this.props["aria-label"],
            "aria-readonly": this.props["aria-readonly"],
            className: mh()("ReactVirtualized__Grid", i),
            id: c,
            onScroll: this._onScroll,
            role: h,
            style: zh()({}, b, p),
            tabIndex: d
          }), x.length > 0 && w.createElement("div", {
            className: "ReactVirtualized__Grid__innerScrollContainer",
            role: s,
            style: zh()({
              width: t ? "auto" : S,
              height: C,
              maxWidth: S,
              maxHeight: C,
              overflow: "hidden",
              pointerEvents: v ? "none" : "",
              position: "relative"
            }, a)
          }, x), T && u())
        }
      }, {
        key: "_calculateChildrenToRender",
        value: function () {
          var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.props,
            t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.state,
            n = e.cellRenderer,
            r = e.cellRangeRenderer,
            i = e.columnCount,
            o = e.deferredMeasurementCache,
            s = e.height,
            a = e.overscanColumnCount,
            l = e.overscanIndicesGetter,
            c = e.overscanRowCount,
            u = e.rowCount,
            h = e.width,
            p = e.isScrollingOptOut,
            d = t.scrollDirectionHorizontal,
            f = t.scrollDirectionVertical,
            m = t.instanceProps,
            g = this._initialScrollTop > 0 ? this._initialScrollTop : t.scrollTop,
            y = this._initialScrollLeft > 0 ? this._initialScrollLeft : t.scrollLeft,
            v = this._isScrolling(e, t);
          if (this._childrenToDisplay = [], s > 0 && h > 0) {
            var w = m.columnSizeAndPositionManager.getVisibleCellRange({
                containerSize: h,
                offset: y
              }),
              b = m.rowSizeAndPositionManager.getVisibleCellRange({
                containerSize: s,
                offset: g
              }),
              S = m.columnSizeAndPositionManager.getOffsetAdjustment({
                containerSize: h,
                offset: y
              }),
              C = m.rowSizeAndPositionManager.getOffsetAdjustment({
                containerSize: s,
                offset: g
              });
            this._renderedColumnStartIndex = w.start, this._renderedColumnStopIndex = w.stop, this._renderedRowStartIndex = b.start, this._renderedRowStopIndex = b.stop;
            var E = l({
                direction: "horizontal",
                cellCount: i,
                overscanCellsCount: a,
                scrollDirection: d,
                startIndex: "number" == typeof w.start ? w.start : 0,
                stopIndex: "number" == typeof w.stop ? w.stop : -1
              }),
              k = l({
                direction: "vertical",
                cellCount: u,
                overscanCellsCount: c,
                scrollDirection: f,
                startIndex: "number" == typeof b.start ? b.start : 0,
                stopIndex: "number" == typeof b.stop ? b.stop : -1
              }),
              x = E.overscanStartIndex,
              T = E.overscanStopIndex,
              R = k.overscanStartIndex,
              D = k.overscanStopIndex;
            if (o) {
              if (!o.hasFixedHeight())
                for (var _ = R; _ <= D; _++)
                  if (!o.has(_, 0)) {
                    x = 0, T = i - 1;
                    break
                  } if (!o.hasFixedWidth())
                for (var A = x; A <= T; A++)
                  if (!o.has(0, A)) {
                    R = 0, D = u - 1;
                    break
                  }
            }
            this._childrenToDisplay = r({
              cellCache: this._cellCache,
              cellRenderer: n,
              columnSizeAndPositionManager: m.columnSizeAndPositionManager,
              columnStartIndex: x,
              columnStopIndex: T,
              deferredMeasurementCache: o,
              horizontalOffsetAdjustment: S,
              isScrolling: v,
              isScrollingOptOut: p,
              parent: this,
              rowSizeAndPositionManager: m.rowSizeAndPositionManager,
              rowStartIndex: R,
              rowStopIndex: D,
              scrollLeft: y,
              scrollTop: g,
              styleCache: this._styleCache,
              verticalOffsetAdjustment: C,
              visibleColumnIndices: w,
              visibleRowIndices: b
            }), this._columnStartIndex = x, this._columnStopIndex = T, this._rowStartIndex = R, this._rowStopIndex = D
          }
        }
      }, {
        key: "_debounceScrollEnded",
        value: function () {
          var e, t, n, r, i = this.props.scrollingResetTimeInterval;
          this._disablePointerEventsTimeoutId && Cp(this._disablePointerEventsTimeoutId), this._disablePointerEventsTimeoutId = (e = this._debounceScrollEndedCallback, t = i, n = Date.now(), r = {
            id: bp((function i() {
              Date.now() - n >= t ? e.call() : r.id = bp(i)
            }))
          })
        }
      }, {
        key: "_handleInvalidatedGridSize",
        value: function () {
          if ("number" == typeof this._deferredInvalidateColumnIndex && "number" == typeof this._deferredInvalidateRowIndex) {
            var e = this._deferredInvalidateColumnIndex,
              t = this._deferredInvalidateRowIndex;
            this._deferredInvalidateColumnIndex = null, this._deferredInvalidateRowIndex = null, this.recomputeGridSize({
              columnIndex: e,
              rowIndex: t
            })
          }
        }
      }, {
        key: "_invokeOnScrollMemoizer",
        value: function (e) {
          var t = this,
            n = e.scrollLeft,
            r = e.scrollTop,
            i = e.totalColumnsWidth,
            o = e.totalRowsHeight;
          this._onScrollMemoizer({
            callback: function (e) {
              var n = e.scrollLeft,
                r = e.scrollTop,
                s = t.props,
                a = s.height;
              (0, s.onScroll)({
                clientHeight: a,
                clientWidth: s.width,
                scrollHeight: o,
                scrollLeft: n,
                scrollTop: r,
                scrollWidth: i
              })
            },
            indices: {
              scrollLeft: n,
              scrollTop: r
            }
          })
        }
      }, {
        key: "_isScrolling",
        value: function () {
          var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.props,
            t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.state;
          return Object.hasOwnProperty.call(e, "isScrolling") ? Boolean(e.isScrolling) : Boolean(t.isScrolling)
        }
      }, {
        key: "_maybeCallOnScrollbarPresenceChange",
        value: function () {
          if (this._scrollbarPresenceChanged) {
            var e = this.props.onScrollbarPresenceChange;
            this._scrollbarPresenceChanged = !1, e({
              horizontal: this._horizontalScrollBarSize > 0,
              size: this.state.instanceProps.scrollbarSize,
              vertical: this._verticalScrollBarSize > 0
            })
          }
        }
      }, {
        key: "scrollToPosition",
        value: function (e) {
          var n = e.scrollLeft,
            r = e.scrollTop,
            i = t._getScrollToPositionStateUpdate({
              prevState: this.state,
              scrollLeft: n,
              scrollTop: r
            });
          i && (i.needToResetStyleCache = !1, this.setState(i))
        }
      }, {
        key: "_getCalculatedScrollLeft",
        value: function () {
          var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.props,
            n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.state;
          return t._getCalculatedScrollLeft(e, n)
        }
      }, {
        key: "_updateScrollLeftForScrollToColumn",
        value: function () {
          var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.props,
            n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.state,
            r = t._getScrollLeftForScrollToColumnStateUpdate(e, n);
          r && (r.needToResetStyleCache = !1, this.setState(r))
        }
      }, {
        key: "_getCalculatedScrollTop",
        value: function () {
          var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.props,
            n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.state;
          return t._getCalculatedScrollTop(e, n)
        }
      }, {
        key: "_resetStyleCache",
        value: function () {
          var e = this._styleCache,
            t = this._cellCache,
            n = this.props.isScrollingOptOut;
          this._cellCache = {}, this._styleCache = {};
          for (var r = this._rowStartIndex; r <= this._rowStopIndex; r++)
            for (var i = this._columnStartIndex; i <= this._columnStopIndex; i++) {
              var o = r + "-" + i;
              this._styleCache[o] = e[o], n && (this._cellCache[o] = t[o])
            }
        }
      }, {
        key: "_updateScrollTopForScrollToRow",
        value: function () {
          var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.props,
            n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.state,
            r = t._getScrollTopForScrollToRowStateUpdate(e, n);
          r && (r.needToResetStyleCache = !1, this.setState(r))
        }
      }], [{
        key: "getDerivedStateFromProps",
        value: function (e, n) {
          var r = {};
          0 === e.columnCount && 0 !== n.scrollLeft || 0 === e.rowCount && 0 !== n.scrollTop ? (r.scrollLeft = 0, r.scrollTop = 0) : (e.scrollLeft !== n.scrollLeft && e.scrollToColumn < 0 || e.scrollTop !== n.scrollTop && e.scrollToRow < 0) && tp()(r, t._getScrollToPositionStateUpdate({
            prevState: n,
            scrollLeft: e.scrollLeft,
            scrollTop: e.scrollTop
          }));
          var i = n.instanceProps;
          r.needToResetStyleCache = !1, e.columnWidth === i.prevColumnWidth && e.rowHeight === i.prevRowHeight || (r.needToResetStyleCache = !0), i.columnSizeAndPositionManager.configure({
            cellCount: e.columnCount,
            estimatedCellSize: t._getEstimatedColumnSize(e),
            cellSizeGetter: t._wrapSizeGetter(e.columnWidth)
          }), i.rowSizeAndPositionManager.configure({
            cellCount: e.rowCount,
            estimatedCellSize: t._getEstimatedRowSize(e),
            cellSizeGetter: t._wrapSizeGetter(e.rowHeight)
          }), 0 !== i.prevColumnCount && 0 !== i.prevRowCount || (i.prevColumnCount = 0, i.prevRowCount = 0), e.autoHeight && !1 === e.isScrolling && !0 === i.prevIsScrolling && tp()(r, {
            isScrolling: !1
          });
          var o = void 0,
            s = void 0;
          return np({
            cellCount: i.prevColumnCount,
            cellSize: "number" == typeof i.prevColumnWidth ? i.prevColumnWidth : null,
            computeMetadataCallback: function () {
              return i.columnSizeAndPositionManager.resetCell(0)
            },
            computeMetadataCallbackProps: e,
            nextCellsCount: e.columnCount,
            nextCellSize: "number" == typeof e.columnWidth ? e.columnWidth : null,
            nextScrollToIndex: e.scrollToColumn,
            scrollToIndex: i.prevScrollToColumn,
            updateScrollOffsetForScrollToIndex: function () {
              o = t._getScrollLeftForScrollToColumnStateUpdate(e, n)
            }
          }), np({
            cellCount: i.prevRowCount,
            cellSize: "number" == typeof i.prevRowHeight ? i.prevRowHeight : null,
            computeMetadataCallback: function () {
              return i.rowSizeAndPositionManager.resetCell(0)
            },
            computeMetadataCallbackProps: e,
            nextCellsCount: e.rowCount,
            nextCellSize: "number" == typeof e.rowHeight ? e.rowHeight : null,
            nextScrollToIndex: e.scrollToRow,
            scrollToIndex: i.prevScrollToRow,
            updateScrollOffsetForScrollToIndex: function () {
              s = t._getScrollTopForScrollToRowStateUpdate(e, n)
            }
          }), i.prevColumnCount = e.columnCount, i.prevColumnWidth = e.columnWidth, i.prevIsScrolling = !0 === e.isScrolling, i.prevRowCount = e.rowCount, i.prevRowHeight = e.rowHeight, i.prevScrollToColumn = e.scrollToColumn, i.prevScrollToRow = e.scrollToRow, i.scrollbarSize = e.getScrollbarSize(), void 0 === i.scrollbarSize ? (i.scrollbarSizeMeasured = !1, i.scrollbarSize = 0) : i.scrollbarSizeMeasured = !0, r.instanceProps = i, zh()({}, r, o, s)
        }
      }, {
        key: "_getEstimatedColumnSize",
        value: function (e) {
          return "number" == typeof e.columnWidth ? e.columnWidth : e.estimatedColumnSize
        }
      }, {
        key: "_getEstimatedRowSize",
        value: function (e) {
          return "number" == typeof e.rowHeight ? e.rowHeight : e.estimatedRowSize
        }
      }, {
        key: "_getScrollToPositionStateUpdate",
        value: function (e) {
          var t = e.prevState,
            n = e.scrollLeft,
            r = e.scrollTop,
            i = {
              scrollPositionChangeReason: kp
            };
          return "number" == typeof n && n >= 0 && (i.scrollDirectionHorizontal = n > t.scrollLeft ? 1 : -1, i.scrollLeft = n), "number" == typeof r && r >= 0 && (i.scrollDirectionVertical = r > t.scrollTop ? 1 : -1, i.scrollTop = r), "number" == typeof n && n >= 0 && n !== t.scrollLeft || "number" == typeof r && r >= 0 && r !== t.scrollTop ? i : null
        }
      }, {
        key: "_wrapSizeGetter",
        value: function (e) {
          return "function" == typeof e ? e : function () {
            return e
          }
        }
      }, {
        key: "_getCalculatedScrollLeft",
        value: function (e, t) {
          var n = e.columnCount,
            r = e.height,
            i = e.scrollToAlignment,
            o = e.scrollToColumn,
            s = e.width,
            a = t.scrollLeft,
            l = t.instanceProps;
          if (n > 0) {
            var c = n - 1,
              u = o < 0 ? c : Math.min(c, o),
              h = l.rowSizeAndPositionManager.getTotalSize(),
              p = l.scrollbarSizeMeasured && h > r ? l.scrollbarSize : 0;
            return l.columnSizeAndPositionManager.getUpdatedOffsetForIndex({
              align: i,
              containerSize: s - p,
              currentOffset: a,
              targetIndex: u
            })
          }
          return 0
        }
      }, {
        key: "_getScrollLeftForScrollToColumnStateUpdate",
        value: function (e, n) {
          var r = n.scrollLeft,
            i = t._getCalculatedScrollLeft(e, n);
          return "number" == typeof i && i >= 0 && r !== i ? t._getScrollToPositionStateUpdate({
            prevState: n,
            scrollLeft: i,
            scrollTop: -1
          }) : null
        }
      }, {
        key: "_getCalculatedScrollTop",
        value: function (e, t) {
          var n = e.height,
            r = e.rowCount,
            i = e.scrollToAlignment,
            o = e.scrollToRow,
            s = e.width,
            a = t.scrollTop,
            l = t.instanceProps;
          if (r > 0) {
            var c = r - 1,
              u = o < 0 ? c : Math.min(c, o),
              h = l.columnSizeAndPositionManager.getTotalSize(),
              p = l.scrollbarSizeMeasured && h > s ? l.scrollbarSize : 0;
            return l.rowSizeAndPositionManager.getUpdatedOffsetForIndex({
              align: i,
              containerSize: n - p,
              currentOffset: a,
              targetIndex: u
            })
          }
          return 0
        }
      }, {
        key: "_getScrollTopForScrollToRowStateUpdate",
        value: function (e, n) {
          var r = n.scrollTop,
            i = t._getCalculatedScrollTop(e, n);
          return "number" == typeof i && i >= 0 && r !== i ? t._getScrollToPositionStateUpdate({
            prevState: n,
            scrollLeft: -1,
            scrollTop: i
          }) : null
        }
      }]), t
    }(w.PureComponent);
  xp.defaultProps = {
      "aria-label": "grid",
      "aria-readonly": !0,
      autoContainerWidth: !1,
      autoHeight: !1,
      autoWidth: !1,
      cellRangeRenderer: function (e) {
        for (var t = e.cellCache, n = e.cellRenderer, r = e.columnSizeAndPositionManager, i = e.columnStartIndex, o = e.columnStopIndex, s = e.deferredMeasurementCache, a = e.horizontalOffsetAdjustment, l = e.isScrolling, c = e.isScrollingOptOut, u = e.parent, h = e.rowSizeAndPositionManager, p = e.rowStartIndex, d = e.rowStopIndex, f = e.styleCache, m = e.verticalOffsetAdjustment, g = e.visibleColumnIndices, y = e.visibleRowIndices, v = [], w = r.areOffsetsAdjusted() || h.areOffsetsAdjusted(), b = !l && !w, S = p; S <= d; S++)
          for (var C = h.getSizeAndPositionOfCell(S), E = i; E <= o; E++) {
            var k = r.getSizeAndPositionOfCell(E),
              x = E >= g.start && E <= g.stop && S >= y.start && S <= y.stop,
              T = S + "-" + E,
              R = void 0;
            b && f[T] ? R = f[T] : s && !s.has(S, E) ? R = {
              height: "auto",
              left: 0,
              position: "absolute",
              top: 0,
              width: "auto"
            } : (R = {
              height: C.size,
              left: k.offset + a,
              position: "absolute",
              top: C.offset + m,
              width: k.size
            }, f[T] = R);
            var D = {
                columnIndex: E,
                isScrolling: l,
                isVisible: x,
                key: T,
                parent: u,
                rowIndex: S,
                style: R
              },
              _ = void 0;
            !c && !l || a || m ? _ = n(D) : (t[T] || (t[T] = n(D)), _ = t[T]), null != _ && !1 !== _ && v.push(_)
          }
        return v
      },
      containerRole: "rowgroup",
      containerStyle: {},
      estimatedColumnSize: 100,
      estimatedRowSize: 30,
      getScrollbarSize: dp.a,
      noContentRenderer: function () {
        return null
      },
      onScroll: function () {},
      onScrollbarPresenceChange: function () {},
      onSectionRendered: function () {},
      overscanColumnCount: 0,
      overscanIndicesGetter: function (e) {
        var t = e.cellCount,
          n = e.overscanCellsCount,
          r = e.scrollDirection,
          i = e.startIndex,
          o = e.stopIndex;
        return 1 === r ? {
          overscanStartIndex: Math.max(0, i),
          overscanStopIndex: Math.min(t - 1, o + n)
        } : {
          overscanStartIndex: Math.max(0, i - n),
          overscanStopIndex: Math.min(t - 1, o)
        }
      },
      overscanRowCount: 10,
      role: "grid",
      scrollingResetTimeInterval: 150,
      scrollToAlignment: "auto",
      scrollToColumn: -1,
      scrollToRow: -1,
      style: {},
      tabIndex: 0,
      isScrollingOptOut: !1
    }, xp.propTypes = null,
    function (e) {
      var t = e.prototype;
      if (!t || !t.isReactComponent) throw new Error("Can only polyfill class components");
      if ("function" != typeof e.getDerivedStateFromProps && "function" != typeof t.getSnapshotBeforeUpdate) return e;
      var n = null,
        r = null,
        i = null;
      if ("function" == typeof t.componentWillMount ? n = "componentWillMount" : "function" == typeof t.UNSAFE_componentWillMount && (n = "UNSAFE_componentWillMount"), "function" == typeof t.componentWillReceiveProps ? r = "componentWillReceiveProps" : "function" == typeof t.UNSAFE_componentWillReceiveProps && (r = "UNSAFE_componentWillReceiveProps"), "function" == typeof t.componentWillUpdate ? i = "componentWillUpdate" : "function" == typeof t.UNSAFE_componentWillUpdate && (i = "UNSAFE_componentWillUpdate"), null !== n || null !== r || null !== i) {
        var o = e.displayName || e.name,
          s = "function" == typeof e.getDerivedStateFromProps ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
        throw Error("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n" + o + " uses " + s + " but also contains the following legacy lifecycles:" + (null !== n ? "\n  " + n : "") + (null !== r ? "\n  " + r : "") + (null !== i ? "\n  " + i : "") + "\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://fb.me/react-async-component-lifecycle-hooks")
      }
      if ("function" == typeof e.getDerivedStateFromProps && (t.componentWillMount = fp, t.componentWillReceiveProps = mp), "function" == typeof t.getSnapshotBeforeUpdate) {
        if ("function" != typeof t.componentDidUpdate) throw new Error("Cannot polyfill getSnapshotBeforeUpdate() for components that do not define componentDidUpdate() on the prototype");
        t.componentWillUpdate = gp;
        var a = t.componentDidUpdate;
        t.componentDidUpdate = function (e, t, n) {
          var r = this.__reactInternalSnapshotFlag ? this.__reactInternalSnapshot : n;
          a.call(this, e, t, r)
        }
      }
    }(xp);
  var Tp = xp;
  class Rp extends w.Component {
    constructor(e) {
      super(e), this.wrapperRef = null, this.focusWithinChangedTimeoutId = null, this.onWrapperRef = e => {
        e && (e.addEventListener("focusin", () => {
          this.onFocusWithinChanged(!0)
        }), e.addEventListener("focusout", () => {
          this.onFocusWithinChanged(!1)
        })), this.wrapperRef = e
      }, this.onClick = e => {
        this.props.onClick && this.props.onClick(e)
      }, this.onKeyDown = e => {
        this.props.onKeyDown && this.props.onKeyDown(e)
      }, this.onMouseDown = e => {
        e.target === this.wrapperRef && e.preventDefault()
      }, this.state = {
        focusWithin: !1
      }
    }
    onFocusWithinChanged(e) {
      this.setState({
        focusWithin: e
      }), null !== this.focusWithinChangedTimeoutId && (cancelAnimationFrame(this.focusWithinChangedTimeoutId), this.focusWithinChangedTimeoutId = null), this.focusWithinChangedTimeoutId = requestAnimationFrame(() => {
        this.props.onFocusWithinChanged && this.props.onFocusWithinChanged(e), this.focusWithinChangedTimeoutId = null
      })
    }
    render() {
      const e = mh()("focus-container", this.props.className, {
        "focus-within": this.state.focusWithin
      });
      return w.createElement("div", {
        className: e,
        ref: this.onWrapperRef,
        onClick: this.onClick,
        onMouseDown: this.onMouseDown,
        onKeyDown: this.onKeyDown
      }, this.props.children)
    }
  }
  class Dp extends w.Component {
    constructor() {
      super(...arguments), this.onRowMouseOver = e => {
        this.props.onRowMouseOver(this.props.rowIndex, e)
      }, this.onRowMouseDown = e => {
        this.props.onRowMouseDown(this.props.rowIndex, e)
      }, this.onRowClick = e => {
        this.props.onRowClick(this.props.rowIndex, e)
      }, this.onRowKeyDown = e => {
        this.props.onRowKeyDown(this.props.rowIndex, e)
      }
    }
    render() {
      const e = this.props.selected,
        t = mh()("list-item", {
          selected: e
        }, {
          "not-selectable": !1 === this.props.selectable
        }, this.props.className),
        n = "menu" === this.props.ariaMode ? "menuitem" : "option",
        r = Object.assign(Object.assign({}, this.props.style), {
          width: "100%"
        });
      return w.createElement("div", {
        id: this.props.id,
        "aria-setsize": this.props.rowCount,
        "aria-posinset": this.props.rowIndex + 1,
        "aria-selected": this.props.selected,
        role: n,
        className: t,
        tabIndex: this.props.tabIndex,
        ref: this.props.onRef,
        onMouseOver: this.onRowMouseOver,
        onMouseDown: this.onRowMouseDown,
        onClick: this.onRowClick,
        onKeyDown: this.onRowKeyDown,
        style: r
      }, this.props.children)
    }
  }

  function _p(e, t, n = (e => !0)) {
    if (0 === e) return null;
    const {
      direction: r,
      row: i
    } = t, o = void 0 === t.wrap || t.wrap;
    let s = i < 0 || i >= e ? "up" === r ? e - 1 : 0 : i;
    "down" === r && -1 === i && (s = -1);
    const a = "up" === r ? -1 : 1;
    for (let t = 0; t < e; t++) {
      if (s += a, s >= e) {
        if (!o) break;
        s = 0
      } else if (s < 0) {
        if (!o) break;
        s = e - 1
      }
      if (i !== s && n(s)) return s
    }
    return null
  }

  function Ap(e, t, n) {
    let r = "up" === e ? 0 : t - 1;
    const i = "up" === e ? 1 : -1;
    for (; r >= 0 && r < t; r += i)
      if (n(r)) return r;
    return null
  }

  function Mp(e, t) {
    return function (e, t, n) {
      null === t && (t = e || 0, e = 0), n || (n = t < e ? -1 : 1);
      const r = Math.max(Math.ceil((t - e) / n), 0),
        i = new Array(r);
      for (let t = 0; t < r; t++, e += n) i[t] = e;
      return i
    }(e, t > e ? t + 1 : t - 1)
  }
  class Pp extends w.Component {
    constructor(e) {
      super(e), this.focusItem = null, this.fakeScroll = null, this.scrollToRow = -1, this.focusRow = -1, this.gridStyle = {
        overflowX: "hidden"
      }, this.lastScroll = null, this.list = null, this.grid = null, this.resizeObserver = null, this.updateSizeTimeoutId = null, this.onResized = (e, t) => {
        this.updateSizeTimeoutId = null;
        const [n, r] = [e.offsetWidth, e.offsetHeight];
        this.state.width === n && this.state.height === r || this.setState({
          width: n,
          height: r
        })
      }, this.onSelectAll = e => {
        const t = this.props.selectionMode;
        if ("range" !== t && "multi" !== t) return;
        if (e.preventDefault(), this.props.rowCount <= 0) return;
        const n = {
            kind: "select-all"
          },
          r = this.props.rowCount - 1;
        if (this.props.onSelectionChanged) {
          const e = Mp(0, r);
          this.props.onSelectionChanged(e, n)
        }
        "range" === t && this.props.onSelectedRangeChanged && this.props.onSelectedRangeChanged(0, r, n)
      }, this.onRef = e => {
        null === e && null !== this.list && this.list.removeEventListener("select-all", this.onSelectAll), this.list = e, null !== e && e.addEventListener("select-all", this.onSelectAll), this.resizeObserver && (this.resizeObserver.disconnect(), null !== e ? this.resizeObserver.observe(e) : this.setState({
          width: void 0,
          height: void 0
        }))
      }, this.onKeyDown = e => {
        if (this.props.selectedRows.forEach(t => {
            this.props.onRowKeyDown && this.props.onRowKeyDown(t, e)
          }), e.defaultPrevented) return;
        const t = {
            kind: "keyboard",
            event: e
          },
          n = "Home" === e.key,
          r = "End" === e.key;
        n ? this.moveSelectionToFirstSelectableRow(t) : r ? this.moveSelectionToLastSelectableRow(t) : "ArrowDown" === e.key ? (e.shiftKey && this.props.selectionMode && "single" !== this.props.selectionMode ? this.addSelection("down", t) : this.moveSelection("down", t), e.preventDefault()) : "ArrowUp" === e.key ? (e.shiftKey && this.props.selectionMode && "single" !== this.props.selectionMode ? this.addSelection("up", t) : this.moveSelection("up", t), e.preventDefault()) : "a" === e.key && e.ctrlKey && this.onSelectAll(e)
      }, this.onRowKeyDown = (e, t) => {
        this.props.onRowKeyDown && this.props.onRowKeyDown(e, t), t.defaultPrevented || "Enter" !== t.key && " " !== t.key || (this.toggleSelection(t), t.preventDefault())
      }, this.onFocusContainerKeyDown = e => {
        e.defaultPrevented || "Enter" !== e.key && " " !== e.key || (this.toggleSelection(e), e.preventDefault())
      }, this.toggleSelection = e => {
        this.props.selectedRows.forEach(t => {
          if (!this.props.onRowClick) return;
          const {
            rowCount: n
          } = this.props;
          t < 0 || t >= n ? log.debug(`[List.toggleSelection] unable to onRowClick for row ${t} as it is outside the bounds of the array [0, ${n}]`) : this.props.onRowClick(t, {
            kind: "keyboard",
            event: e
          })
        })
      }, this.onRowMouseOver = (e, t) => {
        this.props.selectOnHover && this.canSelectRow(e) && this.props.selectedRows.includes(e) && this.props.onSelectionChanged && (this.props.onSelectionChanged([e], {
          kind: "hover",
          event: t
        }), this.scrollRowToVisible(e))
      }, this.canSelectRow = e => !this.props.canSelectRow || this.props.canSelectRow(e), this.onFocusedItemRef = e => {
        this.focusItem = e
      }, this.renderRow = e => {
        const t = e.rowIndex,
          n = this.canSelectRow(t),
          r = -1 !== this.props.selectedRows.indexOf(t),
          i = t === this.focusRow;
        let o = void 0;
        n && (o = r && this.props.selectedRows[0] === t ? 0 : -1);
        const s = i ? this.onFocusedItemRef : void 0,
          a = this.props.rowRenderer(e.rowIndex),
          l = this.state.rowIdPrefix ? `${this.state.rowIdPrefix}-${t}` : void 0;
        return w.createElement(Dp, {
          key: e.key,
          id: l,
          onRef: s,
          rowCount: this.props.rowCount,
          rowIndex: t,
          selected: r,
          ariaMode: this.props.ariaMode,
          onRowClick: this.onRowClick,
          onRowKeyDown: this.onRowKeyDown,
          onRowMouseDown: this.onRowMouseDown,
          onRowMouseOver: this.onRowMouseOver,
          style: e.style,
          tabIndex: o,
          children: a,
          selectable: n
        })
      }, this.onGridRef = e => {
        this.grid = e
      }, this.onFakeScrollRef = e => {
        this.fakeScroll = e
      }, this.onFakeScroll = e => {
        if ("grid" !== this.lastScroll) {
          if (this.lastScroll = "fake", this.grid) {
            const t = S.findDOMNode(this.grid);
            t instanceof Element && (t.scrollTop = e.currentTarget.scrollTop)
          }
        } else this.lastScroll = null
      }, this.onRowMouseDown = (e, t) => {
        if (this.canSelectRow(e)) {
          this.props.onRowMouseDown && this.props.onRowMouseDown(e, t);
          if ((2 === t.button || !1) && this.props.selectedRows.includes(e)) return;
          const n = t.ctrlKey;
          if (t.shiftKey && this.props.selectedRows.length && this.props.selectionMode && "single" !== this.props.selectionMode) {
            const n = this.props.selectedRows[0];
            if (this.props.onSelectionChanged) {
              const r = Mp(n, e);
              this.props.onSelectionChanged(r, {
                kind: "mouseclick",
                event: t
              })
            }
            "range" === this.props.selectionMode && this.props.onSelectedRangeChanged && this.props.onSelectedRangeChanged(n, e, {
              kind: "mouseclick",
              event: t
            })
          } else if (n && "multi" === this.props.selectionMode) {
            if (this.props.onSelectionChanged) {
              let n;
              if (this.props.selectedRows.includes(e)) {
                if (1 === this.props.selectedRows.length) return;
                n = this.props.selectedRows.filter(t => t !== e)
              } else n = [...this.props.selectedRows, e];
              this.props.onSelectionChanged(n, {
                kind: "mouseclick",
                event: t
              })
            }
          } else if ((1 !== this.props.selectedRows.length || 1 === this.props.selectedRows.length && e !== this.props.selectedRows[0]) && (this.props.onSelectionChanged && this.props.onSelectionChanged([e], {
              kind: "mouseclick",
              event: t
            }), this.props.onSelectedRangeChanged && this.props.onSelectedRangeChanged(e, e, {
              kind: "mouseclick",
              event: t
            }), this.props.onSelectedRowChanged)) {
            const {
              rowCount: n
            } = this.props;
            if (e < 0 || e >= n) return void log.debug(`[List.onRowMouseDown] unable to onSelectedRowChanged for row '${e}' as it is outside the bounds of the array [0, ${n}]`);
            this.props.onSelectedRowChanged(e, {
              kind: "mouseclick",
              event: t
            })
          }
        }
      }, this.onRowClick = (e, t) => {
        if (this.canSelectRow(e) && this.props.onRowClick) {
          const n = this.props.rowCount;
          if (e < 0 || e >= n) return void log.debug(`[List.onRowClick] unable to onRowClick for row ${e} as it is outside the bounds of the array [0, ${n}]`);
          this.props.onRowClick(e, {
            kind: "mouseclick",
            event: t
          })
        }
      }, this.onScroll = ({
        scrollTop: e,
        clientHeight: t
      }) => {
        if (this.props.onScroll && this.props.onScroll(e, t), this.fakeScroll) {
          if ("fake" === this.lastScroll) return void(this.lastScroll = null);
          this.lastScroll = "grid", this.fakeScroll.scrollTop = e
        }
      }, e.selectedRows.length > 0 && (this.scrollToRow = e.selectedRows[0]), this.state = {};
      const t = window.ResizeObserver;
      ResizeObserver && (this.resizeObserver = new t(e => {
        for (const t of e) t.target === this.list && (null !== this.updateSizeTimeoutId && clearImmediate(this.updateSizeTimeoutId), this.updateSizeTimeoutId = setImmediate(this.onResized, t.target, t.contentRect))
      }))
    }
    addSelection(e, t) {
      if (0 === this.props.selectedRows.length) return this.moveSelection(e, t);
      const n = this.props.selectedRows[this.props.selectedRows.length - 1],
        r = this.props.selectedRows[0],
        i = _p(this.props.rowCount, {
          direction: e,
          row: n,
          wrap: !1
        }, this.canSelectRow);
      if (null != i) {
        if (this.props.onSelectionChanged) {
          const e = Mp(r, i);
          this.props.onSelectionChanged(e, t)
        }
        "range" === this.props.selectionMode && this.props.onSelectedRangeChanged && this.props.onSelectedRangeChanged(r, i, t), this.scrollRowToVisible(i)
      }
    }
    moveSelection(e, t) {
      const n = this.props.selectedRows.length > 0 ? this.props.selectedRows[this.props.selectedRows.length - 1] : -1,
        r = _p(this.props.rowCount, {
          direction: e,
          row: n
        }, this.canSelectRow);
      null != r && this.moveSelectionTo(r, t)
    }
    moveSelectionToFirstSelectableRow(e) {
      const {
        canSelectRow: t,
        props: n
      } = this, {
        rowCount: r
      } = n, i = Ap("up", r, t);
      null !== i && this.moveSelectionTo(i, e)
    }
    moveSelectionToLastSelectableRow(e) {
      const {
        canSelectRow: t,
        props: n
      } = this, {
        rowCount: r
      } = n, i = Ap("down", r, t);
      null !== i && this.moveSelectionTo(i, e)
    }
    moveSelectionTo(e, t) {
      if (this.props.onSelectionChanged && this.props.onSelectionChanged([e], t), this.props.onSelectedRowChanged) {
        const n = this.props.rowCount;
        if (e < 0 || e >= n) return void log.debug(`[List.moveSelection] unable to onSelectedRowChanged for row '${e}' as it is outside the bounds of the array [0, ${n}]`);
        this.props.onSelectedRowChanged(e, t)
      }
      this.scrollRowToVisible(e)
    }
    scrollRowToVisible(e) {
      this.scrollToRow = e, !1 !== this.props.focusOnHover && (this.focusRow = e), this.forceUpdate()
    }
    componentDidUpdate(e, t) {
      if (this.focusRow >= 0 && this.focusItem) this.focusItem.focus(), this.focusRow = -1, this.forceUpdate();
      else if (this.grid) {
        if (!(this.props.rowCount !== e.rowCount || this.state.width !== t.width || this.state.height !== t.height)) {
          const t = !wu(e.selectedRows, this.props.selectedRows),
            n = !vu(e.invalidationProps, this.props.invalidationProps);
          (t || n) && this.grid.forceUpdate()
        }
      }
    }
    componentWillMount() {
      this.setState({
        rowIdPrefix: vh("ListRow")
      })
    }
    componentWillUnmount() {
      null !== this.updateSizeTimeoutId && (clearImmediate(this.updateSizeTimeoutId), this.updateSizeTimeoutId = null), this.resizeObserver && this.resizeObserver.disconnect(), this.state.rowIdPrefix && wh(this.state.rowIdPrefix)
    }
    render() {
      let e;
      e = this.resizeObserver ? this.state.width && this.state.height ? this.renderContents(this.state.width, this.state.height) : null : w.createElement(Jh, {
        disableWidth: !0,
        disableHeight: !0
      }, ({
        width: e,
        height: t
      }) => this.renderContents(e, t));
      const t = this.props.selectedRows.length && this.state.rowIdPrefix ? `${this.state.rowIdPrefix}-${this.props.selectedRows[this.props.selectedRows.length-1]}` : void 0,
        n = "menu" === this.props.ariaMode ? "menu" : "listbox";
      return w.createElement("div", {
        ref: this.onRef,
        id: this.props.id,
        className: "list",
        onKeyDown: this.onKeyDown,
        role: n,
        "aria-activedescendant": t
      }, e)
    }
    renderContents(e, t) {
      return w.createElement(w.Fragment, null, this.renderGrid(e, t), this.renderFakeScroll(t))
    }
    renderGrid(e, t) {
      let n = this.props.scrollToRow;
      void 0 === n && (n = this.scrollToRow), this.scrollToRow = -1, void 0 !== this.props.setScrollTop && (n = -1);
      const r = this.props.selectedRows.length < 1 && this.props.rowCount > 0 ? 0 : -1;
      return w.createElement(Rp, {
        className: "list-focus-container",
        onKeyDown: this.onFocusContainerKeyDown
      }, w.createElement(Tp, {
        "aria-label": "",
        role: "",
        ref: this.onGridRef,
        autoContainerWidth: !0,
        width: e,
        height: t,
        columnWidth: e,
        columnCount: 1,
        rowCount: this.props.rowCount,
        rowHeight: this.props.rowHeight,
        cellRenderer: this.renderRow,
        onScroll: this.onScroll,
        scrollToRow: n,
        scrollTop: this.props.setScrollTop,
        overscanRowCount: 4,
        style: this.gridStyle,
        tabIndex: r
      }))
    }
    renderFakeScroll(e) {
      let t = 0;
      if ("number" == typeof this.props.rowHeight) t = this.props.rowHeight * this.props.rowCount;
      else
        for (let e = 0; e < this.props.rowCount; e++) t += this.props.rowHeight({
          index: e
        });
      return w.createElement("div", {
        className: "fake-scroll",
        ref: this.onFakeScrollRef,
        style: {
          height: e
        },
        onScroll: this.onFakeScroll
      }, w.createElement("div", {
        style: {
          height: t,
          pointerEvents: "none"
        }
      }))
    }
    focus() {
      if (this.props.selectedRows.length > 0 && this.props.selectedRows[this.props.selectedRows.length - 1] < this.props.rowCount) this.scrollRowToVisible(this.props.selectedRows[this.props.selectedRows.length - 1]);
      else if (this.grid) {
        const e = S.findDOMNode(this.grid);
        e && e.focus()
      }
    }
    forceUpdate(e) {
      super.forceUpdate(e);
      const t = this.grid;
      t && t.forceUpdate()
    }
  }
  class Ip extends w.Component {
    constructor() {
      super(...arguments), this.onClick = e => {
        if (e.preventDefault(), this.props.disabled) return;
        const t = this.props.uri;
        t && ee.openExternal(t);
        const n = this.props.onClick;
        n && n()
      }
    }
    render() {
      const e = this.props.uri || "",
        t = mh()("link-button-component", this.props.className);
      return w.createElement("a", {
        className: t,
        href: e,
        onClick: this.onClick,
        title: this.props.title,
        tabIndex: this.props.tabIndex
      }, this.props.children)
    }
  }
  class Op extends w.Component {
    constructor() {
      super(...arguments), this.inputElement = null, this.onChange = e => {
        const t = e.currentTarget.value;
        this.setState({
          value: t
        }, () => {
          this.props.onValueChanged && this.props.onValueChanged(t)
        })
      }, this.onSearchTextCleared = () => {
        null != this.props.onSearchCleared && this.props.onSearchCleared()
      }, this.onInputRef = e => {
        null != this.inputElement && "search" === this.props.type && this.inputElement.removeEventListener("search", this.onSearchTextCleared), this.inputElement = e, null != this.inputElement && "search" === this.props.type && this.inputElement.addEventListener("search", this.onSearchTextCleared)
      }, this.onContextMenu = e => {
        e.preventDefault(), ie([{
          role: "editMenu"
        }])
      }, this.onKeyDown = e => {
        const t = this.state.value;
        if ("" !== t && "search" === this.props.type && "Escape" === e.key) {
          const t = "";
          e.preventDefault(), this.setState({
            value: t
          }), this.props.onValueChanged && this.props.onValueChanged(t)
        } else "search" === this.props.type && "Escape" === e.key && "" === t && this.props.onBlur && (this.props.onBlur(t), null !== this.inputElement && this.inputElement.blur());
        void 0 !== this.props.onKeyDown && this.props.onKeyDown(e)
      }, this.onFocus = e => {
        this.props.autoFocus || void 0 === this.props.onFocus || this.props.onFocus()
      }, this.onBlur = e => {
        void 0 !== this.props.onBlur && this.props.onBlur(e.target.value)
      }
    }
    componentWillMount() {
      const e = vh("TextBox_" + (this.props.label || this.props.placeholder));
      this.setState({
        inputId: e,
        value: this.props.value
      })
    }
    componentWillUnmount() {
      this.state.inputId && wh(this.state.inputId)
    }
    componentWillReceiveProps(e) {
      this.state.value !== e.value && this.setState({
        value: e.value
      })
    }
    selectAll() {
      null !== this.inputElement && this.inputElement.select()
    }
    focus() {
      null !== this.inputElement && this.inputElement.focus()
    }
    blur() {
      null !== this.inputElement && this.inputElement.blur()
    }
    renderLabelLink() {
      return this.props.labelLinkText ? w.createElement(Ip, {
        uri: this.props.labelLinkUri,
        onClick: this.props.onLabelLinkClick,
        className: "link-label"
      }, this.props.labelLinkText) : null
    }
    renderLabel() {
      return this.props.label ? w.createElement("div", {
        className: "label-container"
      }, w.createElement("label", {
        htmlFor: this.state.inputId
      }, this.props.label), this.renderLabelLink()) : null
    }
    render() {
      const e = mh()("text-box-component", this.props.className),
        t = this.props.label ? this.state.inputId : void 0;
      return w.createElement("div", {
        className: e
      }, this.renderLabel(), w.createElement("input", {
        id: t,
        ref: this.onInputRef,
        onFocus: this.onFocus,
        onBlur: this.onBlur,
        autoFocus: this.props.autoFocus,
        disabled: this.props.disabled,
        type: this.props.type,
        placeholder: this.props.placeholder,
        value: this.state.value,
        onChange: this.onChange,
        onKeyDown: this.onKeyDown,
        tabIndex: this.props.tabIndex,
        onContextMenu: this.onContextMenu
      }))
    }
  }
  class Lp extends w.Component {
    render() {
      const e = mh()("row-component", this.props.className);
      return w.createElement("div", {
        className: e
      }, this.props.children)
    }
  }
  var Np = n(84);

  function Fp(e, t, n) {
    return Np.score(e, t) / n
  }

  function Bp(e, t, n) {
    const r = Fp(e, e, 1);
    return t.map(t => {
      const i = [],
        o = n(t);
      return o.forEach(t => {
        i.push(Np.match(t, e))
      }), {
        score: Fp(o.join(""), e, r),
        item: t,
        matches: {
          title: i[0],
          subtitle: i.length > 1 ? i[1] : []
        }
      }
    }).filter(({
      matches: e
    }) => e.title.length > 0 || e.subtitle.length > 0).sort(({
      score: e
    }, {
      score: t
    }) => wt(e, t))
  }
  class Hp extends w.Component {
    constructor(e) {
      super(e), this.list = null, this.filterTextBox = null, this.renderRow = e => {
        const t = this.state.rows[e];
        return "item" === t.kind ? this.props.renderItem(t.item, t.matches) : this.props.renderGroupHeader ? this.props.renderGroupHeader(t.identifier) : null
      }, this.onTextBoxRef = e => {
        this.filterTextBox = e
      }, this.onListRef = e => {
        this.list = e
      }, this.onFilterValueChanged = e => {
        this.props.onFilterTextChanged && this.props.onFilterTextChanged(e)
      }, this.onSelectedRowChanged = (e, t) => {
        if (this.setState({
            selectedRow: e
          }), this.props.onSelectionChanged) {
          const n = this.state.rows[e];
          "item" === n.kind && this.props.onSelectionChanged(n.item, t)
        }
      }, this.canSelectRow = e => {
        if (this.props.disabled) return !1;
        return "item" === this.state.rows[e].kind
      }, this.onRowClick = (e, t) => {
        if (this.props.onItemClick) {
          const n = this.state.rows[e];
          "item" === n.kind && this.props.onItemClick(n.item, t)
        }
      }, this.onRowKeyDown = (e, t) => {
        if (!this.list) return;
        const n = this.state.rows.length,
          r = _p(n, {
            direction: "down",
            row: -1
          }, this.canSelectRow),
          i = _p(n, {
            direction: "up",
            row: 0
          }, this.canSelectRow);
        let o = !1;
        if (("ArrowUp" === t.key && e === r || "ArrowDown" === t.key && e === i) && (o = !0), o) {
          const e = this.filterTextBox;
          e && (t.preventDefault(), e.focus())
        }
      }, this.onKeyDown = e => {
        const t = this.list,
          n = e.key;
        if (!t) return;
        if (this.props.onFilterKeyDown && this.props.onFilterKeyDown(e), e.defaultPrevented) return;
        const r = this.state.rows.length;
        if ("ArrowDown" === n) {
          if (r > 0) {
            const e = _p(r, {
              direction: "down",
              row: -1
            }, this.canSelectRow);
            null != e && this.setState({
              selectedRow: e
            }, () => {
              t.focus()
            })
          }
          e.preventDefault()
        } else if ("ArrowUp" === n) {
          if (r > 0) {
            const e = _p(r, {
              direction: "up",
              row: 0
            }, this.canSelectRow);
            null != e && this.setState({
              selectedRow: e
            }, () => {
              t.focus()
            })
          }
          e.preventDefault()
        } else if ("Enter" === n) {
          if (0 === r) return e.preventDefault();
          const t = this.props.filterText;
          if (void 0 !== t && !/\S/.test(t)) return e.preventDefault();
          const n = _p(r, {
            direction: "down",
            row: -1
          }, this.canSelectRow);
          null != n && this.onRowClick(n, {
            kind: "keyboard",
            event: e
          })
        }
      }, this.state = Up(e)
    }
    componentWillMount() {
      void 0 !== this.props.filterTextBox && (this.filterTextBox = this.props.filterTextBox)
    }
    componentWillReceiveProps(e) {
      this.setState(Up(e))
    }
    componentDidUpdate(e, t) {
      if (this.props.onSelectionChanged) {
        const e = Vp(t.rows, t.selectedRow),
          n = Vp(this.state.rows, this.state.selectedRow);
        if (e !== n) {
          if ((this.props.selectedItem ? this.props.selectedItem.id : null) !== n) {
            const e = Wp(this.state.rows, this.state.selectedRow);
            this.props.onSelectionChanged(e, {
              kind: "filter",
              filterText: this.props.filterText || ""
            })
          }
        }
      }
      if (void 0 !== this.props.onFilterListResultsChanged) {
        const e = this.state.rows.filter(e => "item" === e.kind).length;
        this.props.onFilterListResultsChanged(e)
      }
    }
    componentDidMount() {
      null !== this.filterTextBox && this.filterTextBox.selectAll()
    }
    renderTextBox() {
      return w.createElement(Op, {
        ref: this.onTextBoxRef,
        type: "search",
        autoFocus: !0,
        placeholder: this.props.placeholderText || "Filter",
        className: "filter-list-filter-field",
        onValueChanged: this.onFilterValueChanged,
        onKeyDown: this.onKeyDown,
        value: this.props.filterText,
        disabled: this.props.disabled
      })
    }
    render() {
      return w.createElement("div", {
        className: mh()("filter-list", this.props.className)
      }, this.props.renderPreList ? this.props.renderPreList() : null, w.createElement(Lp, {
        className: "filter-field-row"
      }, void 0 === this.props.filterTextBox ? this.renderTextBox() : null, this.props.renderPostFilter ? this.props.renderPostFilter() : null), w.createElement("div", {
        className: "filter-list-container"
      }, this.renderContent()))
    }
    selectNextItem(e = !1, t = "down") {
      if (null === this.list) return;
      let n = null;
      n = -1 === this.state.selectedRow || this.state.selectedRow === this.state.rows.length ? _p(this.state.rows.length, {
        direction: t,
        row: -1
      }, this.canSelectRow) : _p(this.state.rows.length, {
        direction: t,
        row: this.state.selectedRow
      }, this.canSelectRow), null !== n && this.setState({
        selectedRow: n
      }, () => {
        e && null !== this.list && this.list.focus()
      })
    }
    renderContent() {
      return 0 === this.state.rows.length && this.props.renderNoItems ? this.props.renderNoItems() : w.createElement(Pp, {
        ref: this.onListRef,
        rowCount: this.state.rows.length,
        rowRenderer: this.renderRow,
        rowHeight: this.props.rowHeight,
        selectedRows: [this.state.selectedRow],
        onSelectedRowChanged: this.onSelectedRowChanged,
        onRowClick: this.onRowClick,
        onRowKeyDown: this.onRowKeyDown,
        canSelectRow: this.canSelectRow,
        invalidationProps: Object.assign(Object.assign({}, this.props), this.props.invalidationProps)
      })
    }
  }

  function zp(e) {
    return e.text
  }

  function Up(e) {
    const t = new Array,
      n = (e.filterText || "").toLowerCase();
    for (const r of e.groups) {
      const i = n ? Bp(n, r.items, zp) : r.items.map(e => ({
        score: 1,
        matches: {
          title: [],
          subtitle: []
        },
        item: e
      }));
      if (i.length) {
        e.renderGroupHeader && t.push({
          kind: "group",
          identifier: r.identifier
        });
        for (const {
            item: e,
            matches: n
          } of i) t.push({
          kind: "item",
          item: e,
          matches: n
        })
      }
    }
    let r = -1;
    const i = e.selectedItem;
    return i && (r = t.findIndex(e => "item" === e.kind && e.item.id === i.id)), r < 0 && n.length && (r = t.findIndex(e => "item" === e.kind)), {
      rows: t,
      selectedRow: r
    }
  }

  function Wp(e, t) {
    if (t >= 0 && t < e.length) {
      const n = e[t];
      if ("item" === n.kind) return n.item
    }
    return null
  }

  function Vp(e, t) {
    const n = Wp(e, t);
    return n ? n.id : null
  }
  class jp extends w.Component {
    constructor() {
      super(...arguments), this.innerButton = null, this.onButtonRef = e => {
        this.innerButton = e, this.props.onButtonRef && this.props.onButtonRef(e)
      }, this.focus = () => {
        this.innerButton && this.innerButton.focus()
      }, this.getBoundingClientRect = () => this.innerButton ? this.innerButton.getBoundingClientRect() : void 0, this.onClick = e => {
        this.props.onClick && this.props.onClick(e), void 0 === this.props.type && e.preventDefault()
      }
    }
    blur() {
      this.innerButton && this.innerButton.blur()
    }
    render() {
      const e = mh()("button-component", {
        "small-button": "small" === this.props.size
      }, this.props.className);
      return w.createElement("button", {
        className: e,
        disabled: this.props.disabled,
        onClick: this.onClick,
        type: this.props.type || "button",
        ref: this.onButtonRef,
        tabIndex: this.props.tabIndex,
        onMouseEnter: this.props.onMouseEnter,
        title: this.props.tooltip,
        role: this.props.role,
        "aria-expanded": this.props.ariaExpanded,
        "aria-haspopup": this.props.ariaHasPopup
      }, this.props.children)
    }
  }
  var Gp = function (e, t) {
    return e === t
  };
  var $p = function (e, t) {
    var n;
    void 0 === t && (t = Gp);
    var r, i = [],
      o = !1,
      s = function (e, n) {
        return t(e, i[n])
      };
    return function () {
      for (var t = arguments.length, a = new Array(t), l = 0; l < t; l++) a[l] = arguments[l];
      return o && n === this && a.length === i.length && a.every(s) || (r = e.apply(this, a), o = !0, n = this, i = a), r
    }
  };
  const qp = Mc(__dirname, "static/empty-no-repo.svg");

  function Kp(e, t) {
    if (null !== t)
      for (const n of e)
        for (const e of n.items)
          if (e.repository.id === t.id) return e;
    return null
  }
  class Yp extends w.Component {
    constructor() {
      super(...arguments), this.getRepositoryGroups = $p((e, t) => null === e ? [] : function (e, t) {
        const n = new Map,
          r = new Set;
        for (const t of e) {
          const e = t instanceof Xi ? t.gitHubRepository : null;
          let i = Nh.NonGitHub;
          e ? e.endpoint === pt() ? (i = e.owner.login, r.add(i)) : i = Nh.Enterprise : i = Nh.NonGitHub;
          let o = n.get(i);
          o || (o = new Array, n.set(i, o)), o.push(t)
        }
        const i = new Array,
          o = e => {
            const r = n.get(e);
            if (!r || 0 === r.length) return;
            const o = new Map;
            for (const e of r) {
              const t = o.get(e.name) || 0;
              o.set(e.name, t + 1)
            }
            r.sort((e, t) => St(e.name, t.name));
            const s = r.map(n => {
              const r = o.get(n.name) || 0,
                {
                  aheadBehind: i,
                  changedFilesCount: s
                } = t.get(n.id) || Fh;
              return {
                text: n instanceof Xi ? [n.name, to(n)] : [n.name],
                id: n.id.toString(),
                repository: n,
                needsDisambiguation: r > 1 && e === Nh.Enterprise,
                aheadBehind: i,
                changedFilesCount: s
              }
            });
            i.push({
              identifier: e,
              items: s
            })
          },
          s = [...r.values()];
        return s.sort(St), s.forEach(o), o(Nh.Enterprise), o(Nh.NonGitHub), i
      }(e, t)), this.getSelectedListItem = $p(Kp), this.renderItem = (e, t) => {
        const n = e.repository;
        return w.createElement(Mh, {
          key: n.id,
          repository: n,
          needsDisambiguation: e.needsDisambiguation,
          askForConfirmationOnRemoveRepository: this.props.askForConfirmationOnRemoveRepository,
          onRemoveRepository: this.props.onRemoveRepository,
          onShowRepository: this.props.onShowRepository,
          onOpenInShell: this.props.onOpenInShell,
          onOpenInExternalEditor: this.props.onOpenInExternalEditor,
          externalEditorLabel: this.props.externalEditorLabel,
          shellLabel: this.props.shellLabel,
          matches: t,
          aheadBehind: e.aheadBehind,
          changedFilesCount: e.changedFilesCount
        })
      }, this.renderGroupHeader = e => {
        const t = e,
          n = this.getGroupLabel(t);
        return w.createElement("div", {
          key: t,
          className: "filter-list-group-header"
        }, n)
      }, this.onItemClick = e => {
        const t = e.changedFilesCount > 0 || null !== e.aheadBehind && (e.aheadBehind.ahead > 0 || e.aheadBehind.behind > 0);
        this.props.dispatcher.recordRepoClicked(t), this.props.onSelectionChanged(e.repository)
      }, this.renderPostFilter = () => w.createElement(jp, {
        className: "new-repository-button",
        onClick: this.onNewRepositoryButtonClick
      }, "添加", w.createElement(bh, {
        symbol: Sh.triangleDown
      })), this.renderNoItems = () => w.createElement("div", {
        className: "no-items no-results-found"
      }, w.createElement("img", {
        src: qp,
        className: "blankslate-image"
      }), w.createElement("div", {
        className: "title"
      }, "抱歉，我找不到存储库"), w.createElement("div", {
        className: "protip"
      }, "专业提示! 按", this.renderAddLocalShortcut(), "键可快速添加本地存储库，按", this.renderCloneRepositoryShortcut(), "B键可从应用程序中的任何位置进行克隆")), this.onNewRepositoryButtonClick = () => {
        ie([{
          label: "克隆存储库…",
          action: this.onCloneRepository
        }, {
          label: "新建存储库…",
          action: this.onCreateNewRepository
        }, {
          label: "添加现有存储库…",
          action: this.onAddExistingRepository
        }])
      }, this.onCloneRepository = () => {
        this.props.dispatcher.showPopup({
          type: Zi.CloneRepository,
          initialURL: null
        })
      }, this.onAddExistingRepository = () => {
        this.props.dispatcher.showPopup({
          type: Zi.AddRepository
        })
      }, this.onCreateNewRepository = () => {
        this.props.dispatcher.showPopup({
          type: Zi.CreateRepository
        })
      }
    }
    getGroupLabel(e) {
      return e === Nh.Enterprise ? "Enterprise" : e === Nh.NonGitHub ? "Other" : e
    }
    render() {
      const e = this.getRepositoryGroups(this.props.repositories, this.props.localRepositoryStateLookup),
        t = this.getSelectedListItem(e, this.props.selectedRepository),
        n = this.props.repositories.length > 7 ? [Bh(this.props.recentRepositories, this.props.repositories, this.props.localRepositoryStateLookup), ...e] : e;
      return w.createElement("div", {
        className: "repository-list"
      }, w.createElement(Hp, {
        rowHeight: 29,
        selectedItem: t,
        filterText: this.props.filterText,
        onFilterTextChanged: this.props.onFilterTextChanged,
        renderItem: this.renderItem,
        renderGroupHeader: this.renderGroupHeader,
        onItemClick: this.onItemClick,
        renderPostFilter: this.renderPostFilter,
        renderNoItems: this.renderNoItems,
        groups: n,
        invalidationProps: {
          repositories: this.props.repositories,
          filterText: this.props.filterText
        }
      }))
    }
    renderAddLocalShortcut() {
      return w.createElement("div", {
        className: "kbd-shortcut"
      }, w.createElement("kbd", null, "Ctrl"), " + ", w.createElement("kbd", null, "O"))
    }
    renderCloneRepositoryShortcut() {
      return w.createElement("div", {
        className: "kbd-shortcut"
      }, w.createElement("kbd", null, "Ctrl"), " + ", w.createElement("kbd", null, "Shift"), " + ", w.createElement("kbd", null, "O"))
    }
  }
  class Qp extends w.Component {
    render() {
      const e = mh()(this.props.className, "ui-view"),
        t = Object.assign(Object.assign({}, this.props), {
          className: e
        });
      return w.createElement("div", Object.assign({}, t), this.props.children)
    }
  }
  var Zp;
  ! function (e) {
    e[e.On = 0] = "On", e[e.Off = 1] = "Off", e[e.Mixed = 2] = "Mixed"
  }(Zp || (Zp = {}));
  class Xp extends w.Component {
    constructor() {
      super(...arguments), this.input = null, this.onChange = e => {
        this.props.onChange && this.props.onChange(e)
      }, this.onInputRef = e => {
        this.input = e, this.updateInputState()
      }
    }
    componentDidUpdate() {
      this.updateInputState()
    }
    componentWillMount() {
      const e = vh("Checkbox_" + (this.props.label || "unknown"));
      this.setState({
        inputId: e
      })
    }
    componentWillUnmount() {
      this.state.inputId && wh(this.state.inputId)
    }
    updateInputState() {
      const e = this.input;
      if (e) {
        const t = this.props.value;
        e.indeterminate = t === Zp.Mixed, e.checked = t !== Zp.Off
      }
    }
    renderLabel() {
      const e = this.props.label,
        t = this.state.inputId;
      return e ? w.createElement("label", {
        htmlFor: t
      }, e) : null
    }
    render() {
      return w.createElement("div", {
        className: "checkbox-component"
      }, w.createElement("input", {
        id: this.state.inputId,
        tabIndex: this.props.tabIndex,
        type: "checkbox",
        onChange: this.onChange,
        ref: this.onInputRef,
        disabled: this.props.disabled
      }), this.renderLabel())
    }
  }
  var Jp = n(133),
    ed = n.n(Jp);
  class td extends w.Component {
    constructor(e) {
      super(e), this.element = null, this.autocompletionRequestID = 0, this.renderItem = e => {
        const t = this.state.autocompletionState;
        if (!t) return null;
        const n = t.items[e],
          r = n === t.selectedItem ? "selected" : "";
        return w.createElement("div", {
          className: "autocompletion-item " + r
        }, t.provider.renderItem(n))
      }, this.onRowMouseDown = (e, t) => {
        const n = this.state.autocompletionState;
        if (!n) return;
        const r = n.items[e];
        r && this.insertCompletion(r, "mouseclick")
      }, this.onSelectedRowChanged = (e, t) => {
        const n = this.state.autocompletionState;
        if (!n) return;
        const r = n.items[e],
          i = Object.assign(Object.assign({}, n), {
            selectedItem: r
          });
        this.setState({
          autocompletionState: i
        })
      }, this.insertCompletionOnClick = e => {
        const t = this.state.autocompletionState;
        if (!t) return;
        const n = t.items;
        if (!n.length) return;
        const r = n[e];
        this.insertCompletion(r, "mouseclick")
      }, this.onContextMenu = e => {
        this.props.onContextMenu ? this.props.onContextMenu(e) : (e.preventDefault(), ie([{
          role: "editMenu"
        }]))
      }, this.onBlur = e => {
        this.close()
      }, this.onRef = e => {
        this.element = e, this.props.onElementRef && this.props.onElementRef(e)
      }, this.onKeyDown = e => {
        if (this.props.onKeyDown && this.props.onKeyDown(e), e.defaultPrevented) return;
        const t = this.state.autocompletionState;
        if (!t || !t.items.length) return;
        const n = t.selectedItem ? t.items.indexOf(t.selectedItem) : -1,
          r = this.getMovementDirection(e);
        if (r) {
          e.preventDefault();
          const i = _p(t.items.length, {
            direction: r,
            row: n
          });
          if (null !== i) {
            const e = t.items[i],
              n = Object.assign(Object.assign({}, t), {
                selectedItem: e
              });
            this.setState({
              autocompletionState: n
            })
          }
        } else if ("Enter" === e.key || "Tab" === e.key) {
          const n = t.selectedItem;
          n && (e.preventDefault(), this.insertCompletion(n, "keyboard"))
        } else "Escape" === e.key && this.close()
      }, this.onChange = async e => {
        const t = e.currentTarget.value;
        this.props.onValueChanged && this.props.onValueChanged(t);
        const n = this.element;
        if (null === n) return;
        const r = n.selectionStart;
        if (null === r) return;
        const i = ++this.autocompletionRequestID,
          o = await this.attemptAutocompletion(t, r);
        i === this.autocompletionRequestID && this.setState({
          autocompletionState: o
        })
      }, this.state = {
        autocompletionState: null
      }
    }
    renderAutocompletions() {
      const e = this.state.autocompletionState;
      if (!e) return null;
      const t = e.items;
      if (!t.length) return null;
      const n = this.element;
      let r = ed()(n, e.range.start);
      r = Object.assign(Object.assign({}, r), {
        top: r.top - n.scrollTop,
        left: r.left - n.scrollLeft
      });
      const i = r.left,
        o = r.top + 20,
        s = e.selectedItem ? t.indexOf(e.selectedItem) : -1,
        a = n.getBoundingClientRect().top + r.top;
      let l;
      if (null !== n.ownerDocument && null !== n.ownerDocument.defaultView) {
        const e = n.ownerDocument.defaultView.innerHeight - a - 20;
        l = Math.min(100, e)
      } else l = 100;
      const c = 29 * t.length,
        u = Math.min(c, l),
        h = e.rangeText,
        p = mh()("autocompletion-popup", e.provider.kind);
      return w.createElement("div", {
        className: p,
        style: {
          top: o,
          left: i,
          height: u
        }
      }, w.createElement(Pp, {
        rowCount: t.length,
        rowHeight: 29,
        selectedRows: [s],
        rowRenderer: this.renderItem,
        scrollToRow: s,
        selectOnHover: !0,
        focusOnHover: !1,
        onRowMouseDown: this.onRowMouseDown,
        onRowClick: this.insertCompletionOnClick,
        onSelectedRowChanged: this.onSelectedRowChanged,
        invalidationProps: h
      }))
    }
    renderTextInput() {
      const e = {
        type: "text",
        placeholder: this.props.placeholder,
        value: this.props.value,
        ref: this.onRef,
        onChange: this.onChange,
        onKeyDown: this.onKeyDown,
        onBlur: this.onBlur,
        onContextMenu: this.onContextMenu,
        disabled: this.props.disabled,
        "aria-required": !!this.props.isRequired
      };
      return w.createElement(this.getElementTagName(), e)
    }
    focus() {
      this.element && this.element.focus()
    }
    render() {
      const e = this.getElementTagName(),
        t = mh()("autocompletion-container", this.props.className, {
          "text-box-component": "input" === e,
          "text-area-component": "textarea" === e
        });
      return w.createElement("div", {
        className: t
      }, this.renderAutocompletions(), this.renderTextInput())
    }
    setCursorPosition(e) {
      null != this.element ? (this.element.selectionStart = e, this.element.selectionEnd = e) : log.warn("Unable to set cursor position when element is null")
    }
    insertCompletion(e, t) {
      const n = this.element,
        r = this.state.autocompletionState,
        i = n.value,
        o = r.range,
        s = r.provider.getCompletionText(e),
        a = i.substr(0, o.start - 1) + s + " ",
        l = a + i.substr(o.start + o.length);
      n.value = l, this.props.onValueChanged && this.props.onValueChanged(l);
      const c = a.length;
      "mouseclick" === t ? window.setTimeout(() => {
        n.focus(), this.setCursorPosition(c)
      }, 0) : this.setCursorPosition(c), this.close()
    }
    getMovementDirection(e) {
      switch (e.key) {
        case "ArrowUp":
          return "up";
        case "ArrowDown":
          return "down"
      }
      return null
    }
    close() {
      this.setState({
        autocompletionState: null
      })
    }
    async attemptAutocompletion(e, t) {
      for (const n of this.props.autocompletionProviders) {
        const r = new RegExp(n.getRegExp());
        r.global || Z(`The regex (${r}) returned from ${n} isn't global, but it should be!`);
        let i = null;
        for (; i = r.exec(e);) {
          const e = r.lastIndex,
            o = i[1] || "";
          if (e === t) {
            const t = {
                start: e - o.length,
                length: o.length
              },
              r = await n.getAutocompletionItems(o);
            return {
              provider: n,
              items: r,
              range: t,
              selectedItem: r[0],
              rangeText: o
            }
          }
        }
      }
      return null
    }
  }
  class nd extends td {
    getElementTagName() {
      return "textarea"
    }
  }
  class rd extends td {
    getElementTagName() {
      return "input"
    }
  }
  class id {
    constructor(e) {
      this.kind = "emoji", this.emoji = e
    }
    getRegExp() {
      return /(?:^|\n| )(?::)([a-z\d\\+-][a-z\d_]*)?/g
    }
    async getAutocompletionItems(e, t = 25) {
      if (0 === e.length) return [...this.emoji.keys()].map(e => ({
        emoji: e,
        matchStart: 0,
        matchLength: 0
      })).slice(0, t);
      const n = new Array,
        r = e.toLowerCase();
      for (const e of this.emoji.keys()) {
        const t = e.indexOf(r); - 1 !== t && n.push({
          emoji: e,
          matchStart: t,
          matchLength: r.length
        })
      }
      return n.sort((e, t) => vt(e.matchStart, t.matchStart) || vt(e.emoji.length, t.emoji.length) || vt(e.emoji, t.emoji)).slice(0, t)
    }
    renderItem(e) {
      const t = e.emoji;
      return w.createElement("div", {
        className: "emoji",
        key: t
      }, w.createElement("img", {
        className: "icon",
        src: this.emoji.get(t)
      }), this.renderHighlightedTitle(e))
    }
    renderHighlightedTitle(e) {
      const t = e.emoji;
      return e.matchLength ? w.createElement("div", {
        className: "title"
      }, t.substr(0, e.matchStart), w.createElement("mark", null, t.substr(e.matchStart, e.matchLength)), t.substr(e.matchStart + e.matchLength)) : w.createElement("div", {
        className: "title"
      }, t)
    }
    getCompletionText(e) {
      return e.emoji
    }
  }
  class od {
    constructor(e) {
      this.timeoutId = null, this.delay = e
    }
    queue(e) {
      this.clear(), this.timeoutId = window.setTimeout(e, this.delay)
    }
    clear() {
      null != this.timeoutId && window.clearTimeout(this.timeoutId)
    }
  }
  class sd {
    constructor(e, t, n) {
      this.kind = "issue", this.updateIssuesScheduler = new od(6e4), this.issuesStore = e, this.repository = t, this.dispatcher = n
    }
    getRegExp() {
      return /(?:^|\n| )(?:#)([a-z\d\\+-][a-z\d_]*)?/g
    }
    getAutocompletionItems(e) {
      return this.updateIssuesScheduler.queue(() => {
        this.dispatcher.refreshIssues(this.repository)
      }), this.issuesStore.getIssuesMatching(this.repository, e)
    }
    renderItem(e) {
      return w.createElement("div", {
        className: "issue",
        key: e.number
      }, w.createElement("span", {
        className: "number"
      }, "#", e.number), w.createElement("span", {
        className: "title"
      }, e.title))
    }
    getCompletionText(e) {
      return "#" + e.number
    }
  }

  function ad(e, t) {
    return {
      username: t.login,
      name: t.name,
      email: t.email,
      endpoint: e.endpoint
    }
  }
  class ld {
    constructor(e, t, n) {
      this.kind = "user", this.gitHubUserStore = e, this.repository = t, this.account = n || null
    }
    getRegExp() {
      return /(?:^|\n| )(?:@)([a-z\d\\+-][a-z\d_-]*)?/g
    }
    async getAutocompletionItems(e) {
      const t = await this.gitHubUserStore.getMentionableUsersMatching(this.repository, e),
        n = this.account;
      return (n ? t.filter(e => e.login !== n.login) : t).map(e => ad(this.repository, e))
    }
    renderItem(e) {
      return w.createElement("div", {
        className: "user",
        key: e.username
      }, w.createElement("span", {
        className: "username"
      }, e.username), w.createElement("span", {
        className: "name"
      }, e.name))
    }
    getCompletionText(e) {
      return "@" + e.username
    }
    async exactMatch(e) {
      if (null === this.account) return null;
      const t = await this.gitHubUserStore.getByLogin(this.account, e);
      return t ? ad(this.repository, t) : null
    }
  }
  const cd = "https://avatars.githubusercontent.com",
    ud = new Sh(16, 16, "M13 13.145a.844.844 0 0 1-.832.855H3.834A.846.846 0 0 1 3 13.142v-.856c0-2.257 3.333-3.429 3.333-3.429s.191-.35 0-.857c-.7-.531-.786-1.363-.833-3.429C5.644 2.503 7.056 2 8 2s2.356.502 2.5 2.571C10.453 6.637 10.367 7.47 9.667 8c-.191.506 0 .857 0 .857S13 10.03 13 12.286v.859z"),
    hd = /^(?:(\d+)\+)?(.+?)@users\.noreply\.github\.com$/i;

  function pd(e, t = 64) {
    const n = new Array;
    if (void 0 === e) return n;
    const {
      email: r,
      endpoint: i,
      avatarURL: o
    } = e;
    if (i === pt()) {
      if (void 0 !== o) try {
        const e = new URL(o);
        e.searchParams.set("s", "" + t), n.push(e.toString())
      } catch (e) {
        n.push(o)
      }
    } else if (null !== i) return n.push(function (e, t = 60) {
      const n = e.trim().toLowerCase();
      return `https://www.gravatar.com/avatar/${Ge.createHash("md5").update(n).digest("hex")}?s=${t}`
    }(r, t)), n;
    const s = hd.exec(r);
    if (s) {
      const [, e, r] = s;
      if (void 0 !== e) {
        const r = encodeURIComponent(e);
        n.push(`${cd}/u/${r}?s=${t}`)
      } else {
        const e = encodeURIComponent(r);
        n.push(`${cd}/${e}?s=${t}`)
      }
    }
    const a = encodeURIComponent(r);
    return n.push(`${cd}/u/e?email=${a}&s=${t}`), n
  }
  class dd extends w.Component {
    constructor(e) {
      super(e), this.onImageError = e => {
        this.state.candidates.length > 0 && this.setState({
          candidates: this.state.candidates.slice(1)
        })
      }, this.onInternetConnected = () => {
        if (0 === this.state.candidates.length) {
          const {
            user: e,
            size: t
          } = this.props, n = pd(e, t);
          n.length > 0 && this.setState({
            candidates: n
          })
        }
      };
      const {
        user: t,
        size: n
      } = e;
      this.state = {
        user: t,
        candidates: pd(t, n)
      }
    }
    static getDerivedStateFromProps(e, t) {
      const {
        user: n,
        size: r
      } = e;
      if (!vu(n, t.user)) {
        return {
          user: n,
          candidates: pd(n, r)
        }
      }
      return null
    }
    getTitle() {
      if (null === this.props.title) return;
      if (void 0 === this.props.title) return this.props.title;
      const e = this.props.user;
      if (e) {
        const t = e.name;
        return t ? `${t} <${e.email}>` : e.email
      }
      return "Unknown user"
    }
    render() {
      const e = this.getTitle(),
        t = this.props.user ? "Avatar for " + (this.props.user.name || this.props.user.email) : "Avatar for unknown user";
      if (0 === this.state.candidates.length) return w.createElement(bh, {
        symbol: ud,
        className: "avatar",
        title: e
      });
      const n = this.state.candidates[0],
        r = w.createElement("img", {
          className: "avatar",
          title: e,
          src: n,
          alt: e,
          "aria-label": t,
          onError: this.onImageError
        });
      return void 0 === e ? r : w.createElement("span", {
        title: e,
        className: "avatar-container"
      }, r)
    }
    componentDidMount() {
      window.addEventListener("online", this.onInternetConnected)
    }
    componentWillUnmount() {
      window.removeEventListener("online", this.onInternetConnected)
    }
  }
  class fd extends w.Component {
    render() {
      return w.createElement(bh, {
        className: "spin",
        symbol: Sh.sync
      })
    }
  }
  var md = n(14),
    gd = n.n(md);

  function yd(e, t) {
    return e.posFromIndex(e.indexFromPos(t) - 1)
  }

  function vd(e, t) {
    return e.posFromIndex(e.indexFromPos(t) + 1)
  }

  function wd(e, t) {
    const n = e.getLine(t.line);
    return !!/\s/.test(n.charAt(t.ch)) || function (e, t) {
      const n = e.findMarksAt(t),
        r = e.indexFromPos(t);
      return n.some(t => {
        const n = t.find();
        if (!n) return !1;
        const i = e.indexFromPos(n.from),
          o = e.indexFromPos(n.to);
        return r > i && r < o
      })
    }(e, t)
  }

  function bd(e, t) {
    return e.line === t.line && e.ch === t.ch
  }

  function Sd(e, t, n, r) {
    return function (e, t, n, r) {
      let i = t;
      for (let o = r(e, t); n(e, o) && !bd(i, o); o = r(e, o)) i = o;
      return i
    }(e, t, (e, t) => !n(e, t), r)
  }

  function Cd(e, t, n) {
    const r = e.getDoc(),
      i = r.posFromIndex(1 / 0);
    r.replaceRange(t, i);
    const o = r.posFromIndex(1 / 0);
    return r.markText(i, o, n)
  }

  function Ed(e, t) {
    const n = e.find(),
      r = t.find();
    return void 0 === n || void 0 === r ? vt(n, r) : vt(n.from, r.from)
  }

  function kd(e, t, n) {
    const r = n.username,
      i = document.createElement("div");
    i.classList.add("user", "unknown");
    const o = document.createElement("span");
    o.className = "username", o.innerText = r, i.appendChild(o);
    const s = document.createElement("span");
    s.className = "description", s.innerText = "Search for user", i.appendChild(s), e.appendChild(i)
  }

  function xd(e, t, n) {
    const r = n.author,
      i = document.createElement("div");
    if (i.className = "user", r.username) {
      const e = document.createElement("span");
      e.className = "username", e.innerText = r.username, i.appendChild(e)
    }
    const o = document.createElement("span");
    o.className = "name", o.innerText = r.name, i.appendChild(o), e.appendChild(i)
  }

  function Td(e) {
    return e.email && e.email.length > 0 ? e.email : Ou(e.username, e.endpoint)
  }

  function Rd(e) {
    return null === e.username ? e.name : "@" + e.username
  }

  function Dd(e, t) {
    const n = document.createElement("span");
    n.classList.add("handle", t ? "error" : "progress"), n.title = t ? "Could not find user with username " + e : "Searching for @" + e;
    const r = t ? Sh.stop : Sh.sync,
      i = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    i.classList.add("icon"), t || i.classList.add("spin");
    const o = document.createElementNS("http://www.w3.org/2000/svg", "path");
    return i.viewBox.baseVal.width = r.w, i.viewBox.baseVal.height = r.h, o.setAttribute("d", r.d), i.appendChild(o), n.appendChild(document.createTextNode("@" + e)), n.appendChild(i), n
  }

  function _d(e, t, n, r) {
    const i = function (e) {
      const t = document.createElement("span");
      return t.classList.add("handle"), t.title = `${e.name} <${e.email}>`, t.innerText = Rd(e), t
    }(r);
    return e.markText(t, n, {
      atomic: !0,
      className: "handle",
      readOnly: !1,
      replacedWith: i,
      handleMouseEvents: !0
    })
  }

  function Ad(e) {
    const t = e.getDoc();
    if (t.somethingSelected()) return;
    const n = t.getCursor();
    bd(n, Sd(t, n, wd, yd)) || e.showHint()
  }

  function Md(e) {
    return {
      name: e.name || e.username,
      email: Td(e),
      username: e.username
    }
  }
  class Pd extends w.Component {
    constructor(e) {
      super(e), this.editor = null, this.resizeDebounceId = null, this.lastKnownWidth = null, this.hintActive = !1, this.label = null, this.placeholder = null, this.authors = [], this.markAuthorMap = new Map, this.authorMarkMap = new Map, this.onResized = () => {
        this.resizeDebounceId = null, this.editor && this.editor.refresh()
      }, this.onContainerRef = e => {
        e ? (this.editor = this.initializeCodeMirror(e), this.resizeObserver.observe(e)) : (this.editor = null, this.resizeObserver.disconnect())
      }, this.applyCompletion = (e, t, n) => {
        const r = n.from || t.from,
          i = n.to || t.to,
          o = n.author;
        this.insertAuthor(e, o, r, i), this.updateAuthors(e)
      }, this.applyUnknownUserCompletion = (e, t, n) => {
        const r = n.from || t.from,
          i = n.to || t.to,
          o = n.username,
          s = "@" + o,
          a = e.getDoc();
        a.replaceRange(s, r, i, "complete");
        const l = a.posFromIndex(a.indexFromPos(r) + s.length),
          c = a.markText(r, l, {
            atomic: !0,
            className: "handle progress",
            readOnly: !1,
            replacedWith: Dd(o, !1),
            handleMouseEvents: !0
          });
        return this.props.autoCompleteProvider.exactMatch(o).then(t => {
          e.operation(() => {
            const n = c.find();
            n && (c.clear(), t ? this.insertAuthor(e, Md(t), n.from, n.to) : a.markText(n.from, n.to, {
              atomic: !0,
              className: "handle error",
              readOnly: !1,
              replacedWith: Dd(o, !0),
              handleMouseEvents: !0
            }))
          })
        })
      }, this.onAutocompleteUser = async (e, t, n) => {
        const r = e.getDoc(),
          i = r.getCursor(),
          o = Sd(r, i, wd, yd),
          s = Sd(r, i, wd, vd),
          a = r.getRange(o, s).replace(/^@/, ""),
          l = await this.props.autoCompleteProvider.getAutocompletionItems(a),
          c = l.some(e => e.username.toLowerCase() === a.toLowerCase()),
          u = new Set(this.authors.map(e => e.username)),
          h = l.map(Md).filter(e => null === e.username || !u.has(e.username)).map(e => ({
            author: e,
            text: Rd(e),
            render: xd,
            className: "autocompletion-item",
            hint: this.applyCompletion
          }));
        return !c && a.length > 0 && h.push({
          text: "@" + a,
          username: a,
          render: kd,
          className: "autocompletion-item",
          hint: this.applyUnknownUserCompletion
        }), {
          list: h,
          from: o,
          to: s
        }
      }, this.resizeObserver = new ResizeObserver(e => {
        if (1 === e.length && this.editor) {
          const t = e[0].contentRect.width;
          if (!this.lastKnownWidth) return void(this.lastKnownWidth = t);
          this.lastKnownWidth !== t && (this.lastKnownWidth = t, null !== this.resizeDebounceId && (cancelAnimationFrame(this.resizeDebounceId), this.resizeDebounceId = null), this.resizeDebounceId = requestAnimationFrame(this.onResized))
        }
      }), this.state = {}
    }
    componentWillUnmount() {
      if (this.editor) {
        const e = this.editor.state;
        e.completionActive && e.completionActive.close && e.completionActive.close()
      }
    }
    componentWillReceiveProps(e) {
      const t = this.editor;
      t && (e.authors === this.props.authors || wu(this.authors, e.authors) || t.operation(() => {
        this.reset(t, e.authors)
      }), e.disabled !== this.props.disabled && t.setOption("readOnly", !!e.disabled && "nocursor"))
    }
    insertAuthor(e, t, n, r) {
      const i = Rd(t),
        o = e.getDoc();
      o.replaceRange(i, n, r, "complete");
      const s = o.posFromIndex(o.indexFromPos(n) + i.length),
        a = _d(o, n, s, t);
      return this.markAuthorMap.set(a, t), this.authorMarkMap.set(t, a), a
    }
    appendAuthor(e, t) {
      const n = e.getDoc();
      return this.insertAuthor(e, t, n.posFromIndex(1 / 0))
    }
    updatePlaceholderVisibility(e) {
      if (this.label && this.placeholder) {
        const t = this.label.find(),
          n = this.placeholder.find();
        if (!t || !n) return;
        const r = e.getDoc(),
          i = r.indexFromPos(t.to) !== r.indexFromPos(n.from);
        this.placeholder.collapsed !== i && (this.placeholder.collapsed = i, this.placeholder.changed())
      }
    }
    getAllHandleMarks(e) {
      return e.getDoc().getAllMarks()
    }
    initializeCodeMirror(e) {
      const t = {
          mode: null,
          lineWrapping: !0,
          extraKeys: {
            Tab: !1,
            Enter: !1,
            "Shift-Tab": !1,
            "Ctrl-Space": "autocomplete",
            "Ctrl-Enter": !1,
            "Cmd-Enter": !1,
            "Ctrl-F": !1,
            "Ctrl-G": !1,
            "Shift-Ctrl-G": !1,
            "Shift-Ctrl-F": !1,
            "Shift-Ctrl-R": !1
          },
          readOnly: !!this.props.disabled && "nocursor",
          hintOptions: {
            completeOnSingleClick: !0,
            completeSingle: !1,
            closeOnUnfocus: !0,
            closeCharacters: /\s/,
            hint: this.onAutocompleteUser
          }
        },
        n = gd()(e, t);
      n.operation(() => {
        this.reset(n, this.props.authors)
      }), n.on("startCompletion", () => {
        this.hintActive = !0
      }), n.on("endCompletion", () => {
        this.hintActive = !1
      }), n.on("change", () => {
        this.updatePlaceholderVisibility(n), this.hintActive || Ad(n)
      }), n.on("focus", () => {
        this.hintActive || Ad(n)
      }), n.on("changes", () => {
        this.updateAuthors(n)
      });
      const r = n.getWrapperElement();
      return r.addEventListener("keypress", e => {
        e.defaultPrevented || "Enter" !== e.key || e.preventDefault()
      }), r.addEventListener("contextmenu", e => {
        this.onContextMenu(n, e)
      }), n
    }
    onContextMenu(e, t) {
      t.preventDefault();
      const n = [{
        label: "Undo",
        action: () => e.getDoc().undo()
      }, {
        label: "Redo",
        action: () => e.getDoc().redo()
      }, {
        type: "separator"
      }, {
        role: "cut"
      }, {
        role: "copy"
      }, {
        role: "paste"
      }];
      n.push({
        type: "separator"
      }), n.push({
        label: "Select all",
        action: () => {
          e.execCommand("selectAll")
        }
      }), ie(n)
    }
    updateAuthors(e) {
      const t = this.getAllHandleMarks(e).sort(Ed),
        n = new Array;
      for (const e of t) {
        const t = this.markAuthorMap.get(e);
        t && n.push(t)
      }
      wu(this.authors, n) || (this.authors = n, this.props.onAuthorsUpdated(n))
    }
    reset(e, t) {
      const n = e.getDoc();
      e.setValue(""), n.clearHistory(), this.authors = [], this.authorMarkMap.clear(), this.markAuthorMap.clear(), this.label = Cd(e, "Co-Authors ", {
        atomic: !0,
        inclusiveLeft: !0,
        className: "label",
        readOnly: !0
      });
      for (const n of t) this.appendAuthor(e, n);
      this.authors = this.props.authors, this.placeholder = Cd(e, "@username", {
        atomic: !0,
        inclusiveRight: !0,
        className: "placeholder",
        readOnly: !0,
        collapsed: t.length > 0
      }), n.setCursor(this.placeholder.find().from)
    }
    render() {
      const e = mh()("author-input-component", this.props.className, {
        disabled: this.props.disabled
      });
      return w.createElement("div", {
        className: e,
        ref: this.onContainerRef
      })
    }
  }

  function Id(e, t) {
    return () => {
      const n = ((performance.now() - e) / 1e3).toFixed(3),
        r = `[Timing] ${t} took ${n}s`;
      log.info(r)
    }
  }

  function Od(e, t) {
    const n = performance && performance.now ? performance.now() : null;
    if (null === n) return log.warn("[Timing] invoked but performance.now not found - are you using this outside the renderer?"), {
      done: () => {}
    };
    return {
      done: Id(n, `Action '${e}' for '${to(t)}'`)
    }
  }
  const Ld = e => w.createElement("div", {
      id: "permissions-commit-warning",
      onContextMenu: Nd
    }, w.createElement("div", {
      className: "warning-icon-container"
    }, w.createElement(bh, {
      className: "warning-icon",
      symbol: Sh.alert
    })), w.createElement("div", {
      className: "warning-message"
    }, e.children)),
    Nd = e => {
      e.preventDefault()
    };

  function Fd(e, t) {
    if (!t) return !1;
    const n = t.owner.endpoint,
      {
        name: r,
        email: i
      } = e.committer;
    if (n === pt() && "GitHub" === r && "noreply@github.com" === i) return !0;
    if ("GitHub Enterprise" === r) {
      const e = new URL(n).host.toLowerCase();
      return i.endsWith("@" + e)
    }
    return !1
  }

  function Bd(e, t) {
    return {
      email: e.email,
      name: e.name,
      endpoint: null === t ? null : t.endpoint,
      avatarURL: void 0
    }
  }

  function Hd(e, t) {
    const n = [];
    n.push(Bd(t.author, e)), n.push(...t.coAuthors.map(t => Bd(t, e)));
    const r = t.coAuthors.some(e => e.name === t.committer.name && e.email === t.committer.email),
      i = null !== e && Fd(t, e);
    return t.authoredByCommitter || i || r || n.push(Bd(t.committer, e)), n
  }
  const zd = new Sh(12, 7, "M9.875 2.125H12v1.75H9.875V6h-1.75V3.875H6v-1.75h2.125V0h1.75v2.125zM6 6.5a.5.5 0 0 1-.5.5h-5a.5.5 0 0 1-.5-.5V6c0-1.316 2-2 2-2s.114-.204 0-.5c-.42-.31-.472-.795-.5-2C1.587.293 2.434 0 3 0s1.413.293 1.5 1.5c-.028 1.205-.08 1.69-.5 2-.114.295 0 .5 0 .5s2 .684 2 2v.5z");

  function Ud(e) {
    for (const t of e)
      if (t instanceof ld) return t;
    return null
  }
  class Wd extends w.Component {
    constructor(e) {
      super(e), this.descriptionComponent = null, this.summaryTextInput = null, this.descriptionTextArea = null, this.descriptionTextAreaScrollDebounceId = null, this.onSummaryChanged = e => {
        this.setState({
          summary: e
        })
      }, this.onDescriptionChanged = e => {
        this.setState({
          description: e
        })
      }, this.onSubmit = () => {
        this.createCommit()
      }, this.onKeyDown = e => {
        if (e.defaultPrevented) return;
        e.ctrlKey && "Enter" === e.key && this.canCommit() && (this.createCommit(), e.preventDefault())
      }, this.onCoAuthorsUpdated = e => {
        this.props.dispatcher.setCoAuthors(this.props.repository, e)
      }, this.onToggleCoAuthors = () => {
        this.props.dispatcher.setShowCoAuthoredBy(this.props.repository, !this.props.showCoAuthoredBy)
      }, this.onContextMenu = e => {
        if (e.defaultPrevented) return;
        e.preventDefault();
        ie([this.getAddRemoveCoAuthorsMenuItem()])
      }, this.onAutocompletingInputContextMenu = e => {
        e.preventDefault();
        ie([this.getAddRemoveCoAuthorsMenuItem(), {
          type: "separator"
        }, {
          role: "editMenu"
        }])
      }, this.onCoAuthorToggleButtonClick = e => {
        e.preventDefault(), this.onToggleCoAuthors()
      }, this.onDescriptionFieldRef = e => {
        this.descriptionComponent = e
      }, this.onDescriptionTextAreaScroll = () => {
        this.descriptionTextAreaScrollDebounceId = null;
        const e = this.descriptionTextArea,
          t = null !== e && e.scrollTop + e.offsetHeight < e.scrollHeight;
        this.state.descriptionObscured !== t && this.setState({
          descriptionObscured: t
        })
      }, this.onDescriptionTextAreaRef = e => {
        if (e) {
          const t = () => {
            null !== this.descriptionTextAreaScrollDebounceId && (cancelAnimationFrame(this.descriptionTextAreaScrollDebounceId), this.descriptionTextAreaScrollDebounceId = null), this.descriptionTextAreaScrollDebounceId = requestAnimationFrame(this.onDescriptionTextAreaScroll)
          };
          e.addEventListener("input", t), e.addEventListener("scroll", t)
        }
        this.descriptionTextArea = e
      }, this.onSummaryInputRef = e => {
        this.summaryTextInput = e
      }, this.onFocusContainerClick = e => {
        this.descriptionComponent && this.descriptionComponent.focus()
      }, this.onSwitchBranch = () => {
        this.props.dispatcher.showFoldout({
          type: V.Branch
        })
      }, this.onMakeFork = () => {
        Ji(this.props.repository) && this.props.dispatcher.showCreateForkDialog(this.props.repository)
      };
      const {
        commitMessage: t
      } = this.props;
      this.state = {
        summary: t ? t.summary : "",
        description: t ? t.description : null,
        userAutocompletionProvider: Ud(e.autocompletionProviders),
        descriptionObscured: !1
      }
    }
    componentWillUnmount() {
      this.props.dispatcher.setCommitMessage(this.props.repository, {
        summary: this.state.summary,
        description: this.state.description
      })
    }
    componentWillReceiveProps(e) {
      const {
        commitMessage: t
      } = e;
      t && t !== this.props.commitMessage && ("" !== this.state.summary || this.state.description || this.setState({
        summary: t.summary,
        description: t.description
      }))
    }
    componentDidUpdate(e) {
      this.props.autocompletionProviders !== e.autocompletionProviders && this.setState({
        userAutocompletionProvider: Ud(this.props.autocompletionProviders)
      }), this.props.focusCommitMessage && this.focusSummary()
    }
    clearCommitMessage() {
      this.setState({
        summary: "",
        description: null
      })
    }
    focusSummary() {
      null !== this.summaryTextInput && (this.summaryTextInput.focus(), this.props.dispatcher.setCommitMessageFocus(!1))
    }
    getCoAuthorTrailers() {
      return this.isCoAuthorInputEnabled ? this.props.coAuthors.map(e => ({
        token: "Co-Authored-By",
        value: `${e.name} <${e.email}>`
      })) : []
    }
    async createCommit() {
      const {
        summary: e,
        description: t
      } = this.state;
      if (!this.canCommit()) return;
      const n = this.getCoAuthorTrailers(),
        r = {
          summary: this.props.prepopulateCommitSummary && !this.state.summary ? this.props.placeholder : e,
          description: t,
          trailers: n
        },
        i = Od("create commit", this.props.repository),
        o = await this.props.onCreateCommit(r);
      i.done(), o && this.clearCommitMessage()
    }
    canCommit() {
      return this.props.anyFilesSelected && this.state.summary.length > 0 || this.props.prepopulateCommitSummary
    }
    renderAvatar() {
      const {
        commitAuthor: e,
        repository: t
      } = this.props, {
        gitHubRepository: n
      } = t, r = e ? `Committing as ${e.name} <${e.email}>` : void 0, i = null !== e ? Bd(e, n) : void 0;
      return w.createElement(dd, {
        user: i,
        title: r
      })
    }
    get isCoAuthorInputEnabled() {
      return null !== this.props.repository.gitHubRepository
    }
    get isCoAuthorInputVisible() {
      return this.props.showCoAuthoredBy && this.isCoAuthorInputEnabled
    }
    renderCoAuthorInput() {
      if (!this.isCoAuthorInputVisible) return null;
      const e = this.state.userAutocompletionProvider;
      return e ? w.createElement(Pd, {
        onAuthorsUpdated: this.onCoAuthorsUpdated,
        authors: this.props.coAuthors,
        autoCompleteProvider: e,
        disabled: this.props.isCommitting
      }) : null
    }
    get toggleCoAuthorsText() {
      return this.props.showCoAuthoredBy ? "Remove co-authors" : "Add co-authors"
    }
    getAddRemoveCoAuthorsMenuItem() {
      return {
        label: this.toggleCoAuthorsText,
        action: this.onToggleCoAuthors,
        enabled: null !== this.props.repository.gitHubRepository && !this.props.isCommitting
      }
    }
    renderCoAuthorToggleButton() {
      return null === this.props.repository.gitHubRepository ? null : w.createElement("button", {
        className: "co-authors-toggle",
        onClick: this.onCoAuthorToggleButtonClick,
        tabIndex: -1,
        "aria-label": this.toggleCoAuthorsText,
        disabled: this.props.isCommitting
      }, w.createElement(bh, {
        symbol: zd
      }))
    }
    get isActionBarEnabled() {
      return this.isCoAuthorInputEnabled
    }
    renderActionBar() {
      if (!this.isCoAuthorInputEnabled) return null;
      const e = mh()("action-bar", {
        disabled: this.props.isCommitting
      });
      return w.createElement("div", {
        className: e
      }, this.renderCoAuthorToggleButton())
    }
    renderPermissionsCommitWarning() {
      const {
        showBranchProtected: e,
        showNoWriteAccess: t,
        repository: n,
        branch: r
      } = this.props;
      return t ? w.createElement(Ld, null, "You don't have write access to ", w.createElement("strong", null, n.name), ". Want to", " ", w.createElement(Ip, {
        onClick: this.onMakeFork
      }, "create a fork"), "?") : e ? null === r ? null : w.createElement(Ld, null, w.createElement("strong", null, r), " is a protected branch. Want to", " ", w.createElement(Ip, {
        onClick: this.onSwitchBranch
      }, "switch branches"), "?") : null
    }
    render() {
      const e = this.state.summary.match(/^\s+$/g),
        t = this.canCommit() && !this.props.isCommitting && !e,
        n = this.props.isCommitting ? w.createElement(fd, null) : void 0,
        r = mh()({
          "with-action-bar": this.isActionBarEnabled,
          "with-co-authors": this.isCoAuthorInputVisible
        }),
        i = mh()("description-field", {
          "with-overflow": this.state.descriptionObscured
        }),
        o = mh()("summary-field", "nudge-arrow", {
          "nudge-arrow-left": this.props.shouldNudge
        }),
        s = this.props.branch,
        a = n ? "Committing" : "Commit",
        l = null !== s ? `${a} to ${s}` : a,
        c = null !== s ? w.createElement(w.Fragment, null, a, " to ", w.createElement("strong", null, s)) : a;
      return w.createElement("div", {
        id: "commit-message",
        role: "group",
        "aria-label": "Create commit",
        className: r,
        onContextMenu: this.onContextMenu,
        onKeyDown: this.onKeyDown
      }, w.createElement("div", {
        className: "summary"
      }, this.renderAvatar(), w.createElement(rd, {
        isRequired: !0,
        className: o,
        placeholder: this.props.placeholder,
        value: this.state.summary,
        onValueChanged: this.onSummaryChanged,
        onElementRef: this.onSummaryInputRef,
        autocompletionProviders: this.props.autocompletionProviders,
        onContextMenu: this.onAutocompletingInputContextMenu,
        disabled: this.props.isCommitting
      })), w.createElement(Rp, {
        className: "description-focus-container",
        onClick: this.onFocusContainerClick
      }, w.createElement(nd, {
        className: i,
        placeholder: "说明",
        value: this.state.description || "",
        onValueChanged: this.onDescriptionChanged,
        autocompletionProviders: this.props.autocompletionProviders,
        ref: this.onDescriptionFieldRef,
        onElementRef: this.onDescriptionTextAreaRef,
        onContextMenu: this.onAutocompletingInputContextMenu,
        disabled: this.props.isCommitting
      }), this.renderActionBar()), this.renderCoAuthorInput(), this.renderPermissionsCommitWarning(), w.createElement(jp, {
        type: "submit",
        className: "commit-button",
        onClick: this.onSubmit,
        disabled: !t
      }, n, w.createElement("span", {
        title: l
      }, c)))
    }
  }

  function Vd(e, t) {
    if (e.length <= t) return e;
    if (t <= 0) return "";
    if (1 === t) return "…";
    const n = (t - 1) / 2;
    return `${e.substr(0,Math.floor(n))}…${e.substr(e.length-Math.ceil(n))}`
  }

  function jd(e, t) {
    if ((t = void 0 === t ? e.length : t) <= 0) return {
      normalizedPath: e,
      directoryText: "",
      fileText: "",
      length: t
    };
    const {
      normalizedFileName: n,
      normalizedDirectory: r
    } = function (e) {
      e = e.endsWith("/") ? e.substr(0, e.length - 1) : e;
      const t = i.basename(e);
      return {
        normalizedFileName: t,
        normalizedDirectory: e.substr(0, e.length - t.length)
      }
    }(e);
    if (t >= e.length) return {
      normalizedPath: e,
      directoryText: r,
      fileText: n,
      length: t
    };
    const o = function (e, t) {
      if (e.length <= t) return e;
      if (t <= 0) return "";
      if (1 === t) return "…";
      const n = e.lastIndexOf(i.sep);
      if (-1 === n) return Vd(e, t);
      const r = e.length - n - 1;
      return r + 2 > t ? Vd(e, t) : `${e.substr(0,t-r-2)}…${e.substr(n)}`
    }(e, t);
    let s = 0;
    for (let e = 0; e < o.length && e < r.length; e++) {
      const t = r[e],
        n = o[e];
      if (t !== n) {
        if ("…" === n) {
          s++;
          const t = e + 1;
          o.length > t && o[t] === i.sep && s++
        }
        break
      }
      s++
    }
    const a = o.substr(s);
    return {
      normalizedPath: e,
      directoryText: o.substr(0, s),
      fileText: a,
      length: t
    }
  }

  function Gd(e, t) {
    const n = i.normalize(e);
    return Object.assign({
      longestFit: 0,
      shortestNonFit: void 0,
      availableWidth: void 0,
      fullTextWidth: void 0
    }, jd(n, t))
  }
  class $d extends w.PureComponent {
    constructor(e) {
      super(e), this.pathElement = null, this.pathInnerElement = null, this.onDialogShow = e => {
        const t = e.target;
        t instanceof Element && t.contains(this.pathElement) && this.resizeIfNecessary()
      }, this.onPathElementRef = e => {
        this.pathElement = e
      }, this.onPathInnerElementRef = e => {
        this.pathInnerElement = e
      }, this.state = Gd(e.path)
    }
    componentWillReceiveProps(e) {
      e.path !== this.props.path && this.setState(Gd(e.path))
    }
    componentDidMount() {
      this.resizeIfNecessary(), document.addEventListener("dialog-show", this.onDialogShow)
    }
    componentWillUnmount() {
      document.removeEventListener("dialog-show", this.onDialogShow)
    }
    componentDidUpdate() {
      this.resizeIfNecessary()
    }
    render() {
      const e = this.state.directoryText && this.state.directoryText.length ? w.createElement("span", {
          className: "dirname"
        }, this.state.directoryText) : null,
        t = this.state.length < this.state.normalizedPath.length ? this.state.normalizedPath : void 0;
      return w.createElement("div", {
        className: "path-text-component",
        ref: this.onPathElementRef,
        title: t
      }, w.createElement("span", {
        ref: this.onPathInnerElementRef
      }, e, w.createElement("span", {
        className: "filename"
      }, this.state.fileText)))
    }
    resizeIfNecessary() {
      if (!this.pathElement || !this.pathInnerElement) return;
      const e = void 0 !== this.props.availableWidth ? this.props.availableWidth : this.pathElement.getBoundingClientRect().width,
        t = Math.max(e, 0);
      if (void 0 !== this.state.fullTextWidth && this.state.fullTextWidth <= t) return this.state.length === this.state.normalizedPath.length ? void(t !== this.state.availableWidth && this.setState(Object.assign(Object.assign({}, this.state), {
        availableWidth: t
      }))) : void this.setState(Object.assign(Object.assign(Object.assign({}, this.state), jd(this.state.normalizedPath)), {
        availableWidth: t
      }));
      if (void 0 !== this.state.availableWidth && this.state.availableWidth !== t) {
        const e = Gd(this.props.path, this.state.length);
        return void(t < this.state.availableWidth ? this.setState(Object.assign(Object.assign({}, e), {
          fullTextWidth: this.state.fullTextWidth,
          shortestNonFit: this.state.shortestNonFit,
          availableWidth: t
        })) : t > this.state.availableWidth && this.setState(Object.assign(Object.assign({}, e), {
          fullTextWidth: this.state.fullTextWidth,
          longestFit: this.state.longestFit,
          availableWidth: t
        })))
      }
      if (0 === t) return void(0 !== this.state.length && this.setState(Object.assign(Object.assign(Object.assign({}, this.state), jd(this.state.normalizedPath, 0)), {
        availableWidth: t,
        longestFit: 0,
        shortestNonFit: 1
      })));
      const n = this.pathInnerElement.getBoundingClientRect().width,
        r = this.state.length === this.state.normalizedPath.length ? n : this.state.fullTextWidth,
        i = 0 === n ? .5 : t / n;
      if (n <= t) {
        if (this.state.length === this.state.normalizedPath.length) return void this.setState(Object.assign(Object.assign({}, this.state), {
          availableWidth: t,
          fullTextWidth: r
        })); {
          const e = this.state.length,
            o = void 0 !== this.state.shortestNonFit ? this.state.shortestNonFit - 1 : this.state.normalizedPath.length,
            s = e + 1;
          if (s >= o) return void this.setState(Object.assign(Object.assign({}, this.state), {
            longestFit: e,
            availableWidth: t,
            fullTextWidth: r
          }));
          if (t - n < 3) return void this.setState(Object.assign(Object.assign({}, this.state), {
            longestFit: e,
            availableWidth: t,
            fullTextWidth: r
          }));
          const a = fl(Math.floor(this.state.length * i), s, o);
          this.setState(Object.assign(Object.assign(Object.assign({}, this.state), jd(this.state.normalizedPath, a)), {
            longestFit: e,
            availableWidth: t,
            fullTextWidth: r
          }))
        }
      } else {
        const e = this.state.length,
          n = e - 1,
          o = this.state.longestFit || 0,
          s = fl(Math.floor(this.state.length * i), o, n);
        this.setState(Object.assign(Object.assign(Object.assign({}, this.state), jd(this.state.normalizedPath, s)), {
          shortestNonFit: e,
          availableWidth: t,
          fullTextWidth: r
        }))
      }
    }
  }
  class qd extends w.Component {
    render() {
      const e = {
          className: "path-label-component"
        },
        {
          status: t
        } = this.props,
        n = this.props.availableWidth;
      if (t.kind === Ki.Renamed || t.kind === Ki.Copied) {
        const r = n ? n / 2 - 10 : void 0;
        return w.createElement("label", Object.assign({}, e), w.createElement($d, {
          path: t.oldPath,
          availableWidth: r
        }), w.createElement(bh, {
          className: "rename-arrow",
          symbol: Sh.arrowRight
        }), w.createElement($d, {
          path: this.props.path,
          availableWidth: r
        }))
      }
      return w.createElement("label", Object.assign({}, e), w.createElement($d, {
        path: this.props.path,
        availableWidth: n
      }))
    }
  }
  class Kd extends w.Component {
    constructor() {
      super(...arguments), this.handleCheckboxChange = e => {
        const t = e.currentTarget.checked;
        this.props.onIncludeChanged(this.props.file.path, t)
      }, this.onContextMenu = e => {
        this.props.onContextMenu(this.props.file, e)
      }
    }
    get checkboxValue() {
      return !0 === this.props.include ? Zp.On : !1 === this.props.include ? Zp.Off : Zp.Mixed
    }
    render() {
      const {
        status: e,
        path: t
      } = this.props.file, n = Ul(e), r = this.props.availableWidth - 20 - 20 - 5 - 16;
      return w.createElement("div", {
        className: "file",
        onContextMenu: this.onContextMenu
      }, w.createElement(Xp, {
        tabIndex: -1,
        value: this.checkboxValue,
        onChange: this.handleCheckboxChange,
        disabled: this.props.disableSelection
      }), w.createElement(qd, {
        path: t,
        status: e,
        availableWidth: r
      }), w.createElement(bh, {
        symbol: Eh(e),
        className: "status status-" + n.toLowerCase(),
        title: n
      }))
    }
  }
  class Yd extends w.Component {
    constructor() {
      super(...arguments), this.onSubmit = async () => {
        const {
          rebaseConflictState: e
        } = this.props;
        await this.props.dispatcher.continueRebase(this.props.repository, this.props.workingDirectory, e)
      }
    }
    render() {
      const {
        manualResolutions: e
      } = this.props.rebaseConflictState;
      let t = !0,
        n = "Continue rebase";
      Ql(this.props.workingDirectory, e).length > 0 && (n = "Resolve all conflicts before continuing", t = !1);
      const r = t && !this.props.isCommitting,
        i = this.props.isCommitting ? w.createElement(fd, null) : void 0,
        o = this.props.hasUntrackedChanges ? w.createElement("div", {
          className: "warning-untracked-files"
        }, "Untracked files will be excluded") : void 0;
      return w.createElement("div", {
        id: "continue-rebase"
      }, w.createElement(jp, {
        type: "submit",
        className: "commit-button",
        onClick: this.onSubmit,
        disabled: !r,
        tooltip: n
      }, i, w.createElement("span", null, void 0 !== i ? "Rebasing" : "Continue rebase")), o)
    }
  }
  const Qd = new Sh(16, 16, "M3.002 15H15V4c.51 0 1 .525 1 .996V15c0 .471-.49 1-1 1H4.002c-.51 0-1-.529-1-1zm-2-2H13V2c.51 0 1 .525 1 .996V13c0 .471-.49 1-1 1H2.002c-.51 0-1-.529-1-1zm10.14-13A.86.86 0 0 1 12 .857v10.286a.86.86 0 0 1-.857.857H.857A.86.86 0 0 1 0 11.143V.857A.86.86 0 0 1 .857 0h10.286zM11 11V1H1v10h10zM3 6c0-1.66 1.34-3 3-3s3 1.34 3 3-1.34 3-3 3-3-1.34-3-3z");

  function Zd(e, t) {
    if (null !== t) {
      if (0 === e.files.length) return Zp.Off;
      if (e.files.every(e => e.status.kind === Ki.Untracked)) return Zp.Off;
      return e.files.every(e => e.status.kind !== Ki.Untracked) ? Zp.On : Zp.Mixed
    }
    const {
      includeAll: n
    } = e;
    return !0 === n ? Zp.On : !1 === n ? Zp.Off : Zp.Mixed
  }

  function Xd(e) {
    const t = e.selectedFileIDs,
      n = [];
    for (const r of t) {
      const t = e.workingDirectory.findFileIndexByID(r); - 1 !== t && n.push(t)
    }
    return n
  }
  class Jd extends w.Component {
    constructor(e) {
      super(e), this.onIncludeAllChanged = e => {
        const t = e.currentTarget.checked;
        this.props.onSelectAll(t)
      }, this.renderRow = e => {
        const {
          workingDirectory: t,
          rebaseConflictState: n,
          isCommitting: r,
          onIncludeChanged: i,
          availableWidth: o
        } = this.props, s = t.files[e], a = s.selection.getSelectionType(), l = a === Ii.All || a !== Ii.None && null, c = null !== n ? s.status.kind !== Ki.Untracked : l, u = r || null !== n;
        return w.createElement(Kd, {
          file: s,
          include: c,
          key: s.id,
          onContextMenu: this.onItemContextMenu,
          onIncludeChanged: i,
          availableWidth: o,
          disableSelection: u
        })
      }, this.onDiscardAllChanges = () => {
        this.props.onDiscardChangesFromFiles(this.props.workingDirectory.files, !0)
      }, this.onStashChanges = () => {
        this.props.dispatcher.createStashForCurrentBranch(this.props.repository)
      }, this.onDiscardChanges = e => {
        const t = this.props.workingDirectory;
        if (1 === e.length) {
          const n = t.files.find(t => t.path === e[0]);
          null != n && this.props.onDiscardChanges(n)
        } else {
          const n = new Array;
          if (e.forEach(e => {
              const r = t.files.find(t => t.path === e);
              null != r && n.push(r)
            }), n.length > 0) {
            const e = n.length === t.files.length;
            this.props.onDiscardChangesFromFiles(n, e)
          }
        }
      }, this.getDiscardChangesMenuItemLabel = e => {
        const t = 1 === e.length ? "放弃更改" : `放弃${e.length}个已选择的更改`;
        return this.props.askForConfirmationOnDiscardChanges ? t + "…" : t
      }, this.onContextMenu = e => {
        if (e.preventDefault(), null !== this.props.rebaseConflictState || this.props.isCommitting) return;
        const t = this.props.workingDirectory.files.length > 0,
          n = null !== this.props.stashEntry,
          r = null !== this.props.conflictState || Vl(this.props.workingDirectory);
        ie([{
          label: "放弃所有更改…",
          action: this.onDiscardAllChanges,
          enabled: t
        }, {
          label: n ? "隐藏所有更改…" : "隐藏所有更改",
          action: this.onStashChanges,
          enabled: t && null !== this.props.branch && !r
        }])
      }, this.getDiscardChangesMenuItem = e => ({
        label: this.getDiscardChangesMenuItemLabel(e),
        action: () => this.onDiscardChanges(e)
      }), this.getCopyPathMenuItem = e => ({
        label: "复制文件路径",
        action: () => {
          const t = i.join(this.props.repository.path, e.path);
          r.clipboard.writeText(t)
        }
      }), this.getRevealInFileManagerMenuItem = e => ({
        label: "在资源管理器中显示",
        action: () => te(this.props.repository, e.path),
        enabled: e.status.kind !== Ki.Deleted
      }), this.getOpenInExternalEditorMenuItem = (e, t) => {
        const {
          externalEditorLabel: n,
          repository: r
        } = this.props;
        return {
          label: n ? "用" + n +"打开": "在外部编辑器中打开",
          action: () => {
            const t = i.join(r.path, e.path);
            this.props.onOpenInExternalEditor(t)
          },
          enabled: t
        }
      }, this.onItemContextMenu = (e, t) => {
        if (this.props.isCommitting) return;
        t.preventDefault();
        ie(null === this.props.rebaseConflictState ? this.getDefaultContextMenu(e) : this.getRebaseContextMenu(e))
      }, this.onScroll = (e, t) => {
        this.props.onChangesListScrolled(e)
      }, this.renderCommitMessageForm = () => {
        const {
          rebaseConflictState: e,
          workingDirectory: t,
          repository: n,
          dispatcher: r,
          isCommitting: i,
          currentBranchProtected: o
        } = this.props;
        if (null !== e) {
          const o = t.files.some(e => e.status.kind === Ki.Untracked);
          return w.createElement(Yd, {
            dispatcher: r,
            repository: n,
            rebaseConflictState: e,
            workingDirectory: t,
            isCommitting: i,
            hasUntrackedChanges: o
          })
        }
        const s = t.files.length,
          a = Zd(t, e),
          l = s > 0 && a !== Zp.Off,
          c = t.files.filter(e => e.selection.getSelectionType() !== Ii.None),
          u = 1 === c.length && !n.isTutorialRepository,
          h = null === this.props.repository.gitHubRepository || ji(this.props.repository.gitHubRepository);
        return w.createElement(Wd, {
          onCreateCommit: this.props.onCreateCommit,
          branch: this.props.branch,
          commitAuthor: this.props.commitAuthor,
          anyFilesSelected: l,
          repository: n,
          dispatcher: r,
          commitMessage: this.props.commitMessage,
          focusCommitMessage: this.props.focusCommitMessage,
          autocompletionProviders: this.props.autocompletionProviders,
          isCommitting: i,
          showCoAuthoredBy: this.props.showCoAuthoredBy,
          coAuthors: this.props.coAuthors,
          placeholder: this.getPlaceholderMessage(c, u),
          prepopulateCommitSummary: u,
          key: n.id,
          showBranchProtected: s > 0 && o,
          showNoWriteAccess: s > 0 && !h,
          shouldNudge: this.props.shouldNudgeToCommit
        })
      }, this.onStashEntryClicked = () => {
        const {
          isShowingStashEntry: e,
          dispatcher: t,
          repository: n
        } = this.props;
        e ? (t.selectWorkingDirectoryFiles(n), t.recordNoActionTakenOnStash()) : (t.selectStashedFile(n), t.recordStashView())
      }, this.onRowKeyDown = (e, t) => {
        !this.props.isCommitting || "Enter" !== t.key && " " !== t.key || t.preventDefault()
      }, this.state = {
        selectedRows: Xd(e)
      }
    }
    componentWillReceiveProps(e) {
      wu(e.selectedFileIDs, this.props.selectedFileIDs) && wu(e.workingDirectory.files, this.props.workingDirectory.files) || this.setState({
        selectedRows: Xd(e)
      })
    }
    getDefaultContextMenu(e) {
      const {
        id: t,
        path: n,
        status: r
      } = e, o = Ah(i.extname(n)), {
        workingDirectory: s,
        selectedFileIDs: a
      } = this.props, l = new Array, c = new Array, u = new Set, h = e => {
        const t = s.findFileWithID(e);
        if (t) {
          l.push(t), c.push(t.path);
          const e = i.extname(t.path);
          e.length && u.add(e)
        }
      };
      a.includes(t) ? a.forEach(h) : h(t);
      const p = [this.getDiscardChangesMenuItem(c), {
        type: "separator"
      }];
      1 === c.length ? p.push({
        label: "忽略文件（添加到.gitignore）",
        action: () => this.props.onIgnore(n),
        enabled: ".gitignore" !== i.basename(n)
      }) : c.length > 1 && p.push({
        label: `忽略${c.length}个选定的文件（添加到.gitignore）`,
        action: () => {
          this.props.onIgnore(c.filter(e => ".gitignore" !== i.basename(e)))
        },
        enabled: c.some(e => ".gitignore" !== i.basename(e))
      }), Array.from(u).slice(0, 5).forEach(e => {
        p.push({
          label: `忽略所有${e}个文件（添加到.gitignore）`,
          action: () => this.props.onIgnore("*" + e)
        })
      });
      const d = o && r.kind !== Ki.Deleted;
      return p.push({
        type: "separator"
      }, this.getCopyPathMenuItem(e), this.getRevealInFileManagerMenuItem(e), this.getOpenInExternalEditorMenuItem(e, d), {
        label: "用默认程序打开",
        action: () => this.props.onOpenItem(n),
        enabled: d
      }), p
    }
    getRebaseContextMenu(e) {
      const {
        path: t,
        status: n
      } = e, r = Ah(i.extname(t)), o = new Array;
      e.status.kind === Ki.Untracked && o.push(this.getDiscardChangesMenuItem([e.path]), {
        type: "separator"
      });
      const s = r && n.kind !== Ki.Deleted;
      return o.push(this.getCopyPathMenuItem(e), this.getRevealInFileManagerMenuItem(e), this.getOpenInExternalEditorMenuItem(e, s), {
        label: "Open with default program",
        action: () => this.props.onOpenItem(t),
        enabled: s
      }), o
    }
    getPlaceholderMessage(e, t) {
      if (!t) return "摘要（必填）";
      const n = e[0],
        r = Object(i.basename)(n.path);
      switch (n.status.kind) {
        case Ki.New:
        case Ki.Untracked:
          return "新建 " + r;
        case Ki.Deleted:
          return "删除 " + r;
        default:
          return "更新 " + r
      }
    }
    renderStashedChanges() {
      if (null === this.props.stashEntry) return null;
      const e = mh()("stashed-changes-button", this.props.isShowingStashEntry ? "selected" : null);
      return w.createElement("button", {
        className: e,
        onClick: this.onStashEntryClicked,
        tabIndex: 0,
        "aria-selected": this.props.isShowingStashEntry
      }, w.createElement(bh, {
        className: "stack-icon",
        symbol: Qd
      }), w.createElement("div", {
        className: "text"
      }, "Stashed Changes"), w.createElement(bh, {
        symbol: Sh.chevronRight
      }))
    }
    render() {
      const e = this.props.workingDirectory.files.length,
        t = `${e} changed ${1===e?"file":"files"}`,
        n = this.props.workingDirectory.files.filter(e => e.selection.getSelectionType() !== Ii.None).length,
        r = `${n} changed ${1===n?"file":"files"} selected`,
        i = Zd(this.props.workingDirectory, this.props.rebaseConflictState),
        o = 0 === e || this.props.isCommitting || null !== this.props.rebaseConflictState;
      return w.createElement("div", {
        className: "changes-list-container file-list"
      }, w.createElement("div", {
        className: "header",
        onContextMenu: this.onContextMenu,
        title: r
      }, w.createElement(Xp, {
        label: t,
        value: i,
        onChange: this.onIncludeAllChanged,
        disabled: o
      })), w.createElement(Pp, {
        id: "changes-list",
        rowCount: this.props.workingDirectory.files.length,
        rowHeight: 29,
        rowRenderer: this.renderRow,
        selectedRows: this.state.selectedRows,
        selectionMode: "multi",
        onSelectionChanged: this.props.onFileSelectionChanged,
        invalidationProps: this.props.workingDirectory,
        onRowClick: this.props.onRowClick,
        onScroll: this.onScroll,
        setScrollTop: this.props.changesListScrollTop,
        onRowKeyDown: this.onRowKeyDown
      }), this.renderStashedChanges(), this.renderCommitMessageForm())
    }
  }
  var ef;
  ! function (e) {
    e[e.Text = 0] = "Text", e[e.Emoji = 1] = "Emoji", e[e.Link = 2] = "Link"
  }(ef || (ef = {}));
  class tf {
    constructor(e, t) {
      this.repository = null, this._results = new Array, this._currentString = "", this.emoji = e, t && Ji(t) && (this.repository = ro(t))
    }
    reset() {
      this._results = new Array, this._currentString = ""
    }
    append(e) {
      this._currentString += e
    }
    flush() {
      this._currentString.length && (this._results.push({
        kind: ef.Text,
        text: this._currentString
      }), this._currentString = "")
    }
    getLastProcessedChar() {
      return this._currentString.length ? this._currentString[this._currentString.length - 1] : null
    }
    scanForEndOfWord(e, t) {
      const n = e.indexOf("\n", t + 1),
        r = e.indexOf(" ", t + 1);
      return n > -1 && r > -1 ? Math.min(n, r) : n > -1 ? n : r > -1 ? r : e.length
    }
    scanForEmoji(e, t) {
      const n = this.scanForEndOfWord(e, t),
        r = e.slice(t, n);
      if (!/^:.*?:$/.test(r)) return null;
      const i = this.emoji.get(r);
      return i ? (this.flush(), this._results.push({
        kind: ef.Emoji,
        text: r,
        path: i
      }), {
        nextIndex: n
      }) : null
    }
    scanForIssue(e, t, n) {
      let r = this.scanForEndOfWord(e, t),
        i = e.slice(t, r);
      if (i.endsWith(")") && (r -= 1, i = e.slice(t, r)), i.endsWith(".") && (r -= 1, i = e.slice(t, r)), i.endsWith(",") && (r -= 1, i = e.slice(t, r)), !/^#\d+$/.test(i)) return null;
      this.flush();
      const o = parseInt(i.substr(1), 10);
      if (isNaN(o)) return null;
      const s = `${n.htmlURL}/issues/${o}`;
      return this._results.push({
        kind: ef.Link,
        text: i,
        url: s
      }), {
        nextIndex: r
      }
    }
    scanForMention(e, t, n) {
      const r = this.getLastProcessedChar();
      if (r && " " !== r) return null;
      let i = this.scanForEndOfWord(e, t),
        o = e.slice(t, i);
      if ((o.endsWith("!") || o.endsWith(",")) && (i -= 1, o = e.slice(t, i)), !/^@[a-zA-Z0-9\-]+$/.test(o)) return null;
      this.flush();
      const s = o.substr(1),
        a = `${ht(n.endpoint)}/${s}`;
      return this._results.push({
        kind: ef.Link,
        text: o,
        url: a
      }), {
        nextIndex: i
      }
    }
    scanForHyperlink(e, t, n) {
      const r = this.getLastProcessedChar();
      if (r && " " !== r) return null;
      const i = this.scanForEndOfWord(e, t),
        o = e.slice(t, i);
      if (!/^https?:\/\/.+/.test(o)) return null;
      if (this.flush(), n && n.htmlURL) {
        const e = n.htmlURL.toLowerCase();
        if (o.toLowerCase().startsWith(e + "/issues/")) {
          const e = /\/issues\/(\d+)/.exec(o);
          if (e) {
            const t = e[1];
            return this._results.push({
              kind: ef.Link,
              url: o,
              text: "#" + t
            }), {
              nextIndex: i
            }
          }
        }
      }
      return this._results.push({
        kind: ef.Link,
        url: o,
        text: o
      }), {
        nextIndex: i
      }
    }
    inspectAndMove(e, t, n) {
      const r = n();
      return r ? r.nextIndex : (this.append(e), t + 1)
    }
    tokenizeNonGitHubRepository(e) {
      let t = 0;
      for (; t < e.length;) {
        const n = e[t];
        switch (n) {
          case ":":
            t = this.inspectAndMove(n, t, () => this.scanForEmoji(e, t));
            break;
          case "h":
            t = this.inspectAndMove(n, t, () => this.scanForHyperlink(e, t));
            break;
          default:
            this.append(n), t++
        }
      }
      return this.flush(), this._results
    }
    tokenizeGitHubRepository(e, t) {
      let n = 0;
      for (; n < e.length;) {
        const r = e[n];
        switch (r) {
          case ":":
            n = this.inspectAndMove(r, n, () => this.scanForEmoji(e, n));
            break;
          case "#":
            n = this.inspectAndMove(r, n, () => this.scanForIssue(e, n, t));
            break;
          case "@":
            n = this.inspectAndMove(r, n, () => this.scanForMention(e, n, t));
            break;
          case "h":
            n = this.inspectAndMove(r, n, () => this.scanForHyperlink(e, n, t));
            break;
          default:
            this.append(r), n++
        }
      }
      return this.flush(), this._results
    }
    tokenize(e) {
      return this.reset(), this.repository ? this.tokenizeGitHubRepository(e, this.repository) : this.tokenizeNonGitHubRepository(e)
    }
  }

  function nf(e, t, n, r) {
    const i = new tf(e, t);
    return ("string" == typeof r ? i.tokenize(r) : r).map((e, t) => {
      switch (e.kind) {
        case ef.Emoji:
          return w.createElement("img", {
            key: t,
            alt: e.text,
            className: "emoji",
            src: e.path
          });
        case ef.Link:
          return !1 !== n ? w.createElement(Ip, {
            key: t,
            uri: e.url,
            title: e.url
          }, e.text) : w.createElement("span", {
            key: t
          }, e.text);
        case ef.Text:
          return w.createElement("span", {
            key: t
          }, e.text);
        default:
          return X(0, "Unknown token type: " + e)
      }
    })
  }
  class rf extends w.Component {
    constructor() {
      super(...arguments), this.getElements = $p(nf), this.getTitle = $p(e => "string" == typeof e ? e : e.map(e => e.text).join(""))
    }
    render() {
      const {
        emoji: e,
        repository: t,
        renderUrlsAsLinks: n,
        text: r
      } = this.props;
      return 0 === r.length ? null : w.createElement("div", {
        className: this.props.className,
        title: this.getTitle(r)
      }, this.getElements(e, t, n, r))
    }
  }
  class of extends w.Component {
    constructor(e) {
      super(e), this.timer = null, this.updateFromScheduler = () => {
        this.updateWithDate(this.props.date)
      }, this.state = {
        absoluteText: "",
        relativeText: ""
      }
    }
    clearTimer() {
      this.timer && (window.clearTimeout(this.timer), this.timer = null)
    }
    updateAndSchedule(e, t, n) {
      this.clearTimer(), this.timer = window.setTimeout(this.updateFromScheduler, Math.min(n, 2147483647)), this.setState({
        absoluteText: e,
        relativeText: t
      })
    }
    updateWithDate(e) {
      const t = k()(e),
        n = k()(),
        r = t.diff(n),
        i = Math.abs(r),
        o = t.format("LLLL"),
        s = !0 === this.props.abbreviate ? k.a.duration(i, "milliseconds").format("y[y] M[m] w[w] d[d] h[h] m[m]", {
          largest: 1
        }) : t.from(n);
      r > 0 && i > 6e4 ? this.updateAndSchedule(o, t.format("lll"), i) : i < 6e4 ? this.updateAndSchedule(o, "just now", 6e4 - i) : i < 36e5 ? this.updateAndSchedule(o, s, 6e4) : i < 864e5 ? this.updateAndSchedule(o, s, 36e5) : i < 6048e5 ? this.updateAndSchedule(o, s, 216e5) : this.setState({
        absoluteText: o,
        relativeText: t.format("ll")
      })
    }
    componentWillReceiveProps(e) {
      this.props.date !== e.date && this.updateWithDate(e.date)
    }
    componentWillMount() {
      this.updateWithDate(this.props.date)
    }
    componentWillUnmount() {
      this.clearTimer()
    }
    shouldComponentUpdate(e, t) {
      return e.date !== this.props.date || t.absoluteText !== this.state.absoluteText || t.relativeText !== this.state.relativeText
    }
    render() {
      return w.createElement("span", {
        title: this.state.absoluteText
      }, this.state.relativeText)
    }
  }
  class sf extends w.Component {
    render() {
      const e = this.props.isPushPullFetchInProgress || this.props.isCommitting,
        t = e ? "Undo is disabled while the repository is being updated" : void 0,
        n = this.props.commit.author.date;
      return w.createElement("div", {
        id: "undo-commit",
        role: "group",
        "aria-label": "Undo commit"
      }, w.createElement("div", {
        className: "commit-info"
      }, w.createElement("div", {
        className: "ago"
      }, "Committed ", w.createElement( of , {
        date: n
      })), w.createElement(rf, {
        emoji: this.props.emoji,
        className: "summary",
        text: this.props.commit.summary,
        renderUrlsAsLinks: !1
      })), w.createElement("div", {
        className: "actions",
        title: t
      }, w.createElement(jp, {
        size: "small",
        disabled: e,
        onClick: this.props.onUndo
      }, "Undo")))
    }
  }
  async function af(e, t) {
    if (!await ee.openExternal("file://" + e)) {
      const n = {
        name: "no-external-program",
        message: `Unable to open file ${e} in an external program. Please check you have a program associated with this file extension`
      };
      await t.postError(n)
    }
  }
  class lf extends w.Component {
    constructor(e) {
      super(e), this.autocompletionProviders = null, this.onCreateCommit = async e => {
        const {
          workingDirectory: t
        } = this.props.changes, n = await async function (e, t, n) {
          const r = 1e6 * n,
            o = new Array,
            s = t.files.filter(e => e.selection.getSelectionType() !== Ii.None);
          for (const t of s) {
            const n = Object(i.join)(e.path, t.path);
            try {
              const e = await Object(Ci.stat)(n);
              e.size > r && o.push(t.path)
            } catch (e) {
              log.debug("Unable to get the file size for " + n, e)
            }
          }
          return o
        }(this.props.repository, t, 100), r = await async function (e, t) {
          const n = new Array;
          for (const r of t) {
            await zl(e, r) || n.push(r)
          }
          return n
        }(this.props.repository, n);
        if (0 !== r.length) return this.props.dispatcher.showPopup({
          type: Zi.OversizedFiles,
          oversizedFiles: r,
          context: e,
          repository: this.props.repository
        }), !1;
        0 === t.files.filter(e => Wl(e.status) && e.selection.getSelectionType() === Ii.None).length && (this.props.dispatcher.clearBanner(), this.props.dispatcher.recordUnguidedConflictedMergeCompletion());
        const o = t.files.filter(e => Wl(e.status) && jl(e.status) && e.selection.getSelectionType() !== Ii.None);
        return o.length > 0 ? (this.props.dispatcher.showPopup({
          type: Zi.CommitConflictsWarning,
          files: o,
          repository: this.props.repository,
          context: e
        }), !1) : this.props.dispatcher.commitIncludedChanges(this.props.repository, e)
      }, this.onFileSelectionChanged = e => {
        const t = e.map(e => this.props.changes.workingDirectory.files[e]);
        this.props.dispatcher.selectWorkingDirectoryFiles(this.props.repository, t)
      }, this.onIncludeChanged = (e, t) => {
        const n = this.props.changes.workingDirectory.files.find(t => t.path === e);
        n ? this.props.dispatcher.changeFileIncluded(this.props.repository, n, t) : console.error("unable to find working directory file to apply included change: " + e)
      }, this.onSelectAll = e => {
        this.props.dispatcher.changeIncludeAllFiles(this.props.repository, e)
      }, this.onDiscardChanges = e => {
        this.props.askForConfirmationOnDiscardChanges ? this.props.dispatcher.showPopup({
          type: Zi.ConfirmDiscardChanges,
          repository: this.props.repository,
          files: [e]
        }) : this.props.dispatcher.discardChanges(this.props.repository, [e])
      }, this.onDiscardChangesFromFiles = (e, t) => {
        this.props.dispatcher.showPopup({
          type: Zi.ConfirmDiscardChanges,
          repository: this.props.repository,
          showDiscardChangesSetting: !1,
          discardingAllChanges: t,
          files: e
        })
      }, this.onIgnore = e => {
        this.props.dispatcher.appendIgnoreRule(this.props.repository, e)
      }, this.onOpenItem = e => {
        af(i.join(this.props.repository.path, e), this.props.dispatcher)
      }, this.onChangedItemClick = (e, t) => {
        "keyboard" === t.kind && (e instanceof Array ? e.forEach(e => this.onToggleInclude(e)) : this.onToggleInclude(e))
      }, this.onUndo = () => {
        const e = this.props.mostRecentLocalCommit;
        e && 0 === e.tags.length && this.props.dispatcher.undoCommit(this.props.repository, e)
      }, this.renderUndoCommit = e => null !== e ? null : this.renderMostRecentLocalCommit(), this.receiveProps(e)
    }
    componentWillReceiveProps(e) {
      this.receiveProps(e)
    }
    receiveProps(e) {
      if (null === this.autocompletionProviders || 0 === this.props.emoji.size || e.repository.hash !== this.props.repository.hash || e.accounts !== this.props.accounts) {
        const t = [new id(e.emoji)],
          {
            repository: n
          } = e,
          r = Ji(n) ? ro(n) : null;
        if (null !== r) {
          t.push(new sd(e.issuesStore, r, e.dispatcher));
          const n = this.props.accounts.find(e => e.endpoint === r.endpoint);
          t.push(new ld(e.gitHubUserStore, r, n))
        }
        this.autocompletionProviders = t
      }
    }
    onToggleInclude(e) {
      const t = this.props.changes.workingDirectory.files[e];
      if (!t) return void console.error("keyboard selection toggle despite no file - what?");
      const n = t.selection.getSelectionType();
      this.props.dispatcher.changeFileIncluded(this.props.repository, t, n === Ii.None)
    }
    renderMostRecentLocalCommit() {
      const e = this.props.mostRecentLocalCommit;
      let t = null;
      return e && 0 === e.tags.length && (t = w.createElement(K, {
        classNames: "undo",
        appear: !0,
        timeout: 500
      }, w.createElement(sf, {
        isPushPullFetchInProgress: this.props.isPushPullFetchInProgress,
        commit: e,
        onUndo: this.onUndo,
        emoji: this.props.emoji,
        isCommitting: this.props.isCommitting
      }))), w.createElement(O, null, t)
    }
    render() {
      const {
        workingDirectory: e,
        commitMessage: t,
        showCoAuthoredBy: n,
        coAuthors: r,
        conflictState: i,
        selection: o,
        currentBranchProtected: s
      } = this.props.changes;
      let a = null;
      null !== i && (a = Q(i) ? i : null);
      const l = o.kind === G.WorkingDirectory ? o.selectedFileIDs : [],
        c = o.kind === G.Stash;
      return w.createElement("div", {
        className: "panel"
      }, w.createElement(Jd, {
        dispatcher: this.props.dispatcher,
        repository: this.props.repository,
        workingDirectory: e,
        conflictState: i,
        rebaseConflictState: a,
        selectedFileIDs: l,
        onFileSelectionChanged: this.onFileSelectionChanged,
        onCreateCommit: this.onCreateCommit,
        onIncludeChanged: this.onIncludeChanged,
        onSelectAll: this.onSelectAll,
        onDiscardChanges: this.onDiscardChanges,
        askForConfirmationOnDiscardChanges: this.props.askForConfirmationOnDiscardChanges,
        onDiscardChangesFromFiles: this.onDiscardChangesFromFiles,
        onOpenItem: this.onOpenItem,
        onRowClick: this.onChangedItemClick,
        commitAuthor: this.props.commitAuthor,
        branch: this.props.branch,
        commitMessage: t,
        focusCommitMessage: this.props.focusCommitMessage,
        autocompletionProviders: this.autocompletionProviders,
        availableWidth: this.props.availableWidth,
        onIgnore: this.onIgnore,
        isCommitting: this.props.isCommitting,
        showCoAuthoredBy: n,
        coAuthors: r,
        externalEditorLabel: this.props.externalEditorLabel,
        onOpenInExternalEditor: this.props.onOpenInExternalEditor,
        onChangesListScrolled: this.props.onChangesListScrolled,
        changesListScrollTop: this.props.changesListScrollTop,
        stashEntry: this.props.changes.stashEntry,
        isShowingStashEntry: c,
        currentBranchProtected: s,
        shouldNudgeToCommit: this.props.shouldNudgeToCommit
      }), this.renderUndoCommit(a))
    }
  }
  class cf extends w.Component {
    render() {
      const e = this.props.status,
        t = Ul(e);
      return w.createElement("div", {
        className: "header"
      }, w.createElement(qd, {
        path: this.props.path,
        status: this.props.status
      }), this.renderDecorator(), w.createElement(bh, {
        symbol: Eh(e),
        className: "status status-" + t.toLowerCase(),
        title: t
      }))
    }
    renderDecorator() {
      const e = this.props.diff;
      if (null === e) return null;
      if (e.kind === Mi.Text && e.lineEndingsChange) {
        const t = `Warning: line endings will be changed from '${e.lineEndingsChange.from}' to '${e.lineEndingsChange.to}'.`;
        return w.createElement(bh, {
          symbol: Sh.alert,
          className: "line-endings",
          title: t
        })
      }
      return null
    }
  }
  var uf;
  ! function (e) {
    e[e.Tabs = 0] = "Tabs", e[e.Switch = 1] = "Switch", e[e.Vertical = 2] = "Vertical"
  }(uf || (uf = {}));
  class hf extends w.Component {
    constructor() {
      super(...arguments), this.tabRefsByIndex = new Map, this.onSelectAdjacentTab = (e, t) => {
        const n = w.Children.toArray(this.props.children);
        if (0 === n.length) return;
        const r = (t + ("next" === e ? 1 : -1) + n.length) % n.length,
          i = this.tabRefsByIndex.get(r);
        i && i.focus(), this.props.onTabClicked(r)
      }, this.onTabClicked = e => {
        this.props.onTabClicked(e)
      }, this.onTabRef = (e, t) => {
        t ? this.tabRefsByIndex.set(e, t) : this.tabRefsByIndex.delete(e)
      }
    }
    render() {
      const {
        type: e
      } = this.props;
      return w.createElement("div", {
        className: "tab-bar " + (e === uf.Switch ? "switch" : e === uf.Vertical ? "vertical" : "tabs"),
        role: "tablist"
      }, this.renderItems())
    }
    renderItems() {
      return w.Children.toArray(this.props.children).map((e, t) => {
        const n = t === this.props.selectedIndex;
        return w.createElement(pf, {
          key: t,
          selected: n,
          index: t,
          onClick: this.onTabClicked,
          onSelectAdjacent: this.onSelectAdjacentTab,
          onButtonRef: this.onTabRef,
          type: this.props.type
        }, e)
      })
    }
  }
  class pf extends w.Component {
    constructor() {
      super(...arguments), this.onClick = e => {
        this.props.onClick(this.props.index)
      }, this.onKeyDown = e => {
        const {
          type: t,
          index: n
        } = this.props, r = t === uf.Vertical ? "ArrowUp" : "ArrowLeft", i = t === uf.Vertical ? "ArrowDown" : "ArrowRight";
        e.key === r ? (this.props.onSelectAdjacent("previous", n), e.preventDefault()) : e.key === i && (this.props.onSelectAdjacent("next", n), e.preventDefault())
      }, this.onButtonRef = e => {
        this.props.onButtonRef(this.props.index, e)
      }
    }
    render() {
      const e = this.props.selected,
        t = mh()("tab-bar-item", {
          selected: e
        });
      return w.createElement("button", {
        ref: this.onButtonRef,
        className: t,
        onClick: this.onClick,
        role: "tab",
        "aria-selected": e,
        tabIndex: e ? void 0 : -1,
        onKeyDown: this.onKeyDown,
        type: "button"
      }, this.props.children)
    }
  }
  class df extends w.Component {
    constructor() {
      super(...arguments), this.onLoad = e => {
        this.props.onElementLoad && this.props.onElementLoad(e.currentTarget)
      }
    }
    render() {
      const e = this.props.image,
        t = `data:${e.mediaType};base64,${e.contents}`;
      return w.createElement("img", {
        src: t,
        style: this.props.style,
        onLoad: this.onLoad
      })
    }
  }
  class ff extends w.Component {
    render() {
      const e = {
          width: 0,
          height: 0
        },
        t = this.props.previousImageSize || e,
        n = this.props.currentImageSize || e,
        r = ((e, t) => {
          const n = Math.round(100 * (t - e) / e);
          return (n > 0 ? "+" : "") + n + "%"
        })(this.props.previous.bytes, this.props.current.bytes),
        i = this.props.current.bytes - this.props.previous.bytes,
        o = i >= 0 ? "+" : "-";
      return w.createElement("div", {
        className: "image-diff-container",
        ref: this.props.onContainerRef
      }, w.createElement("div", {
        className: "image-diff-two-up"
      }, w.createElement("div", {
        className: "image-diff-previous"
      }, w.createElement("div", {
        className: "image-diff-header"
      }, "Deleted"), w.createElement(df, {
        image: this.props.previous,
        onElementLoad: this.props.onPreviousImageLoad
      }), w.createElement("div", {
        className: "image-diff-footer"
      }, w.createElement("span", {
        className: "strong"
      }, "W:"), " ", t.width, "px | ", w.createElement("span", {
        className: "strong"
      }, "H:"), " ", t.height, "px | ", w.createElement("span", {
        className: "strong"
      }, "Size:"), " ", ga(this.props.previous.bytes))), w.createElement("div", {
        className: "image-diff-current"
      }, w.createElement("div", {
        className: "image-diff-header"
      }, "Added"), w.createElement(df, {
        image: this.props.current,
        onElementLoad: this.props.onCurrentImageLoad
      }), w.createElement("div", {
        className: "image-diff-footer"
      }, w.createElement("span", {
        className: "strong"
      }, "W:"), " ", n.width, "px | ", w.createElement("span", {
        className: "strong"
      }, "H:"), " ", n.height, "px | ", w.createElement("span", {
        className: "strong"
      }, "Size:"), " ", ga(this.props.current.bytes)))), w.createElement("div", {
        className: "image-diff-summary"
      }, "Diff:", " ", w.createElement("span", {
        className: mh()({
          added: i > 0,
          removed: i < 0
        })
      }, 0 !== i ? `${o}${ga(i)} (${r})` : "No size difference")))
    }
  }
  class mf extends w.Component {
    render() {
      const e = {
          height: this.props.maxSize.height,
          width: this.props.maxSize.width
        },
        t = {
          maxHeight: this.props.maxSize.height,
          maxWidth: this.props.maxSize.width
        };
      return w.createElement("div", {
        className: "image-diff-difference",
        ref: this.props.onContainerRef
      }, w.createElement("div", {
        className: "sizing-container"
      }, w.createElement("div", {
        className: "image-container",
        style: e
      }, w.createElement("div", {
        className: "image-diff-previous"
      }, w.createElement(df, {
        image: this.props.previous,
        onElementLoad: this.props.onPreviousImageLoad,
        style: t
      })), w.createElement("div", {
        className: "image-diff-current"
      }, w.createElement(df, {
        image: this.props.current,
        onElementLoad: this.props.onCurrentImageLoad,
        style: Object.assign(Object.assign({}, t), {
          mixBlendMode: "difference"
        })
      })))))
    }
  }
  class gf extends w.Component {
    constructor(e) {
      super(e), this.onValueChange = e => {
        this.setState({
          crossfade: e.currentTarget.valueAsNumber
        })
      }, this.state = {
        crossfade: 1
      }
    }
    render() {
      const e = {
          height: this.props.maxSize.height,
          width: this.props.maxSize.width
        },
        t = {
          maxHeight: this.props.maxSize.height,
          maxWidth: this.props.maxSize.width
        };
      return w.createElement("div", {
        className: "image-diff-onion-skin"
      }, w.createElement("div", {
        className: "sizing-container",
        ref: this.props.onContainerRef
      }, w.createElement("div", {
        className: "image-container",
        style: e
      }, w.createElement("div", {
        className: "image-diff-previous",
        style: e
      }, w.createElement(df, {
        image: this.props.previous,
        onElementLoad: this.props.onPreviousImageLoad,
        style: t
      })), w.createElement("div", {
        className: "image-diff-current",
        style: Object.assign(Object.assign({}, e), {
          opacity: this.state.crossfade
        })
      }, w.createElement(df, {
        image: this.props.current,
        onElementLoad: this.props.onCurrentImageLoad,
        style: t
      })))), w.createElement("input", {
        style: {
          width: this.props.maxSize.width / 2
        },
        className: "slider",
        type: "range",
        max: 1,
        min: 0,
        value: this.state.crossfade,
        step: .001,
        onChange: this.onValueChange
      }))
    }
  }
  class yf extends w.Component {
    constructor(e) {
      super(e), this.onValueChange = e => {
        const t = e.currentTarget.valueAsNumber;
        this.setState({
          percentage: t
        })
      }, this.state = {
        percentage: 1
      }
    }
    render() {
      const e = {
          height: this.props.maxSize.height,
          width: this.props.maxSize.width
        },
        t = {
          maxHeight: this.props.maxSize.height,
          maxWidth: this.props.maxSize.width
        };
      return w.createElement("div", {
        className: "image-diff-swipe"
      }, w.createElement("div", {
        className: "sizing-container",
        ref: this.props.onContainerRef
      }, w.createElement("div", {
        className: "image-container",
        style: e
      }, w.createElement("div", {
        className: "image-diff-current",
        style: e
      }, w.createElement(df, {
        image: this.props.current,
        onElementLoad: this.props.onCurrentImageLoad,
        style: t
      })), w.createElement("div", {
        className: "swiper",
        style: {
          width: this.props.maxSize.width * (1 - this.state.percentage),
          height: this.props.maxSize.height
        }
      }, w.createElement("div", {
        className: "image-diff-previous",
        style: e
      }, w.createElement(df, {
        image: this.props.previous,
        onElementLoad: this.props.onPreviousImageLoad,
        style: t
      }))))), w.createElement("input", {
        style: {
          width: this.props.maxSize.width + 14
        },
        className: "slider",
        type: "range",
        max: 1,
        min: 0,
        value: this.state.percentage,
        step: .001,
        onChange: this.onValueChange
      }))
    }
  }

  function vf(e, t) {
    const n = t.height < e.height ? e.height / t.height : 1,
      r = t.width < e.width ? e.width / t.width : 1;
    let i = Math.max(1, r);
    return r < n && (i = Math.max(1, n)), {
      width: e.width / i,
      height: e.height / i
    }
  }
  class wf extends w.Component {
    constructor(e) {
      super(e), this.container = null, this.resizedTimeoutID = null, this.onPreviousImageLoad = e => {
        const t = {
          width: e.naturalWidth,
          height: e.naturalHeight
        };
        this.setState({
          previousImageSize: t
        })
      }, this.onCurrentImageLoad = e => {
        const t = {
          width: e.naturalWidth,
          height: e.naturalHeight
        };
        this.setState({
          currentImageSize: t
        })
      }, this.onResized = (e, t) => {
        this.resizedTimeoutID = null;
        const n = {
          width: t.width,
          height: t.height
        };
        this.setState({
          containerSize: n
        })
      }, this.onContainerRef = e => {
        this.container = e, this.resizeObserver.disconnect(), e && this.resizeObserver.observe(e)
      }, this.resizeObserver = new ResizeObserver(e => {
        for (const t of e) t.target === this.container && (null !== this.resizedTimeoutID && clearImmediate(this.resizedTimeoutID), this.resizedTimeoutID = setImmediate(this.onResized, t.target, t.contentRect))
      }), this.state = {
        previousImageSize: null,
        currentImageSize: null,
        containerSize: null
      }
    }
    getMaxSize() {
      const e = {
          width: 0,
          height: 0,
          containerWidth: 0
        },
        t = this.state.containerSize;
      if (!t) return e;
      const {
        previousImageSize: n,
        currentImageSize: r
      } = this.state;
      if (!n || !r) return e;
      return function (e, t, n) {
        const r = vf(e, n),
          i = vf(t, n);
        return {
          width: Math.max(r.width, i.width),
          height: Math.max(r.height, i.height)
        }
      }(n, r, t)
    }
    render() {
      return w.createElement("div", {
        className: "panel image",
        id: "diff"
      }, this.renderCurrentDiffType(), w.createElement(hf, {
        selectedIndex: this.props.diffType,
        onTabClicked: this.props.onChangeDiffType,
        type: uf.Switch
      }, w.createElement("span", null, "2-up"), w.createElement("span", null, "Swipe"), w.createElement("span", null, "Onion Skin"), w.createElement("span", null, "Difference")))
    }
    renderCurrentDiffType() {
      const e = this.getMaxSize(),
        t = this.props.diffType;
      switch (t) {
        case Oi.TwoUp:
          return w.createElement(ff, Object.assign({}, this.getCommonProps(e), {
            previousImageSize: this.state.previousImageSize,
            currentImageSize: this.state.currentImageSize
          }));
        case Oi.Swipe:
          return w.createElement(yf, Object.assign({}, this.getCommonProps(e)));
        case Oi.OnionSkin:
          return w.createElement(gf, Object.assign({}, this.getCommonProps(e)));
        case Oi.Difference:
          return w.createElement(mf, Object.assign({}, this.getCommonProps(e)));
        default:
          return X(0, "Unknown diff type: " + t)
      }
    }
    getCommonProps(e) {
      return {
        maxSize: e,
        previous: this.props.previous,
        current: this.props.current,
        onPreviousImageLoad: this.onPreviousImageLoad,
        onCurrentImageLoad: this.onCurrentImageLoad,
        onContainerRef: this.onContainerRef
      }
    }
  }
  class bf extends w.Component {
    render() {
      return w.createElement("div", {
        className: "panel image",
        id: "diff"
      }, w.createElement("div", {
        className: "image-diff-current"
      }, w.createElement("div", {
        className: "image-diff-header"
      }, "Added"), w.createElement(df, {
        image: this.props.current
      })))
    }
  }
  class Sf extends w.Component {
    render() {
      return w.createElement("div", {
        className: "panel image",
        id: "diff"
      }, w.createElement("div", {
        className: "image-diff-previous"
      }, w.createElement("div", {
        className: "image-diff-header"
      }, "Deleted"), w.createElement(df, {
        image: this.props.previous
      })))
    }
  }
  class Cf extends w.Component {
    constructor() {
      super(...arguments), this.open = () => {
        const e = i.join(this.props.repository.path, this.props.path);
        this.props.onOpenBinaryFile(e)
      }
    }
    render() {
      return w.createElement("div", {
        className: "panel binary",
        id: "diff"
      }, w.createElement("div", {
        className: "image-header"
      }, "This binary file has changed."), w.createElement("div", {
        className: "image-header"
      }, w.createElement(Ip, {
        onClick: this.open
      }, "Open file in external program.")))
    }
  }
  var Ef;

  function kf(e, t) {
    return e.find(e => t >= e.unifiedDiffStart && t <= e.unifiedDiffEnd) || null
  }

  function xf(e, t) {
    const n = kf(e, t);
    return n && n.lines[t - n.unifiedDiffStart] || null
  }

  function Tf(e, t) {
    let n = 0;
    for (const r of t) {
      const t = r.lines.indexOf(e);
      if (t > -1) return t + n;
      n += r.lines.length
    }
    return -1
  }

  function Rf(e, t) {
    const n = kf(e, t);
    if (!n) return null;
    const r = t - n.unifiedDiffStart;
    let i = Df(null, n.lines[r]),
      o = null;
    for (let e = r - 1; e >= 0; e--) {
      const t = n.lines[e];
      if (!t.isIncludeableLine()) {
        const t = e + 1;
        o = n.unifiedDiffStart + t;
        break
      }
      i = Df(i, t)
    }
    const s = null !== o ? o : n.unifiedDiffStart + 1;
    let a = null;
    for (let e = r + 1; e < n.lines.length; e++) {
      const t = n.lines[e];
      if (!t.isIncludeableLine()) {
        const t = e - 1;
        a = n.unifiedDiffStart + t;
        break
      }
      i = Df(i, t)
    }
    return {
      from: s,
      to: null !== a ? a : n.unifiedDiffEnd,
      type: i
    }
  }

  function Df(e, t) {
    return t.type !== Pi.Add && t.type !== Pi.Delete ? e : null === e ? t.type === Pi.Add ? Ef.Additions : Ef.Deletions : e === Ef.Mixed ? e : t.type === Pi.Add && e !== Ef.Additions || t.type === Pi.Delete && e !== Ef.Deletions ? Ef.Mixed : e
  }! function (e) {
    e[e.Additions = 0] = "Additions", e[e.Deletions = 1] = "Deletions", e[e.Mixed = 2] = "Mixed"
  }(Ef || (Ef = {}));
  n(282);
  const _f = {
    "+": "diff-add",
    "-": "diff-delete",
    "@": "diff-hunk",
    " ": "diff-context"
  };

  function Af(e, t) {
    return e.skipToEnd(), t.diffLineIndex++, null
  }
  class Mf {
    constructor(e, t, n) {
      this.token = (e, t) => {
        if (e.sol()) {
          const n = e.next();
          e.eol() && t.diffLineIndex++;
          const r = n ? _f[n] : null;
          return r ? `line-${r} line-background-${r}` : null
        }
        if (null == this.hunks) return Af(e, t);
        const n = xf(this.hunks, t.diffLineIndex);
        if (!n) return Af(e, t);
        const r = function (e, t, n) {
          return t && e.oldLineNumber && t[e.oldLineNumber - 1] ? t[e.oldLineNumber - 1] : n && e.newLineNumber && n[e.newLineNumber - 1] ? n[e.newLineNumber - 1] : null
        }(n, this.oldTokens, this.newTokens);
        if (!r) return Af(e, t);
        const i = r[e.pos - e.lineStart - 1];
        if (i) e.pos += i.length;
        else
          do {
            e.pos++
          } while (!e.eol() && !r[e.pos - e.lineStart - 1]);
        return e.eol() && t.diffLineIndex++, i ? i.token : null
      }, this.hunks = e, this.oldTokens = t, this.newTokens = n
    }
    startState() {
      return {
        diffLineIndex: 0
      }
    }
    blankLine(e) {
      e.diffLineIndex++
    }
  }
  Mf.ModeName = "github-diff-syntax", md.defineMode(Mf.ModeName, (function (e, t) {
    if (!t) throw new Error("I needs me some options");
    return new Mf(t.hunks, t.oldTokens, t.newTokens)
  }));
  n(283), n(284), n(285);
  class Pf extends w.Component {
    constructor(e) {
      super(e), this.wrapper = null, this.codeMirror = null, this.resizeDebounceId = null, this.lastKnownWidth = null, this.onSwapDoc = (e, t) => {
        this.props.onSwapDoc && this.props.onSwapDoc(e, t)
      }, this.onContextMenu = (e, t) => {
        this.props.onContextMenu && this.props.onContextMenu(e, t)
      }, this.onCopy = (e, t) => {
        this.props.onCopy && this.props.onCopy(e, t)
      }, this.beforeSelectionChanged = (e, t) => {
        this.props.isSelectionEnabled && (this.props.isSelectionEnabled() || t.update([{
          head: {
            line: 0,
            ch: 0
          },
          anchor: {
            line: 0,
            ch: 0
          }
        }]))
      }, this.onChanges = (e, t) => {
        this.props.onChanges && this.props.onChanges(e, t)
      }, this.onViewportChange = (e, t, n) => {
        this.props.onViewportChange && this.props.onViewportChange(e, t, n)
      }, this.onRenderLine = (e, t, n) => {
        this.props.onRenderLine && this.props.onRenderLine(e, t, n)
      }, this.onResized = () => {
        this.resizeDebounceId = null, this.codeMirror && this.codeMirror.refresh()
      }, this.onRef = e => {
        this.wrapper = e
      }, this.resizeObserver = new ResizeObserver(e => {
        if (1 === e.length && this.codeMirror) {
          const t = e[0].contentRect.width;
          null === this.lastKnownWidth ? this.lastKnownWidth = t : this.lastKnownWidth !== t && (this.lastKnownWidth = t, null !== this.resizeDebounceId && (cancelAnimationFrame(this.resizeDebounceId), this.resizeDebounceId = null), this.resizeDebounceId = requestAnimationFrame(this.onResized))
        }
      })
    }
    static updateDoc(e, t) {
      "string" == typeof t ? e.setValue(t) : (! function (e) {
        if (e.state && e.state.selectingText instanceof Function) try {
          e.state.selectingText(new CustomEvent("fake-event"))
        } catch (e) {
          log.info("Unable to cancel CodeMirror selection", e)
        }
      }(e), e.swapDoc(t))
    }
    getEditor() {
      return this.codeMirror
    }
    componentDidMount() {
      this.codeMirror = gd()(this.wrapper, this.props.options), this.codeMirror.on("renderLine", this.onRenderLine), this.codeMirror.on("changes", this.onChanges), this.codeMirror.on("viewportChange", this.onViewportChange), this.codeMirror.on("beforeSelectionChange", this.beforeSelectionChanged), this.codeMirror.on("copy", this.onCopy), this.codeMirror.on("contextmenu", this.onContextMenu), this.codeMirror.on("swapDoc", this.onSwapDoc), Pf.updateDoc(this.codeMirror, this.props.value), this.resizeObserver.observe(this.codeMirror.getWrapperElement())
    }
    componentWillUnmount() {
      const e = this.codeMirror;
      e && (e.off("changes", this.onChanges), e.off("viewportChange", this.onViewportChange), e.off("renderLine", this.onRenderLine), e.off("beforeSelectionChange", this.beforeSelectionChanged), e.off("copy", this.onCopy), e.off("swapDoc", this.onSwapDoc), this.codeMirror = null), this.resizeObserver.disconnect()
    }
    componentDidUpdate(e) {
      if (this.codeMirror && this.props.value !== e.value) {
        const e = this.codeMirror.getDoc();
        Pf.updateDoc(this.codeMirror, this.props.value);
        const t = this.codeMirror.getDoc();
        this.props.onAfterSwapDoc && this.props.onAfterSwapDoc(this.codeMirror, e, t)
      }
    }
    render() {
      return w.createElement("div", {
        className: this.props.className,
        ref: this.onRef
      })
    }
  }
  const If = new Array,
    Of = Mc(__dirname, "highlighter.js");

  function Lf(e, t, n, r, i) {
    if (!e.length || !i.length) return Promise.resolve({});
    const o = If.shift() || new Worker(Of);
    return new Promise((s, a) => {
      let l = null;
      const c = () => {
        l && (window.clearTimeout(l), l = null)
      };
      o.onerror = e => {
        c(), o.terminate(), a(e.error || new Error(e.message))
      }, o.onmessage = e => {
        c(), If.length < 2 ? If.push(o) : o.terminate(), s(e.data)
      };
      const u = {
        contents: e,
        basename: t,
        extension: n,
        tabSize: r,
        lines: i,
        addModeClass: !0
      };
      o.postMessage(u), l = window.setTimeout(() => {
        o.terminate(), a(new Error("timed out"))
      }, 5e3)
    })
  }
  async function Nf(e, t) {
    return t.status.kind === Ki.Deleted ? Buffer.alloc(0) : t instanceof co ? async function (e, t, n) {
      return await new Promise((r, i) => {
        const o = new Array;
        let s = 0;
        Ci.createReadStream(e, {
          start: t,
          end: n
        }).on("data", e => {
          o.push(e), s += e.length
        }).on("error", i).on("end", () => r(Buffer.concat(o, s)))
      })
    }(i.join(e.path, t.path), 0, 262143): t instanceof uo ? as(e, t.commitish, t.path, 262144) : X(0, "Unknown file change type")
  }
  async function Ff(e, t, n) {
    const r = n.oldLineFilter.length ? async function (e, t) {
      if (t.status.kind === Ki.New || t.status.kind === Ki.Untracked) return Buffer.alloc(0);
      let n;
      if (t instanceof co) n = "HEAD";
      else {
        if (!(t instanceof uo)) return X(0, "Unknown file change type");
        n = t.commitish + "^"
      }
      return as(e, n, hs(t), 262144)
    }(e, t): Promise.resolve(Buffer.alloc(0)), i = n.newLineFilter.length ? Nf(e, t) : Promise.resolve(Buffer.alloc(0)), [o, s] = await Promise.all([r.catch(e => (log.error("Could not load old contents for syntax highlighting", e), Buffer.alloc(0))), i.catch(e => (log.error("Could not load new contents for syntax highlighting", e), Buffer.alloc(0)))]);
    return {
      file: t,
      oldContents: o,
      newContents: s
    }
  }

  function Bf(e) {
    return e.location + e.length
  }

  function Hf(e, t, n, r, i) {
    const o = Math.min(t.length, r.length),
      s = i ? Bf(t) - 1 : t.location,
      a = i ? Bf(r) - 1 : r.location,
      l = i ? -1 : 1;
    let c = 0;
    for (; Math.abs(c) < o && e[s + c] === n[a + c];) c += l;
    return Math.abs(c)
  }

  function zf(e, t) {
    let n = {
        location: 0,
        length: t.length
      },
      r = {
        location: 0,
        length: e.length
      };
    const i = Hf(t, n, e, r, !1);
    n = {
      location: n.location + i,
      length: n.length - i
    }, r = {
      location: r.location + i,
      length: r.length - i
    };
    const o = Hf(t, n, e, r, !0);
    return n.length -= o, r.length -= o, {
      stringARange: r,
      stringBRange: n
    }
  }
  const Uf = new Sh(16, 8, "m 16,1 0,3 c 0,0.55 -0.45,1 -1,1 l -3,0 0,2 -3,-3 3,-3 0,2 2,0 0,-2 2,0 z M 8,4 C 8,6.2 6.2,8 4,8 1.8,8 0,6.2 0,4 0,1.8 1.8,0 4,0 6.2,0 8,1.8 8,4 Z M 1.5,5.66 5.66,1.5 C 5.18,1.19 4.61,1 4,1 2.34,1 1,2.34 1,4 1,4.61 1.19,5.17 1.5,5.66 Z M 7,4 C 7,3.39 6.81,2.83 6.5,2.34 L 2.34,6.5 C 2.82,6.81 3.39,7 4,7 5.66,7 7,5.66 7,4 Z");

  function Wf(e, t) {
    return e === t || e.file.id === t.file.id && e.diff.text === t.diff.text
  }

  function Vf() {
    const e = document.createElement("span"),
      t = Ye(),
      {
        w: n,
        h: r,
        d: i
      } = Uf,
      o = "http://www.w3.org/2000/svg",
      s = document.createElementNS(o, "svg");
    s.setAttribute("version", "1.1"), s.setAttribute("viewBox", `0 0 ${n} ${r}`), s.setAttribute("role", "img"), s.setAttribute("aria-labelledby", t), s.classList.add("no-newline");
    const a = document.createElementNS(o, "title");
    a.setAttribute("id", t), a.setAttribute("lang", "en"), a.textContent = "No newline at end of file", s.appendChild(a);
    const l = document.createElementNS(o, "path");
    return l.setAttribute("role", "presentation"), l.setAttribute("d", i), l.textContent = "No newline at end of file", s.appendChild(l), e.appendChild(s), e
  }

  function jf(e, t) {
    return null !== e && (t >= Math.min(e.from, e.to) && t <= Math.max(e.to, e.from))
  }

  function Gf(e, t) {
    return e instanceof HTMLElement && e.classList.contains(t)
  }

  function $f(e) {
    return e instanceof co
  }

  function qf(e) {
    const t = e.getWrapperElement(),
      n = t.querySelector(":scope > .CodeMirror-dialog .CodeMirror-search-field");
    if (null !== n) return void(n instanceof HTMLElement && n.focus());
    e.execCommand("findPersistent");
    const r = t.querySelector(".CodeMirror-dialog");
    if (null === r) return;
    r.classList.add("CodeMirror-search-dialog");
    const i = r.querySelector(".CodeMirror-search-field");
    i instanceof HTMLInputElement && (i.placeholder = "Search", i.style.removeProperty("width"))
  }

  function Kf(e, t) {
    return n => {
      const r = Math.round(n.defaultTextHeight() + 4),
        i = n.getScrollInfo();
      if ("line" === t) n.scrollTo(void 0, i.top + e * r);
      else {
        const t = i.clientHeight - r;
        n.scrollTo(void 0, i.top + e * t)
      }
    }
  }
  const Yf = {
    lineNumbers: !1,
    readOnly: !0,
    showCursorWhenSelecting: !1,
    cursorBlinkRate: -1,
    lineWrapping: !0,
    mode: {
      name: Mf.ModeName
    },
    extraKeys: {
      Tab: !1,
      Home: "goDocStart",
      End: "goDocEnd",
      "Shift-Tab": !1,
      "Ctrl-F": qf,
      "Ctrl-G": !1,
      "Shift-Ctrl-G": !1,
      "Shift-Ctrl-F": !1,
      "Shift-Ctrl-R": !1,
      Down: Kf(1, "line"),
      Up: Kf(-1, "line"),
      PageDown: Kf(1, "page"),
      PageUp: Kf(-1, "page")
    },
    scrollbarStyle: "native",
    styleSelectedText: !0,
    lineSeparator: "\n",
    specialChars: /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/,
    gutters: ["diff-gutter"]
  };
  class Qf extends w.Component {
    constructor() {
      super(...arguments), this.codeMirror = null, this.getCodeMirrorDocument = $p((e, t) => {
        const {
          mode: n,
          firstLineNumber: r,
          lineSeparator: i
        } = Yf; - 1 !== e.indexOf("\r") && (e = e.replace(/\r(?=\n|$)/g, ""));
        const o = new md.Doc(e, n, r, i);
        for (const e of t) o.setBookmark({
          line: e,
          ch: 1 / 0
        }, {
          widget: Vf()
        });
        return o
      }, yu), this.getNoNewlineIndicatorLines = $p(e => {
        const t = new Array;
        for (const n of e)
          for (const r of n.lines) r.noTrailingNewLine && t.push(Tf(r, e));
        return t
      }), this.selection = null, this.hunkHighlightRange = null, this.swappedDocumentHasUpdatedViewport = !0, this.onDocumentMouseMove = e => {
        if (null === this.codeMirror || null === this.selection || "range" !== this.selection.kind) return;
        const t = Math.max(0, this.codeMirror.getDoc().lineCount() - 1),
          n = fl(this.codeMirror.lineAtHeight(e.y), 0, t);
        this.codeMirror.scrollIntoView({
          line: n,
          ch: 0
        }), n !== this.selection.to && (this.selection = Object.assign(Object.assign({}, this.selection), {
          to: n
        }), this.updateViewport())
      }, this.onDocumentMouseUp = e => {
        if (e.preventDefault(), 0 === e.button) {
          if (null === this.selection || null === this.codeMirror) return this.cancelSelection();
          if ("hunk" === this.selection.kind) {
            if (!Gf(e.target, "hunk-handle") || !jf(this.selection, this.codeMirror.lineAtHeight(e.y))) return this.cancelSelection()
          } else {
            if ("range" !== this.selection.kind) return X(this.selection.kind, "Unknown selection kind " + this.selection.kind);
            if (this.selection.from === this.selection.to && !Gf(e.target, "diff-line-number") && !Gf(e.target, "diff-line-gutter")) return this.cancelSelection()
          }
          this.endSelection()
        }
      }, this.isSelectionEnabled = () => null === this.selection, this.getAndStoreCodeMirrorInstance = e => {
        this.codeMirror = null === e ? null : e.getEditor()
      }, this.onContextMenu = (e, t) => {
        const n = null != e.getDoc().listSelections(),
          r = [{
            label: "Copy",
            action: () => {
              null !== this.onCopy && this.onCopy(e, t)
            },
            enabled: this.onCopy && n
          }],
          i = this.buildDiscardMenuItems(e, t);
        null !== i && r.push({
          type: "separator"
        }, ...i), ie(r)
      }, this.onCopy = (e, t) => {
        t.preventDefault();
        const n = e.getDoc(),
          i = n.getSelections(),
          o = n.listSelections(),
          s = [];
        for (let e = 0; e < i.length; e++) {
          const t = o[e],
            n = i[e].split("\n");
          for (const [e, r] of n.entries()) 0 === e && t.head.ch > 0 ? s.push(r) : s.push(r.substr(1));
          const a = s.join("\n");
          r.clipboard.writeText(a)
        }
      }, this.onSwapDoc = (e, t) => {
        this.swappedDocumentHasUpdatedViewport = !1, this.initDiffSyntaxMode(), this.markIntraLineChanges(e.getDoc(), this.props.diff.hunks)
      }, this.onAfterSwapDoc = (e, t, n) => {
        this.swappedDocumentHasUpdatedViewport || this.updateViewport()
      }, this.onViewportChange = (e, t, n) => {
        const r = e.getDoc(),
          i = new Array;
        this.swappedDocumentHasUpdatedViewport = !0, r.eachLine(t, n, t => {
          const n = r.getLineNumber(t);
          if (null !== n) {
            const r = xf(this.props.diff.hunks, n);
            if (null !== r) {
              const o = e.lineInfo(t);
              if (o.gutterMarkers && "diff-gutter" in o.gutterMarkers) {
                const e = o.gutterMarkers["diff-gutter"];
                e instanceof HTMLElement && this.updateGutterMarker(e, n, r)
              } else i.push(() => {
                const i = this.createGutterMarker(n, r);
                e.setGutterMarker(t, "diff-gutter", i)
              })
            }
          }
        }), i.length > 0 && e.operation(() => i.forEach(e => e()))
      }, this.onHunkHandleMouseEnter = e => {
        if (null === this.codeMirror || this.props.readOnly || null !== this.selection && "range" === this.selection.kind) return;
        const t = this.codeMirror.lineAtHeight(e.y),
          n = xf(this.props.diff.hunks, t);
        if (!n || !n.isIncludeableLine()) return;
        const r = Rf(this.props.diff.hunks, t);
        if (null === r) return;
        const {
          from: i,
          to: o
        } = r;
        this.hunkHighlightRange = {
          from: i,
          to: o,
          kind: "hunk",
          isSelected: !1
        }, this.updateViewport()
      }, this.onDiffLineGutterMouseDown = e => {
        if (e.defaultPrevented || null === this.codeMirror) return;
        if (0 !== e.button) return;
        const {
          file: t,
          diff: n,
          readOnly: r
        } = this.props;
        if (!$f(t) || r) return;
        e.preventDefault();
        const i = this.codeMirror.lineAtHeight(e.y);
        this.startSelection(t, n.hunks, i, "range")
      }, this.onHunkHandleMouseLeave = e => {
        null !== this.hunkHighlightRange && (this.hunkHighlightRange = null, this.updateViewport())
      }, this.onHunkHandleMouseDown = e => {
        if (!this.codeMirror) return;
        if (0 !== e.button) return;
        const {
          file: t,
          diff: n,
          readOnly: r
        } = this.props;
        if (!$f(t) || r) return;
        e.preventDefault();
        const i = this.codeMirror.lineAtHeight(e.y);
        this.startSelection(t, n.hunks, i, "hunk")
      }, this.onFindText = e => {
        !e.defaultPrevented && this.codeMirror && (e.preventDefault(), qf(this.codeMirror))
      }
    }
    async initDiffSyntaxMode() {
      if (!this.codeMirror) return;
      const {
        file: e,
        diff: t,
        repository: n
      } = this.props, r = this.props, o = function (e) {
        const t = new Array,
          n = new Array,
          r = new Array;
        let i = !1,
          o = !1;
        for (const t of e)
          for (const e of t.lines) i = i || e.type === Pi.Add, o = o || e.type === Pi.Delete, r.push(e);
        for (const e of r) null !== e.oldLineNumber && null !== e.newLineNumber ? i && !o ? n.push(e.newLineNumber - 1) : t.push(e.oldLineNumber - 1) : null !== e.oldLineNumber ? t.push(e.oldLineNumber - 1) : null !== e.newLineNumber && n.push(e.newLineNumber - 1);
        return {
          oldLineFilter: t,
          newLineFilter: n
        }
      }(t.hunks), s = this.codeMirror.getOption("tabSize"), a = "number" == typeof s ? s : 4, l = await Ff(n, e, o);
      if (!Wf(this.props, r)) return;
      const c = await async function (e, t, n) {
        const {
          file: r,
          oldContents: o,
          newContents: s
        } = e, a = hs(r), [l, c] = await Promise.all([Lf(o.toString("utf8"), i.basename(a), i.extname(a), t, n.oldLineFilter).catch(e => (log.error("Highlighter worked failed for old contents", e), {})), Lf(s.toString("utf8"), i.basename(r.path), i.extname(r.path), t, n.newLineFilter).catch(e => (log.error("Highlighter worked failed for new contents", e), {}))]);
        return {
          oldTokens: l,
          newTokens: c
        }
      }(l, a, o);
      if (!Wf(this.props, r)) return;
      const u = {
        name: Mf.ModeName,
        hunks: this.props.diff.hunks,
        oldTokens: c.oldTokens,
        newTokens: c.newTokens
      };
      this.codeMirror && this.codeMirror.setOption("mode", u)
    }
    startSelection(e, t, n, r) {
      null !== this.selection && this.cancelSelection();
      const i = !e.selection.isSelected(n);
      if ("hunk" === r) {
        const e = Rf(t, n);
        if (!e) return void console.error("unable to find range for given line in diff");
        const {
          from: o,
          to: s
        } = e;
        this.selection = {
          isSelected: i,
          from: o,
          to: s,
          kind: r
        }
      } else "range" === r ? (this.selection = {
        isSelected: i,
        from: n,
        to: n,
        kind: r
      }, document.addEventListener("mousemove", this.onDocumentMouseMove)) : X(0, "Unknown selection kind " + r);
      document.addEventListener("mouseup", this.onDocumentMouseUp, {
        once: !0
      })
    }
    cancelSelection() {
      this.selection && (document.removeEventListener("mouseup", this.onDocumentMouseUp), document.removeEventListener("mousemove", this.onDocumentMouseMove), this.selection = null, this.updateViewport())
    }
    endSelection() {
      const {
        onIncludeChanged: e,
        file: t
      } = this.props;
      if (e && this.selection && $f(t)) {
        const n = t.selection,
          {
            isSelected: r
          } = this.selection,
          i = Math.min(this.selection.from, this.selection.to),
          o = Math.max(this.selection.from, this.selection.to) - i + 1;
        e(n.withRangeSelection(i, o, r)), this.selection = null
      }
    }
    buildDiscardMenuItems(e, t) {
      const n = this.props.file;
      if (this.props.readOnly || !$f(n)) return null;
      if (!(t instanceof MouseEvent)) return null;
      if (!this.props.onDiscardChanges) return null;
      const r = e.lineAtHeight(t.y),
        i = xf(this.props.diff.hunks, r);
      if (null === i || !i.isIncludeableLine()) return null;
      const o = Rf(this.props.diff.hunks, r);
      return null === o || null === o.type ? null : Gf(t.target, "hunk-handle") ? [{
        label: this.getDiscardLabel(o.type, o.to - o.from + 1),
        action: () => this.onDiscardChanges(n, o.from, o.to)
      }] : Gf(t.target, "diff-line-number") ? [{
        label: this.getDiscardLabel(o.type, 1),
        action: () => this.onDiscardChanges(n, r),
        enabled: o.type !== Ef.Mixed
      }] : null
    }
    onDiscardChanges(e, t, n = t) {
      if (!this.props.onDiscardChanges) return;
      const r = e.selection.withSelectNone().withRangeSelection(t, n - t + 1, !0);
      this.props.onDiscardChanges(this.props.diff, r)
    }
    getDiscardLabel(e, t) {
      const n = this.props.askForConfirmationOnDiscardChanges ? "…" : "";
      let r = "";
      e === Ef.Additions ? r = "added" : e === Ef.Deletions ? r = "removed" : e === Ef.Mixed ? r = "modified" : X(0, "Invalid range type: " + e);
      return `Discard ${r} line${t>1?"s":""}${n}`
    }
    markIntraLineChanges(e, t) {
      for (const n of t) {
        const r = n.lines.filter(e => e.type === Pi.Add),
          i = n.lines.filter(e => e.type === Pi.Delete);
        if (r.length === i.length)
          for (let n = 0; n < r.length; n++) {
            const o = r[n],
              s = i[n];
            if (o.text.length > 4096 || s.text.length > 4096) continue;
            const a = zf(o.content, s.content),
              l = a.stringARange;
            if (l.length > 0) {
              const n = Tf(o, t);
              if (n > -1) {
                const t = {
                    line: n,
                    ch: l.location + 1
                  },
                  r = {
                    line: n,
                    ch: l.location + l.length + 1
                  };
                e.markText(t, r, {
                  className: "cm-diff-add-inner"
                })
              }
            }
            const c = a.stringBRange;
            if (c.length > 0) {
              const n = Tf(s, t);
              if (n > -1) {
                const t = {
                    line: n,
                    ch: c.location + 1
                  },
                  r = {
                    line: n,
                    ch: c.location + c.length + 1
                  };
                e.markText(t, r, {
                  className: "cm-diff-delete-inner"
                })
              }
            }
          }
      }
    }
    isIncluded(e) {
      const {
        file: t
      } = this.props;
      return jf(this.selection, e) ? this.selection.isSelected : $f(t) && t.selection.isSelected(e)
    }
    getGutterLineClassNameInfo(e, t) {
      const n = t.isIncludeableLine(),
        r = n && this.isIncluded(e),
        i = n && jf(this.hunkHighlightRange, e);
      return {
        "diff-line-gutter": !0,
        "diff-add": t.type === Pi.Add,
        "diff-delete": t.type === Pi.Delete,
        "diff-context": t.type === Pi.Context,
        "diff-hunk": t.type === Pi.Hunk,
        "read-only": this.props.readOnly,
        "diff-line-selected": r,
        "diff-line-hover": i,
        includeable: n && !this.props.readOnly
      }
    }
    createGutterMarker(e, t) {
      const n = document.createElement("div");
      n.className = "diff-line-gutter", n.addEventListener("mousedown", this.onDiffLineGutterMouseDown);
      const r = document.createElement("div");
      r.classList.add("diff-line-number", "before"), n.appendChild(r);
      const i = document.createElement("div");
      i.classList.add("diff-line-number", "after"), n.appendChild(i);
      const o = document.createElement("div");
      return o.addEventListener("mouseenter", this.onHunkHandleMouseEnter), o.addEventListener("mouseleave", this.onHunkHandleMouseLeave), o.addEventListener("mousedown", this.onHunkHandleMouseDown), o.classList.add("hunk-handle"), n.appendChild(o), this.updateGutterMarker(n, e, t), n
    }
    updateGutterMarker(e, t, n) {
      const r = this.getGutterLineClassNameInfo(t, n);
      for (const [t, n] of Object.entries(r)) n ? e.classList.add(t) : e.classList.remove(t);
      !this.props.readOnly && n.isIncludeableLine() ? e.setAttribute("role", "button") : e.removeAttribute("role");
      e.childNodes[0].textContent = null === n.oldLineNumber ? "" : "" + n.oldLineNumber;
      e.childNodes[1].textContent = null === n.newLineNumber ? "" : "" + n.newLineNumber
    }
    updateViewport() {
      if (this.codeMirror) {
        const {
          from: e,
          to: t
        } = this.codeMirror.getViewport();
        this.onViewportChange(this.codeMirror, e, t)
      }
    }
    componentWillUnmount() {
      this.cancelSelection(), this.codeMirror = null, document.removeEventListener("find-text", this.onFindText)
    }
    componentDidUpdate(e, t, n) {
      null !== this.codeMirror && ($f(this.props.file) && ($f(e.file) && this.props.file.selection === e.file.selection || this.props.diff.text === e.diff.text && this.updateViewport()), null !== n && this.codeMirror.scrollTo(void 0, n.top))
    }
    getSnapshotBeforeUpdate(e) {
      return null !== this.codeMirror && this.props.file !== e.file && this.props.file.id === e.file.id && this.props.diff.text !== e.diff.text ? this.codeMirror.getScrollInfo() : null
    }
    componentDidMount() {
      this.initDiffSyntaxMode(), document.addEventListener("find-text", this.onFindText)
    }
    render() {
      const e = this.getCodeMirrorDocument(this.props.diff.text, this.getNoNewlineIndicatorLines(this.props.diff.hunks));
      return w.createElement(Pf, {
        className: "diff-code-mirror",
        value: e,
        options: Yf,
        isSelectionEnabled: this.isSelectionEnabled,
        onSwapDoc: this.onSwapDoc,
        onAfterSwapDoc: this.onAfterSwapDoc,
        onViewportChange: this.onViewportChange,
        ref: this.getAndStoreCodeMirrorInstance,
        onContextMenu: this.onContextMenu,
        onCopy: this.onCopy
      })
    }
  }
  const Zf = Mc(__dirname, "static/ufo-alert.svg");
  class Xf extends w.Component {
    constructor(e) {
      super(e), this.showLargeDiff = () => {
        this.setState({
          forceShowLargeDiff: !0
        })
      }, this.state = {
        forceShowLargeDiff: !1
      }
    }
    render() {
      const e = this.props.diff;
      switch (e.kind) {
        case Mi.Text:
          return this.renderText(e);
        case Mi.Binary:
          return this.renderBinaryFile();
        case Mi.Image:
          return this.renderImage(e);
        case Mi.LargeText:
          return this.state.forceShowLargeDiff ? this.renderLargeText(e) : this.renderLargeTextDiff();
        case Mi.Unrenderable:
          return this.renderUnrenderableDiff();
        default:
          return X(0, "Unsupported diff type: " + e)
      }
    }
    renderImage(e) {
      return e.current && e.previous ? w.createElement(wf, {
        onChangeDiffType: this.props.onChangeImageDiffType,
        diffType: this.props.imageDiffType,
        current: e.current,
        previous: e.previous
      }) : !e.current || this.props.file.status.kind !== Ki.New && this.props.file.status.kind !== Ki.Untracked ? e.previous && this.props.file.status.kind === Ki.Deleted ? w.createElement(Sf, {
        previous: e.previous
      }) : null : w.createElement(bf, {
        current: e.current
      })
    }
    renderLargeTextDiff() {
      return w.createElement("div", {
        className: "panel empty large-diff"
      }, w.createElement("img", {
        src: Zf,
        className: "blankslate-image"
      }), w.createElement("p", null, "差异太大，默认情况下无法显示.", w.createElement("br", null), "但无论如何，你可能会表现出负面影响"), w.createElement(jp, {
        onClick: this.showLargeDiff
      }, "显示差异"))
    }
    renderUnrenderableDiff() {
      return w.createElement("div", {
        className: "panel empty large-diff"
      }, w.createElement("img", {
        src: Zf
      }), w.createElement("p", null, "差异太大，无法显示."))
    }
    renderLargeText(e) {
      const t = {
        text: e.text,
        hunks: e.hunks,
        kind: Mi.Text,
        lineEndingsChange: e.lineEndingsChange
      };
      return this.renderTextDiff(t)
    }
    renderText(e) {
      return 0 === e.hunks.length ? this.props.file.status.kind === Ki.New || this.props.file.status.kind === Ki.Untracked ? w.createElement("div", {
        className: "panel empty"
      }, "The file is empty") : this.props.file.status.kind === Ki.Renamed ? w.createElement("div", {
        className: "panel renamed"
      }, "The file was renamed but not changed") : oo(this.props.file.status) && ao(this.props.file.status) ? w.createElement("div", {
        className: "panel empty"
      }, "The file is in conflict and must be resolved via the command line.") : this.props.hideWhitespaceInDiff ? w.createElement("div", {
        className: "panel empty"
      }, "Only whitespace changes found") : w.createElement("div", {
        className: "panel empty"
      }, "No content changes found") : this.renderTextDiff(e)
    }
    renderBinaryFile() {
      return w.createElement(Cf, {
        path: this.props.file.path,
        repository: this.props.repository,
        onOpenBinaryFile: this.props.onOpenBinaryFile
      })
    }
    renderTextDiff(e) {
      return w.createElement(Qf, {
        repository: this.props.repository,
        file: this.props.file,
        readOnly: this.props.readOnly,
        onIncludeChanged: this.props.onIncludeChanged,
        onDiscardChanges: this.props.onDiscardChanges,
        diff: e,
        askForConfirmationOnDiscardChanges: this.props.askForConfirmationOnDiscardChanges
      })
    }
  }

  function Jf() {}
  class em extends w.Component {
    constructor(e) {
      super(e), this.slowLoadingTimeoutId = null, this.onSlowLoadingTimeout = () => {
        this.setState({
          isLoadingSlow: !0
        })
      }, this.state = {
        isLoadingDiff: null === e.diff,
        isLoadingSlow: !1,
        propSnapshot: e
      }
    }
    static getDerivedStateFromProps(e, t) {
      const n = null === e.diff,
        r = n !== t.isLoadingDiff;
      return Object.assign(Object.assign({
        isLoadingDiff: n
      }, n ? void 0 : {
        propSnapshot: e
      }), r ? {
        isLoadingSlow: !1
      } : void 0)
    }
    componentDidMount() {
      this.state.isLoadingDiff && this.scheduleSlowLoadingTimeout()
    }
    componentWillUnmount() {
      this.clearSlowLoadingTimeout()
    }
    componentDidUpdate(e, t) {
      this.state.isLoadingDiff !== t.isLoadingDiff && (this.state.isLoadingDiff ? this.scheduleSlowLoadingTimeout() : this.clearSlowLoadingTimeout())
    }
    scheduleSlowLoadingTimeout() {
      this.clearSlowLoadingTimeout(), this.slowLoadingTimeoutId = window.setTimeout(this.onSlowLoadingTimeout, 150)
    }
    clearSlowLoadingTimeout() {
      null !== this.slowLoadingTimeoutId && (window.clearTimeout(this.slowLoadingTimeoutId), this.slowLoadingTimeoutId = null)
    }
    render() {
      const {
        isLoadingDiff: e,
        isLoadingSlow: t
      } = this.state, {
        repository: n,
        imageDiffType: r,
        readOnly: i,
        hideWhitespaceInDiff: o,
        onIncludeChanged: s,
        onDiscardChanges: a,
        diff: l,
        file: c,
        onOpenBinaryFile: u,
        onChangeImageDiffType: h
      } = this.state.propSnapshot, p = mh()("seamless-diff-switcher", {
        loading: e,
        slow: e && t,
        "has-diff": null !== l
      }), d = e ? w.createElement("div", {
        className: "loading-indicator"
      }, w.createElement(fd, null)) : null;
      return w.createElement("div", {
        className: p
      }, null !== l ? w.createElement(Xf, {
        repository: n,
        imageDiffType: r,
        file: c,
        diff: l,
        readOnly: i,
        hideWhitespaceInDiff: o,
        askForConfirmationOnDiscardChanges: this.props.askForConfirmationOnDiscardChanges,
        onIncludeChanged: e ? Jf : s,
        onDiscardChanges: e ? Jf : a,
        onOpenBinaryFile: e ? Jf : u,
        onChangeImageDiffType: e ? Jf : h
      }) : null, d)
    }
  }
  class tm extends w.Component {
    constructor() {
      super(...arguments), this.onDiffLineIncludeChanged = e => {
        const t = this.props.file;
        this.props.dispatcher.changeFileLineSelection(this.props.repository, t, e)
      }, this.onDiscardChanges = (e, t) => {
        this.props.askForConfirmationOnDiscardChanges ? this.props.dispatcher.showPopup({
          type: Zi.ConfirmDiscardSelection,
          repository: this.props.repository,
          file: this.props.file,
          diff: e,
          selection: t
        }) : this.props.dispatcher.discardChangesFromSelection(this.props.repository, this.props.file.path, e, t)
      }
    }
    render() {
      const e = this.props.diff,
        t = this.props.file,
        n = this.props.isCommitting;
      return w.createElement("div", {
        className: "changed-file"
      }, w.createElement(cf, {
        path: t.path,
        status: t.status,
        diff: e
      }), w.createElement(em, {
        repository: this.props.repository,
        imageDiffType: this.props.imageDiffType,
        file: t,
        readOnly: n,
        onIncludeChanged: this.onDiffLineIncludeChanged,
        onDiscardChanges: this.onDiscardChanges,
        diff: e,
        hideWhitespaceInDiff: this.props.hideWhitespaceInDiff,
        askForConfirmationOnDiscardChanges: this.props.askForConfirmationOnDiscardChanges,
        onOpenBinaryFile: this.props.onOpenBinaryFile,
        onChangeImageDiffType: this.props.onChangeImageDiffType
      }))
    }
  }

  function nm(e) {
    switch (e.toLowerCase()) {
      case "cmdorctrl":
      case "commandorcontrol":
        return "Ctrl";
      case "ctrl":
      case "control":
        return "Ctrl";
      case "shift":
        return "Shift";
      case "alt":
        return "Alt";
      case "cmd":
      case "command":
        return "⌘";
      case "option":
        return "⌥";
      case " ":
        return "Space"
    }
    return e
  }
  class rm extends w.Component {
    render() {
      const e = "primary" === this.props.type,
        t = mh()("suggested-action", {
          primary: e
        }),
        n = void 0 === this.props.description ? void 0 : w.createElement("p", {
          className: "description"
        }, this.props.description);
      return w.createElement("div", {
        className: t
      }, this.props.image && w.createElement("div", {
        className: "image-wrapper"
      }, this.props.image), w.createElement("div", {
        className: "text-wrapper"
      }, w.createElement("h2", null, this.props.title), n, this.props.discoverabilityContent && w.createElement("p", {
        className: "discoverability"
      }, this.props.discoverabilityContent)), w.createElement(jp, {
        type: e ? "submit" : void 0,
        onClick: this.props.onClick,
        disabled: this.props.disabled
      }, this.props.buttonText))
    }
  }
  class im extends w.Component {
    constructor() {
      super(...arguments), this.onClick = e => {
        void 0 !== this.props.onClick && this.props.onClick(e), e.defaultPrevented || re(this.props.menuItemId)
      }
    }
    render() {
      return w.createElement(rm, {
        title: this.props.title,
        description: this.props.description,
        discoverabilityContent: this.props.discoverabilityContent,
        buttonText: this.props.buttonText,
        onClick: this.onClick,
        type: this.props.type,
        disabled: this.props.disabled
      })
    }
  }
  var om = n(134),
    sm = n.n(om);
  const am = e => {
    const t = "suggested-action-group " + (e.type ? e.type : "normal");
    if ("replace" === e.transitions) {
      const n = void 0 === e.enableTransitions || e.enableTransitions;
      return w.createElement(sm.a, {
        transitionAppear: !1,
        overflowHidden: !1,
        transitionEnter: n,
        transitionLeave: n,
        transitionName: e.transitions,
        component: "div",
        className: t,
        transitionEnterTimeout: 750,
        transitionLeaveTimeout: 500
      }, e.children)
    }
    return w.createElement("div", {
      className: t
    }, e.children)
  };
  class lm extends w.Component {
    render() {
      return w.createElement("em", {
        className: "ref-component"
      }, this.props.children)
    }
  }

  function cm(e) {
    return e.replace(/&?&/g, e => e.length > 1 ? "&" : "")
  }
  const um = Mc(__dirname, "static/paper-stack.svg");

  function hm(e) {
    return "separator" === e.type || "submenuItem" === e.type || null === e.accelerator ? [] : e.accelerator.split("+").map(nm)
  }
  class pm extends w.Component {
    constructor(e) {
      super(e), this.getMenuInfoMap = $p(e => void 0 === e ? new Map : function e(t, n = new Map, r) {
        for (const i of t.items) {
          if ("separator" === i.type) continue;
          const t = {
            label: i.label,
            acceleratorKeys: hm(i),
            parentMenuLabels: void 0 === r ? [] : [r.label, ...r.parentMenuLabels],
            enabled: i.enabled
          };
          n.set(i.id, t), "submenuItem" === i.type && e(i.menu, n, t)
        }
        return n
      }(e)), this.transitionTimer = null, this.onShowInFileManagerClicked = () => this.props.dispatcher.recordSuggestedStepOpenWorkingDirectory(), this.onViewOnGitHubClicked = () => this.props.dispatcher.recordSuggestedStepViewOnGitHub(), this.openPreferences = () => {
        re("preferences")
      }, this.onOpenInExternalEditorClicked = () => this.props.dispatcher.recordSuggestedStepOpenInExternalEditor(), this.onViewStashClicked = () => this.props.dispatcher.recordSuggestedStepViewStash(), this.onPublishRepositoryClicked = () => this.props.dispatcher.recordSuggestedStepPublishRepository(), this.onPublishBranchClicked = () => this.props.dispatcher.recordSuggestedStepPublishBranch(), this.onCreatePullRequestClicked = () => this.props.dispatcher.recordSuggestedStepCreatePullRequest(), this.state = {
        enableTransitions: !1
      }
    }
    getMenuItemInfo(e) {
      return this.getMenuInfoMap(this.props.appMenu).get(e)
    }
    getPlatformFileManagerName() {
      return "资源管理器"
    }
    renderDiscoverabilityElements(e) {
      const t = function (e) {
        return cm(e.parentMenuLabels.join(" -> "))
      }(e);
      return w.createElement(w.Fragment, null, t, "菜单或", " ", this.renderDiscoverabilityKeyboardShortcut(e))
    }
    renderDiscoverabilityKeyboardShortcut(e) {
      return e.acceleratorKeys.map((e, t) => w.createElement("kbd", {
        key: e + t
      }, e))
    }
    renderMenuBackedAction(e, t, n, r) {
      const i = this.getMenuItemInfo(e);
      return void 0 === i ? (log.error("Could not find matching menu item for " + e), null) : w.createElement(im, {
        title: t,
        description: n,
        discoverabilityContent: this.renderDiscoverabilityElements(i),
        menuItemId: e,
        buttonText: cm(i.label),
        disabled: !i.enabled,
        onClick: r
      })
    }
    renderShowInFileManager() {
      const e = this.getPlatformFileManagerName();
      return this.renderMenuBackedAction("open-working-directory", "在"+e+"中查看存储库的文件", void 0, this.onShowInFileManagerClicked)
    }
    renderViewOnGitHub() {
      return null !== this.props.repository.gitHubRepository ? this.renderMenuBackedAction("view-repository-on-github", "在浏览器中打开GitHub上的repository页面", void 0, this.onViewOnGitHubClicked) : null
    }
    renderOpenInExternalEditor() {
      if (!this.props.isExternalEditorAvailable) return null;
      const e = "open-external-editor";
      if (void 0 === this.getMenuItemInfo(e)) return log.error("找不到与"+e+"匹配的菜单项" ), null;
      if (void 0 === this.getMenuItemInfo("preferences")) return log.error("找不到与"+e+"匹配的菜单项"), null;
      const t = w.createElement(w.Fragment, null, "选择编辑器于", " ", w.createElement(Ip, {
        onClick: this.openPreferences
      }, "选项"));
      return this.renderMenuBackedAction(e, "在外部编辑器中打开存储库", t, this.onOpenInExternalEditorClicked)
    }
    renderRemoteAction() {
      const {
        remote: e,
        aheadBehind: t,
        branchesState: n,
        tagsToPush: r
      } = this.props.repositoryState, {
        tip: i,
        defaultBranch: o,
        currentPullRequest: s
      } = n;
      if (i.kind !== Qi.Valid) return null;
      if (null === e) return this.renderPublishRepositoryAction();
      if (null === t) return this.renderPublishBranchAction(i);
      if (yl(n, t)) return null;
      if (t.behind > 0) return this.renderPullBranchAction(i, e, t);
      if (t.ahead > 0 || null !== r && r.length > 0) return this.renderPushBranchAction(i, e, t, r);
      const a = null !== this.props.repository.gitHubRepository,
        l = null !== s,
        c = null !== o && i.branch.name === o.name;
      return !a || l || c ? null : this.renderCreatePullRequestAction(i)
    }
    renderViewStashAction() {
      const {
        changesState: e,
        branchesState: t
      } = this.props.repositoryState, {
        tip: n
      } = t;
      if (n.kind !== Qi.Valid) return null;
      const {
        stashEntry: r
      } = e;
      if (null === r) return null;
      if (r.files.kind !== zc.Loaded) return null;
      const i = r.files.files.length,
        o = w.createElement(w.Fragment, null, "您有", i, " ", 1 === i ? "正在进行的更改" : "正在进行的更改", " 尚未提交."),
        s = w.createElement(w.Fragment, null, "在左侧“更改”选项卡的底部访问它."),
        a = "toggle-stashed-changes",
        l = this.getMenuItemInfo(a);
      return void 0 === l ? (log.error("找不到与" + a + "匹配的菜单项"), null) : w.createElement(im, {
        key: "view-stash-action",
        title: "查看你已经贮藏的更改",
        menuItemId: a,
        description: o,
        discoverabilityContent: s,
        buttonText: "查看贮藏",
        type: "primary",
        disabled: null !== l && !l.enabled,
        onClick: this.onViewStashClicked
      })
    }
    renderPublishRepositoryAction() {
      const e = this.getMenuItemInfo("push");
      if (void 0 === e) return log.error("找不到匹配的菜单项"), null;
      const t = w.createElement(w.Fragment, null, "在工具栏中可访问或快捷键", " ", this.renderDiscoverabilityKeyboardShortcut(e));
      return w.createElement(im, {
        key: "publish-repository-action",
        title: "将存储库发布到GitHub",
        description: "此存储库当前仅在本地计算机上可用.通过在github上发布它，您可以共享它，并与其他人协作.",
        discoverabilityContent: t,
        buttonText: "发布存储库",
        menuItemId: "push",
        type: "primary",
        disabled: !e.enabled,
        onClick: this.onPublishRepositoryClicked
      })
    }
    renderPublishBranchAction(e) {
      const t = this.getMenuItemInfo("push");
      if (void 0 === t) return log.error("找不到匹配的菜单项"), null;
      const n = null !== this.props.repository.gitHubRepository,
        r = w.createElement(w.Fragment, null, "当前分支(", w.createElement(lm, null, e.branch.name), ")尚未发布到远程.通过发布它 ", n ? "至Github" : "", "你可以分享它, ", n ? "打开 pull request, " : "", "与他人合作."),
        i = w.createElement(w.Fragment, null, "在工具栏中可访问或快捷键", " ", this.renderDiscoverabilityKeyboardShortcut(t));
      return w.createElement(im, {
        key: "publish-branch-action",
        title: "发布你的分支",
        menuItemId: "push",
        description: r,
        discoverabilityContent: i,
        buttonText: "发布分支",
        type: "primary",
        disabled: !t.enabled,
        onClick: this.onPublishBranchClicked
      })
    }
    renderPullBranchAction(e, t, n) {
      const r = this.getMenuItemInfo("pull");
      if (void 0 === r) return log.error("Could not find matching menu item for pull"), null;
      const i = null !== this.props.repository.gitHubRepository,
        o = w.createElement(w.Fragment, null, "The current branch (", w.createElement(lm, null, e.branch.name), ") 有", " ", 1 === n.behind ? "a commit" : "commits", " 至远程", " ", i ? "GitHub" : "但", " ", " ", 1 === n.behind ? "不" : "不", " 存在与你的机器."),
        s = w.createElement(w.Fragment, null, "当有远程更改时可在工具栏中访问或快捷键", " ", this.renderDiscoverabilityKeyboardShortcut(r)),
        a = `Pull ${n.behind} ${1===n.behind?"commit":"commits"} from the ${t.name} remote`,
        l = "Pull " + t.name;
      return w.createElement(im, {
        key: "pull-branch-action",
        title: a,
        menuItemId: "pull",
        description: o,
        discoverabilityContent: s,
        buttonText: l,
        type: "primary",
        disabled: !r.enabled
      })
    }
    renderPushBranchAction(e, t, n, r) {
      const i = this.getMenuItemInfo("push");
      if (void 0 === i) return log.error("Could not find matching menu item for push"), null;
      const o = null !== this.props.repository.gitHubRepository,
        s = [],
        a = [];
      n.ahead > 0 && (s.push("commits"), a.push(1 === n.ahead ? "1 local commit" : n.ahead + " local commits")), null !== r && r.length > 0 && (s.push("tags"), a.push(1 === r.length ? "1 tag" : r.length + " tags"));
      const l = `You have ${a.join(" and ")} waiting to be pushed to ${o?"GitHub":"the remote"}.`,
        c = w.createElement(w.Fragment, null, "Always available in the toolbar when there are local commits waiting to be pushed or ", this.renderDiscoverabilityKeyboardShortcut(i)),
        u = `Push ${s.join(" and ")} to the ${t.name} remote`,
        h = "Push " + t.name;
      return w.createElement(im, {
        key: "push-branch-action",
        title: u,
        menuItemId: "push",
        description: l,
        discoverabilityContent: c,
        buttonText: h,
        type: "primary",
        disabled: !i.enabled
      })
    }
    renderCreatePullRequestAction(e) {
      const t = "create-pull-request",
        n = this.getMenuItemInfo(t);
      if (void 0 === n) return log.error("Could not find matching menu item for " + t), null;
      const r = w.createElement(w.Fragment, null, "The current branch (", w.createElement(lm, null, e.branch.name), ") is already published to GitHub. Create a pull request to propose and collaborate on your changes.");
      return w.createElement(im, {
        key: "create-pr-action",
        title: "Create a Pull Request from your current branch",
        menuItemId: t,
        description: r,
        buttonText: "Create Pull Request",
        discoverabilityContent: this.renderDiscoverabilityElements(n),
        type: "primary",
        disabled: !n.enabled,
        onClick: this.onCreatePullRequestClicked
      })
    }
    renderActions() {
      return w.createElement(w.Fragment, null, w.createElement(am, {
        type: "primary",
        transitions: "replace",
        enableTransitions: this.state.enableTransitions
      }, this.renderViewStashAction() || this.renderRemoteAction()), w.createElement(am, null, this.renderOpenInExternalEditor(), this.renderShowInFileManager(), this.renderViewOnGitHub()))
    }
    componentDidMount() {
      this.transitionTimer = window.setTimeout(() => {
        this.setState({
          enableTransitions: !0
        }), this.transitionTimer = null
      }, 500)
    }
    componentWillUnmount() {
      null !== this.transitionTimer && clearTimeout(this.transitionTimer)
    }
    render() {
      return w.createElement("div", {
        id: "no-changes"
      }, w.createElement("div", {
        className: "content"
      }, w.createElement("div", {
        className: "header"
      }, w.createElement("div", {
        className: "text"
      }, w.createElement("h1", null, "无本地更改"), w.createElement("p", null, "此存储库中没有未提交的更改. 下面是一些关于下一步该怎么做的友好建议.")), w.createElement("img", {
        src: um,
        className: "blankslate-image"
      })), this.renderActions()))
    }
  }
  const dm = Mc(__dirname, "static/multiple-files-selected.svg");
  class fm extends w.Component {
    render() {
      return w.createElement("div", {
        className: "panel blankslate",
        id: "no-changes"
      }, w.createElement("img", {
        src: dm,
        className: "blankslate-image"
      }), w.createElement("div", null, this.props.count, " files selected"))
    }
  }
  class mm extends w.Component {
    render() {
      const e = this.props.filesChangedCount,
        t = e > 300 ? "300+" : e;
      return w.createElement("span", {
        className: "counter"
      }, t)
    }
  }
  class gm extends w.Component {
    constructor() {
      super(...arguments), this.startWidth = null, this.startX = null, this.handleDragStart = e => {
        this.startX = e.clientX, this.startWidth = this.getCurrentWidth() || null, document.addEventListener("mousemove", this.handleDragMove), document.addEventListener("mouseup", this.handleDragStop), e.preventDefault()
      }, this.handleDragMove = e => {
        if (null == this.startWidth || null == this.startX) return;
        const t = e.clientX - this.startX,
          n = this.startWidth + t,
          r = this.clampWidth(n);
        this.props.onResize && this.props.onResize(r), e.preventDefault()
      }, this.handleDragStop = e => {
        document.removeEventListener("mousemove", this.handleDragMove), document.removeEventListener("mouseup", this.handleDragStop), e.preventDefault()
      }, this.handleDoubleClick = () => {
        this.props.onReset && this.props.onReset()
      }
    }
    getCurrentWidth() {
      return this.clampWidth(this.props.width)
    }
    clampWidth(e) {
      return Math.max(this.props.minimumWidth, Math.min(this.props.maximumWidth, e))
    }
    render() {
      const e = {
        width: this.getCurrentWidth(),
        maxWidth: this.props.maximumWidth,
        minWidth: this.props.minimumWidth
      };
      return w.createElement("div", {
        id: this.props.id,
        className: "resizable-component",
        style: e
      }, this.props.children, w.createElement("div", {
        onMouseDown: this.handleDragStart,
        onDoubleClick: this.handleDoubleClick,
        className: "resize-handle"
      }))
    }
  }
  gm.defaultProps = {
    width: 250,
    maximumWidth: 350,
    minimumWidth: 200
  };
  class ym extends w.Component {
    render() {
      const e = [],
        t = this.props.users;
      for (let n = 0; n < this.props.users.length; n++) t.length > 3 && 2 === n && e.push(w.createElement("div", {
        key: "more",
        className: "avatar-more avatar"
      })), e.push(w.createElement(dd, {
        key: "" + n,
        user: t[n],
        title: null
      }));
      const n = mh()("AvatarStack", {
        "AvatarStack--small": !0,
        "AvatarStack--two": 2 === t.length,
        "AvatarStack--three-plus": t.length >= 3
      });
      return w.createElement("div", {
        className: n
      }, w.createElement("div", {
        className: "AvatarStack-body"
      }, e))
    }
  }
  class vm extends w.Component {
    renderAuthorInline(e) {
      return w.createElement("span", {
        className: "author"
      }, e.name)
    }
    renderAuthors(e) {
      if (1 === e.length) return w.createElement("span", {
        className: "authors"
      }, this.renderAuthorInline(e[0]));
      if (2 === e.length) {
        const t = e.map(e => e.name).join(", ");
        return w.createElement("span", {
          className: "authors",
          title: t
        }, this.renderAuthorInline(e[0]), ", ", this.renderAuthorInline(e[1]))
      } {
        const t = e.map(e => e.name).join(", ");
        return w.createElement("span", {
          className: "authors",
          title: t
        }, e.length, " people")
      }
    }
    render() {
      const e = this.props.commit,
        {
          author: t,
          committer: n,
          coAuthors: r
        } = e,
        i = !(e.authoredByCommitter || null !== this.props.gitHubRepository && Fd(e, this.props.gitHubRepository)) ? [t, n, ...r] : [t, ...r];
      return w.createElement("span", {
        className: "commit-attribution-component"
      }, this.renderAuthors(i))
    }
  }

  function wm() {
    return bm("…")
  }

  function bm(e) {
    return {
      kind: ef.Text,
      text: e
    }
  }

  function Sm(e, t) {
    return {
      kind: ef.Link,
      text: e,
      url: t
    }
  }

  function Cm(e, t) {
    const n = new tf(t.emoji, t.repository),
      {
        summary: r,
        body: i
      } = function (e, t, n, r = 72) {
        const i = n.tokenize(e.trimRight()),
          o = new Array,
          s = new Array;
        let a = r;
        for (const e of i) {
          const t = e.kind === ef.Emoji ? 2 : e.text.length;
          if (a <= 0) s.push(e);
          else if (a >= t) o.push(e), a -= t;
          else {
            if (e.kind === ef.Text) o.push(bm(e.text.substr(0, a))), s.push(bm(e.text.substr(a)));
            else if (e.kind === ef.Emoji) s.push(e);
            else {
              if (e.kind !== ef.Link) return X(0, "Unknown token type");
              !e.text.startsWith("#") && a > 5 ? (o.push(Sm(e.text.substr(0, a), e.text)), s.push(Sm(e.text.substr(a), e.text))) : s.push(e)
            }
            a = 0
          }
        }
        let l = n.tokenize(t.trimRight());
        return s.length > 0 && (o.push(wm()), l = l.length > 0 ? [wm(), ...s, bm("\n\n"), ...l] : [wm(), ...s]), {
          summary: o,
          body: l
        }
      }(t.commit.summary, t.commit.body, n);
    return {
      isOverflowed: e,
      summary: r,
      body: i,
      avatarUsers: Hd(t.repository.gitHubRepository, t.commit)
    }
  }
  class Em extends w.Component {
    constructor(e) {
      super(e), this.descriptionScrollViewRef = null, this.resizeObserver = null, this.updateOverflowTimeoutId = null, this.descriptionRef = null, this.onHideWhitespaceInDiffChanged = e => {
        const t = e.currentTarget.checked;
        this.props.onHideWhitespaceInDiffChanged(t)
      }, this.onResized = () => {
        if (this.descriptionRef) {
          const e = this.descriptionRef.getBoundingClientRect().bottom;
          this.props.onDescriptionBottomChanged(e)
        }
        this.props.isExpanded || this.updateOverflow()
      }, this.onDescriptionScrollViewRef = e => {
        this.descriptionScrollViewRef = e, this.resizeObserver && (this.resizeObserver.disconnect(), e ? this.resizeObserver.observe(e) : this.setState({
          isOverflowed: !1
        }))
      }, this.onDescriptionRef = e => {
        this.descriptionRef = e
      }, this.onExpand = () => {
        this.props.onExpandChanged(!0)
      }, this.onCollapse = () => {
        this.descriptionScrollViewRef && (this.descriptionScrollViewRef.scrollTop = 0), this.props.onExpandChanged(!1)
      }, this.state = Cm(!1, e);
      const t = window.ResizeObserver;
      t && (this.resizeObserver = new t(e => {
        for (const t of e) t.target === this.descriptionScrollViewRef && (null !== this.updateOverflowTimeoutId && clearImmediate(this.updateOverflowTimeoutId), this.updateOverflowTimeoutId = setImmediate(this.onResized))
      }))
    }
    renderExpander() {
      if (!this.state.body.length || !this.props.isExpanded && !this.state.isOverflowed) return null;
      const e = this.props.isExpanded,
        t = e ? this.onCollapse : this.onExpand,
        n = e ? Sh.fold : Sh.unfold;
      return w.createElement("a", {
        onClick: t,
        className: "expander"
      }, w.createElement(bh, {
        symbol: n
      }), e ? "Collapse" : "Expand")
    }
    updateOverflow() {
      const e = this.descriptionScrollViewRef;
      e ? this.setState({
        isOverflowed: e.scrollHeight > e.offsetHeight
      }) : this.state.isOverflowed && this.setState({
        isOverflowed: !1
      })
    }
    componentDidMount() {
      this.props.isExpanded || this.updateOverflow()
    }
    componentWillUpdate(e) {
      var t, n;
      t = e.commit, n = this.props.commit, (t.summary !== n.summary || t.body !== n.body) && this.setState(Cm(!1, e))
    }
    componentDidUpdate(e, t) {
      this.props.isExpanded ? this.state.isOverflowed && this.setState({
        isOverflowed: !1
      }) : (t.body !== this.state.body || e.isExpanded) && this.updateOverflow()
    }
    renderDescription() {
      return 0 === this.state.body.length ? null : w.createElement("div", {
        className: "commit-summary-description-container",
        ref: this.onDescriptionRef
      }, w.createElement("div", {
        className: "commit-summary-description-scroll-view",
        ref: this.onDescriptionScrollViewRef
      }, w.createElement(rf, {
        className: "commit-summary-description",
        emoji: this.props.emoji,
        repository: this.props.repository,
        text: this.state.body
      })), this.renderExpander())
    }
    render() {
      const e = this.props.files.length,
        t = `${e} changed ${1===e?"file":"files"}`,
        n = this.props.commit.shortSha,
        r = mh()({
          expanded: this.props.isExpanded,
          collapsed: !this.props.isExpanded,
          "has-expander": this.props.isExpanded || this.state.isOverflowed,
          "hide-description-border": this.props.hideDescriptionBorder
        });
      return w.createElement("div", {
        id: "commit-summary",
        className: r
      }, w.createElement("div", {
        className: "commit-summary-header"
      }, w.createElement(rf, {
        className: "commit-summary-title",
        emoji: this.props.emoji,
        repository: this.props.repository,
        text: this.state.summary
      }), w.createElement("ul", {
        className: "commit-summary-meta"
      }, w.createElement("li", {
        className: "commit-summary-meta-item without-truncation",
        "aria-label": "Author"
      }, w.createElement(ym, {
        users: this.state.avatarUsers
      }), w.createElement(vm, {
        gitHubRepository: this.props.repository.gitHubRepository,
        commit: this.props.commit
      })), w.createElement("li", {
        className: "commit-summary-meta-item without-truncation",
        "aria-label": "SHA"
      }, w.createElement("span", {
        "aria-hidden": "true"
      }, w.createElement(bh, {
        symbol: Sh.gitCommit
      })), w.createElement("span", {
        className: "sha"
      }, n)), w.createElement("li", {
        className: "commit-summary-meta-item without-truncation",
        title: t
      }, w.createElement("span", {
        "aria-hidden": "true"
      }, w.createElement(bh, {
        symbol: Sh.diff
      })), t), this.renderTags(), w.createElement("li", {
        className: "commit-summary-meta-item without-truncation",
        title: t
      }, w.createElement(Xp, {
        label: "Hide Whitespace",
        value: this.props.hideWhitespaceInDiff ? Zp.On : Zp.Off,
        onChange: this.onHideWhitespaceInDiffChanged
      })))), this.renderDescription())
    }
    renderTags() {
      const e = this.props.commit.tags || [];
      return 0 === e.length ? null : w.createElement("li", {
        className: "commit-summary-meta-item",
        title: e.join("\n")
      }, w.createElement("span", {
        "aria-label": "Tags"
      }, w.createElement(bh, {
        symbol: Sh.tag
      })), w.createElement("span", {
        className: "tags"
      }, e.join(", ")))
    }
  }
  class km extends w.Component {
    constructor() {
      super(...arguments), this.onSelectedRowChanged = e => {
        const t = this.props.files[e];
        this.props.onSelectedFileChanged(t)
      }, this.renderFile = e => {
        const t = this.props.files[e],
          n = t.status,
          r = Ul(n),
          i = this.props.availableWidth - 20 - 5 - 16;
        return w.createElement("div", {
          className: "file",
          onContextMenu: this.props.onContextMenu
        }, w.createElement(qd, {
          path: t.path,
          status: t.status,
          availableWidth: i
        }), w.createElement(bh, {
          symbol: Eh(n),
          className: "status status-" + r.toLowerCase(),
          title: r
        }))
      }
    }
    rowForFile(e) {
      return e ? this.props.files.findIndex(t => t.path === e.path) : -1
    }
    render() {
      return w.createElement("div", {
        className: "file-list"
      }, w.createElement(Pp, {
        rowRenderer: this.renderFile,
        rowCount: this.props.files.length,
        rowHeight: 29,
        selectedRows: [this.rowForFile(this.props.selectedFile)],
        onSelectedRowChanged: this.onSelectedRowChanged
      }))
    }
  }
  class xm extends w.Component {
    constructor(e) {
      super(e), this.loadChangedFilesScheduler = new od(200), this.historyRef = null, this.onFileSelected = e => {
        this.props.dispatcher.changeFileSelection(this.props.repository, e)
      }, this.onHistoryRef = e => {
        this.historyRef = e
      }, this.onExpandChanged = e => {
        this.setState({
          isExpanded: e
        })
      }, this.onDescriptionBottomChanged = e => {
        if (this.historyRef) {
          const t = this.historyRef.getBoundingClientRect().bottom;
          this.setState({
            hideDescriptionBorder: e >= t
          })
        }
      }, this.onHideWhitespaceInDiffChanged = e => {
        this.props.dispatcher.onHideWhitespaceInDiffChanged(e, this.props.repository, this.props.selectedFile)
      }, this.onCommitSummaryReset = () => {
        this.props.dispatcher.resetCommitSummaryWidth()
      }, this.onCommitSummaryResize = e => {
        this.props.dispatcher.setCommitSummaryWidth(e)
      }, this.onOpenItem = e => {
        af(i.join(this.props.repository.path, e), this.props.dispatcher)
      }, this.onContextMenu = async e => {
        if (e.preventDefault(), null == this.props.selectedFile) return;
        const t = this.props.selectedFile.path,
          n = i.join(this.props.repository.path, t),
          o = await Object(Ci.pathExists)(n);
        if (!o) return void ie([{
          label: "磁盘上不存在文件",
          enabled: !1
        }]);
        const s = Ah(i.extname(t));
        ie([{
          label: "复制文件路径",
          action: () => r.clipboard.writeText(n)
        }, {
          label: "在资源管理器中显示",
          action: () => te(this.props.repository, t),
          enabled: o
        }, {
          label: this.props.externalEditorLabel ? "用" + this.props.externalEditorLabel+"打开" : "在外部编辑器中打开",
          action: () => this.props.onOpenInExternalEditor(n),
          enabled: s && o
        }, {
          label: "用默认程序打开",
          action: () => this.onOpenItem(t),
          enabled: s && o
        }])
      }, this.state = {
        isExpanded: !1,
        hideDescriptionBorder: !1
      }
    }
    componentWillUpdate(e) {
      const t = this.props.selectedCommit ? this.props.selectedCommit.sha : void 0,
        n = e.selectedCommit ? e.selectedCommit.sha : void 0;
      (t || n) && t !== n && this.state.isExpanded && this.setState({
        isExpanded: !1
      })
    }
    componentWillUnmount() {
      this.loadChangedFilesScheduler.clear()
    }
    renderDiff() {
      const e = this.props.selectedFile,
        t = this.props.currentDiff;
      if (null == e) {
        const e = 0 === this.props.changedFiles.length ? "" : "No file selected";
        return w.createElement("div", {
          className: "panel blankslate",
          id: "diff"
        }, e)
      }
      return w.createElement(em, {
        repository: this.props.repository,
        imageDiffType: this.props.selectedDiffType,
        file: e,
        diff: t,
        readOnly: !0,
        hideWhitespaceInDiff: this.props.hideWhitespaceInDiff,
        onOpenBinaryFile: this.props.onOpenBinaryFile,
        onChangeImageDiffType: this.props.onChangeImageDiffType
      })
    }
    renderCommitSummary(e) {
      return w.createElement(Em, {
        commit: e,
        files: this.props.changedFiles,
        emoji: this.props.emoji,
        repository: this.props.repository,
        onExpandChanged: this.onExpandChanged,
        isExpanded: this.state.isExpanded,
        onDescriptionBottomChanged: this.onDescriptionBottomChanged,
        hideDescriptionBorder: this.state.hideDescriptionBorder,
        hideWhitespaceInDiff: this.props.hideWhitespaceInDiff,
        onHideWhitespaceInDiffChanged: this.onHideWhitespaceInDiffChanged
      })
    }
    renderFileList() {
      const e = this.props.changedFiles;
      if (0 === e.length) return w.createElement("div", {
        className: "fill-window"
      }, "No files in commit");
      const t = this.props.commitSummaryWidth - 1;
      return w.createElement(km, {
        files: e,
        onSelectedFileChanged: this.onFileSelected,
        selectedFile: this.props.selectedFile,
        availableWidth: t,
        onContextMenu: this.onContextMenu
      })
    }
    render() {
      const e = this.props.selectedCommit;
      if (null == e) return w.createElement(Tm, null);
      const t = this.state.isExpanded ? "expanded" : "collapsed";
      return w.createElement("div", {
        id: "history",
        ref: this.onHistoryRef,
        className: t
      }, this.renderCommitSummary(e), w.createElement("div", {
        className: "commit-details"
      }, w.createElement(gm, {
        width: this.props.commitSummaryWidth,
        onResize: this.onCommitSummaryResize,
        onReset: this.onCommitSummaryReset
      }, this.renderFileList()), this.renderDiff()))
    }
  }

  function Tm() {
    const e = Mc(__dirname, "static/empty-no-commit.svg");
    return w.createElement("div", {
      className: "panel blankslate"
    }, w.createElement("img", {
      src: e,
      className: "blankslate-image"
    }), "No commit selected")
  }
  class Rm extends w.PureComponent {
    constructor(e) {
      super(e), this.onCopySHA = () => {
        r.clipboard.writeText(this.props.commit.sha)
      }, this.onViewOnGitHub = () => {
        this.props.onViewCommitOnGitHub && this.props.onViewCommitOnGitHub(this.props.commit.sha)
      }, this.onCreateTag = () => {
        this.props.onCreateTag && this.props.onCreateTag(this.props.commit.sha)
      }, this.onContextMenu = e => {
        e.preventDefault();
        let t = "在GitHub上查看";
        const n = this.props.gitHubRepository;
        n && n.endpoint !== pt() && (t = "View on GitHub Enterprise");
        const r = [{
          label: "还原此提交",
          action: () => {
            this.props.onRevertCommit && this.props.onRevertCommit(this.props.commit)
          },
          enabled: void 0 !== this.props.onRevertCommit
        }]; {
          r.push({
            label: "创建Tag…",
            action: this.onCreateTag,
            enabled: void 0 !== this.props.onCreateTag
          });
          const e = this.getDeleteTagsMenuItem();
          null !== e && r.push({
            type: "separator"
          }, e)
        }
        r.push({
          type: "separator"
        }, {
          label: "复制SHA",
          action: this.onCopySHA
        }, {
          label: t,
          action: this.onViewOnGitHub,
          enabled: !this.props.isLocal && !!n
        }), ie(r)
      }, this.state = {
        avatarUsers: Hd(e.gitHubRepository, e.commit)
      }
    }
    componentWillReceiveProps(e) {
      e.commit !== this.props.commit && this.setState({
        avatarUsers: Hd(e.gitHubRepository, e.commit)
      })
    }
    render() {
      const e = this.props.commit,
        {
          author: {
            date: t
          }
        } = e;
      return w.createElement("div", {
        className: "commit",
        onContextMenu: this.onContextMenu
      }, w.createElement("div", {
        className: "info"
      }, w.createElement(rf, {
        className: "summary",
        emoji: this.props.emoji,
        text: e.summary,
        renderUrlsAsLinks: !1
      }), w.createElement("div", {
        className: "description"
      }, w.createElement(ym, {
        users: this.state.avatarUsers
      }), w.createElement("div", {
        className: "byline"
      }, w.createElement(vm, {
        gitHubRepository: this.props.gitHubRepository,
        commit: e
      }), function (e) {
        return w.createElement(w.Fragment, null, " • ", w.createElement( of , {
          date: e,
          abbreviate: !0
        }))
      }(t)))), this.renderCommitIndicators())
    }
    renderCommitIndicators() {
      const e = function (e) {
          if (0 === e.length) return null;
          const [t] = e;
          return w.createElement("span", {
            className: "tag-indicator"
          }, w.createElement("span", {
            className: "tag-name",
            key: t
          }, t), e.length > 1 && w.createElement("span", {
            key: e.length,
            className: "tag-indicator-more"
          }))
        }(this.props.commit.tags),
        t = this.renderUnpushedIndicator();
      return e || t ? w.createElement("div", {
        className: "commit-indicators"
      }, e, t) : null
    }
    renderUnpushedIndicator() {
      return this.props.showUnpushedIndicator ? w.createElement("div", {
        className: "unpushed-indicator",
        title: this.props.unpushedIndicatorTitle
      }, w.createElement(bh, {
        symbol: Sh.arrowUp
      })) : null
    }
    getDeleteTagsMenuItem() {
      const {
        unpushedTags: e,
        onDeleteTag: t,
        commit: n
      } = this.props;
      if (void 0 === t || void 0 === e || 0 === n.tags.length) return null;
      if (1 === n.tags.length) {
        const r = n.tags[0];
        return {
          label: "删除tag " + r,
          action: () => t(r),
          enabled: e.includes(r)
        }
      }
      const r = new Set(e);
      return {
        label: "删除tag…",
        submenu: n.tags.map(e => ({
          label: e,
          action: () => t(e),
          enabled: r.has(e)
        }))
      }
    }
  }
  class Dm extends w.Component {
    constructor() {
      super(...arguments), this.commitsHash = $p(Am, wu), this.renderCommit = e => {
        const t = this.props.commitSHAs[e],
          n = this.props.commitLookup.get(t);
        if (null == n) return null;
        const r = new Set(this.props.tagsToPush || []),
          i = this.props.localCommitSHAs.includes(n.sha),
          o = n.tags.filter(e => r.has(e)),
          s = (i || o.length > 0) && !1 === this.props.isLocalRepository;
        return w.createElement(Rm, {
          key: n.sha,
          gitHubRepository: this.props.gitHubRepository,
          isLocal: i,
          showUnpushedIndicator: s,
          unpushedIndicatorTitle: this.getUnpushedIndicatorTitle(i, o.length),
          unpushedTags: o,
          commit: n,
          emoji: this.props.emoji,
          onCreateTag: this.props.onCreateTag,
          onDeleteTag: this.props.onDeleteTag,
          onRevertCommit: this.props.onRevertCommit,
          onViewCommitOnGitHub: this.props.onViewCommitOnGitHub
        })
      }, this.onSelectedRowChanged = e => {
        const t = this.props.commitSHAs[e],
          n = this.props.commitLookup.get(t);
        n && this.props.onCommitSelected(n)
      }, this.onScroll = (e, t) => {
        const n = Math.ceil(t / 50),
          r = Math.floor(e / 50),
          i = r + n;
        this.props.onScroll(r, i), null != this.props.onCompareListScrolled && this.props.onCompareListScrolled(e)
      }
    }
    getVisibleCommits() {
      const e = new Array;
      for (const t of this.props.commitSHAs) {
        const n = this.props.commitLookup.get(t);
        void 0 !== n && e.push(n)
      }
      return e
    }
    getUnpushedIndicatorTitle(e, t) {
      return e ? "This commit has not been pushed to the remote repository" : t > 0 ? `This commit has ${t} tag${t>1?"s":""} to push` : void 0
    }
    rowForSHA(e) {
      const t = e;
      return t ? this.props.commitSHAs.findIndex(e => e === t) : -1
    }
    render() {
      return 0 === this.props.commitSHAs.length ? w.createElement("div", {
        className: "panel blankslate"
      }, this.props.emptyListMessage) : w.createElement("div", {
        id: "commit-list"
      }, w.createElement(Pp, {
        rowCount: this.props.commitSHAs.length,
        rowHeight: 50,
        selectedRows: [this.rowForSHA(this.props.selectedSHA)],
        rowRenderer: this.renderCommit,
        onSelectedRowChanged: this.onSelectedRowChanged,
        onScroll: this.onScroll,
        invalidationProps: {
          commits: this.props.commitSHAs,
          localCommitSHAs: this.props.localCommitSHAs,
          commitLookupHash: this.commitsHash(this.getVisibleCommits()),
          tagsToPush: this.props.tagsToPush
        },
        setScrollTop: this.props.compareListScrollTop
      }))
    }
  }

  function _m(e) {
    return `${e.sha} ${e.tags}`
  }

  function Am(e) {
    return e.map(_m).join(" ")
  }
  class Mm extends w.Component {
    render() {
      const e = mh()("dialog-content", this.props.className);
      return w.createElement("div", {
        className: e,
        ref: this.props.onRef
      }, this.props.children)
    }
  }
  class Pm extends w.Component {
    constructor() {
      super(...arguments), this.onCloseButtonClick = e => {
        this.props.onDismissed && this.props.onDismissed()
      }
    }
    renderCloseButton() {
      return this.props.dismissable ? w.createElement("a", {
        className: "close",
        onClick: this.onCloseButtonClick,
        "aria-label": "close",
        role: "button"
      }, w.createElement(bh, {
        symbol: Sh.x
      })) : null
    }
    renderTitle() {
      return w.createElement("h1", {
        id: this.props.titleId
      }, this.props.title)
    }
    render() {
      const e = this.props.loading ? w.createElement(bh, {
        className: "icon spin",
        symbol: Sh.sync
      }) : null;
      return w.createElement("header", {
        className: "dialog-header"
      }, this.renderTitle(), e, this.renderCloseButton(), this.props.children)
    }
  }
  class Im extends w.Component {
    constructor(e) {
      super(e), this.dialogElement = null, this.disableClickDismissalTimeoutId = null, this.disableClickDismissal = !1, this.resizeDebounceId = null, this.scheduleResizeEvent = () => {
        null !== this.resizeDebounceId && (cancelAnimationFrame(this.resizeDebounceId), this.resizeDebounceId = null), this.resizeDebounceId = requestAnimationFrame(this.onResized)
      }, this.onResized = () => {
        if (!this.dialogElement) return;
        const {
          offsetTop: e,
          offsetHeight: t
        } = this.dialogElement;
        if (t > window.innerHeight - 28) return;
        const n = e + t + 10 - window.innerHeight;
        if (n > 0) {
          const t = Math.max(28, e - n);
          this.dialogElement.style.top = t + "px"
        }
      }, this.onDismissGraceTimer = () => {
        this.setState({
          isAppearing: !1
        })
      }, this.onWindowFocus = () => {
        this.clearClickDismissalTimer(), this.disableClickDismissal = !0, this.disableClickDismissalTimeoutId = window.setTimeout(() => {
          this.disableClickDismissal = !1, this.disableClickDismissalTimeoutId = null
        }, 500)
      }, this.onDialogCancel = e => {
        e.preventDefault(), this.onDismiss()
      }, this.onDialogMouseDown = e => {
        if (!e.defaultPrevented && !1 !== this.isDismissable() && e.target === this.dialogElement) return this.disableClickDismissal ? (this.disableClickDismissal = !1, void this.clearClickDismissalTimer()) : void(this.mouseEventIsInsideDialog(e) || document.addEventListener("mouseup", this.onDocumentMouseUp, {
          once: !0
        }))
      }, this.onDocumentMouseUp = e => {
        e.defaultPrevented || this.mouseEventIsInsideDialog(e) || (e.preventDefault(), this.onDismiss())
      }, this.onDialogRef = e => {
        e ? e.addEventListener("cancel", this.onDialogCancel) : this.dialogElement && this.dialogElement.removeEventListener("cancel", this.onDialogCancel), this.dialogElement = e
      }, this.onKeyDown = e => {
        if (e.defaultPrevented) return;
        (e.ctrlKey && "w" === e.key || "Escape" === e.key) && this.onDialogCancel(e)
      }, this.onDismiss = () => {
        this.isDismissable() && !this.state.isAppearing && this.props.onDismissed && this.props.onDismissed()
      }, this.onSubmit = e => {
        e.preventDefault(), this.props.onSubmit ? this.props.onSubmit() : this.onDismiss()
      }, this.state = {
        isAppearing: !0
      }, this.resizeObserver = new ResizeObserver(this.scheduleResizeEvent)
    }
    clearDismissGraceTimeout() {
      void 0 !== this.dismissGraceTimeoutId && (window.clearTimeout(this.dismissGraceTimeoutId), this.dismissGraceTimeoutId = void 0)
    }
    scheduleDismissGraceTimeout() {
      this.clearDismissGraceTimeout(), this.dismissGraceTimeoutId = window.setTimeout(this.onDismissGraceTimer, 250)
    }
    isDismissable() {
      return void 0 === this.props.dismissable || this.props.dismissable
    }
    updateTitleId() {
      if (this.state.titleId && (wh(this.state.titleId), this.setState({
          titleId: void 0
        })), this.props.title) {
        const e = "string" == typeof this.props.title ? this.props.title : "???";
        this.setState({
          titleId: vh(`Dialog_${this.props.id}_${e}`)
        })
      }
    }
    componentWillMount() {
      this.updateTitleId()
    }
    componentDidMount() {
      this.dialogElement && (this.dialogElement.showModal(), this.dialogElement.dispatchEvent(new CustomEvent("dialog-show", {
        bubbles: !0,
        cancelable: !1
      })), this.setState({
        isAppearing: !0
      }), this.scheduleDismissGraceTimeout(), this.focusFirstSuitableChild(), window.addEventListener("focus", this.onWindowFocus), this.resizeObserver.observe(this.dialogElement), window.addEventListener("resize", this.scheduleResizeEvent))
    }
    focusFirstSuitableChild() {
      const e = this.dialogElement;
      if (null === e) return;
      const t = ['input:not([type=hidden]):not(:disabled):not([tabindex="-1"])', 'textarea:not(:disabled):not([tabindex="-1"])', 'button:not(:disabled):not([tabindex="-1"])', '[tabindex]:not(:disabled):not([tabindex="-1"])'].join(", ");
      let n = [1 / 0, null],
        r = null,
        i = null,
        o = null;
      const s = `input${[":not([type=button])",":not([type=submit])",":not([type=reset])",":not([type=hidden])",":not([type=checkbox])",":not([type=radio])"].join("")}, textarea`;
      for (const a of e.querySelectorAll(t)) {
        if (!(a instanceof HTMLElement)) continue;
        const e = parseInt(a.getAttribute("tabindex") || "", 10);
        e > 0 && e < n[0] ? n = [e, a] : null !== o || 0 !== e && !a.matches(s) ? null === r && a.matches("input[type=submit], button[type=submit]") ? r = a : null === i && a.matches("input[type=button], input[type=submit] input[type=reset], button") && (i = a) : o = a
      }
      const a = n[1] || o || r || i;
      null !== a && a.focus()
    }
    clearClickDismissalTimer() {
      this.disableClickDismissalTimeoutId && (window.clearTimeout(this.disableClickDismissalTimeoutId), this.disableClickDismissalTimeoutId = null)
    }
    componentWillUnmount() {
      this.clearDismissGraceTimeout(), this.state.titleId && wh(this.state.titleId), window.removeEventListener("focus", this.onWindowFocus), document.removeEventListener("mouseup", this.onDocumentMouseUp), this.resizeObserver.disconnect(), window.removeEventListener("resize", this.scheduleResizeEvent)
    }
    componentDidUpdate() {
      !this.props.title && this.state.titleId && this.updateTitleId()
    }
    mouseEventIsInsideDialog(e) {
      if (null === this.dialogElement) return !1;
      if (e.clientY <= 28) return !1;
      const t = this.dialogElement.getBoundingClientRect();
      return t.top <= e.clientY && e.clientY <= t.top + t.height && t.left <= e.clientX && e.clientX <= t.left + t.width
    }
    renderHeader() {
      return this.props.title ? w.createElement(Pm, {
        title: this.props.title,
        titleId: this.state.titleId,
        dismissable: this.isDismissable(),
        onDismissed: this.onDismiss,
        loading: this.props.loading
      }) : null
    }
    render() {
      const e = mh()({
        error: "error" === this.props.type,
        warning: "warning" === this.props.type
      }, this.props.className);
      return w.createElement("dialog", {
        ref: this.onDialogRef,
        id: this.props.id,
        onMouseDown: this.onDialogMouseDown,
        onKeyDown: this.onKeyDown,
        className: e,
        "aria-labelledby": this.state.titleId,
        tabIndex: -1
      }, this.renderHeader(), w.createElement("form", {
        onSubmit: this.onSubmit,
        onReset: this.onDismiss
      }, w.createElement("fieldset", {
        disabled: this.props.disabled
      }, this.props.children)))
    }
  }
  class Om extends w.Component {
    render() {
      return w.createElement("div", {
        className: "dialog-error"
      }, w.createElement(bh, {
        symbol: Sh.stop
      }), w.createElement("div", null, this.props.children))
    }
  }
  class Lm extends w.Component {
    render() {
      return w.createElement("div", {
        className: "dialog-footer"
      }, this.props.children)
    }
  }
  class Nm extends w.Component {
    constructor() {
      super(...arguments), this.onOkButtonClick = e => {
        void 0 !== this.props.onOkButtonClick && this.props.onOkButtonClick(e), e.defaultPrevented || !0 === this.props.destructive && (e.preventDefault(), e.currentTarget.form && e.currentTarget.form.dispatchEvent(new Event("submit")))
      }, this.onCancelButtonClick = e => {
        void 0 !== this.props.onCancelButtonClick && this.props.onCancelButtonClick(e), e.defaultPrevented || !0 === this.props.destructive && (e.preventDefault(), e.currentTarget.form && e.currentTarget.form.dispatchEvent(new Event("reset")))
      }
    }
    renderOkButton() {
      return w.createElement(jp, {
        onClick: this.onOkButtonClick,
        disabled: this.props.okButtonDisabled,
        tooltip: this.props.okButtonTitle,
        type: !0 === this.props.destructive ? "button" : "submit"
      }, this.props.okButtonText || "Ok")
    }
    renderCancelButton() {
      return !1 === this.props.cancelButtonVisible ? null : w.createElement(jp, {
        onClick: this.onCancelButtonClick,
        disabled: this.props.cancelButtonDisabled,
        tooltip: this.props.cancelButtonTitle,
        type: !0 === this.props.destructive ? "submit" : "reset"
      }, this.props.cancelButtonText || "取消")
    }
    renderButtons() {
      return w.createElement(w.Fragment, null, this.renderOkButton(), this.renderCancelButton())
    }
    render() {
      const e = mh()("button-group", this.props.className, {
        destructive: !0 === this.props.destructive
      });
      return w.createElement("div", {
        className: e
      }, this.renderButtons(), this.props.children)
    }
  }
  class Fm extends w.Component {
    render() {
      return w.createElement(Lm, null, w.createElement(Nm, {
        okButtonText: this.props.buttonText || "Close",
        okButtonTitle: this.props.buttonTitle,
        onOkButtonClick: this.props.onButtonClick,
        okButtonDisabled: this.props.disabled,
        cancelButtonVisible: !1
      }))
    }
  }

  function Bm(e) {
    return void 0 === e
  }
  class Hm extends w.Component {
    constructor(e) {
      super(e), this.onCreateWithoutPushButtonClick = e => {
        e.preventDefault(), this.props.onConfirm(this.props.repository, this.props.branch), this.props.onDismissed()
      }, this.onSubmit = async () => {
        const {
          repository: e,
          branch: t
        } = this.props;
        this.setState({
          isPushingOrPublishing: !0
        });
        try {
          await this.props.dispatcher.push(e)
        } finally {
          this.setState({
            isPushingOrPublishing: !1
          })
        }
        this.props.onConfirm(e, t), this.props.onDismissed()
      }, this.state = {
        isPushingOrPublishing: !1
      }
    }
    render() {
      return w.createElement(Im, {
        id: "push-branch-commits",
        key: "push-branch-commits",
        title: this.renderDialogTitle(),
        onDismissed: this.props.onDismissed,
        onSubmit: this.onSubmit,
        loading: this.state.isPushingOrPublishing,
        disabled: this.state.isPushingOrPublishing
      }, this.renderDialogContent(), w.createElement(Lm, null, this.renderButtonGroup()))
    }
    renderDialogContent() {
      if (Bm(this.props.unPushedCommits)) return w.createElement(Mm, null, w.createElement("p", null, "Your branch must be published before opening a pull request."), w.createElement("p", null, "Would you like to publish ", w.createElement(lm, null, this.props.branch.name), " now and open a pull request?"));
      const e = (t = this.props.unPushedCommits, n = "local commit", 1 === t ? `${t} ${n}` : `${t} ${n}s`);
      var t, n;
      return w.createElement(Mm, null, w.createElement("p", null, "You have ", e, " that haven't been pushed to the remote yet."), w.createElement("p", null, "Would you like to push your changes to", " ", w.createElement(lm, null, this.props.branch.name), " before creating your pull request?"))
    }
    renderDialogTitle() {
      return Bm(this.props.unPushedCommits) ? "Publish branch?" : "Push local changes?"
    }
    renderButtonGroup() {
      return Bm(this.props.unPushedCommits) ? w.createElement(Nm, {
        okButtonText: "Publish branch"
      }) : w.createElement(Nm, {
        okButtonText: "Push commits",
        cancelButtonText: "Create without pushing",
        onCancelButtonClick: this.onCreateWithoutPushButtonClick
      })
    }
  }
  const zm = Mc(__dirname, "static/empty-no-branches.svg");
  class Um extends w.Component {
    render() {
      return this.props.canCreateNewBranch ? w.createElement("div", {
        className: "no-branches"
      }, w.createElement("img", {
        src: zm,
        className: "blankslate-image"
      }), w.createElement("div", {
        className: "title"
      }, "Sorry, I can't find that branch"), w.createElement("div", {
        className: "subtitle"
      }, "Do you want to create a new branch instead?"), w.createElement(jp, {
        className: "create-branch-button",
        onClick: this.props.onCreateNewBranch,
        type: "submit"
      }, "Create new branch"), w.createElement("div", {
        className: "protip"
      }, "ProTip! Press ", this.renderShortcut(), " to quickly create a new branch from anywhere within the app")) : w.createElement("div", {
        className: "no-branches"
      }, "Sorry, I can't find that branch")
    }
    renderShortcut() {
      return w.createElement("span", null, w.createElement("kbd", null, "Ctrl"), " + ", w.createElement("kbd", null, "Shift"), " + ", w.createElement("kbd", null, "N"))
    }
  }

  function Wm(e) {
    const t = function (e, t, n, r) {
      const i = new Array;
      e && i.push({
        identifier: "default",
        items: [{
          text: [e.name],
          id: e.name,
          branch: e
        }]
      });
      const o = new Set,
        s = e ? e.name : null,
        a = r.filter(e => e.name !== s);
      if (a.length > 0) {
        const e = new Array;
        for (const t of a) e.push({
          text: [t.name],
          id: t.name,
          branch: t
        }), o.add(t.name);
        i.push({
          identifier: "recent",
          items: e
        })
      }
      const l = n.filter(e => e.name !== s && !o.has(e.name)).map(e => ({
        text: [e.name],
        id: e.name,
        branch: e
      }));
      return i.push({
        identifier: "other",
        items: l
      }), i
    }(e.defaultBranch, e.currentBranch, e.allBranches, e.recentBranches);
    let n = null;
    const r = e.selectedBranch;
    if (r)
      for (const e of t)
        if (n = e.items.find(e => e.branch.name === r.name) || null, n) break;
    return {
      groups: t,
      selectedItem: n
    }
  }
  class Vm extends w.Component {
    constructor(e) {
      super(e), this.branchFilterList = null, this.onBranchesFilterListRef = e => {
        this.branchFilterList = e
      }, this.renderItem = (e, t) => this.props.renderBranch(e, t), this.renderGroupHeader = e => {
        const t = this.parseHeader(e);
        return null !== t ? w.createElement("div", {
          className: "branches-list-content filter-list-group-header"
        }, this.getGroupLabel(t)) : null
      }, this.onRenderNoItems = () => w.createElement(Um, {
        onCreateNewBranch: this.onCreateNewBranch,
        canCreateNewBranch: this.props.canCreateNewBranch
      }), this.onRenderNewButton = () => this.props.canCreateNewBranch ? w.createElement(jp, {
        className: "new-branch-button",
        onClick: this.onCreateNewBranch
      }, "New branch") : null, this.onItemClick = e => {
        this.props.onItemClick && this.props.onItemClick(e.branch)
      }, this.onSelectionChanged = (e, t) => {
        this.props.onSelectionChanged && this.props.onSelectionChanged(e ? e.branch : null, t)
      }, this.onCreateNewBranch = () => {
        this.props.onCreateNewBranch && this.props.onCreateNewBranch(this.props.filterText)
      }, this.state = Wm(e)
    }
    componentWillReceiveProps(e) {
      this.setState(Wm(e))
    }
    selectNextItem(e = !1, t) {
      null !== this.branchFilterList && this.branchFilterList.selectNextItem(e, t)
    }
    render() {
      return w.createElement(Hp, {
        ref: this.onBranchesFilterListRef,
        className: "branches-list",
        rowHeight: 30,
        filterText: this.props.filterText,
        onFilterTextChanged: this.props.onFilterTextChanged,
        onFilterKeyDown: this.props.onFilterKeyDown,
        selectedItem: this.state.selectedItem,
        renderItem: this.renderItem,
        renderGroupHeader: this.renderGroupHeader,
        onItemClick: this.onItemClick,
        onSelectionChanged: this.onSelectionChanged,
        groups: this.state.groups,
        invalidationProps: this.props.allBranches,
        renderPostFilter: this.onRenderNewButton,
        renderNoItems: this.onRenderNoItems,
        filterTextBox: this.props.textbox,
        onFilterListResultsChanged: this.props.onFilterListResultsChanged
      })
    }
    parseHeader(e) {
      switch (e) {
        case "default":
        case "recent":
        case "other":
          return e;
        default:
          return null
      }
    }
    getGroupLabel(e) {
      return "default" === e ? "默认分支" : "recent" === e ? "最近分支" : "other" === e ? "其他分支" : X(0, "Unknown identifier: " + e)
    }
  }

  function jm(e) {
    const t = e.statuses.length || 0;
    if (0 === t) return function (e) {
      switch (e) {
        case "failure":
          return "Commit status: failed";
        case "pending":
        case "success":
          return "Commit status: " + e;
        default:
          return X(0, "Unknown APIRefState value: " + e)
      }
    }(e.state);
    if (1 === t) return function (e) {
      const t = e.state;
      return `${t.charAt(0).toUpperCase()+t.substring(1,t.length)}: ${e.description}`
    }(e.statuses[0]);
    return `${e.statuses.filter(e=>"success"===e.state).length}/${t} checks OK`
  }
  class Gm extends w.PureComponent {
    constructor(e) {
      super(e), this.statusSubscription = null, this.onStatus = e => {
        this.setState({
          status: e
        })
      }, this.state = {
        status: e.dispatcher.tryGetCommitStatus(this.props.repository, this.props.commitRef)
      }
    }
    subscribe() {
      this.unsubscribe(), this.statusSubscription = this.props.dispatcher.subscribeToCommitStatus(this.props.repository, this.props.commitRef, this.onStatus)
    }
    unsubscribe() {
      this.statusSubscription && (this.statusSubscription.dispose(), this.statusSubscription = null)
    }
    componentDidUpdate(e) {
      this.props.repository === e.repository && this.props.commitRef === e.commitRef || (this.setState({
        status: this.props.dispatcher.tryGetCommitStatus(this.props.repository, this.props.commitRef)
      }), this.subscribe())
    }
    componentDidMount() {
      this.subscribe()
    }
    componentWillUnmount() {
      this.unsubscribe()
    }
    render() {
      const {
        status: e
      } = this.state;
      if (null === e || 0 === e.total_count) return null;
      const t = jm(e),
        n = e.state;
      return w.createElement(bh, {
        className: mh()("ci-status", "ci-status-" + n, this.props.className),
        symbol: $m(n),
        title: t
      })
    }
  }

  function $m(e) {
    switch (e) {
      case "pending":
        return Sh.primitiveDot;
      case "failure":
        return Sh.x;
      case "success":
        return Sh.check;
      default:
        return X(0, "Unknown state: " + e)
    }
  }
  class qm extends w.Component {
    getSubtitle() {
      if (!0 === this.props.loading) return;
      const e = k()(this.props.created).fromNow();
      return `#${this.props.number} opened ${e} by ${this.props.author}`
    }
    render() {
      const e = !0 === this.props.loading ? void 0 : this.props.title,
        t = this.getSubtitle(),
        n = this.props.matches,
        r = mh()("pull-request-item", {
          loading: !0 === this.props.loading
        });
      return w.createElement("div", {
        className: r
      }, w.createElement(bh, {
        className: "icon",
        symbol: Sh.gitPullRequest
      }), w.createElement("div", {
        className: "info"
      }, w.createElement("div", {
        className: "title",
        title: e
      }, w.createElement(Dh, {
        text: e || "",
        highlight: n.title
      })), w.createElement("div", {
        className: "subtitle",
        title: t
      }, w.createElement(Dh, {
        text: t || "",
        highlight: n.subtitle
      }))), this.renderPullRequestStatus())
    }
    renderPullRequestStatus() {
      const e = `refs/pull/${this.props.number}/head`;
      return w.createElement(Gm, {
        dispatcher: this.props.dispatcher,
        repository: this.props.repository,
        commitRef: e
      })
    }
  }
  const Km = Mc(__dirname, "static/empty-no-pull-requests.svg");
  class Ym extends w.Component {
    render() {
      return w.createElement("div", {
        className: "no-pull-requests"
      }, w.createElement("img", {
        src: Km,
        className: "blankslate-image"
      }), this.renderTitle(), this.renderCallToAction())
    }
    renderTitle() {
      return this.props.isSearch ? w.createElement("div", {
        className: "title"
      }, "Sorry, I can't find that pull request!") : this.props.isLoadingPullRequests ? w.createElement("div", {
        className: "title"
      }, "Hang tight") : w.createElement("div", null, w.createElement("div", {
        className: "title"
      }, "You're all set!"), w.createElement("div", {
        className: "no-prs"
      }, "No open pull requests in ", w.createElement(lm, null, this.props.repositoryName)))
    }
    renderCallToAction() {
      return this.props.isLoadingPullRequests ? w.createElement("div", {
        className: "call-to-action"
      }, "Loading pull requests as fast as I can!") : this.props.isOnDefaultBranch ? w.createElement("div", {
        className: "call-to-action"
      }, "Would you like to", " ", w.createElement(Ip, {
        onClick: this.props.onCreateBranch
      }, "create a new branch"), " ", "and get going on your next project?") : w.createElement("div", {
        className: "call-to-action"
      }, "Would you like to", " ", w.createElement(Ip, {
        onClick: this.props.onCreatePullRequest
      }, "create a pull request"), " ", "from the current branch?")
    }
  }

  function Qm(e, t, n) {
    let r = null;
    return null != t.selectedPullRequest && (r = eg(e, t.selectedPullRequest)), null == r && null != n && (r = eg(e, n.pullRequest)), r
  }
  class Zm extends w.Component {
    constructor(e) {
      super(e), this.renderNoItems = () => w.createElement(Ym, {
        isSearch: this.state.filterText.length > 0,
        isLoadingPullRequests: this.props.isLoadingPullRequests,
        repositoryName: this.getRepositoryName(),
        isOnDefaultBranch: this.props.isOnDefaultBranch,
        onCreateBranch: this.props.onCreateBranch,
        onCreatePullRequest: this.onCreatePullRequest
      }), this.renderPullRequest = (e, t) => {
        const n = e.pullRequest;
        return w.createElement(qm, {
          title: n.title,
          number: n.pullRequestNumber,
          created: n.created,
          author: n.author,
          matches: t,
          dispatcher: this.props.dispatcher,
          repository: n.base.gitHubRepository
        })
      }, this.onItemClick = (e, t) => {
        const n = e.pullRequest;
        this.props.dispatcher.closeFoldout(V.Branch);
        const r = Od("checkout pull request from list", this.props.repository);
        this.props.dispatcher.checkoutPullRequest(this.props.repository, n).then(() => r.done()), this.props.onSelectionChanged(n, t)
      }, this.onSelectionChanged = (e, t) => {
        this.props.onSelectionChanged(null != e ? e.pullRequest : null, t)
      }, this.renderListHeader = () => w.createElement("div", {
        className: "filter-list-group-header"
      }, "Pull requests in ", this.getRepositoryName()), this.onRefreshPullRequests = () => {
        this.props.dispatcher.refreshPullRequests(this.props.repository)
      }, this.renderPostFilter = () => w.createElement(jp, {
        disabled: this.props.isLoadingPullRequests,
        onClick: this.onRefreshPullRequests,
        tooltip: "Refresh the list of pull requests"
      }, w.createElement(bh, {
        symbol: Sh.sync,
        className: this.props.isLoadingPullRequests ? "spin" : void 0
      })), this.onFilterTextChanged = e => {
        this.setState({
          filterText: e
        })
      }, this.onCreatePullRequest = () => {
        this.props.dispatcher.closeFoldout(V.Branch), this.props.dispatcher.createPullRequest(this.props.repository)
      };
      const t = Jm(e.pullRequests),
        n = Qm(t, e, null);
      this.state = {
        filterText: "",
        groupedItems: [t],
        selectedItem: n
      }
    }
    componentWillReceiveProps(e) {
      const t = Jm(e.pullRequests),
        n = Qm(t, e, this.state.selectedItem);
      this.setState({
        groupedItems: [t],
        selectedItem: n
      })
    }
    render() {
      return w.createElement(Hp, {
        className: "pull-request-list",
        rowHeight: 47,
        groups: this.state.groupedItems,
        selectedItem: this.state.selectedItem,
        renderItem: this.renderPullRequest,
        filterText: this.state.filterText,
        onFilterTextChanged: this.onFilterTextChanged,
        invalidationProps: this.props.pullRequests,
        onItemClick: this.onItemClick,
        onSelectionChanged: this.onSelectionChanged,
        onFilterKeyDown: this.props.onFilterKeyDown,
        renderGroupHeader: this.renderListHeader,
        renderNoItems: this.renderNoItems,
        renderPostFilter: this.renderPostFilter
      })
    }
    getRepositoryName() {
      return ro(this.props.repository).fullName
    }
  }

  function Xm(e) {
    const t = k()(e.created).fromNow();
    return `#${e.pullRequestNumber} opened ${t} by ${e.author}`
  }

  function Jm(e) {
    return {
      identifier: "pull-requests",
      items: e.map(e => ({
        text: [e.title, Xm(e)],
        id: e.pullRequestNumber.toString(),
        pullRequest: e
      }))
    }
  }

  function eg(e, t) {
    return e.items.find(e => e.pullRequest.pullRequestNumber === t.pullRequestNumber) || null
  }
  class tg extends w.Component {
    render() {
      const e = this.props.lastCommitDate,
        t = this.props.isCurrentBranch,
        n = this.props.name,
        r = e ? k()(e).fromNow() : "",
        i = t ? Sh.check : Sh.gitBranch,
        o = t ? "Current branch" : e ? e.toString() : "";
      return w.createElement("div", {
        className: "branches-list-item"
      }, w.createElement(bh, {
        className: "icon",
        symbol: i
      }), w.createElement("div", {
        className: "name",
        title: n
      }, w.createElement(Dh, {
        text: n,
        highlight: this.props.matches.title
      })), w.createElement("div", {
        className: "description",
        title: o
      }, r))
    }
  }

  function ng(e, t, n) {
    const r = e.branch,
      i = r.tip,
      o = n ? n.name : null;
    return w.createElement(tg, {
      name: r.name,
      isCurrentBranch: r.name === o,
      lastCommitDate: i ? i.author.date : null,
      matches: t
    })
  }
  class rg extends w.Component {
    constructor(e) {
      super(e), this.getBranchName = () => {
        const {
          currentBranch: e,
          defaultBranch: t
        } = this.props;
        return null != e ? e.name : null != t ? t.name : "master"
      }, this.renderBranch = (e, t) => ng(e, t, this.props.currentBranch), this.onTabClicked = e => {
        this.props.dispatcher.changeBranchesTab(e)
      }, this.onDismiss = () => {
        this.props.dispatcher.closeFoldout(V.Branch)
      }, this.onMergeClick = () => {
        this.props.dispatcher.closeFoldout(V.Branch), this.props.dispatcher.showPopup({
          type: Zi.MergeBranch,
          repository: this.props.repository
        })
      }, this.onBranchItemClick = e => {
        this.props.dispatcher.closeFoldout(V.Branch);
        const {
          currentBranch: t,
          repository: n,
          currentBranchProtected: r,
          dispatcher: i,
          couldOverwriteStash: o
        } = this.props;
        if (null == t || t.name !== e.name) {
          if (!r && this.props.selectedUncommittedChangesStrategy.kind === pu.kind && o) return void i.showPopup({
            type: Zi.ConfirmOverwriteStash,
            repository: n,
            branchToCheckout: e
          });
          const t = Od("checkout branch from list", n),
            s = r ? {
              kind: cu.MoveToNewBranch,
              transientStashEntry: null
            } : this.props.selectedUncommittedChangesStrategy;
          this.props.dispatcher.checkoutBranch(n, e, s).then(() => t.done())
        }
      }, this.onBranchSelectionChanged = e => {
        this.setState({
          selectedBranch: e
        })
      }, this.onBranchFilterTextChanged = e => {
        this.setState({
          branchFilterText: e
        })
      }, this.onCreateBranchWithName = e => {
        const {
          repository: t,
          currentBranchProtected: n
        } = this.props;
        this.props.dispatcher.closeFoldout(V.Branch), this.props.dispatcher.showPopup({
          type: Zi.CreateBranch,
          repository: t,
          currentBranchProtected: n,
          initialName: e
        })
      }, this.onCreateBranch = () => {
        this.onCreateBranchWithName("")
      }, this.onPullRequestSelectionChanged = e => {
        this.setState({
          selectedPullRequest: e
        })
      }, this.state = {
        selectedBranch: e.currentBranch,
        selectedPullRequest: e.currentPullRequest,
        currentPullRequest: e.currentPullRequest,
        branchFilterText: ""
      }
    }
    static getDerivedStateFromProps(e, t) {
      return t.currentPullRequest !== e.currentPullRequest ? {
        currentPullRequest: e.currentPullRequest,
        selectedPullRequest: e.currentPullRequest
      } : null
    }
    render() {
      const e = this.getBranchName();
      return w.createElement("div", {
        className: "branches-container"
      }, this.renderTabBar(), this.renderSelectedTab(), w.createElement(Lp, {
        className: "merge-button-row"
      }, w.createElement(jp, {
        className: "merge-button",
        onClick: this.onMergeClick
      }, w.createElement(bh, {
        className: "icon",
        symbol: Sh.gitMerge
      }), w.createElement("span", {
        title: "Merge a branch into " + e
      }, "Choose a branch to merge into ", w.createElement("strong", null, e)))))
    }
    renderOpenPullRequestsBubble() {
      const e = this.props.pullRequests;
      return e.length > 0 ? w.createElement("span", {
        className: "count"
      }, e.length) : null
    }
    renderTabBar() {
      return this.props.repository.gitHubRepository ? w.createElement(hf, {
        onTabClicked: this.onTabClicked,
        selectedIndex: this.props.selectedTab
      }, w.createElement("span", null, "分支"), w.createElement("span", {
        className: "pull-request-tab"
      }, "拉取请求", this.renderOpenPullRequestsBubble())) : null
    }
    renderSelectedTab() {
      let e = this.props.selectedTab;
      switch (this.props.repository.gitHubRepository || (e = bi.Branches), e) {
        case bi.Branches:
          return w.createElement(Vm, {
            defaultBranch: this.props.defaultBranch,
            currentBranch: this.props.currentBranch,
            allBranches: this.props.allBranches,
            recentBranches: this.props.recentBranches,
            onItemClick: this.onBranchItemClick,
            filterText: this.state.branchFilterText,
            onFilterTextChanged: this.onBranchFilterTextChanged,
            selectedBranch: this.state.selectedBranch,
            onSelectionChanged: this.onBranchSelectionChanged,
            canCreateNewBranch: !0,
            onCreateNewBranch: this.onCreateBranchWithName,
            renderBranch: this.renderBranch
          });
        case bi.PullRequests:
          return this.renderPullRequests();
        default:
          return X(0, "Unknown Branches tab: " + e)
      }
    }
    renderPullRequests() {
      const e = this.props.repository;
      if (!Ji(e)) return null;
      const t = this.props.defaultBranch && this.props.currentBranch && this.props.defaultBranch.name === this.props.currentBranch.name;
      return w.createElement(Zm, {
        key: "pr-list",
        pullRequests: this.props.pullRequests,
        selectedPullRequest: this.state.selectedPullRequest,
        isOnDefaultBranch: !!t,
        onSelectionChanged: this.onPullRequestSelectionChanged,
        onCreateBranch: this.onCreateBranch,
        onDismiss: this.onDismiss,
        dispatcher: this.props.dispatcher,
        repository: e,
        isLoadingPullRequests: this.props.isLoadingPullRequests
      })
    }
  }
  class ig extends w.Component {
    render() {
      const e = `refs/pull/${this.props.number}/head`;
      return w.createElement("div", {
        className: "pr-badge"
      }, w.createElement("span", {
        className: "number"
      }, "#", this.props.number), w.createElement(Gm, {
        commitRef: e,
        dispatcher: this.props.dispatcher,
        repository: this.props.repository
      }))
    }
  }
  class og extends w.Component {
    render() {
      const e = this.props.isCurrentBranch,
        t = this.props.branch,
        n = e ? Sh.check : Sh.gitBranch,
        r = this.props.aheadBehind,
        i = r ? w.createElement("div", {
          className: "branch-commit-counter"
        }, w.createElement("span", {
          className: "branch-commit-counter-item"
        }, r.behind, w.createElement(bh, {
          className: "icon",
          symbol: Sh.arrowDown
        })), w.createElement("span", {
          className: "branch-commit-counter-item"
        }, r.ahead, w.createElement(bh, {
          className: "icon",
          symbol: Sh.arrowUp
        }))) : null;
      return w.createElement("div", {
        className: "branches-list-item"
      }, w.createElement(bh, {
        className: "icon",
        symbol: n
      }), w.createElement("div", {
        className: "name",
        title: t.name
      }, w.createElement(Dh, {
        text: t.name,
        highlight: this.props.matches.title
      })), i)
    }
  }
  class sg extends w.Component {
    constructor(e) {
      super(e), this.onFocus = () => {
        void 0 !== this.props.onFocus && this.props.onFocus(), this.setState({
          isFocused: !0
        })
      }, this.onBlur = e => {
        void 0 !== this.props.onBlur && this.props.onBlur(e), this.setState({
          isFocused: !1
        })
      }, this.state = {
        isFocused: !1
      }
    }
    render() {
      const e = mh()("fancy-text-box-component", this.props.className, {
          disabled: this.props.disabled
        }, {
          focused: this.state.isFocused
        }),
        t = mh()("fancy-octicon");
      return w.createElement("div", {
        className: e
      }, w.createElement(bh, {
        className: t,
        symbol: this.props.symbol
      }), w.createElement(Op, {
        value: this.props.value,
        onFocus: this.onFocus,
        onBlur: this.onBlur,
        autoFocus: this.props.autoFocus,
        disabled: this.props.disabled,
        type: this.props.type,
        placeholder: this.props.placeholder,
        onKeyDown: this.props.onKeyDown,
        onValueChanged: this.props.onValueChanged,
        onSearchCleared: this.props.onSearchCleared,
        tabIndex: this.props.tabIndex,
        ref: this.props.onRef
      }))
    }
  }
  var ag;
  ! function (e) {
    e.Close = "close", e.Compare = "compare", e.Merge = "merge"
  }(ag || (ag = {}));
  class lg extends w.Component {
    constructor() {
      super(...arguments), this.onDismissed = () => {
        this.props.onDismiss(ag.Close)
      }, this.onComparedClicked = () => {
        const {
          repository: e,
          dispatcher: t
        } = this.props;
        t.executeCompare(e, {
          kind: $.Compare,
          branch: this.props.baseBranch,
          comparisonMode: q.Behind
        }), t.recordDivergingBranchBannerInitiatedCompare(), this.props.onDismiss(ag.Compare)
      }, this.onMergeClicked = () => {
        const {
          repository: e,
          dispatcher: t
        } = this.props;
        t.showPopup({
          type: Zi.MergeBranch,
          branch: this.props.baseBranch,
          repository: e
        }), t.recordDivergingBranchBannerInitatedMerge(), this.props.onDismiss(ag.Merge)
      }
    }
    render() {
      const e = this.props.commitsBehindBaseBranch > 1;
      return w.createElement("div", {
        className: "notification-banner diverge-banner"
      }, w.createElement(bh, {
        symbol: Sh.lightBulb,
        className: "notification-icon"
      }), w.createElement("div", {
        className: "notification-banner-content"
      }, w.createElement("div", {
        className: "notification-banner-content-body"
      }, w.createElement("p", null, "We have noticed that your branch is", " ", w.createElement("strong", null, this.props.commitsBehindBaseBranch, " commit", e ? "s" : ""), " ", "behind ", w.createElement(lm, null, this.props.baseBranch.name), ".")), w.createElement("div", null, w.createElement(jp, {
        className: "small-button",
        onClick: this.onComparedClicked
      }, "View commits"), w.createElement(jp, {
        className: "small-button",
        type: "submit",
        onClick: this.onMergeClicked
      }, "Merge..."))), w.createElement("a", {
        className: "close",
        "aria-label": "Dismiss banner",
        onClick: this.onDismissed
      }, w.createElement(bh, {
        symbol: Sh.x
      })))
    }
  }
  class cg extends w.Component {
    render() {
      const {
        status: e,
        classNamePrefix: t
      } = this.props;
      if (null === e) return null;
      const {
        kind: n
      } = e, r = t + "-icon-container";
      return w.createElement("div", {
        className: r
      }, w.createElement(bh, {
        className: mh()(t, `${t}-${n}`, this.props.className),
        symbol: ug(n)
      }))
    }
  }

  function ug(e) {
    switch (e) {
      case al.Loading:
        return Sh.primitiveDot;
      case al.Conflicts:
        return Sh.alert;
      case al.Invalid:
        return Sh.x;
      case al.Clean:
        return Sh.check;
      default:
        return X(0, "Unknown state: " + JSON.stringify(e))
    }
  }
  class hg extends w.Component {
    constructor() {
      super(...arguments), this.onMergeClicked = async () => {
        const {
          comparisonBranch: e,
          repository: t,
          mergeStatus: n
        } = this.props;
        this.props.dispatcher.recordCompareInitiatedMerge(), await this.props.dispatcher.mergeBranch(t, e.name, n), this.props.dispatcher.executeCompare(t, {
          kind: $.History
        }), this.props.dispatcher.updateCompareForm(t, {
          showBranchList: !1,
          filterText: ""
        }), this.props.onMerged()
      }
    }
    render() {
      const {
        commitsBehind: e
      } = this.props, t = null != this.props.mergeStatus && this.props.mergeStatus.kind === al.Invalid, n = e <= 0 || t, r = e > 0 ? this.renderMergeStatus() : null;
      return w.createElement("div", {
        className: "merge-cta"
      }, r, w.createElement(jp, {
        type: "submit",
        disabled: n,
        onClick: this.onMergeClicked
      }, "Merge into ", w.createElement("strong", null, this.props.currentBranch.name)))
    }
    renderMergeStatus() {
      return w.createElement("div", {
        className: "merge-status-component"
      }, w.createElement(cg, {
        status: this.props.mergeStatus,
        classNamePrefix: "merge-status"
      }), this.renderMergeDetails(this.props.currentBranch, this.props.comparisonBranch, this.props.mergeStatus, this.props.commitsBehind))
    }
    renderMergeDetails(e, t, n, r) {
      return null === n ? null : n.kind === al.Loading ? this.renderLoadingMergeMessage() : n.kind === al.Clean ? this.renderCleanMergeMessage(e, t, r) : n.kind === al.Invalid ? this.renderInvalidMergeMessage() : n.kind === al.Conflicts ? this.renderConflictedMergeMessage(e, t, n.conflictedFiles) : null
    }
    renderLoadingMergeMessage() {
      return w.createElement("div", {
        className: "merge-message merge-message-loading"
      }, "Checking for ability to merge automatically...")
    }
    renderCleanMergeMessage(e, t, n) {
      if (n > 0) {
        const r = 1 === n ? "commit" : "commits";
        return w.createElement("div", {
          className: "merge-message"
        }, "This will merge", w.createElement("strong", null, ` ${n} ${r}`), " from ", w.createElement("strong", null, t.name), " into ", w.createElement("strong", null, e.name))
      }
      return null
    }
    renderInvalidMergeMessage() {
      return w.createElement("div", {
        className: "merge-message"
      }, "Unable to merge unrelated histories in this repository")
    }
    renderConflictedMergeMessage(e, t, n) {
      const r = 1 === n ? "file" : "files";
      return w.createElement("div", {
        className: "merge-message"
      }, "There will be", w.createElement("strong", null, ` ${n} conflicted ${r}`), " when merging ", w.createElement("strong", null, t.name), " into ", w.createElement("strong", null, e.name))
    }
  }
  class pg extends w.Component {
    constructor(e) {
      super(e), this.textbox = null, this.loadChangedFilesScheduler = new od(200), this.branchList = null, this.loadingMoreCommitsPromise = null, this.resultCount = 0, this.onBranchesListRef = e => {
        this.branchList = e
      }, this.filterListResultsChanged = e => {
        this.resultCount = e
      }, this.viewHistoryForBranch = () => {
        this.props.dispatcher.executeCompare(this.props.repository, {
          kind: $.History
        }), this.props.dispatcher.updateCompareForm(this.props.repository, {
          showBranchList: !1
        })
      }, this.onTabClicked = e => {
        const t = this.props.compareState.formState;
        if (t.kind === $.History) return;
        const n = 0 === e ? q.Behind : q.Ahead,
          r = t.comparisonBranch;
        this.props.dispatcher.executeCompare(this.props.repository, {
          kind: $.Compare,
          branch: r,
          comparisonMode: n
        })
      }, this.renderCompareBranchListItem = (e, t) => {
        const n = this.props.currentBranch,
          r = null != n ? n.name : null,
          i = e.branch,
          o = n ? this.props.compareState.aheadBehindCache.get(n.tip.sha, i.tip.sha) : null;
        return w.createElement(og, {
          branch: i,
          isCurrentBranch: i.name === r,
          matches: t,
          aheadBehind: o
        })
      }, this.onBranchFilterKeyDown = e => {
        const t = e.key;
        if ("Enter" === t) {
          if (0 === this.resultCount) return void e.preventDefault();
          const t = this.state.focusedBranch;
          null === t ? this.viewHistoryForBranch() : (this.props.dispatcher.executeCompare(this.props.repository, {
            kind: $.Compare,
            comparisonMode: q.Behind,
            branch: t
          }), this.props.dispatcher.updateCompareForm(this.props.repository, {
            filterText: t.name
          })), this.textbox && this.textbox.blur()
        } else "Escape" === t ? this.handleEscape() : "ArrowDown" === t ? null !== this.branchList && this.branchList.selectNextItem(!0, "down") : "ArrowUp" === t && null !== this.branchList && this.branchList.selectNextItem(!0, "up")
      }, this.handleEscape = () => {
        this.clearFilterState(), this.textbox && this.textbox.blur()
      }, this.onCommitSelected = e => {
        this.props.dispatcher.changeCommitSelection(this.props.repository, e.sha), this.loadChangedFilesScheduler.queue(() => {
          this.props.dispatcher.loadChangedFilesForCurrentSelection(this.props.repository)
        })
      }, this.onScroll = (e, t) => {
        const n = this.props.compareState;
        if (n.formState.kind === $.Compare) return;
        if (n.commitSHAs.length - t <= 10) {
          if (null != this.loadingMoreCommitsPromise) return;
          this.loadingMoreCommitsPromise = this.props.dispatcher.loadNextCommitBatch(this.props.repository).then(() => {
            window.setTimeout(() => {
              this.loadingMoreCommitsPromise = null
            }, 500)
          })
        }
      }, this.onBranchFilterTextChanged = e => {
        0 === e.length && this.setState({
          focusedBranch: null
        }), this.props.dispatcher.updateCompareForm(this.props.repository, {
          filterText: e
        })
      }, this.clearFilterState = () => {
        this.setState({
          focusedBranch: null
        }), this.props.dispatcher.updateCompareForm(this.props.repository, {
          filterText: ""
        }), this.viewHistoryForBranch()
      }, this.onBranchItemClicked = e => {
        this.props.dispatcher.executeCompare(this.props.repository, {
          kind: $.Compare,
          comparisonMode: q.Behind,
          branch: e
        }), this.setState({
          focusedBranch: null
        }), this.props.dispatcher.updateCompareForm(this.props.repository, {
          filterText: e.name,
          showBranchList: !1
        })
      }, this.onSelectionChanged = (e, t) => {
        this.setState({
          focusedBranch: e
        })
      }, this.onTextBoxFocused = () => {
        this.props.dispatcher.updateCompareForm(this.props.repository, {
          showBranchList: !0
        })
      }, this.onTextBoxRef = e => {
        this.textbox = e
      }, this.onNotificationBannerDismissed = e => {
        switch (e === ag.Close && this.props.dispatcher.dismissDivergingBranchBanner(this.props.repository), this.props.dispatcher.recordDivergingBranchBannerDismissal(), e) {
          case ag.Close:
            this.setState({
              hasConsumedNotification: !1
            });
            break;
          case ag.Compare:
          case ag.Merge:
            this.setState({
              hasConsumedNotification: !0
            });
            break;
          default:
            X(0, "Unknown reason")
        }
      }, this.onMerge = () => {
        this.state.hasConsumedNotification && this.props.dispatcher.recordDivergingBranchBannerInfluencedMerge()
      }, this.onCreateTag = e => {
        this.props.dispatcher.showCreateTagDialog(this.props.repository, e, this.props.localTags)
      }, this.onDeleteTag = e => {
        this.props.dispatcher.showDeleteTagDialog(this.props.repository, e)
      }, this.state = {
        focusedBranch: null,
        hasConsumedNotification: !1
      }
    }
    componentDidMount() {
      this.props.dispatcher.setDivergingBranchNudgeVisibility(this.props.repository, !1)
    }
    componentWillReceiveProps(e) {
      const t = e.compareState.formState,
        n = this.props.compareState.formState;
      if (t.kind === n.kind || t.kind !== $.History) {
        if (t.kind !== $.History && n.kind !== $.History) {
          const e = n.comparisonBranch,
            r = t.comparisonBranch;
          e.name !== r.name && this.setState({
            focusedBranch: r
          })
        }
      } else this.setState({
        focusedBranch: null
      })
    }
    componentDidUpdate(e) {
      const {
        showBranchList: t
      } = this.props.compareState;
      null !== this.textbox && (t ? this.textbox.focus() : t || this.textbox.blur())
    }
    componentWillMount() {
      this.props.dispatcher.initializeCompare(this.props.repository)
    }
    componentWillUnmount() {
      this.textbox = null, this.props.dispatcher.updateCompareForm(this.props.repository, {
        showBranchList: !1
      })
    }
    render() {
      const {
        allBranches: e,
        filterText: t,
        showBranchList: n
      } = this.props.compareState, r = function (e) {
        const {
          allBranches: t,
          formState: n
        } = e;
        return 0 === t.length ? "没有可比较的分支" : n.kind === $.History ? "选择要比较的分支..." : void 0
      }(this.props.compareState);
      return w.createElement("div", {
        id: "compare-view"
      }, !1, w.createElement("div", {
        className: "compare-form"
      }, w.createElement(sg, {
        symbol: Sh.gitBranch,
        type: "search",
        placeholder: r,
        onFocus: this.onTextBoxFocused,
        value: t,
        disabled: 0 === e.length,
        onRef: this.onTextBoxRef,
        onValueChanged: this.onBranchFilterTextChanged,
        onKeyDown: this.onBranchFilterKeyDown,
        onSearchCleared: this.handleEscape
      })), n ? this.renderFilterList() : this.renderCommits())
    }
    renderNotificationBanner() {
      const e = this.props.compareState.divergingBranchBannerState;
      if (!e.isPromptVisible || e.isPromptDismissed) return null;
      const {
        inferredComparisonBranch: t
      } = this.props.compareState;
      return null !== t.branch && null !== t.aheadBehind && t.aheadBehind.behind > 0 ? w.createElement(K, {
        classNames: "diverge-banner",
        appear: !0,
        timeout: 300
      }, w.createElement("div", {
        className: "diverge-banner-wrapper"
      }, w.createElement(lg, {
        dispatcher: this.props.dispatcher,
        repository: this.props.repository,
        commitsBehindBaseBranch: t.aheadBehind.behind,
        baseBranch: t.branch,
        onDismiss: this.onNotificationBannerDismissed
      }))) : null
    }
    renderCommits() {
      const e = this.props.compareState.formState;
      return w.createElement("div", {
        className: "compare-commit-list"
      }, e.kind === $.History ? this.renderCommitList() : this.renderTabBar(e))
    }
    renderCommitList() {
      const {
        formState: e,
        commitSHAs: t
      } = this.props.compareState;
      let n;
      if (e.kind === $.History) n = "No history";
      else {
        const t = e.comparisonBranch.name;
        n = e.comparisonMode === q.Ahead ? w.createElement("p", null, "The compared branch (", w.createElement(lm, null, t), ") is up to date with your branch") : w.createElement("p", null, "Your branch is up to date with the compared branch (", w.createElement(lm, null, t), ")")
      }
      return w.createElement(Dm, {
        gitHubRepository: this.props.repository.gitHubRepository,
        isLocalRepository: this.props.isLocalRepository,
        commitLookup: this.props.commitLookup,
        commitSHAs: t,
        selectedSHA: this.props.selectedCommitSha,
        localCommitSHAs: this.props.localCommitSHAs,
        emoji: this.props.emoji,
        onViewCommitOnGitHub: this.props.onViewCommitOnGitHub,
        onRevertCommit: dg(this.props.compareState.formState) ? this.props.onRevertCommit : void 0,
        onCommitSelected: this.onCommitSelected,
        onScroll: this.onScroll,
        onCreateTag: this.onCreateTag,
        onDeleteTag: this.onDeleteTag,
        emptyListMessage: n,
        onCompareListScrolled: this.props.onCompareListScrolled,
        compareListScrollTop: this.props.compareListScrollTop,
        tagsToPush: this.props.tagsToPush
      })
    }
    renderActiveTab(e) {
      return w.createElement("div", {
        className: "compare-commit-list"
      }, this.renderCommitList(), e.comparisonMode === q.Behind ? this.renderMergeCallToAction(e) : null)
    }
    renderFilterList() {
      const {
        defaultBranch: e,
        allBranches: t,
        recentBranches: n,
        filterText: r
      } = this.props.compareState;
      return w.createElement(Vm, {
        ref: this.onBranchesListRef,
        defaultBranch: e,
        currentBranch: this.props.currentBranch,
        allBranches: t,
        recentBranches: n,
        filterText: r,
        textbox: this.textbox,
        selectedBranch: this.state.focusedBranch,
        canCreateNewBranch: !1,
        onSelectionChanged: this.onSelectionChanged,
        onItemClick: this.onBranchItemClicked,
        onFilterTextChanged: this.onBranchFilterTextChanged,
        renderBranch: this.renderCompareBranchListItem,
        onFilterListResultsChanged: this.filterListResultsChanged
      })
    }
    renderMergeCallToAction(e) {
      return null == this.props.currentBranch ? null : w.createElement(hg, {
        repository: this.props.repository,
        dispatcher: this.props.dispatcher,
        mergeStatus: this.props.compareState.mergeStatus,
        currentBranch: this.props.currentBranch,
        comparisonBranch: e.comparisonBranch,
        commitsBehind: e.aheadBehind.behind,
        onMerged: this.onMerge
      })
    }
    renderTabBar(e) {
      const t = e.comparisonMode === q.Behind ? 0 : 1;
      return w.createElement("div", {
        className: "compare-content"
      }, w.createElement(hf, {
        selectedIndex: t,
        onTabClicked: this.onTabClicked
      }, w.createElement("span", null, `Behind (${e.aheadBehind.behind})`), w.createElement("span", null, `Ahead (${e.aheadBehind.ahead})`)), this.renderActiveTab(e))
    }
  }

  function dg(e) {
    return e.kind === $.History || e.comparisonMode === q.Ahead
  }
  class fg extends w.Component {
    constructor(e) {
      super(e), this.onDiscardClick = () => {
        const {
          dispatcher: e,
          repository: t,
          stashEntry: n
        } = this.props;
        e.showPopup({
          type: Zi.ConfirmDiscardStash,
          stash: n,
          repository: t
        })
      }, this.onRestoreClick = async () => {
        const {
          dispatcher: e,
          repository: t,
          stashEntry: n
        } = this.props;
        this.setState({
          isRestoring: !0
        }, () => {
          e.popStash(t, n)
        })
      }, this.state = {
        isRestoring: !1
      }
    }
    render() {
      const {
        isWorkingTreeClean: e
      } = this.props, {
        isRestoring: t
      } = this.state;
      return w.createElement("div", {
        className: "header"
      }, w.createElement("h3", null, "Stashed changes"), w.createElement("div", {
        className: "row"
      }, w.createElement(Nm, {
        okButtonText: "Restore",
        okButtonDisabled: t || !e,
        onOkButtonClick: this.onRestoreClick,
        cancelButtonText: "Discard",
        cancelButtonDisabled: t,
        onCancelButtonClick: this.onDiscardClick
      }), this.renderExplanatoryText()))
    }
    renderExplanatoryText() {
      const {
        isWorkingTreeClean: e
      } = this.props;
      return e || this.state.isRestoring ? w.createElement("div", {
        className: "explanatory-text"
      }, w.createElement("span", {
        className: "text"
      }, w.createElement("strong", null, "Restore"), " will move your stashed files to the Changes list.")) : w.createElement("div", {
        className: "explanatory-text"
      }, w.createElement(bh, {
        symbol: Sh.alert
      }), w.createElement("span", {
        className: "text"
      }, "Unable to restore stash when changes are present on your branch."))
    }
  }
  class mg extends w.PureComponent {
    constructor() {
      super(...arguments), this.onSelectedFileChanged = e => this.props.dispatcher.selectStashedFile(this.props.repository, e), this.onResize = e => this.props.dispatcher.setStashedFilesWidth(e), this.onReset = () => this.props.dispatcher.resetStashedFilesWidth()
    }
    render() {
      const {
        stashEntry: e,
        selectedStashedFile: t,
        stashedFileDiff: n,
        repository: r,
        dispatcher: i,
        imageDiffType: o,
        isWorkingTreeClean: s,
        fileListWidth: a,
        onOpenBinaryFile: l,
        onChangeImageDiffType: c
      } = this.props, u = e.files.kind === zc.Loaded ? e.files.files : new Array, h = null !== t ? w.createElement(em, {
        repository: r,
        readOnly: !0,
        file: t,
        diff: n,
        imageDiffType: o,
        hideWhitespaceInDiff: !1,
        onOpenBinaryFile: l,
        onChangeImageDiffType: c
      }) : null;
      return w.createElement("section", {
        id: "stash-diff-viewer"
      }, w.createElement(fg, {
        stashEntry: e,
        repository: r,
        dispatcher: i,
        isWorkingTreeClean: s
      }), w.createElement("div", {
        className: "commit-details"
      }, w.createElement(gm, {
        width: this.props.fileListWidth,
        onResize: this.onResize,
        onReset: this.onReset
      }, w.createElement(km, {
        files: u,
        onSelectedFileChanged: this.onSelectedFileChanged,
        selectedFile: t,
        availableWidth: a
      })), h))
    }
  }
  const gg = Mc(__dirname, "static/required-status-check.svg");
  class yg extends w.Component {
    constructor(e) {
      super(e), this.openTutorialFileInEditor = () => {
        this.props.dispatcher.openInExternalEditor(Object(i.join)(this.props.repository.path, "README.md"))
      }, this.openPullRequest = () => {
        this.props.dispatcher.createPullRequest(this.props.repository)
      }, this.skipEditorInstall = () => {
        this.props.dispatcher.skipPickEditorTutorialStep(this.props.repository)
      }, this.skipCreatePR = () => {
        this.props.dispatcher.markPullRequestTutorialStepAsComplete(this.props.repository)
      }, this.isStepComplete = e => Eu.indexOf(e) < Eu.indexOf(this.props.currentTutorialStep), this.isStepNextTodo = e => e === this.props.currentTutorialStep, this.onStepSummaryClick = e => {
        this.setState({
          currentlyOpenSectionId: e
        })
      }, this.onPreferencesClick = () => {
        this.props.dispatcher.showPopup({
          type: Zi.Preferences,
          initialSelectedTab: dh.Advanced
        })
      }, this.state = {
        currentlyOpenSectionId: this.props.currentTutorialStep
      }
    }
    componentWillReceiveProps(e) {
      this.props.currentTutorialStep !== e.currentTutorialStep && this.setState({
        currentlyOpenSectionId: e.currentTutorialStep
      })
    }
    render() {
      return w.createElement("div", {
        className: "tutorial-panel-component panel"
      }, w.createElement("div", {
        className: "titleArea"
      }, w.createElement("h3", null, "Get started"), w.createElement("img", {
        src: gg
      })), w.createElement("ol", null, w.createElement(vg, {
        summaryText: "Install a text editor",
        isComplete: this.isStepComplete,
        isNextStepTodo: this.isStepNextTodo,
        sectionId: Su.PickEditor,
        currentlyOpenSectionId: this.state.currentlyOpenSectionId,
        skipLinkButton: w.createElement(wg, {
          onClick: this.skipEditorInstall
        }),
        onSummaryClick: this.onStepSummaryClick
      }, this.isStepComplete(Su.PickEditor) ? w.createElement("p", {
        className: "description"
      }, "Your default editor is", " ", w.createElement("strong", null, this.props.resolvedExternalEditor), ". You can change your preferred editor in", " ", w.createElement(Ip, {
        onClick: this.onPreferencesClick
      }, "options")) : w.createElement(w.Fragment, null, w.createElement("p", {
        className: "description"
      }, "It doesn’t look like you have a text editor installed. We can recommend", " ", w.createElement(Ip, {
        uri: "https://atom.io",
        title: "Open the Atom website"
      }, "Atom"), " or ", w.createElement(Ip, {
        uri: "https://code.visualstudio.com",
        title: "Open the VS Code website"
      }, "Visual Studio Code"), ", but feel free to use any."), w.createElement("div", {
        className: "action"
      }, w.createElement(Ip, {
        onClick: this.skipEditorInstall
      }, "I have an editor")))), w.createElement(vg, {
        summaryText: "Create a branch",
        isComplete: this.isStepComplete,
        isNextStepTodo: this.isStepNextTodo,
        sectionId: Su.CreateBranch,
        currentlyOpenSectionId: this.state.currentlyOpenSectionId,
        onSummaryClick: this.onStepSummaryClick
      }, w.createElement("p", {
        className: "description"
      }, 'A branch allows you to work on different versions of a repository at one time. Create a\n                branch by going into the branch menu in the top bar and\n              clicking "New branch".'), w.createElement("div", {
        className: "action"
      }, w.createElement(w.Fragment, null, w.createElement("kbd", null, "Ctrl"), w.createElement("kbd", null, "Shift"), w.createElement("kbd", null, "N")))), w.createElement(vg, {
        summaryText: "Edit a file",
        isComplete: this.isStepComplete,
        isNextStepTodo: this.isStepNextTodo,
        sectionId: Su.EditFile,
        currentlyOpenSectionId: this.state.currentlyOpenSectionId,
        onSummaryClick: this.onStepSummaryClick
      }, w.createElement("p", {
        className: "description"
      }, "Open this repository in your preferred text editor. Edit the", " ", w.createElement(lm, null, "README.md"), " ", "file, save it, and come back."), this.props.resolvedExternalEditor && w.createElement("div", {
        className: "action"
      }, w.createElement(jp, {
        onClick: this.openTutorialFileInEditor
      }, "Open editor"), w.createElement(w.Fragment, null, w.createElement("kbd", null, "Ctrl"), w.createElement("kbd", null, "Shift"), w.createElement("kbd", null, "A")))), w.createElement(vg, {
        summaryText: "Make a commit",
        isComplete: this.isStepComplete,
        isNextStepTodo: this.isStepNextTodo,
        sectionId: Su.MakeCommit,
        currentlyOpenSectionId: this.state.currentlyOpenSectionId,
        onSummaryClick: this.onStepSummaryClick
      }, w.createElement("p", {
        className: "description"
      }, "A commit allows you to save sets of changes. In the “summary“ field in the bottom left, write a short message that describes the changes you made. When you’re done, click the blue Commit button to finish.")), w.createElement(vg, {
        summaryText: "Publish to GitHub",
        isComplete: this.isStepComplete,
        isNextStepTodo: this.isStepNextTodo,
        sectionId: Su.PushBranch,
        currentlyOpenSectionId: this.state.currentlyOpenSectionId,
        onSummaryClick: this.onStepSummaryClick
      }, w.createElement("p", {
        className: "description"
      }, "Publishing will “push”, or upload, your commits to this branch of your repository on GitHub. Publish using the third button in the top bar."), w.createElement("div", {
        className: "action"
      }, w.createElement(w.Fragment, null, w.createElement("kbd", null, "Ctrl"), w.createElement("kbd", null, "P")))), w.createElement(vg, {
        summaryText: "Open a pull request",
        isComplete: this.isStepComplete,
        isNextStepTodo: this.isStepNextTodo,
        sectionId: Su.OpenPullRequest,
        currentlyOpenSectionId: this.state.currentlyOpenSectionId,
        skipLinkButton: w.createElement(wg, {
          onClick: this.skipCreatePR
        }),
        onSummaryClick: this.onStepSummaryClick
      }, w.createElement("p", {
        className: "description"
      }, "A pull request allows you to propose changes to the code. By opening one, you’re requesting that someone review and merge them. Since this is a demo repository, this pull request will be private."), w.createElement("div", {
        className: "action"
      }, w.createElement(jp, {
        onClick: this.openPullRequest
      }, "Open pull request", w.createElement(bh, {
        symbol: Sh.linkExternal
      })), w.createElement(w.Fragment, null, w.createElement("kbd", null, "Ctrl"), w.createElement("kbd", null, "R"))))), w.createElement("div", {
        className: "footer"
      }, w.createElement(jp, {
        onClick: this.props.onExitTutorial
      }, "Exit tutorial")))
    }
  }
  class vg extends w.Component {
    constructor() {
      super(...arguments), this.renderSummary = () => {
        const e = void 0 !== this.props.skipLinkButton && this.props.currentlyOpenSectionId === this.props.sectionId && this.props.isNextStepTodo(this.props.sectionId);
        return w.createElement("summary", null, this.renderTutorialStepIcon(), w.createElement("span", {
          className: "summary-text"
        }, this.props.summaryText), w.createElement("span", {
          className: "hang-right"
        }, e ? this.props.skipLinkButton : w.createElement(bh, {
          symbol: Sh.chevronDown
        })))
      }, this.onSummaryClick = e => {
        e.preventDefault(), this.props.onSummaryClick(this.props.sectionId)
      }
    }
    render() {
      return w.createElement("li", {
        key: this.props.sectionId,
        onClick: this.onSummaryClick
      }, w.createElement("details", {
        open: this.props.sectionId === this.props.currentlyOpenSectionId,
        onClick: this.onSummaryClick
      }, this.renderSummary(), w.createElement("div", {
        className: "contents"
      }, this.props.children)))
    }
    renderTutorialStepIcon() {
      if (this.props.isComplete(this.props.sectionId)) return w.createElement("div", {
        className: "green-circle"
      }, w.createElement(bh, {
        symbol: Sh.check
      }));
      const e = Eu.indexOf(this.props.sectionId) + 1;
      return this.props.isNextStepTodo(this.props.sectionId) ? w.createElement("div", {
        className: "blue-circle"
      }, e) : w.createElement("div", {
        className: "empty-circle"
      }, e)
    }
  }
  const wg = e => w.createElement(Ip, {
      onClick: e.onClick
    }, "Skip"),
    bg = Mc(__dirname, "static/code.svg"),
    Sg = Mc(__dirname, "static/github-for-teams.svg"),
    Cg = Mc(__dirname, "static/github-for-business.svg");
  class Eg extends w.Component {
    render() {
      return w.createElement("div", {
        id: "tutorial-welcome"
      }, w.createElement("div", {
        className: "header"
      }, w.createElement("h1", null, "Welcome to GitHub Desktop"), w.createElement("p", null, "Use this tutorial to get comfortable with Git, GitHub, and GitHub Desktop.")), w.createElement("ul", {
        className: "definitions"
      }, w.createElement("li", null, w.createElement("img", {
        src: bg
      }), w.createElement("p", null, w.createElement("strong", null, "Git"), " is the version control system.")), w.createElement("li", null, w.createElement("img", {
        src: Sg
      }), w.createElement("p", null, w.createElement("strong", null, "GitHub"), " is where you store your code and collaborate with others.")), w.createElement("li", null, w.createElement("img", {
        src: Cg
      }), w.createElement("p", null, w.createElement("strong", null, "GitHub Desktop"), " helps you work with GitHub locally."))))
    }
  }
  const kg = Mc(__dirname, "static/admin-mentoring.svg"),
    xg = w.createElement(bh, {
      symbol: Sh.telescope
    }),
    Tg = w.createElement(bh, {
      symbol: Sh.plus
    }),
    Rg = w.createElement(bh, {
      symbol: Sh.fileDirectory
    });
  class Dg extends w.Component {
    constructor() {
      super(...arguments), this.openDotcomExplore = () => {
        this.props.dispatcher.showGitHubExplore(this.props.repository)
      }, this.onCreateNewRepository = () => {
        this.props.dispatcher.showPopup({
          type: Zi.CreateRepository
        })
      }, this.onAddExistingRepository = () => {
        this.props.dispatcher.showPopup({
          type: Zi.AddRepository
        })
      }
    }
    render() {
      return w.createElement("div", {
        id: "tutorial-done"
      }, w.createElement("div", {
        className: "content"
      }, w.createElement("div", {
        className: "header"
      }, w.createElement("div", {
        className: "text"
      }, w.createElement("h1", null, "You're done!"), w.createElement("p", null, "You’ve learned the basics on how to use GitHub Desktop. Here are some suggestions for what to do next.")), w.createElement("img", {
        src: kg,
        className: "image"
      })), w.createElement(am, null, w.createElement(rm, {
        title: "探索GitHub上的项目",
        description: "Contribute to a project that interests you",
        buttonText: "在浏览器中打开",
        onClick: this.openDotcomExplore,
        type: "normal",
        image: xg
      }), w.createElement(rm, {
        title: "创建新存储库",
        description: "Get started on a brand new project",
        buttonText: "创建存储库",
        onClick: this.onCreateNewRepository,
        type: "normal",
        image: Tg
      }), w.createElement(rm, {
        title: "添加本地存储库",
        description: "Work on an existing project in GitHub Desktop",
        buttonText: "添加存储库",
        onClick: this.onAddExistingRepository,
        type: "normal",
        image: Rg
      }))))
    }
  }
  class _g extends w.Component {
    constructor() {
      super(...arguments), this.onContinue = () => {
        this.props.onContinue() && this.props.onDismissed()
      }
    }
    render() {
      return w.createElement(Im, {
        title: "Exit tutorial",
        onDismissed: this.props.onDismissed,
        onSubmit: this.onContinue,
        type: "normal"
      }, w.createElement(Mm, null, w.createElement("p", null, "Are you sure you want to leave the tutorial? This will bring you back to the home screen.")), w.createElement(Lm, null, w.createElement(Nm, {
        okButtonText: "Exit tutorial"
      })))
    }
  }
  class Ag extends w.Component {
    constructor(e) {
      super(e), this.previousSection = this.props.state.selectedSection, this.onChangesListScrolled = e => {
        this.setState({
          changesListScrollTop: e
        })
      }, this.onCompareListScrolled = e => {
        this.setState({
          compareListScrollTop: e
        })
      }, this.handleSidebarWidthReset = () => {
        this.props.dispatcher.resetSidebarWidth()
      }, this.handleSidebarResize = e => {
        this.props.dispatcher.setSidebarWidth(e)
      }, this.onSidebarFocusWithinChanged = e => {
        !1 === e && this.props.state.selectedSection === j.History && this.props.dispatcher.updateCompareForm(this.props.repository, {
          showBranchList: !1
        })
      }, this.onOpenBinaryFile = e => {
        af(e, this.props.dispatcher)
      }, this.onChangeImageDiffType = e => {
        this.props.dispatcher.changeImageDiffType(e)
      }, this.onRevertCommit = e => {
        this.props.dispatcher.revertCommit(this.props.repository, e)
      }, this.onGlobalKeyDown = e => {
        e.defaultPrevented || this.props.isShowingModal || this.props.isShowingFoldout || e.ctrlKey && "Tab" === e.key && (this.changeTab(), e.preventDefault())
      }, this.onTabClicked = e => {
        const t = 1 === e ? j.History : j.Changes;
        this.props.dispatcher.changeRepositorySection(this.props.repository, t), t && this.props.dispatcher.updateCompareForm(this.props.repository, {
          showBranchList: !1
        })
      }, this.state = {
        changesListScrollTop: 0,
        compareListScrollTop: 0
      }
    }
    renderChangesBadge() {
      const e = this.props.state.changesState.workingDirectory.files.length;
      return e <= 0 ? null : w.createElement(mm, {
        filesChangedCount: e
      })
    }
    renderTabs() {
      const e = this.props.state.selectedSection === j.Changes ? 0 : 1;
      return w.createElement(hf, {
        selectedIndex: e,
        onTabClicked: this.onTabClicked
      }, w.createElement("span", {
        className: "with-indicator"
      }, w.createElement("span", null, "更改"), this.renderChangesBadge()), w.createElement("div", {
        className: "with-indicator"
      }, w.createElement("span", null, "历史记录"), null))
    }
    renderChangesSidebar() {
      const e = this.props.state.branchesState.tip;
      let t = null;
      e.kind === Qi.Valid ? t = e.branch.name : e.kind === Qi.Unborn && (t = e.ref);
      const n = this.props.state.localCommitSHAs,
        r = n.length > 0 ? n[0] : null,
        i = (r ? this.props.state.commitLookup.get(r) : null) || null,
        o = this.props.sidebarWidth - 1,
        s = this.previousSection === j.History ? this.state.changesListScrollTop : void 0;
      return this.previousSection = j.Changes, w.createElement(lf, {
        repository: this.props.repository,
        dispatcher: this.props.dispatcher,
        changes: this.props.state.changesState,
        branch: t,
        commitAuthor: this.props.state.commitAuthor,
        emoji: this.props.emoji,
        mostRecentLocalCommit: i,
        issuesStore: this.props.issuesStore,
        availableWidth: o,
        gitHubUserStore: this.props.gitHubUserStore,
        isCommitting: this.props.state.isCommitting,
        isPushPullFetchInProgress: this.props.state.isPushPullFetchInProgress,
        focusCommitMessage: this.props.focusCommitMessage,
        askForConfirmationOnDiscardChanges: this.props.askForConfirmationOnDiscardChanges,
        accounts: this.props.accounts,
        externalEditorLabel: this.props.externalEditorLabel,
        onOpenInExternalEditor: this.props.onOpenInExternalEditor,
        onChangesListScrolled: this.onChangesListScrolled,
        changesListScrollTop: s,
        shouldNudgeToCommit: this.props.currentTutorialStep === Su.MakeCommit
      })
    }
    renderCompareSidebar() {
      const e = this.props.state.branchesState.tip,
        t = e.kind === Qi.Valid ? e.branch : null,
        n = this.previousSection === j.Changes ? this.state.compareListScrollTop : void 0;
      return this.previousSection = j.History, w.createElement(pg, {
        repository: this.props.repository,
        isLocalRepository: null === this.props.state.remote,
        compareState: this.props.state.compareState,
        selectedCommitSha: this.props.state.commitSelection.sha,
        currentBranch: t,
        emoji: this.props.emoji,
        commitLookup: this.props.state.commitLookup,
        localCommitSHAs: this.props.state.localCommitSHAs,
        localTags: this.props.state.localTags,
        dispatcher: this.props.dispatcher,
        onRevertCommit: this.onRevertCommit,
        onViewCommitOnGitHub: this.props.onViewCommitOnGitHub,
        onCompareListScrolled: this.onCompareListScrolled,
        compareListScrollTop: n,
        tagsToPush: this.props.state.tagsToPush
      })
    }
    renderSidebarContents() {
      const e = this.props.state.selectedSection;
      return e === j.Changes ? this.renderChangesSidebar() : e === j.History ? this.renderCompareSidebar() : X(0, "Unknown repository section")
    }
    renderSidebar() {
      return w.createElement(Rp, {
        onFocusWithinChanged: this.onSidebarFocusWithinChanged
      }, w.createElement(gm, {
        id: "repository-sidebar",
        width: this.props.sidebarWidth,
        onReset: this.handleSidebarWidthReset,
        onResize: this.handleSidebarResize,
        maximumWidth: 495
      }, this.renderTabs(), this.renderSidebarContents()))
    }
    renderStashedChangesContent() {
      const {
        changesState: e
      } = this.props.state, {
        selection: t,
        stashEntry: n,
        workingDirectory: r
      } = e, i = 0 === r.files.length;
      return t.kind !== G.Stash || null === n ? null : n.files.kind === zc.Loaded ? w.createElement(mg, {
        stashEntry: n,
        selectedStashedFile: t.selectedStashedFile,
        stashedFileDiff: t.selectedStashedFileDiff,
        imageDiffType: this.props.imageDiffType,
        fileListWidth: this.props.stashedFilesWidth,
        repository: this.props.repository,
        dispatcher: this.props.dispatcher,
        isWorkingTreeClean: i,
        onOpenBinaryFile: this.onOpenBinaryFile,
        onChangeImageDiffType: this.onChangeImageDiffType
      }) : null
    }
    renderContentForHistory() {
      const {
        commitSelection: e
      } = this.props.state, t = e.sha, n = null != t && this.props.state.commitLookup.get(t) || null, {
        changedFiles: r,
        file: i,
        diff: o
      } = e;
      return w.createElement(xm, {
        repository: this.props.repository,
        dispatcher: this.props.dispatcher,
        selectedCommit: n,
        changedFiles: r,
        selectedFile: i,
        currentDiff: o,
        emoji: this.props.emoji,
        commitSummaryWidth: this.props.commitSummaryWidth,
        selectedDiffType: this.props.imageDiffType,
        externalEditorLabel: this.props.externalEditorLabel,
        onOpenInExternalEditor: this.props.onOpenInExternalEditor,
        hideWhitespaceInDiff: this.props.hideWhitespaceInDiff,
        onOpenBinaryFile: this.onOpenBinaryFile,
        onChangeImageDiffType: this.onChangeImageDiffType
      })
    }
    renderTutorialPane() {
      return this.props.currentTutorialStep === Su.AllDone ? w.createElement(Dg, {
        dispatcher: this.props.dispatcher,
        repository: this.props.repository
      }) : w.createElement(Eg, null)
    }
    renderContentForChanges() {
      const {
        changesState: e
      } = this.props.state, {
        workingDirectory: t,
        selection: n
      } = e;
      if (n.kind === G.Stash) return this.renderStashedChangesContent();
      const {
        selectedFileIDs: r,
        diff: i
      } = n;
      if (r.length > 1) return w.createElement(fm, {
        count: r.length
      });
      if (0 === t.files.length) return this.props.currentTutorialStep !== Su.NotApplicable ? this.renderTutorialPane() : w.createElement(pm, {
        key: this.props.repository.id,
        appMenu: this.props.appMenu,
        repository: this.props.repository,
        repositoryState: this.props.state,
        isExternalEditorAvailable: void 0 !== this.props.externalEditorLabel,
        dispatcher: this.props.dispatcher
      }); {
        if (0 === r.length) return null;
        const e = t.findFileWithID(r[0]);
        return null === e ? null : w.createElement(tm, {
          repository: this.props.repository,
          dispatcher: this.props.dispatcher,
          file: e,
          diff: i,
          isCommitting: this.props.state.isCommitting,
          imageDiffType: this.props.imageDiffType,
          hideWhitespaceInDiff: this.props.hideWhitespaceInDiff,
          onOpenBinaryFile: this.onOpenBinaryFile,
          onChangeImageDiffType: this.onChangeImageDiffType,
          askForConfirmationOnDiscardChanges: this.props.askForConfirmationOnDiscardChanges
        })
      }
    }
    renderContent() {
      const e = this.props.state.selectedSection;
      return e === j.Changes ? this.renderContentForChanges() : e === j.History ? this.renderContentForHistory() : X(0, "Unknown repository section")
    }
    render() {
      return w.createElement(Qp, {
        id: "repository"
      }, this.renderSidebar(), this.renderContent(), this.maybeRenderTutorialPanel())
    }
    componentDidMount() {
      window.addEventListener("keydown", this.onGlobalKeyDown)
    }
    componentWillUnmount() {
      window.removeEventListener("keydown", this.onGlobalKeyDown)
    }
    changeTab() {
      const e = this.props.state.selectedSection === j.History ? j.Changes : j.History;
      this.props.dispatcher.changeRepositorySection(this.props.repository, e)
    }
    maybeRenderTutorialPanel() {
      return Cu(this.props.currentTutorialStep) ? w.createElement(yg, {
        dispatcher: this.props.dispatcher,
        repository: this.props.repository,
        resolvedExternalEditor: this.props.resolvedExternalEditor,
        currentTutorialStep: this.props.currentTutorialStep,
        onExitTutorial: this.props.onExitTutorial
      }) : null
    }
  }
  const Mg = /[\x00-\x20\x7F~^:?*\[\\|""<>]+|@{|\.\.+|^\.|\.$|\.lock$|\/$/g;

  function Pg(e) {
    return e.replace(Mg, "-").replace(/^[-\+]*/g, "")
  }
  class Ig extends w.Component {
    constructor(e) {
      super(e), this.textBoxRef = w.createRef(), this.onValueChange = e => {
        const t = Pg(e),
          n = this.state.sanitizedValue;
        this.setState({
          proposedValue: e,
          sanitizedValue: t
        }), t !== n && void 0 !== this.props.onValueChange && this.props.onValueChange(t)
      }, this.onBlur = e => {
        void 0 !== this.props.onBlur && this.props.onBlur(Pg(e))
      };
      const t = e.initialValue || "";
      this.state = {
        proposedValue: t,
        sanitizedValue: Pg(t)
      }
    }
    componentDidMount() {
      this.state.sanitizedValue !== this.props.initialValue && void 0 !== this.props.onValueChange && this.props.onValueChange(this.state.sanitizedValue)
    }
    render() {
      return w.createElement("div", {
        className: "ref-name-text-box"
      }, w.createElement(Op, {
        label: this.props.label,
        value: this.state.proposedValue,
        ref: this.textBoxRef,
        onValueChanged: this.onValueChange,
        onBlur: this.onBlur
      }), this.renderRefValueWarning())
    }
    focus() {
      null !== this.textBoxRef.current && this.textBoxRef.current.focus()
    }
    renderRefValueWarning() {
      var e;
      const {
        proposedValue: t,
        sanitizedValue: n
      } = this.state;
      if (t === n) return null;
      const r = null !== (e = this.props.renderWarningMessage) && void 0 !== e ? e : this.defaultRenderWarningMessage;
      return w.createElement("div", {
        className: "warning-helper-text"
      }, w.createElement(bh, {
        symbol: Sh.alert
      }), w.createElement("p", null, r(n, t)))
    }
    defaultRenderWarningMessage(e, t) {
      return 0 === e.length ? w.createElement(w.Fragment, null, w.createElement(lm, null, t), " is not a valid name.") : w.createElement(w.Fragment, null, "Will be created as ", w.createElement(lm, null, e), ".")
    }
  }
  class Og extends w.Component {
    constructor(e) {
      super(e), this.onNameChange = e => {
        this.setState({
          newName: e
        })
      }, this.renameBranch = () => {
        this.props.dispatcher.renameBranch(this.props.repository, this.props.branch, this.state.newName), this.props.onDismissed()
      }, this.state = {
        newName: e.branch.name
      }
    }
    render() {
      return w.createElement(Im, {
        id: "rename-branch",
        title: "重命名分支",
        onDismissed: this.props.onDismissed,
        onSubmit: this.renameBranch
      }, w.createElement(Mm, null, w.createElement(Ig, {
        label: "分支名",
        initialValue: this.props.branch.name,
        onValueChange: this.onNameChange
      }), null != (e = this.props.branch).upstream ? w.createElement(Lp, {
        className: "warning-helper-text"
      }, w.createElement(bh, {
        symbol: Sh.alert
      }), w.createElement("p", null, "此分支正在跟踪 ", w.createElement(lm, null, e.upstream), " 重命名此分支不会更改远程上的分支名称.")) : null, null === this.props.stash ? null : w.createElement(Lp, {
        className: "warning-helper-text"
      }, w.createElement(bh, {
        symbol: Sh.alert
      }), w.createElement("p", null, "如果分支被重命名，您当前保存在该分支上的更改将在GitHub桌面中不再可见."))), w.createElement(Lm, null, w.createElement(Nm, {
        okButtonText: "重命名 " + this.props.branch.name,
        okButtonDisabled: 0 === this.state.newName.length
      })));
      var e
    }
  }
  class Lg extends w.Component {
    constructor(e) {
      super(e), this.onIncludeRemoteChanged = e => {
        const t = e.currentTarget.checked;
        this.setState({
          includeRemoteBranch: t
        })
      }, this.deleteBranch = async () => {
        const {
          dispatcher: e,
          repository: t,
          branch: n
        } = this.props;
        this.setState({
          isDeleting: !0
        }), await e.deleteBranch(t, n, this.state.includeRemoteBranch), this.props.onDeleted(t), this.props.onDismissed()
      }, this.state = {
        includeRemoteBranch: !1,
        isDeleting: !1
      }
    }
    render() {
      return w.createElement(Im, {
        id: "delete-branch",
        title: "删除分支",
        type: "warning",
        onSubmit: this.deleteBranch,
        onDismissed: this.props.onDismissed,
        disabled: this.state.isDeleting,
        loading: this.state.isDeleting
      }, w.createElement(Mm, null, w.createElement("p", null, "删除分支 ", w.createElement(lm, null, this.props.branch.name), "?", w.createElement("br", null), "此操作无法撤消."), this.renderDeleteOnRemote()), w.createElement(Lm, null, w.createElement(Nm, {
        destructive: !0,
        okButtonText: "删除"
      })))
    }
    renderDeleteOnRemote() {
      return this.props.branch.remote && this.props.existsOnRemote ? w.createElement("div", null, w.createElement("p", null, w.createElement("strong", null, "远程上也存在分支，是否也要将其删除?")), w.createElement(Xp, {
        label: "是，删除远程上的此分支",
        value: this.state.includeRemoteBranch ? Zp.On : Zp.Off,
        onChange: this.onIncludeRemoteChanged
      })) : null
    }
  }
  class Ng extends w.Component {
    render() {
      const e = this.props.progress.value || void 0;
      return w.createElement(Qp, {
        id: "cloning-repository-view"
      }, w.createElement("div", {
        className: "title-container"
      }, w.createElement(bh, {
        symbol: Sh.desktopDownload
      }), w.createElement("div", {
        className: "title"
      }, "Cloning ", this.props.repository.name)), w.createElement("progress", {
        value: e
      }), w.createElement("div", {
        className: "details"
      }, this.props.progress.description))
    }
  }
  class Fg extends w.Component {
    render() {
      return w.createElement("div", {
        id: this.props.id,
        className: "toolbar"
      }, this.props.children)
    }
  }
  var Bg;
  ! function (e) {
    e[e.Standard = 0] = "Standard", e[e.Subtitle = 1] = "Subtitle"
  }(Bg || (Bg = {}));
  class Hg extends w.Component {
    constructor() {
      super(...arguments), this.innerButton = null, this.onClick = e => {
        this.props.onClick && this.props.onClick(e)
      }, this.onButtonRef = e => {
        this.innerButton = e
      }, this.focusButton = () => {
        this.innerButton && this.innerButton.focus()
      }, this.getButtonBoundingClientRect = () => this.innerButton ? this.innerButton.getBoundingClientRect() : void 0
    }
    render() {
      const e = this.props.icon ? w.createElement(bh, {
          symbol: this.props.icon,
          className: mh()("icon", this.props.iconClassName)
        }) : null,
        t = mh()("toolbar-button", {
          "has-progress": void 0 !== this.props.progressValue
        }, this.props.className),
        n = void 0 !== this.props.progressValue ? Math.round(100 * fl(this.props.progressValue, 0, 1)) / 100 : void 0,
        r = void 0 !== n ? w.createElement("div", {
          className: "progress",
          style: {
            transform: `scaleX(${n})`
          }
        }) : void 0;
      return w.createElement("div", {
        className: t,
        onKeyDown: this.props.onKeyDown,
        title: this.props.tooltip
      }, w.createElement(jp, {
        onClick: this.onClick,
        ref: this.onButtonRef,
        disabled: this.props.disabled,
        onMouseEnter: this.props.onMouseEnter,
        tabIndex: this.props.tabIndex,
        role: this.props.role,
        ariaExpanded: this.props.ariaExpanded
      }, r, e, this.renderText(), this.props.children))
    }
    renderText() {
      if (void 0 === this.props.title && void 0 === this.props.description) return null;
      const e = void 0 !== this.props.title ? w.createElement("div", {
          className: "title"
        }, this.props.title) : null,
        t = void 0 !== this.props.description ? w.createElement("div", {
          className: "description"
        }, this.props.description) : null,
        n = this.props.style || Bg.Standard;
      switch (n) {
        case Bg.Standard:
          return w.createElement("div", {
            className: "text"
          }, t, e);
        case Bg.Subtitle:
          return w.createElement("div", {
            className: "text"
          }, w.createElement("div", {
            className: "title"
          }, this.props.title), t);
        default:
          return X(0, "Unknown button style: " + n)
      }
    }
  }
  class zg extends w.Component {
    constructor(e) {
      super(e), this.innerButton = null, this.onClick = e => {
        const t = "open" === this.props.dropdownState ? "closed" : "open",
          n = e.clientX || e.clientY ? "pointer" : "keyboard";
        this.props.onDropdownStateChanged(t, n)
      }, this.handleOverlayClick = () => {
        this.props.onDropdownStateChanged("closed", "pointer")
      }, this.onFoldoutKeyDown = e => {
        !e.defaultPrevented && this.isOpen && "Escape" === e.key && (e.preventDefault(), this.props.onDropdownStateChanged("closed", "keyboard"))
      }, this.renderDropdownContents = () => "open" !== this.props.dropdownState ? null : w.createElement("div", {
        id: "foldout-container",
        style: this.getFoldoutContainerStyle()
      }, w.createElement("div", {
        className: "overlay",
        tabIndex: -1,
        onClick: this.handleOverlayClick
      }), w.createElement("div", {
        className: "foldout",
        style: this.getFoldoutStyle(),
        tabIndex: -1,
        onKeyDown: this.onFoldoutKeyDown
      }, this.props.dropdownContentRenderer())), this.onRef = e => {
        this.innerButton = e
      }, this.focusButton = () => {
        this.innerButton && this.innerButton.focusButton()
      }, this.state = {
        clientRect: null
      }
    }
    get isOpen() {
      return "open" === this.props.dropdownState
    }
    dropdownIcon(e) {
      return "open" === e ? Sh.triangleUp : "closed" === e ? Sh.triangleDown : X(0, "Unknown dropdown state " + e)
    }
    renderDropdownArrow() {
      if (!1 === this.props.showDisclosureArrow) return null;
      const e = this.props.dropdownState;
      return w.createElement(bh, {
        symbol: this.dropdownIcon(e),
        className: "dropdownArrow"
      })
    }
    updateClientRectIfNecessary() {
      if ("open" === this.props.dropdownState && this.innerButton) {
        const n = this.innerButton.getButtonBoundingClientRect();
        if (n) {
          const r = this.state.clientRect;
          r && ((e = r) === (t = n) || e.left === t.left && e.right === t.right && e.top === t.top && e.bottom === t.bottom && e.width === t.width && e.height === t.height) || this.setState({
            clientRect: n
          })
        }
      }
      var e, t
    }
    componentDidMount() {
      this.updateClientRectIfNecessary()
    }
    componentWillUnmount() {
      this.innerButton = null
    }
    componentDidUpdate() {
      this.updateClientRectIfNecessary()
    }
    getFoldoutContainerStyle() {
      const e = this.state.clientRect;
      if (e) return {
        position: "absolute",
        top: e.bottom,
        left: 0,
        width: "100%",
        height: `calc(100% - ${e.bottom}px)`
      }
    }
    getFoldoutStyle() {
      if (this.props.foldoutStyle) return this.props.foldoutStyle;
      const e = this.state.clientRect;
      return e ? {
        position: "absolute",
        marginLeft: e.left,
        minWidth: e.width,
        height: "100%",
        top: 0
      } : void 0
    }
    render() {
      const e = mh()("toolbar-dropdown", this.props.dropdownState, this.props.className),
        t = "open" === this.props.dropdownState ? "true" : "false";
      return w.createElement("div", {
        className: e,
        onKeyDown: this.props.onKeyDown,
        role: this.props.role,
        "aria-expanded": t
      }, this.renderDropdownContents(), w.createElement(Hg, {
        className: this.props.buttonClassName,
        ref: this.onRef,
        icon: this.props.icon,
        title: this.props.title,
        description: this.props.description,
        tooltip: this.props.tooltip,
        onClick: this.onClick,
        onMouseEnter: this.props.onMouseEnter,
        style: this.props.style,
        iconClassName: this.props.iconClassName,
        disabled: this.props.disabled,
        tabIndex: this.props.tabIndex,
        progressValue: this.props.progressValue,
        role: this.props.buttonRole
      }, this.props.children, this.renderDropdownArrow()))
    }
  }

  function Ug(e, t) {
    const {
      ahead: n,
      behind: r
    } = e;
    if (0 === n && 0 === r && 0 === t) return null;
    const i = new Array;
    return (n > 0 || t > 0) && i.push(w.createElement("span", {
      key: "ahead"
    }, n + t, w.createElement(bh, {
      symbol: Sh.arrowSmallUp
    }))), r > 0 && i.push(w.createElement("span", {
      key: "behind"
    }, r, w.createElement(bh, {
      symbol: Sh.arrowSmallDown
    }))), w.createElement("div", {
      className: "ahead-behind"
    }, i)
  }

  function Wg(e) {
    return e ? w.createElement("span", null, "Last fetched ", w.createElement( of , {
      date: e
    })) : "Never fetched"
  }
  const Vg = {
    className: "push-pull-button",
    style: Bg.Subtitle
  };
  const jg = new Sh(10, 16, "M3 11H0l5-6 5 6H7v4H3v-4zM5 1l5 6H8.33L5 3 1.662 7H0l5-6z");
  class Gg extends w.Component {
    constructor() {
      super(...arguments), this.push = () => {
        this.props.dispatcher.push(this.props.repository)
      }, this.forcePushWithLease = () => {
        this.props.dispatcher.confirmOrForcePush(this.props.repository)
      }, this.pull = () => {
        this.props.dispatcher.pull(this.props.repository)
      }, this.fetch = () => {
        this.props.dispatcher.fetch(this.props.repository, Li.UserInitiatedTask)
      }
    }
    render() {
      const {
        progress: e,
        networkActionInProgress: t,
        aheadBehind: n,
        numTagsToPush: r,
        remoteName: i,
        repository: o,
        tipState: s,
        rebaseInProgress: a,
        lastFetched: l,
        pullWithRebase: c,
        isForcePush: u
      } = this.props;
      if (null !== e) return function (e, t) {
        return w.createElement(Hg, Object.assign({}, Vg, {
          title: e.title,
          description: e.description || "Hang on…",
          progressValue: e.value,
          icon: Sh.sync,
          iconClassName: t ? "spin" : "",
          tooltip: e.description,
          disabled: !0
        }))
      }(e, t);
      if (null === i) return h = this.push, w.createElement(Hg, Object.assign({}, Vg, {
        title: "发布存储库",
        description: "Publish this repository to GitHub",
        className: "push-pull-button",
        icon: Sh.cloudUpload,
        style: Bg.Subtitle,
        onClick: h
      }));
      var h;
      if (s === Qi.Unborn) return w.createElement(Hg, Object.assign({}, Vg, {
        title: "发布分支",
        description: "Cannot publish unborn HEAD",
        icon: Sh.cloudUpload,
        disabled: !0
      }));
      if (s === Qi.Detached) return function (e) {
        const t = e ? "Rebase in progress" : "Cannot publish detached HEAD";
        return w.createElement(Hg, Object.assign({}, Vg, {
          title: "发布分支",
          description: t,
          icon: Sh.cloudUpload,
          disabled: !0
        }))
      }(a);
      if (null === n) {
        return function (e, t, n) {
          const r = e ? "Publish this branch to GitHub" : "Publish this branch to the remote",
            i = mh()(Vg.className, "nudge-arrow", {
              "nudge-arrow-up": n
            });
          return w.createElement(Hg, Object.assign({}, Vg, {
            title: "发布分支",
            description: r,
            icon: Sh.cloudUpload,
            onClick: t,
            className: i
          }))
        }(null !== o.gitHubRepository, this.push, this.props.shouldNudge)
      }
      const {
        ahead: p,
        behind: d
      } = n;
      return 0 === p && 0 === d && 0 === r ? function (e, t, n, r, i) {
        const o = "Fetch " + e;
        return w.createElement(Hg, Object.assign({}, Vg, {
          title: o,
          description: Wg(r),
          icon: Sh.sync,
          onClick: i
        }), Ug(t, n))
      }(i, n, r, l, this.fetch) : u ? function (e, t, n, r, i) {
        return w.createElement(Hg, Object.assign({}, Vg, {
          title: "强制推送 " + e,
          description: Wg(r),
          icon: jg,
          onClick: i
        }), Ug(t, n))
      }(i, n, r, l, this.forcePushWithLease) : d > 0 ? function (e, t, n, r, i, o) {
        const s = i ? `Pull ${e} with rebase` : "Pull " + e;
        return w.createElement(Hg, Object.assign({}, Vg, {
          title: s,
          description: Wg(r),
          icon: Sh.arrowDown,
          onClick: o
        }), Ug(t, n))
      }(i, n, r, l, c || !1, this.pull) : function (e, t, n, r, i) {
        return w.createElement(Hg, Object.assign({}, Vg, {
          title: "推送 " + e,
          description: Wg(r),
          icon: Sh.arrowUp,
          onClick: i
        }), Ug(t, n))
      }(i, n, r, l, this.push)
    }
  }
  class $g extends w.Component {
    constructor() {
      super(...arguments), this.renderBranchFoldout = () => {
        const e = this.props.repositoryState,
          t = e.branchesState,
          n = e.changesState.currentBranchProtected,
          r = e.branchesState.tip,
          i = r.kind === Qi.Valid ? r.branch : null;
        return w.createElement(rg, {
          allBranches: t.allBranches,
          recentBranches: t.recentBranches,
          currentBranch: i,
          defaultBranch: t.defaultBranch,
          dispatcher: this.props.dispatcher,
          repository: this.props.repository,
          selectedTab: this.props.selectedTab,
          pullRequests: this.props.pullRequests,
          currentPullRequest: this.props.currentPullRequest,
          isLoadingPullRequests: this.props.isLoadingPullRequests,
          currentBranchProtected: n,
          selectedUncommittedChangesStrategy: this.props.selectedUncommittedChangesStrategy,
          couldOverwriteStash: this.props.couldOverwriteStash
        })
      }, this.onDropDownStateChanged = e => {
        "open" === e && this.props.repositoryState.checkoutProgress || this.props.onDropDownStateChanged(e)
      }
    }
    render() {
      const {
        repositoryState: e
      } = this.props, {
        branchesState: t,
        checkoutProgress: n,
        changesState: r
      } = e, {
        tip: i
      } = t, {
        conflictState: o
      } = r, s = i.kind;
      let a, l, c = Sh.gitBranch,
        u = void 0,
        h = "当前分支",
        p = !0,
        d = !1;
      if (this.props.currentPullRequest && (c = Sh.gitPullRequest), i.kind === Qi.Unknown) return null;
      if (i.kind === Qi.Unborn) a = i.ref, l = "当前分支是" + i.ref, p = t.allBranches.length > 0;
      else if (i.kind === Qi.Detached) a = "On " + i.currentSha.substr(0, 7), l = "目前正在进行中", c = Sh.gitCommit, h = "Detached HEAD";
      else {
        if (i.kind !== Qi.Valid) return X(0, "Unknown tip state: " + s);
        a = i.branch.name, l = "当前分支是" + a
      }
      let f = void 0;
      if (n) {
        if (a = n.targetBranch, h = "切换到分支", n.value > 0) {
          h = `${h} (${Math.round(100*n.value)}%)`
        }
        f = n.value, c = Sh.sync, u = "spin", p = !1
      } else null !== o && Q(o) && (a = o.targetBranch, h = "Rebasing branch", c = Sh.gitBranch, p = !1, d = !0);
      const m = this.props.isOpen && p ? "open" : "closed",
        g = mh()("nudge-arrow", {
          "nudge-arrow-up": this.props.shouldNudge
        });
      return w.createElement(zg, {
        className: "branch-button",
        icon: c,
        iconClassName: u,
        title: a,
        description: h,
        tooltip: l,
        onDropdownStateChanged: this.onDropDownStateChanged,
        dropdownContentRenderer: this.renderBranchFoldout,
        dropdownState: m,
        disabled: d,
        showDisclosureArrow: p,
        progressValue: f,
        buttonClassName: g
      }, this.renderPullRequestInfo())
    }
    renderPullRequestInfo() {
      const e = this.props.currentPullRequest;
      return null === e ? null : w.createElement(ig, {
        number: e.pullRequestNumber,
        dispatcher: this.props.dispatcher,
        repository: e.base.gitHubRepository
      })
    }
  }
  class qg extends w.Component {
    render() {
      const e = this.props.progress,
        t = e.title || "Hang on…";
      return w.createElement(Hg, {
        title: "恢复…",
        description: t,
        progressValue: e.value,
        className: "revert-progress",
        icon: Sh.sync,
        iconClassName: "spin",
        style: Bg.Subtitle,
        disabled: !0
      })
    }
  }
  class Kg extends w.Component {
    constructor(e) {
      super(e), this.discard = async () => {
        this.setState({
          isDiscardingChanges: !0
        }), await this.props.dispatcher.discardChanges(this.props.repository, this.props.files), this.props.onConfirmDiscardChangesChanged(this.state.confirmDiscardChanges), this.props.onDismissed()
      }, this.onConfirmDiscardChangesChanged = e => {
        const t = !e.currentTarget.checked;
        this.setState({
          confirmDiscardChanges: t
        })
      }, this.state = {
        isDiscardingChanges: !1,
        confirmDiscardChanges: this.props.confirmDiscardChanges
      }
    }
    getOkButtonLabel() {
      return this.props.discardingAllChanges ? "放弃所有更改" : "放弃更改"
    }
    getDialogTitle() {
      return this.props.discardingAllChanges ? "确认放弃所有更改" : "确认放弃更改"
    }
    render() {
      const e = this.state.isDiscardingChanges;
      return w.createElement(Im, {
        id: "discard-changes",
        title: this.getDialogTitle(),
        onDismissed: this.props.onDismissed,
        onSubmit: this.discard,
        dismissable: !e,
        loading: e,
        disabled: e,
        type: "warning"
      }, w.createElement(Mm, null, this.renderFileList(), w.createElement("p", null, "Changes can be restored by retrieving them from the ", "Recycle Bin", "."), this.renderConfirmDiscardChanges()), w.createElement(Lm, null, w.createElement(Nm, {
        destructive: !0,
        okButtonText: this.getOkButtonLabel()
      })))
    }
    renderConfirmDiscardChanges() {
      return this.props.showDiscardChangesSetting ? w.createElement(Xp, {
        label: "不再显示此消息",
        value: this.state.confirmDiscardChanges ? Zp.Off : Zp.On,
        onChange: this.onConfirmDiscardChangesChanged
      }) : null
    }
    renderFileList() {
      return this.props.files.length > 10 ? w.createElement("p", null, "Are you sure you want to discard all ", this.props.files.length, " changed files?") : w.createElement("div", null, w.createElement("p", null, "Are you sure you want to discard all changes to:"), w.createElement("ul", null, this.props.files.map(e => w.createElement("li", {
        key: e.id
      }, w.createElement($d, {
        path: e.path
      })))))
    }
  }
  class Yg extends w.Component {
    constructor() {
      super(...arguments), this.onSubmit = e => {
        e.preventDefault(), this.props.onSubmit && this.props.onSubmit()
      }
    }
    render() {
      const e = mh()("form-component", this.props.className);
      return w.createElement("form", {
        className: e,
        onSubmit: this.onSubmit
      }, this.props.children)
    }
  }
  class Qg extends w.Component {
    render() {
      const e = mh()("errors-component", this.props.className);
      return w.createElement("div", {
        className: e
      }, this.props.children)
    }
  }
  const Zg = "Your browser will redirect you back to GitHub Desktop once you've signed in. If your browser asks for your permission to launch GitHub Desktop please allow it to.";
  class Xg extends w.Component {
    constructor(e) {
      super(e), this.onUsernameChange = e => {
        this.setState({
          username: e
        })
      }, this.onPasswordChange = e => {
        this.setState({
          password: e
        })
      }, this.signInWithBrowser = e => {
        e && e.preventDefault(), this.props.onBrowserSignInRequested()
      }, this.signIn = () => {
        this.props.onSubmit(this.state.username, this.state.password)
      }, this.state = {
        username: "",
        password: ""
      }
    }
    render() {
      const e = this.props.supportsBasicAuth ? this.renderSignInForm() : this.renderEndpointRequiresWebFlow();
      return w.createElement(Yg, {
        className: "sign-in-form",
        onSubmit: this.signIn
      }, e)
    }
    renderUsernamePassword() {
      const e = this.props.loading;
      return w.createElement(w.Fragment, null, w.createElement(Op, {
        label: "Username or email address",
        disabled: e,
        autoFocus: !0,
        onValueChanged: this.onUsernameChange
      }), w.createElement(Op, {
        label: "Password",
        type: "password",
        disabled: e,
        onValueChanged: this.onPasswordChange
      }), this.renderError(), w.createElement("div", {
        className: "sign-in-footer"
      }, this.renderActions()))
    }
    renderActions() {
      const e = Boolean(!this.state.username.length || !this.state.password.length || this.props.loading);
      return w.createElement("div", {
        className: "actions"
      }, this.props.supportsBasicAuth ? w.createElement(jp, {
        type: "submit",
        disabled: e
      }, this.props.loading ? w.createElement(fd, null) : null, " Sign in") : null, this.props.additionalButtons, this.props.supportsBasicAuth ? w.createElement(Ip, {
        className: "forgot-password-link",
        uri: this.props.forgotPasswordUrl
      }, "Forgot password?") : null)
    }
    renderSignInWithBrowser() {
      return w.createElement(w.Fragment, null, this.renderSignInWithBrowserButton(), this.props.additionalButtons)
    }
    renderSignInForm() {
      return this.props.endpoint === pt() ? this.renderUsernamePassword() : w.createElement(w.Fragment, null, this.renderSignInWithBrowser(), this.renderUsernamePassword())
    }
    renderEndpointRequiresWebFlow() {
      return w.createElement(w.Fragment, null, this.props.endpoint === pt() ? w.createElement(w.Fragment, null, w.createElement("p", null, "GitHub now requires you to sign in with your browser."), w.createElement("p", null, Zg)) : w.createElement("p", null, "Your GitHub Enterprise Server instance requires you to sign in with your browser."), this.renderSignInWithBrowserButton(), this.props.additionalButtons)
    }
    renderSignInWithBrowserButton() {
      return w.createElement(jp, {
        type: "submit",
        className: "button-with-icon",
        onClick: this.signInWithBrowser
      }, "Sign in using your browser", w.createElement(bh, {
        symbol: Sh.linkExternal
      }))
    }
    renderError() {
      const e = this.props.error;
      return e ? w.createElement(Qg, null, e.message) : null
    }
  }
  class Jg extends w.Component {
    constructor() {
      super(...arguments), this.signInWithBrowser = e => {
        e && e.preventDefault(), this.props.advance(cy.SignInToDotComWithBrowser), this.props.dispatcher.requestBrowserAuthenticationToDotcom()
      }, this.cancelBrowserAuth = () => {
        this.props.advance(cy.Start)
      }, this.signInToDotCom = () => {
        this.props.advance(cy.SignInToDotCom)
      }, this.signInToEnterprise = () => {
        this.props.advance(cy.SignInToEnterprise)
      }, this.skip = () => {
        this.props.advance(cy.ConfigureGit)
      }
    }
    render() {
      return w.createElement("div", {
        id: "start"
      }, w.createElement("h1", {
        className: "welcome-title"
      }, "Welcome to GitHub Desktop"), this.props.loadingBrowserAuth ? w.createElement("p", null, Zg) : w.createElement(w.Fragment, null, w.createElement("p", {
        className: "welcome-text"
      }, "GitHub Desktop is a seamless way to contribute to projects on GitHub and GitHub Enterprise Server. Sign in below to get started with your existing projects."), w.createElement("p", {
        className: "welcome-text"
      }, "New to GitHub?", " ", w.createElement(Ip, {
        uri: "https://github.com/join?source=github-desktop",
        className: "create-account-link"
      }, "Create your free account."))), w.createElement("div", {
        className: "welcome-main-buttons"
      }, w.createElement(jp, {
        type: "submit",
        className: "button-with-icon",
        disabled: this.props.loadingBrowserAuth,
        onClick: this.signInWithBrowser
      }, this.props.loadingBrowserAuth && w.createElement(fd, null), "Sign in to GitHub.com", w.createElement(bh, {
        symbol: Sh.linkExternal
      })), this.props.loadingBrowserAuth ? w.createElement(jp, {
        onClick: this.cancelBrowserAuth
      }, "Cancel") : w.createElement(jp, {
        onClick: this.signInToEnterprise
      }, "Sign in to GitHub Enterprise Server")), !this.props.loadingBrowserAuth && this.props.dotComSupportsBasicAuth && w.createElement("div", null, w.createElement(Ip, {
        onClick: this.signInToDotCom,
        className: "basic-auth-link"
      }, "Sign in to GitHub.com using your username and password")), w.createElement("div", {
        className: "skip-action-container"
      }, w.createElement(Ip, {
        className: "skip-button",
        onClick: this.skip
      }, "Skip this step")))
    }
  }
  class ey extends w.Component {
    constructor(e) {
      super(e), this.onOTPChange = e => {
        this.setState({
          otp: e
        })
      }, this.signIn = () => {
        this.props.onOTPEntered(this.state.otp)
      }, this.state = {
        otp: ""
      }
    }
    render() {
      const e = this.props.loading,
        t = !/\S+/.test(this.state.otp) || this.props.loading,
        n = this.props.error ? w.createElement(Qg, null, this.props.error.message) : null;
      return w.createElement("div", null, w.createElement("p", {
        className: "welcome-text"
      }, je(this.props.type)), w.createElement(Yg, {
        onSubmit: this.signIn
      }, w.createElement(Op, {
        label: "Authentication code",
        disabled: e,
        autoFocus: !0,
        onValueChanged: this.onOTPChange
      }), n, w.createElement("div", {
        className: "actions"
      }, w.createElement(jp, {
        type: "submit",
        disabled: t
      }, this.props.loading ? w.createElement(fd, null) : null, " Verify"), this.props.additionalButtons)))
    }
  }
  class ty extends w.Component {
    constructor(e) {
      super(e), this.onServerAddressChanged = e => {
        this.setState({
          serverAddress: e
        })
      }, this.onSubmit = () => {
        this.props.onSubmit(this.state.serverAddress)
      }, this.state = {
        serverAddress: ""
      }
    }
    render() {
      const e = this.props.loading,
        t = 0 === this.state.serverAddress.length || this.props.loading;
      return w.createElement(Yg, {
        onSubmit: this.onSubmit
      }, w.createElement(Op, {
        label: "Enterprise Server address",
        autoFocus: !0,
        disabled: e,
        onValueChanged: this.onServerAddressChanged,
        placeholder: "https://github.example.com"
      }), this.props.error ? w.createElement(Qg, null, this.props.error.message) : null, w.createElement("div", {
        className: "actions"
      }, w.createElement(jp, {
        type: "submit",
        disabled: t
      }, this.props.loading ? w.createElement(fd, null) : null, " Continue"), this.props.additionalButtons))
    }
  }
  class ny extends w.Component {
    constructor() {
      super(...arguments), this.onEndpointEntered = e => {
        this.props.dispatcher.setSignInEndpoint(e)
      }, this.onCredentialsEntered = (e, t) => {
        this.props.dispatcher.setSignInCredentials(e, t)
      }, this.onBrowserSignInRequested = () => {
        this.props.dispatcher.requestBrowserAuthentication()
      }, this.onOTPEntered = e => {
        this.props.dispatcher.setSignInOTP(e)
      }
    }
    renderEndpointEntryStep(e) {
      const t = this.props.children;
      return w.createElement(ty, {
        loading: e.loading,
        error: e.error,
        onSubmit: this.onEndpointEntered,
        additionalButtons: t
      })
    }
    renderAuthenticationStep(e) {
      const t = this.props.children;
      return w.createElement(Xg, {
        loading: e.loading,
        error: e.error,
        supportsBasicAuth: e.supportsBasicAuth,
        additionalButtons: t,
        onBrowserSignInRequested: this.onBrowserSignInRequested,
        onSubmit: this.onCredentialsEntered,
        forgotPasswordUrl: e.forgotPasswordUrl,
        endpoint: e.endpoint
      })
    }
    renderTwoFactorAuthenticationStep(e) {
      return w.createElement(ey, {
        loading: e.loading,
        error: e.error,
        type: e.type,
        additionalButtons: this.props.children,
        onOTPEntered: this.onOTPEntered
      })
    }
    render() {
      const e = this.props.signInState,
        t = this.props.signInState.kind;
      switch (e.kind) {
        case Yu.EndpointEntry:
          return this.renderEndpointEntryStep(e);
        case Yu.Authentication:
          return this.renderAuthenticationStep(e);
        case Yu.TwoFactorAuthentication:
          return this.renderTwoFactorAuthenticationStep(e);
        case Yu.Success:
          return null;
        default:
          return X(0, "Unknown sign-in step: " + t)
      }
    }
  }
  class ry extends w.Component {
    constructor() {
      super(...arguments), this.cancel = () => {
        this.props.advance(cy.Start)
      }
    }
    componentWillMount() {
      this.props.dispatcher.beginDotComSignIn()
    }
    render() {
      const e = this.props.signInState;
      return e ? w.createElement("div", {
        id: "sign-in-dot-com"
      }, w.createElement("h1", {
        className: "welcome-title"
      }, "Sign in to GitHub.com"), w.createElement(ny, {
        signInState: e,
        dispatcher: this.props.dispatcher
      }, w.createElement(jp, {
        onClick: this.cancel
      }, "Cancel"))) : null
    }
  }
  class iy extends w.Component {
    constructor() {
      super(...arguments), this.cancel = () => {
        this.props.advance(cy.Start)
      }
    }
    render() {
      const e = this.props.signInState;
      return e ? w.createElement("div", {
        id: "sign-in-enterprise"
      }, w.createElement("h1", {
        className: "welcome-title"
      }, "Sign in to your GitHub Enterprise Server"), w.createElement(ny, {
        signInState: e,
        dispatcher: this.props.dispatcher
      }, w.createElement(jp, {
        onClick: this.cancel
      }, "Cancel"))) : null
    }
  }
  class oy extends w.Component {
    constructor() {
      super(...arguments), this.onDeleteLockFile = async () => {
        try {
          await Object(Ci.unlink)(this.props.lockFilePath)
        } catch (e) {
          if ("ENOENT" !== e.code) return void this.props.onError(e)
        }
        this.props.onLockFileDeleted()
      }
    }
    render() {
      return w.createElement("div", {
        className: "config-lock-file-exists-component"
      }, w.createElement("p", null, "Failed to update Git configuration file. A lock file already exists at", " ", w.createElement(lm, null, this.props.lockFilePath), "."), w.createElement("p", null, "This can happen if another tool is currently modifying the Git configuration or if a Git process has terminated earlier without cleaning up the lock file. Do you want to", " ", w.createElement(Ip, {
        onClick: this.onDeleteLockFile
      }, "delete the lock file"), " ", "and try again?"))
    }
  }
  class sy extends w.Component {
    constructor(e) {
      super(e), this.globalUsernamePromise = Io("user.name"), this.globalEmailPromise = Io("user.email"), this.onLockFileDeleted = () => {
        this.setState({
          existingLockFilePath: void 0
        })
      }, this.onLockFileDeleteError = e => {
        log.error("Failed to unlink config lock file", e), this.setState({
          existingLockFilePath: void 0
        })
      }, this.onNameChange = e => {
        this.setState({
          name: e
        })
      }, this.onEmailChange = e => {
        this.setState({
          email: e
        })
      }, this.save = async () => {
        const {
          name: e,
          email: t,
          globalUserName: n,
          globalUserEmail: r
        } = this.state;
        try {
          e.length > 0 && e !== n && await Oo("user.name", e), t.length > 0 && t !== r && await Oo("user.email", t)
        } catch (e) {
          if (zo(e)) {
            const t = Wo(e.result);
            if (null !== t) return void this.setState({
              existingLockFilePath: t
            })
          }
        }
        this.props.onSave && this.props.onSave()
      }, this.state = {
        globalUserName: null,
        globalUserEmail: null,
        name: "",
        email: ""
      }
    }
    async componentDidMount() {
      const e = this.props.accounts,
        [t, n] = await Promise.all([this.globalUsernamePromise, this.globalEmailPromise]);
      this.setState(e => ({
        globalUserName: t,
        globalUserEmail: n,
        name: 0 === e.name.length ? t || "" : e.name,
        email: 0 === e.email.length ? n || "" : e.email
      }), () => {
        e === this.props.accounts && e.length > 0 && this.setDefaultValuesFromAccount(e[0])
      })
    }
    componentDidUpdate(e) {
      if (this.props.accounts !== e.accounts && this.props.accounts.length > 0 && this.props.accounts[0] !== e.accounts[0]) {
        const e = this.props.accounts[0];
        this.setDefaultValuesFromAccount(e)
      }
    }
    setDefaultValuesFromAccount(e) {
      0 === this.state.name.length && this.setState({
        name: e.name || e.login
      }), 0 === this.state.email.length && this.setState({
        email: Pu(e)
      })
    }
    dateWithMinuteOffset(e, t) {
      const n = new Date(e.getTime());
      return n.setTime(n.getTime() + 60 * t * 1e3), n
    }
    render() {
      const e = new Date,
        t = new Os(this.state.name, this.state.email, this.dateWithMinuteOffset(e, -30)),
        n = new Ia(this.state.name, this.state.name.slice(0, 7), "Fix all the things", "", t, t, [], [], []),
        r = new Map,
        i = void 0 !== this.state.existingLockFilePath ? w.createElement(oy, {
          lockFilePath: this.state.existingLockFilePath,
          onLockFileDeleted: this.onLockFileDeleted,
          onError: this.onLockFileDeleteError
        }) : null;
      return w.createElement("div", {
        id: "configure-git-user"
      }, i, w.createElement(Yg, {
        className: "sign-in-form",
        onSubmit: this.save
      }, w.createElement(Op, {
        label: "Name",
        placeholder: "Your Name",
        value: this.state.name,
        onValueChanged: this.onNameChange
      }), w.createElement(Op, {
        label: "Email",
        placeholder: "your-email@example.com",
        value: this.state.email,
        onValueChanged: this.onEmailChange
      }), w.createElement(Lp, null, w.createElement(jp, {
        type: "submit"
      }, this.props.saveLabel || "Save"), this.props.children)), w.createElement("div", {
        id: "commit-list",
        className: "commit-list-example"
      }, w.createElement("div", {
        className: "header"
      }, "Example commit"), w.createElement(Rm, {
        commit: n,
        emoji: r,
        gitHubRepository: null,
        isLocal: !1,
        showUnpushedIndicator: !1
      })))
    }
  }
  class ay extends w.Component {
    constructor() {
      super(...arguments), this.cancel = () => {
        this.props.advance(cy.Start)
      }, this.continue = () => {
        this.props.advance(cy.UsageOptOut)
      }
    }
    render() {
      return w.createElement("div", {
        id: "configure-git"
      }, w.createElement("h1", {
        className: "welcome-title"
      }, "Configure Git"), w.createElement("p", {
        className: "welcome-text"
      }, "This is used to identify the commits you create. Anyone will be able to see this information if you publish commits."), w.createElement(sy, {
        accounts: this.props.accounts,
        onSave: this.continue,
        saveLabel: "Continue"
      }, w.createElement(jp, {
        onClick: this.cancel
      }, "Cancel")))
    }
  }
  class ly extends w.Component {
    constructor(e) {
      super(e), this.onChange = e => {
        const t = e.currentTarget.checked;
        this.setState({
          newOptOutValue: !t
        })
      }, this.cancel = () => {
        this.props.advance(cy.ConfigureGit)
      }, this.finish = () => {
        this.props.dispatcher.setStatsOptOut(this.state.newOptOutValue, !0), this.props.dispatcher.markUsageStatsNoteSeen(), this.props.done()
      }, this.state = {
        newOptOutValue: e.optOut
      }
    }
    render() {
      return w.createElement("div", {
        className: "usage-opt-out"
      }, w.createElement("h1", {
        className: "welcome-title"
      }, "Make GitHub Desktop better!"), w.createElement("p", null, "Would you like to help us improve GitHub Desktop by periodically submitting ", w.createElement(Ip, {
        uri: lh
      }, "usage stats"), "?"), w.createElement(Yg, {
        onSubmit: this.finish
      }, w.createElement(Lp, null, w.createElement(Xp, {
        label: "Yes, submit periodic usage stats",
        value: this.state.newOptOutValue ? Zp.Off : Zp.On,
        onChange: this.onChange
      })), w.createElement(Lp, {
        className: "actions"
      }, w.createElement(jp, {
        type: "submit"
      }, "Finish"), w.createElement(jp, {
        onClick: this.cancel
      }, "Cancel"))))
    }
  }
  var cy;
  ! function (e) {
    e.Start = "Start", e.SignInToDotComWithBrowser = "SignInToDotComWithBrowser", e.SignInToDotCom = "SignInToDotCom", e.SignInToEnterprise = "SignInToEnterprise", e.ConfigureGit = "ConfigureGit", e.UsageOptOut = "UsageOptOut"
  }(cy || (cy = {}));
  const uy = Mc(__dirname, "static/welcome-illustration-right.svg"),
    hy = Mc(__dirname, "static/welcome-illustration-left-top.svg"),
    py = Mc(__dirname, "static/welcome-illustration-left-bottom.svg");
  class dy extends w.Component {
    constructor(e) {
      super(e), this.dotComSupportsBasicAuthSubscription = null, this.onDotComSupportsBasicAuthUpdated = e => {
        this.setState({
          dotComSupportsBasicAuth: e
        })
      }, this.advanceToStep = e => {
        log.info("[Welcome] advancing to step: " + e), e === cy.SignInToDotCom ? this.props.dispatcher.beginDotComSignIn() : e === cy.SignInToEnterprise && this.props.dispatcher.beginEnterpriseSignIn(), this.setState({
          currentStep: e
        })
      }, this.done = () => {
        this.setState({
          exiting: !0
        }, () => {
          setTimeout(() => {
            this.props.dispatcher.endWelcomeFlow()
          }, 250)
        })
      }, this.state = {
        currentStep: cy.Start,
        exiting: !1,
        dotComSupportsBasicAuth: e.dispatcher.tryGetDotComSupportsBasicAuth()
      }
    }
    componentWillReceiveProps(e) {
      this.advanceOnSuccessfulSignIn(e)
    }
    componentDidMount() {
      this.props.dispatcher.recordWelcomeWizardInitiated(), this.dotComSupportsBasicAuthSubscription = this.props.dispatcher.onDotComSupportsBasicAuthUpdated(this.onDotComSupportsBasicAuthUpdated)
    }
    componentWillUnmount() {
      null !== this.dotComSupportsBasicAuthSubscription && (this.dotComSupportsBasicAuthSubscription.dispose(), this.dotComSupportsBasicAuthSubscription = null)
    }
    get inSignInStep() {
      return this.state.currentStep === cy.SignInToDotCom || (this.state.currentStep === cy.SignInToDotComWithBrowser || this.state.currentStep === cy.SignInToEnterprise)
    }
    advanceOnSuccessfulSignIn(e) {
      this.inSignInStep ? this.props.signInState ? e.signInState ? this.props.signInState.kind !== e.signInState.kind ? e.signInState.kind === Yu.Success && (this.advanceToStep(cy.ConfigureGit), this.props.dispatcher.resetSignInState()) : log.info(`[Welcome] kind ${this.props.signInState.kind} is the same as ${e.signInState.kind}. ignoring...`) : log.info("[Welcome] next sign in state not found. ignoring...") : log.info("[Welcome] current sign in state not found. ignoring...") : log.info("[Welcome] no sign in step found. ignoring...")
    }
    getComponentForCurrentStep() {
      const e = this.state.currentStep,
        t = this.props.signInState;
      switch (e) {
        case cy.Start:
        case cy.SignInToDotComWithBrowser:
          const n = e === cy.SignInToDotComWithBrowser && null !== t && t.kind === Yu.Authentication && t.loading;
          return w.createElement(Jg, {
            advance: this.advanceToStep,
            dispatcher: this.props.dispatcher,
            loadingBrowserAuth: n,
            dotComSupportsBasicAuth: this.state.dotComSupportsBasicAuth
          });
        case cy.SignInToDotCom:
          return w.createElement(ry, {
            dispatcher: this.props.dispatcher,
            advance: this.advanceToStep,
            signInState: t
          });
        case cy.SignInToEnterprise:
          return w.createElement(iy, {
            dispatcher: this.props.dispatcher,
            advance: this.advanceToStep,
            signInState: t
          });
        case cy.ConfigureGit:
          return w.createElement(ay, {
            advance: this.advanceToStep,
            accounts: this.props.accounts
          });
        case cy.UsageOptOut:
          return w.createElement(ly, {
            dispatcher: this.props.dispatcher,
            advance: this.advanceToStep,
            optOut: this.props.optOut,
            done: this.done
          });
        default:
          return X(0, "Unknown welcome step: " + e)
      }
    }
    render() {
      const e = mh()({
        exiting: this.state.exiting
      });
      return w.createElement(Qp, {
        id: "welcome",
        className: e
      }, w.createElement("div", {
        className: "welcome-left"
      }, w.createElement("div", {
        className: "welcome-content"
      }, this.getComponentForCurrentStep(), w.createElement("img", {
        className: "welcome-graphic-top",
        src: hy
      }), w.createElement("img", {
        className: "welcome-graphic-bottom",
        src: py
      }))), w.createElement("div", {
        className: "welcome-right"
      }, w.createElement("img", {
        className: "welcome-graphic",
        src: uy
      })))
    }
  }

  function fy(e) {
    return e.replace("&&", "&")
  }
  class my extends w.Component {
    shouldComponentUpdate(e) {
      return this.props.text !== e.text || this.props.highlight !== e.highlight
    }
    render() {
      const e = this.props.text.match(/^(.*?)?(?:&([^&]))(.*)?$/);
      if (!e) return w.createElement("span", null, this.props.text);
      const t = new Array;
      e[1] && t.push(w.createElement("span", {
        key: 1,
        "aria-hidden": !0
      }, fy(e[1])));
      const n = mh()("access-key", {
        highlight: this.props.highlight
      });
      t.push(w.createElement("span", {
        "aria-hidden": !0,
        key: 2,
        className: n
      }, e[2])), e[3] && t.push(w.createElement("span", {
        key: 3,
        "aria-hidden": !0
      }, fy(e[3])));
      const r = `${e[1]?fy(e[1]):""}${e[2]}${e[3]?fy(e[3]):""}`;
      return w.createElement("span", {
        "aria-label": r
      }, t)
    }
  }
  class gy extends w.Component {
    getIcon(e) {
      return "checkbox" === e.type && e.checked ? w.createElement(bh, {
        className: "icon",
        symbol: Sh.check
      }) : "radio" === e.type && e.checked ? w.createElement(bh, {
        className: "icon",
        symbol: Sh.primitiveDot
      }) : null
    }
    render() {
      const e = this.props.item;
      if ("separator" === e.type) return w.createElement("hr", null);
      const t = "submenuItem" === e.type && !1 !== this.props.renderSubMenuArrow ? w.createElement(bh, {
          className: "submenu-arrow",
          symbol: Sh.triangleRight
        }) : null,
        n = "submenuItem" !== e.type && e.accelerator && !1 !== this.props.renderAcceleratorText ? w.createElement("div", {
          className: "accelerator"
        }, function (e) {
          return e.split("+").map(nm).join("+")
        }(e.accelerator)) : null,
        r = mh()("menu-item", {
          disabled: !e.enabled
        }, {
          checkbox: "checkbox" === e.type
        }, {
          radio: "radio" === e.type
        }, {
          checked: ("checkbox" === e.type || "radio" === e.type) && e.checked
        });
      return w.createElement("div", {
        className: r
      }, this.getIcon(e), w.createElement("div", {
        className: "label"
      }, w.createElement(my, {
        text: e.label,
        highlight: this.props.highlightAccessKey
      })), n, t)
    }
  }

  function yy(e) {
    return e.reduce((e, t) => e + function (e) {
      if (!e.visible) return 0;
      return "separator" === e.type ? 10 : 30
    }(t), 0)
  }

  function vy(e) {
    const t = new Array,
      n = e.selectedItem;
    let r = -1;
    for (let i = 0; i < e.items.length; i++) {
      const o = e.items[i];
      o.visible && (t.push(o), o === n && (r = t.length - 1))
    }
    return {
      items: t,
      selectedIndex: r
    }
  }
  class wy extends w.Component {
    constructor(e) {
      super(e), this.list = null, this.onRowClick = (e, t) => {
        const n = this.state.items[e];
        "separator" !== n.type && n.enabled && this.props.onItemClicked(this.props.depth, n, t)
      }, this.onSelectedRowChanged = (e, t) => {
        const n = this.state.items[e];
        this.props.onSelectionChanged(this.props.depth, n, t)
      }, this.onKeyDown = e => {
        if (e.defaultPrevented) return;
        if (e.altKey || e.ctrlKey || e.metaKey) return;
        if (!this.props.enableAccessKeyNavigation) return;
        const t = Ri(e.key, this.state.items);
        t && Ti(t) && (e.preventDefault(), this.props.onSelectionChanged(this.props.depth, t, {
          kind: "keyboard",
          event: e
        }), this.props.onItemClicked(this.props.depth, t, {
          kind: "keyboard",
          event: e
        }))
      }, this.onRowKeyDown = (e, t) => {
        if (this.props.onItemKeyDown) {
          const n = this.state.items[e];
          this.props.onItemKeyDown(this.props.depth, n, t)
        }
      }, this.canSelectRow = e => Ti(this.state.items[e]), this.onListRef = e => {
        this.list = e
      }, this.onMouseEnter = e => {
        this.props.onMouseEnter && this.props.onMouseEnter(this.props.depth)
      }, this.renderMenuItem = e => {
        const t = this.state.items[e];
        return w.createElement(gy, {
          key: t.id,
          item: t,
          highlightAccessKey: this.props.enableAccessKeyNavigation
        })
      }, this.rowHeight = e => "separator" === this.state.items[e.index].type ? 10 : 30, this.state = vy(e)
    }
    componentWillReceiveProps(e) {
      if (this.props.items === e.items) {
        if (this.props.selectedItem !== e.selectedItem) {
          const r = (t = e.selectedItem, n = this.state.items, t ? n.findIndex(e => e.id === t.id) : -1);
          this.setState({
            selectedIndex: r
          })
        }
      } else this.setState(vy(e));
      var t, n
    }
    render() {
      const e = !0 === this.props.autoHeight ? {
          height: yy(this.props.items) + 5,
          maxHeight: "100%"
        } : {},
        t = mh()("menu-pane", this.props.className);
      return w.createElement("div", {
        className: t,
        onMouseEnter: this.onMouseEnter,
        onKeyDown: this.onKeyDown,
        style: e
      }, w.createElement(Pp, {
        ref: this.onListRef,
        rowCount: this.state.items.length,
        rowHeight: this.rowHeight,
        rowRenderer: this.renderMenuItem,
        selectedRows: [this.state.selectedIndex],
        onRowClick: this.onRowClick,
        onSelectedRowChanged: this.onSelectedRowChanged,
        canSelectRow: this.canSelectRow,
        onRowKeyDown: this.onRowKeyDown,
        invalidationProps: this.state.items,
        selectOnHover: !0,
        ariaMode: "menu"
      }))
    }
    focus() {
      this.list && this.list.focus()
    }
  }
  class by extends w.Component {
    constructor(e) {
      super(e), this.focusPane = -1, this.paneRefs = [], this.expandCollapseTimer = null, this.onItemClicked = (e, t, n) => {
        if (this.clearExpandCollapseTimer(), "submenuItem" === t.type) {
          const r = this.props.enableAccessKeyNavigation && "keyboard" === n.kind && "Enter" !== n.event.key && " " !== n.event.key;
          this.props.dispatcher.setAppMenuState(e => e.withOpenedMenu(t, r)), "keyboard" === n.kind && (this.focusPane = e + 1)
        } else "separator" !== t.type && (this.props.onClose({
          type: "item-executed"
        }), this.props.dispatcher.executeMenuItem(t))
      }, this.onItemKeyDown = (e, t, n) => {
        "ArrowLeft" === n.key || "Escape" === n.key ? (this.clearExpandCollapseTimer(), 0 === e && "Escape" === n.key ? (this.props.onClose({
          type: "keyboard",
          event: n
        }), n.preventDefault()) : e > 0 && (this.props.dispatcher.setAppMenuState(t => t.withClosedMenu(this.props.state[e])), this.focusPane = e - 1, n.preventDefault())) : "ArrowRight" === n.key && (this.clearExpandCollapseTimer(), "submenuItem" === t.type && (this.props.dispatcher.setAppMenuState(e => e.withOpenedMenu(t, !0)), this.focusPane = e + 1, n.preventDefault()))
      }, this.onSelectionChanged = (e, t, n) => {
        this.clearExpandCollapseTimer(), "keyboard" === n.kind ? this.props.dispatcher.setAppMenuState(n => n.withSelectedItem(t).withLastMenu(this.props.state[e])) : ("submenuItem" === t.type ? this.scheduleExpand(t) : this.scheduleCollapseTo(this.props.state[e]), this.props.dispatcher.setAppMenuState(e => e.withSelectedItem(t)))
      }, this.onMenuPaneRef = e => {
        e && (this.paneRefs[e.props.depth] = e)
      }, this.onPaneMouseEnter = e => {
        this.clearExpandCollapseTimer();
        const t = this.props.state[e],
          n = t.selectedItem;
        n ? this.props.dispatcher.setAppMenuState(e => e.withSelectedItem(n)) : this.props.dispatcher.setAppMenuState(e => e.withDeselectedMenu(t)), this.focusPane = e
      }, this.onKeyDown = e => {
        e.defaultPrevented || "Escape" !== e.key || (e.preventDefault(), this.props.onClose({
          type: "keyboard",
          event: e
        }))
      }, this.focusPane = e.state.length - 1, this.receiveProps(null, e)
    }
    receiveProps(e, t) {
      t.openedWithAccessKey && (e && e.openedWithAccessKey || (this.focusPane = t.state.length - 1))
    }
    clearExpandCollapseTimer() {
      this.expandCollapseTimer && (window.clearTimeout(this.expandCollapseTimer), this.expandCollapseTimer = null)
    }
    scheduleExpand(e) {
      this.clearExpandCollapseTimer(), this.expandCollapseTimer = window.setTimeout(() => {
        this.props.dispatcher.setAppMenuState(t => t.withOpenedMenu(e))
      }, 300)
    }
    scheduleCollapseTo(e) {
      this.clearExpandCollapseTimer(), this.expandCollapseTimer = window.setTimeout(() => {
        this.props.dispatcher.setAppMenuState(t => t.withLastMenu(e))
      }, 300)
    }
    renderMenuPane(e, t) {
      const n = t.id || "@",
        r = t.id ? function (e) {
          const t = e.replace(/^@\./, "").replace(/&/g, "").replace(/[^a-z0-9_]+/gi, "-").replace(/_+/, "_").toLowerCase();
          return t.length ? "menu-pane-" + t : void 0
        }(t.id) : void 0;
      return w.createElement(wy, {
        key: n,
        ref: this.onMenuPaneRef,
        className: r,
        autoHeight: this.props.autoHeight,
        depth: e,
        items: t.items,
        selectedItem: t.selectedItem,
        onItemClicked: this.onItemClicked,
        onMouseEnter: this.onPaneMouseEnter,
        onItemKeyDown: this.onItemKeyDown,
        onSelectionChanged: this.onSelectionChanged,
        enableAccessKeyNavigation: this.props.enableAccessKeyNavigation
      })
    }
    render() {
      const e = this.props.state.map((e, t) => this.renderMenuPane(t, e));
      return this.paneRefs = this.paneRefs.slice(0, e.length), w.createElement("div", {
        id: "app-menu-foldout",
        onKeyDown: this.onKeyDown
      }, e)
    }
    ensurePaneFocus() {
      if (this.focusPane >= 0) {
        const e = this.paneRefs[this.focusPane];
        e && (e.focus(), this.focusPane = -1)
      }
    }
    componentWillReceiveProps(e) {
      this.receiveProps(this.props, e)
    }
    componentDidMount() {
      this.ensurePaneFocus()
    }
    componentDidUpdate() {
      this.ensurePaneFocus()
    }
    componentWillUnmount() {
      this.clearExpandCollapseTimer()
    }
  }
  class Sy extends w.Component {
    constructor() {
      super(...arguments), this.innerDropDown = null, this.onDropDownRef = e => {
        this.innerDropDown = e
      }, this.onMouseEnter = e => {
        this.props.onMouseEnter(this.props.menuItem)
      }, this.onKeyDown = e => {
        e.defaultPrevented || (this.props.onKeyDown(this.props.menuItem, e), this.isMenuOpen || e.defaultPrevented || "ArrowDown" === e.key && (this.props.onOpen(this.props.menuItem, !0), e.preventDefault()))
      }, this.onMenuClose = e => {
        "keyboard" === e.type && "Escape" === e.event.key && this.focusButton(), this.props.onClose(this.props.menuItem, e.type)
      }, this.onDropdownStateChanged = (e, t) => {
        this.isMenuOpen ? this.props.onClose(this.props.menuItem, t) : this.props.onOpen(this.props.menuItem)
      }, this.dropDownContentRenderer = () => {
        const e = this.props.menuState;
        return this.isMenuOpen ? w.createElement(by, {
          dispatcher: this.props.dispatcher,
          onClose: this.onMenuClose,
          openedWithAccessKey: this.props.openedWithAccessKey,
          state: e,
          enableAccessKeyNavigation: this.props.enableAccessKeyNavigation,
          autoHeight: !0
        }) : null
      }
    }
    get isMenuOpen() {
      return 0 !== this.props.menuState.length
    }
    focusButton() {
      this.innerDropDown && this.innerDropDown.focusButton()
    }
    componentDidMount() {
      this.props.onDidMount && this.props.onDidMount(this.props.menuItem, this)
    }
    componentWillUnmount() {
      this.props.onWillUnmount && this.props.onWillUnmount(this.props.menuItem, this)
    }
    render() {
      const e = this.props.menuItem,
        t = this.isMenuOpen ? "open" : "closed";
      return w.createElement(zg, {
        ref: this.onDropDownRef,
        key: e.id,
        dropdownState: t,
        onDropdownStateChanged: this.onDropdownStateChanged,
        dropdownContentRenderer: this.dropDownContentRenderer,
        showDisclosureArrow: !1,
        onMouseEnter: this.onMouseEnter,
        onKeyDown: this.onKeyDown,
        tabIndex: -1,
        role: "menuitem"
      }, w.createElement(gy, {
        item: e,
        highlightAccessKey: this.props.highlightMenuAccessKey,
        renderAcceleratorText: !1,
        renderSubMenuArrow: !1
      }))
    }
  }

  function Cy(e) {
    if (!e.appMenu.length) return {
      menuItems: []
    };
    const t = e.appMenu[0].items,
      n = new Array;
    for (const e of t) "submenuItem" === e.type && e.visible && n.push(e);
    return {
      menuItems: n
    }
  }
  class Ey extends w.Component {
    constructor(e) {
      super(e), this.menuBar = null, this.menuButtonRefsByMenuItemId = {}, this.focusOutTimeout = null, this.hasFocus = !1, this.stolenFocusElement = null, this.onMenuBarFocusIn = e => {
        const t = e;
        this.hasFocus || (t.relatedTarget && t.relatedTarget instanceof HTMLElement ? this.stolenFocusElement = t.relatedTarget : this.stolenFocusElement = null, this.hasFocus = !0), this.clearFocusOutTimeout()
      }, this.onMenuBarFocusOut = e => {
        this.clearFocusOutTimeout(), this.focusOutTimeout = requestAnimationFrame(this.onLostFocusWithin)
      }, this.onLostFocusWithin = () => {
        this.hasFocus = !1, this.focusOutTimeout = null, this.props.onLostFocus && this.props.onLostFocus(), this.stolenFocusElement = null
      }, this.onMenuBarRef = e => {
        this.menuBar && (this.menuBar.removeEventListener("focusin", this.onMenuBarFocusIn), this.menuBar.removeEventListener("focusout", this.onMenuBarFocusOut)), this.menuBar = e, this.menuBar && (this.menuBar.addEventListener("focusin", this.onMenuBarFocusIn), this.menuBar.addEventListener("focusout", this.onMenuBarFocusOut))
      }, this.onMenuClose = (e, t) => {
        "pointer" !== t && "item-executed" !== t || this.restoreFocusOrBlur(), this.props.dispatcher.setAppMenuState(t => t.withClosedMenu(e.menu))
      }, this.onMenuOpen = (e, t) => {
        const n = !!this.props.foldoutState && this.props.foldoutState.enableAccessKeyNavigation;
        this.props.dispatcher.showFoldout({
          type: V.AppMenu,
          enableAccessKeyNavigation: n
        }), this.props.dispatcher.setAppMenuState(n => n.withOpenedMenu(e, t))
      }, this.onMenuButtonMouseEnter = e => {
        this.hasFocus && this.focusMenuItem(e), this.props.appMenu.length > 1 && this.props.dispatcher.setAppMenuState(t => t.withOpenedMenu(e))
      }, this.onMenuButtonKeyDown = (e, t) => {
        if (t.defaultPrevented) return;
        const n = this.props.foldoutState;
        if (n)
          if ("Escape" === t.key) this.isMenuItemOpen(e) || (this.restoreFocusOrBlur(), t.preventDefault());
          else if ("ArrowLeft" === t.key) this.moveToAdjacentMenu("previous", e), t.preventDefault();
        else if ("ArrowRight" === t.key) this.moveToAdjacentMenu("next", e), t.preventDefault();
        else if (n.enableAccessKeyNavigation) {
          if (t.altKey || t.ctrlKey || t.metaKey) return;
          const e = Ri(t.key, this.state.menuItems);
          e && Ti(e) && ("submenuItem" === e.type ? this.props.dispatcher.setAppMenuState(t => t.withReset().withSelectedItem(e).withOpenedMenu(e, !0)) : (this.restoreFocusOrBlur(), this.props.dispatcher.executeMenuItem(e)), t.preventDefault())
        }
      }, this.onMenuButtonDidMount = (e, t) => {
        this.menuButtonRefsByMenuItemId[e.id] = t
      }, this.onMenuButtonWillUnmount = (e, t) => {
        delete this.menuButtonRefsByMenuItemId[e.id]
      }, this.state = Cy(e)
    }
    componentWillReceiveProps(e) {
      e.appMenu !== this.props.appMenu && this.setState(Cy(e))
    }
    componentDidUpdate(e) {
      this.props.foldoutState && !e.foldoutState ? 1 !== this.props.appMenu.length || this.hasFocus || this.focusFirstMenuItem() : !this.props.foldoutState && e.foldoutState && this.restoreFocusOrBlur()
    }
    componentDidMount() {
      this.props.foldoutState && 1 === this.props.appMenu.length && this.focusFirstMenuItem()
    }
    componentWillUnmount() {
      this.hasFocus && this.restoreFocusOrBlur(), this.stolenFocusElement = null
    }
    render() {
      return w.createElement("div", {
        id: "app-menu-bar",
        ref: this.onMenuBarRef,
        role: "menubar",
        "aria-label": "Application menu"
      }, this.state.menuItems.map(this.renderMenuItem, this))
    }
    isMenuItemOpen(e) {
      const t = this.props.foldoutState && this.props.appMenu.length > 1 ? this.props.appMenu[1] : null;
      return null !== t && t.id === e.id
    }
    focusFirstMenuItem() {
      if (this.props.appMenu.length > 1) return;
      const e = this.state.menuItems;
      if (!e.length) return;
      const t = e[0];
      t && this.focusMenuItem(t)
    }
    focusMenuItem(e) {
      const t = this.menuButtonRefsByMenuItemId[e.id];
      t && t.focusButton()
    }
    restoreFocusOrBlur() {
      this.hasFocus && (this.stolenFocusElement && document.contains(this.stolenFocusElement) ? this.stolenFocusElement.focus() : document.activeElement instanceof HTMLElement && document.activeElement.blur(), this.stolenFocusElement = null)
    }
    clearFocusOutTimeout() {
      null !== this.focusOutTimeout && (cancelAnimationFrame(this.focusOutTimeout), this.focusOutTimeout = null)
    }
    moveToAdjacentMenu(e, t) {
      const n = this.state.menuItems,
        r = n.findIndex(e => e.id === t.id);
      if (-1 === r) return;
      const i = n[(r + ("next" === e ? 1 : -1) + n.length) % n.length];
      if (!i) return;
      if (null !== this.props.foldoutState && this.props.appMenu.length > 1) this.props.dispatcher.setAppMenuState(e => e.withOpenedMenu(i, !0));
      else {
        const e = this.menuButtonRefsByMenuItemId[i.id];
        e && e.focusButton()
      }
    }
    renderMenuItem(e) {
      const t = this.props.foldoutState,
        n = this.isMenuItemOpen(e) ? this.props.appMenu.slice(1) : [],
        r = t && t.openedWithAccessKey || !1,
        i = !!t && t.enableAccessKeyNavigation,
        o = this.props.highlightAppMenuAccessKeys || !this.isMenuItemOpen(e) && i;
      return w.createElement(Sy, {
        key: e.id,
        dispatcher: this.props.dispatcher,
        menuItem: e,
        menuState: n,
        highlightMenuAccessKey: o,
        enableAccessKeyNavigation: i,
        openedWithAccessKey: r,
        onClose: this.onMenuClose,
        onOpen: this.onMenuOpen,
        onMouseEnter: this.onMenuButtonMouseEnter,
        onKeyDown: this.onMenuButtonKeyDown,
        onDidMount: this.onMenuButtonDidMount,
        onWillUnmount: this.onMenuButtonWillUnmount
      })
    }
  }
  class ky extends w.Component {
    constructor() {
      super(...arguments), this.timeoutId = null, this.componentDidMount = () => {
        void 0 !== this.props.timeout && (this.timeoutId = window.setTimeout(() => {
          this.props.onDismissed()
        }, this.props.timeout))
      }, this.componentWillUnmount = () => {
        void 0 !== this.props.timeout && null !== this.timeoutId && window.clearTimeout(this.timeoutId)
      }
    }
    render() {
      return w.createElement("div", {
        id: this.props.id,
        className: "banner"
      }, w.createElement("div", {
        className: "contents"
      }, this.props.children), this.renderCloseButton())
    }
    renderCloseButton() {
      const {
        dismissable: e
      } = this.props;
      return void 0 === e || !1 === e ? null : w.createElement("div", {
        className: "close"
      }, w.createElement("a", {
        onClick: this.props.onDismissed
      }, w.createElement(bh, {
        symbol: Sh.x
      })))
    }
  }
  const xy = "https://desktop.github.com/release-notes/";
  class Ty extends w.Component {
    constructor() {
      super(...arguments), this.showReleaseNotes = () => {
        null == this.props.newRelease ? ee.openExternal(xy) : this.props.dispatcher.showPopup({
          type: Zi.ReleaseNotes,
          newRelease: this.props.newRelease
        })
      }, this.updateNow = () => {
        ke.quitAndInstallUpdate()
      }
    }
    render() {
      return w.createElement(ky, {
        id: "update-available",
        onDismissed: this.props.onDismissed
      }, w.createElement(bh, {
        className: "download-icon",
        symbol: Sh.desktopDownload
      }), w.createElement("span", {
        onSubmit: this.updateNow
      }, "An updated version of GitHub Desktop is available and will be installed at the next launch. See", " ", w.createElement(Ip, {
        onClick: this.showReleaseNotes
      }, "what's new"), " or", " ", w.createElement(Ip, {
        onClick: this.updateNow
      }, "restart GitHub Desktop"), "."))
    }
  }
  class Ry extends w.Component {
    constructor() {
      super(...arguments), this.openDialog = () => {
        this.props.onDismissed(), this.props.dispatcher.showPopup(this.props.popup), this.props.dispatcher.recordMergeConflictsDialogReopened()
      }
    }
    render() {
      return w.createElement(ky, {
        id: "merge-conflicts-banner",
        dismissable: !1,
        onDismissed: this.props.onDismissed
      }, w.createElement(bh, {
        className: "alert-icon",
        symbol: Sh.alert
      }), w.createElement("div", {
        className: "banner-message"
      }, w.createElement("span", null, "Resolve conflicts and commit to merge into", " ", w.createElement("strong", null, this.props.ourBranch), "."), w.createElement(Ip, {
        onClick: this.openDialog
      }, "View conflicts")))
    }
  }

  function Dy({
    ourBranch: e,
    theirBranch: t,
    onDismissed: n
  }) {
    const r = void 0 !== t ? w.createElement("span", null, "Successfully merged ", w.createElement("strong", null, t), " into ", w.createElement("strong", null, e)) : w.createElement("span", null, "Successfully merged into ", w.createElement("strong", null, e));
    return w.createElement(ky, {
      id: "successful-merge",
      timeout: 5e3,
      onDismissed: n
    }, w.createElement("div", {
      className: "green-circle"
    }, w.createElement(bh, {
      className: "check-icon",
      symbol: Sh.check
    })), w.createElement("div", {
      className: "banner-message"
    }, r))
  }
  class _y extends w.Component {
    constructor() {
      super(...arguments), this.openDialog = async () => {
        this.props.onDismissed(), this.props.onOpenDialog(), this.props.dispatcher.recordRebaseConflictsDialogReopened()
      }, this.onDismissed = () => {
        log.warn("[RebaseConflictsBanner] this is not dismissable by default unless the user clicks on the link")
      }
    }
    render() {
      return w.createElement(ky, {
        id: "rebase-conflicts-banner",
        dismissable: !1,
        onDismissed: this.onDismissed
      }, w.createElement(bh, {
        className: "alert-icon",
        symbol: Sh.alert
      }), w.createElement("div", {
        className: "banner-message"
      }, w.createElement("span", null, "Resolve conflicts to continue rebasing", " ", w.createElement("strong", null, this.props.targetBranch), "."), w.createElement(Ip, {
        onClick: this.openDialog
      }, "View conflicts")))
    }
  }

  function Ay({
    baseBranch: e,
    targetBranch: t,
    onDismissed: n
  }) {
    const r = void 0 !== e ? w.createElement("span", null, "Successfully rebased ", w.createElement("strong", null, t), " onto ", w.createElement("strong", null, e)) : w.createElement("span", null, "Successfully rebased ", w.createElement("strong", null, t));
    return w.createElement(ky, {
      id: "successful-rebase",
      timeout: 5e3,
      onDismissed: n
    }, w.createElement("div", {
      className: "green-circle"
    }, w.createElement(bh, {
      className: "check-icon",
      symbol: Sh.check
    })), w.createElement("div", {
      className: "banner-message"
    }, r))
  }
  class My extends w.Component {
    constructor() {
      super(...arguments), this.onClick = e => {
        e.preventDefault(), this.props.onAction()
      }
    }
    render() {
      return w.createElement(Lp, {
        className: "call-to-action"
      }, this.props.children, w.createElement(jp, {
        className: "action-button",
        type: "submit",
        onClick: this.onClick
      }, this.props.actionTitle))
    }
  }
  var Py;
  ! function (e) {
    e[e.DotCom = 0] = "DotCom", e[e.Enterprise = 1] = "Enterprise"
  }(Py || (Py = {}));
  class Iy extends w.Component {
    constructor() {
      super(...arguments), this.onDotComSignIn = () => {
        this.props.onDotComSignIn()
      }, this.onEnterpriseSignIn = () => {
        this.props.onEnterpriseSignIn()
      }, this.logout = e => () => {
        this.props.onLogout(e)
      }
    }
    render() {
      return w.createElement(Mm, {
        className: "accounts-tab"
      }, w.createElement("h2", null, "GitHub.com"), this.props.dotComAccount ? this.renderAccount(this.props.dotComAccount) : this.renderSignIn(Py.DotCom), w.createElement("h2", null, "GitHub Enterprise Server"), this.props.enterpriseAccount ? this.renderAccount(this.props.enterpriseAccount) : this.renderSignIn(Py.Enterprise))
    }
    renderAccount(e) {
      const t = {
        name: e.name,
        email: Pu(e),
        avatarURL: e.avatarURL,
        endpoint: e.endpoint
      };
      return w.createElement(Lp, {
        className: "account-info"
      }, w.createElement(dd, {
        user: t
      }), w.createElement("div", {
        className: "user-info"
      }, w.createElement("div", {
        className: "name"
      }, e.name), w.createElement("div", {
        className: "login"
      }, "@", e.login)), w.createElement(jp, {
        onClick: this.logout(e)
      }, "退出"))
    }
    renderSignIn(e) {
      switch (e) {
        case Py.DotCom:
          return w.createElement(My, {
            actionTitle: "登录",
            onAction: this.onDotComSignIn
          }, w.createElement("div", null, "登录到您的GitHub.com网站访问存储库的帐户."));
        case Py.Enterprise:
          return w.createElement(My, {
            actionTitle: "登录",
            onAction: this.onEnterpriseSignIn
          }, w.createElement("div", null, "如果您有一个GitHub企业服务器帐户正在工作，请登录该帐户以访问您的存储库."));
        default:
          return X(0, "Unknown sign in type: " + e)
      }
    }
  }
  class Oy extends w.Component {
    constructor(e) {
      super(e), this.onSelected = e => {
        this.props.onSelected(this.props.value, e)
      }, this.state = {
        inputId: vh("RadioButton_" + this.props.value)
      }
    }
    componentWillUnmount() {
      wh(this.state.inputId)
    }
    render() {
      return w.createElement("div", {
        className: "radio-button-component"
      }, w.createElement("input", {
        type: "radio",
        id: this.state.inputId,
        value: this.props.value,
        checked: this.props.checked,
        onChange: this.onSelected
      }), w.createElement("label", {
        htmlFor: this.state.inputId
      }, this.props.label))
    }
  }
  class Ly extends w.Component {
    constructor(e) {
      super(e), this.onReportingOptOutChanged = e => {
        const t = !e.currentTarget.checked;
        this.setState({
          optOutOfUsageTracking: t
        }), this.props.onOptOutofReportingchanged(t)
      }, this.onConfirmDiscardChangesChanged = e => {
        const t = e.currentTarget.checked;
        this.setState({
          confirmDiscardChanges: t
        }), this.props.onConfirmDiscardChangesChanged(t)
      }, this.onConfirmForcePushChanged = e => {
        const t = e.currentTarget.checked;
        this.setState({
          confirmForcePush: t
        }), this.props.onConfirmForcePushChanged(t)
      }, this.onConfirmRepositoryRemovalChanged = e => {
        const t = e.currentTarget.checked;
        this.setState({
          confirmRepositoryRemoval: t
        }), this.props.onConfirmRepositoryRemovalChanged(t)
      }, this.onUncommittedChangesStrategyKindChanged = e => {
        this.setState({
          uncommittedChangesStrategyKind: e
        }), this.props.onUncommittedChangesStrategyKindChanged(e)
      }, this.onSchannelCheckRevokeChanged = e => {
        const t = e.currentTarget.checked;
        this.props.onSchannelCheckRevokeChanged(!1 === t)
      }, this.state = {
        optOutOfUsageTracking: this.props.optOutOfUsageTracking,
        confirmRepositoryRemoval: this.props.confirmRepositoryRemoval,
        confirmDiscardChanges: this.props.confirmDiscardChanges,
        confirmForcePush: this.props.confirmForcePush,
        uncommittedChangesStrategyKind: this.props.uncommittedChangesStrategyKind
      }
    }
    reportDesktopUsageLabel() {
      return w.createElement("span", null, "帮助 GitHub Desktop 改进，提交", " ", w.createElement(Ip, {
        uri: lh
      }, "使用情况统计"))
    }
    render() {
      return w.createElement(Mm, null, w.createElement("div", {
        className: "advanced-section"
      }, w.createElement("h2", null, "如果我已经改动了文件，又要切换分支..."), w.createElement(Oy, {
        value: cu.AskForConfirmation,
        checked: this.state.uncommittedChangesStrategyKind === cu.AskForConfirmation,
        label: "询问我想要如何保留改动",
        onSelected: this.onUncommittedChangesStrategyKindChanged
      }), w.createElement(Oy, {
        value: cu.MoveToNewBranch,
        checked: this.state.uncommittedChangesStrategyKind === cu.MoveToNewBranch,
        label: "总是把我的改动代入新分支",
        onSelected: this.onUncommittedChangesStrategyKindChanged
      }), w.createElement(Oy, {
        value: cu.StashOnCurrentBranch,
        checked: this.state.uncommittedChangesStrategyKind === cu.StashOnCurrentBranch,
        label: "总是贮藏并保留改动到当前分支",
        onSelected: this.onUncommittedChangesStrategyKindChanged
      })), w.createElement("div", {
        className: "advanced-section"
      }, w.createElement("h2", null, "显示确认对话框于..."), w.createElement(Xp, {
        label: "删除存储库之前",
        value: this.state.confirmRepositoryRemoval ? Zp.On : Zp.Off,
        onChange: this.onConfirmRepositoryRemovalChanged
      }), w.createElement(Xp, {
        label: "放弃更改之前",
        value: this.state.confirmDiscardChanges ? Zp.On : Zp.Off,
        onChange: this.onConfirmDiscardChangesChanged
      }), w.createElement(Xp, {
        label: "强制推送之前",
        value: this.state.confirmForcePush ? Zp.On : Zp.Off,
        onChange: this.onConfirmForcePushChanged
      })), w.createElement("div", {
        className: "advanced-section"
      }, w.createElement("h2", null, "用途"), w.createElement(Xp, {
        label: this.reportDesktopUsageLabel(),
        value: this.state.optOutOfUsageTracking ? Zp.Off : Zp.On,
        onChange: this.onReportingOptOutChanged
      })), this.renderGitAdvancedSection())
    }
    renderGitAdvancedSection() {
      if (null !== this.props.schannelCheckRevoke) return w.createElement("div", {
        className: "git-advanced-section"
      }, w.createElement("h2", null, "Git"), w.createElement(Xp, {
        label: "禁用证书撤销检查",
        value: this.props.schannelCheckRevoke ? Zp.Off : Zp.On,
        onChange: this.onSchannelCheckRevokeChanged
      }))
    }
  }
  class Ny extends w.Component {
    constructor(e) {
      super(e), this.defaultBranchInputRef = w.createRef(), this.renderWarningMessage = (e, t) => "" === e ? w.createElement(w.Fragment, null, w.createElement(lm, null, t), " is an invalid branch name.") : w.createElement(w.Fragment, null, "Will be saved as ", w.createElement(lm, null, e), "."), this.onDefaultBranchChanged = e => {
        this.setState({
          defaultBranchIsOther: !eu.includes(e)
        }), this.props.onDefaultBranchChanged(e)
      }, this.state = {
        defaultBranchIsOther: !eu.includes(this.props.defaultBranch)
      }
    }
    componentDidUpdate(e) {
      this.props.defaultBranch !== e.defaultBranch && "" === this.props.defaultBranch && null !== this.defaultBranchInputRef.current && this.defaultBranchInputRef.current.focus()
    }
    render() {
      return w.createElement(Mm, null, w.createElement(Lp, null, w.createElement(Op, {
        label: "用户名",
        value: this.props.name,
        onValueChanged: this.props.onNameChanged
      })), w.createElement(Lp, null, w.createElement(Op, {
        label: "邮箱",
        value: this.props.email,
        onValueChanged: this.props.onEmailChanged
      })), this.renderDefaultBranchSetting())
    }
    renderDefaultBranchSetting() {
      if (!Ys()) return null;
      const {
        defaultBranchIsOther: e
      } = this.state;
      return w.createElement("div", {
        className: "default-branch-component"
      }, w.createElement("h2", null, "新存储库的默认分支"), eu.map(t => w.createElement(Oy, {
        key: t,
        checked: !e && this.props.defaultBranch === t,
        value: t,
        label: t,
        onSelected: this.onDefaultBranchChanged
      })), w.createElement(Oy, {
        key: "",
        checked: e,
        value: "",
        label: "其他…",
        onSelected: this.onDefaultBranchChanged
      }), e && w.createElement(Ig, {
        initialValue: this.props.defaultBranch,
        renderWarningMessage: this.renderWarningMessage,
        onValueChange: this.props.onDefaultBranchChanged,
        ref: this.defaultBranchInputRef
      }), w.createElement("p", {
        className: "git-settings-description"
      }, "These preferences will edit your global Git config."))
    }
  }
  const Fy = /^[\x00-\x20.,:;<>"\\']+$/;
  class By extends w.Component {
    constructor() {
      super(...arguments), this.onClick = () => {
        this.props.onClick(this.props.value)
      }
    }
    render() {
      const e = this.props.description ? w.createElement("p", null, this.props.description) : void 0,
        t = this.props.isSelected,
        n = t ? "selected" : void 0;
      return w.createElement("li", {
        className: n,
        onClick: this.onClick,
        role: "radio",
        id: this.props.id,
        "aria-checked": t ? "true" : "false"
      }, w.createElement("div", {
        className: "title"
      }, this.props.title), e)
    }
  }
  class Hy extends w.Component {
    constructor(e) {
      super(e), this.listRef = null, this.formRef = null, this.onItemClick = e => {
        e !== this.props.selectedKey && this.props.onSelectionChanged(e)
      }, this.onKeyDown = e => {
        const t = this.findSelectedIndex(this.props.items);
        if ("ArrowUp" === e.key) t > 0 && this.props.onSelectionChanged(this.props.items[t - 1].key), e.preventDefault();
        else if ("ArrowDown" === e.key) t < this.props.items.length - 1 && this.props.onSelectionChanged(this.props.items[t + 1].key), e.preventDefault();
        else if ("Enter" === e.key) {
          const e = this.formRef;
          e && e.dispatchEvent(new Event("submit"))
        }
      }, this.onListRef = e => {
        this.listRef = e
      }, this.onFieldsetRef = e => {
        this.formRef = e ? e.form : null
      }, this.onLegendClick = () => {
        this.listRef && this.listRef.focus()
      }, this.state = {}
    }
    updateListId(e) {
      this.state.listId && (wh(this.state.listId), this.setState({
        listId: void 0
      })), e && this.setState({
        listId: vh("VerticalSegmentedControl_" + e)
      })
    }
    componentWillMount() {
      this.updateListId(this.props.label)
    }
    componentWillUnmount() {
      this.state.listId && wh(this.state.listId)
    }
    componentWillReceiveProps(e) {
      this.props.label !== e.label && this.updateListId(e.label)
    }
    getListItemId(e) {
      return `${this.state.listId}_Item_${e}`
    }
    renderItem(e, t) {
      return w.createElement(By, {
        id: this.getListItemId(t),
        key: e.key,
        title: e.title,
        description: e.description,
        isSelected: e.key === this.props.selectedKey,
        value: e.key,
        onClick: this.onItemClick
      })
    }
    render() {
      if (0 === this.props.items.length) return null;
      const e = this.props.label ? w.createElement("legend", {
          onClick: this.onLegendClick
        }, this.props.label) : void 0,
        t = this.findSelectedIndex(this.props.items),
        n = this.getListItemId(t);
      return w.createElement("fieldset", {
        className: "vertical-segmented-control",
        ref: this.onFieldsetRef
      }, e, w.createElement("ul", {
        ref: this.onListRef,
        id: this.state.listId,
        className: "vertical-segmented-control",
        tabIndex: 0,
        onKeyDown: this.onKeyDown,
        role: "radiogroup",
        "aria-activedescendant": n
      }, this.props.items.map((e, t) => this.renderItem(e, t))))
    }
    findSelectedIndex(e) {
      return e.findIndex(e => e.key === this.props.selectedKey)
    }
  }
  const zy = [{
    title: "Light",
    description: "GitHub桌面的默认主题",
    key: pi.Light
  }, {
    title: "Dark",
    description: "GitHub桌面也适合你，夜猫子",
    key: pi.Dark
  }];
  class Uy extends w.Component {
    constructor() {
      super(...arguments), this.onSelectedThemeChanged = e => {
        this.props.onSelectedThemeChanged(e), this.props.onAutomaticallySwitchThemeChanged(!1)
      }, this.onAutomaticallySwitchThemeChanged = e => {
        const t = e.currentTarget.checked;
        t && this.onSelectedThemeChanged(fo() ? pi.Dark : pi.Light), this.props.onAutomaticallySwitchThemeChanged(t)
      }
    }
    render() {
      return w.createElement(Mm, null, this.renderThemeOptions(), this.renderAutoSwitcherOption())
    }
    renderThemeOptions() {
      return w.createElement(Lp, null, w.createElement(Hy, {
        items: zy,
        selectedKey: this.props.selectedTheme,
        onSelectionChanged: this.onSelectedThemeChanged
      }))
    }
    renderAutoSwitcherOption() {
      return po() ? w.createElement(Lp, null, w.createElement(Xp, {
        label: "自动切换主题以匹配系统主题.",
        value: this.props.automaticallySwitchTheme ? Zp.On : Zp.Off,
        onChange: this.onAutomaticallySwitchThemeChanged
      })) : null
    }
  }
  class Wy extends w.Component {
    componentWillMount() {
      const e = vh("Select_" + (this.props.label || "unknown"));
      this.setState({
        inputId: e
      })
    }
    componentWillUnmount() {
      this.state.inputId && wh(this.state.inputId)
    }
    renderLabel() {
      const e = this.props.label,
        t = this.state.inputId;
      return e ? w.createElement("label", {
        htmlFor: t
      }, e) : null
    }
    render() {
      return w.createElement("div", {
        className: "select-component"
      }, this.renderLabel(), w.createElement("select", {
        id: this.state.inputId,
        onChange: this.props.onChange,
        value: this.props.value,
        defaultValue: this.props.defaultValue
      }, this.props.children))
    }
  }
  class Vy extends w.Component {
    constructor(e) {
      super(e), this.onSelectedEditorChanged = e => {
        const t = Co(e.currentTarget.value);
        t && (this.setState({
          selectedExternalEditor: t
        }), this.props.onSelectedEditorChanged(t))
      }, this.onSelectedShellChanged = e => {
        const t = dc(e.currentTarget.value);
        this.setState({
          selectedShell: t
        }), this.props.onSelectedShellChanged(t)
      }, this.state = {
        selectedExternalEditor: this.props.selectedExternalEditor,
        selectedShell: this.props.selectedShell
      }
    }
    async componentWillReceiveProps(e) {
      const t = e.availableEditors;
      let n = e.selectedExternalEditor;
      if (t.length) {
        -1 === (n ? t.indexOf(n) : -1) && (n = t[0], e.onSelectedEditorChanged(n))
      }
      const r = e.availableShells;
      let i = e.selectedShell;
      if (r.length) {
        -1 === r.indexOf(i) && (i = r[0], e.onSelectedShellChanged(i))
      }
      this.setState({
        selectedExternalEditor: n,
        selectedShell: i
      })
    }
    renderExternalEditor() {
      const e = this.props.availableEditors,
        t = this.state.selectedExternalEditor;
      return 0 === e.length ? w.createElement("div", {
        className: "select-component no-options-found"
      }, w.createElement("label", null, "External editor"), w.createElement("span", null, "No editors found.", " ", w.createElement(Ip, {
        uri: "https://atom.io/"
      }, "Install Atom?"))) : w.createElement(Wy, {
        label: "外部编辑器",
        value: t || void 0,
        onChange: this.onSelectedEditorChanged
      }, e.map(e => w.createElement("option", {
        key: e,
        value: e
      }, e)))
    }
    renderSelectedShell() {
      const e = this.props.availableShells;
      return w.createElement(Wy, {
        label: "Shell",
        value: this.state.selectedShell,
        onChange: this.onSelectedShellChanged
      }, e.map(e => w.createElement("option", {
        key: e,
        value: e
      }, e)))
    }
    render() {
      return w.createElement(Mm, null, w.createElement("h2", null, "应用"), w.createElement(Lp, null, this.renderExternalEditor()), w.createElement(Lp, null, this.renderSelectedShell()))
    }
  }
  class jy extends w.Component {
    constructor(e) {
      super(e), this.onDotComSignIn = () => {
        this.props.onDismissed(), this.props.dispatcher.showDotComSignInDialog()
      }, this.onEnterpriseSignIn = () => {
        this.props.onDismissed(), this.props.dispatcher.showEnterpriseSignInDialog()
      }, this.onLogout = e => {
        this.props.dispatcher.removeAccount(e)
      }, this.onLockFileDeleted = () => {
        this.setState({
          existingLockFilePath: void 0
        })
      }, this.onLockFileDeleteError = e => {
        this.props.dispatcher.postError(e)
      }, this.onOptOutofReportingChanged = e => {
        this.setState({
          optOutOfUsageTracking: e
        })
      }, this.onConfirmRepositoryRemovalChanged = e => {
        this.setState({
          confirmRepositoryRemoval: e
        })
      }, this.onConfirmDiscardChangesChanged = e => {
        this.setState({
          confirmDiscardChanges: e
        })
      }, this.onConfirmForcePushChanged = e => {
        this.setState({
          confirmForcePush: e
        })
      }, this.onUncommittedChangesStrategyKindChanged = e => {
        this.setState({
          uncommittedChangesStrategyKind: e
        })
      }, this.onCommitterNameChanged = e => {
        var t;
        this.setState({
          committerName: e,
          disallowedCharactersMessage: (t = e, Fy.test(t) ? "Name is invalid, it consists only of disallowed characters." : null)
        })
      }, this.onCommitterEmailChanged = e => {
        this.setState({
          committerEmail: e
        })
      }, this.onDefaultBranchChanged = e => {
        this.setState({
          defaultBranch: e
        })
      }, this.onSelectedEditorChanged = e => {
        this.setState({
          selectedExternalEditor: e
        })
      }, this.onSelectedShellChanged = e => {
        this.setState({
          selectedShell: e
        })
      }, this.onSelectedThemeChanged = e => {
        this.props.dispatcher.setSelectedTheme(e)
      }, this.onAutomaticallySwitchThemeChanged = e => {
        this.props.dispatcher.onAutomaticallySwitchThemeChanged(e)
      }, this.onSchannelCheckRevokeChanged = e => {
        this.setState({
          schannelCheckRevoke: e
        })
      }, this.onSave = async () => {
        try {
          this.state.committerName !== this.state.initialCommitterName && await Oo("user.name", this.state.committerName), this.state.committerEmail !== this.state.initialCommitterEmail && await Oo("user.email", this.state.committerEmail), this.state.defaultBranch.length > 0 && this.state.defaultBranch !== this.state.initialDefaultBranch && await async function (e) {
            return Oo("init.defaultBranch", e)
          }(this.state.defaultBranch), this.state.schannelCheckRevoke !== this.state.initialSchannelCheckRevoke && null !== this.state.schannelCheckRevoke && await Oo("http.schannelCheckRevoke", this.state.schannelCheckRevoke.toString())
        } catch (e) {
          if (zo(e)) {
            const t = Wo(e.result);
            if (null !== t) return void this.setState({
              existingLockFilePath: t,
              selectedIndex: dh.Git
            })
          }
          return this.props.onDismissed(), void this.props.dispatcher.postError(e)
        }
        await this.props.dispatcher.setStatsOptOut(this.state.optOutOfUsageTracking, !1), await this.props.dispatcher.setConfirmRepoRemovalSetting(this.state.confirmRepositoryRemoval), await this.props.dispatcher.setConfirmForcePushSetting(this.state.confirmForcePush), this.state.selectedExternalEditor && await this.props.dispatcher.setExternalEditor(this.state.selectedExternalEditor), await this.props.dispatcher.setShell(this.state.selectedShell), await this.props.dispatcher.setConfirmDiscardChangesSetting(this.state.confirmDiscardChanges), await this.props.dispatcher.setUncommittedChangesStrategyKindSetting(this.state.uncommittedChangesStrategyKind), this.props.onDismissed()
      }, this.onTabClicked = e => {
        this.setState({
          selectedIndex: e
        })
      }, this.state = {
        selectedIndex: this.props.initialSelectedTab || dh.Accounts,
        committerName: "",
        committerEmail: "",
        defaultBranch: "",
        initialCommitterName: null,
        initialCommitterEmail: null,
        initialDefaultBranch: null,
        disallowedCharactersMessage: null,
        availableEditors: [],
        optOutOfUsageTracking: !1,
        confirmRepositoryRemoval: !1,
        confirmDiscardChanges: !1,
        confirmForcePush: !1,
        uncommittedChangesStrategyKind: uu,
        selectedExternalEditor: this.props.selectedExternalEditor,
        availableShells: [],
        selectedShell: this.props.selectedShell,
        initialSchannelCheckRevoke: null,
        schannelCheckRevoke: null
      }
    }
    async componentWillMount() {
      const e = await Io("user.name"),
        t = await Io("user.email"),
        n = await tu(),
        r = await async function (e, t) {
          const n = await Lo(e, null, "bool", t);
          return null === n ? null : "false" !== n
        }("http.schannelCheckRevoke");
      let i = e,
        o = t;
      if (!i || !o) {
        const e = this.props.dotComAccount || this.props.enterpriseAccount;
        e && (i || (i = e.login), o || (o = Pu(e)))
      }
      i = i || "", o = o || "";
      const [s, a] = await Promise.all([xo(), fc()]), l = s.map(e => e.editor), c = a.map(e => e.shell);
      this.setState({
        committerName: i,
        committerEmail: o,
        defaultBranch: n,
        initialCommitterName: e,
        initialCommitterEmail: t,
        initialDefaultBranch: n,
        optOutOfUsageTracking: this.props.optOutOfUsageTracking,
        confirmRepositoryRemoval: this.props.confirmRepositoryRemoval,
        confirmDiscardChanges: this.props.confirmDiscardChanges,
        confirmForcePush: this.props.confirmForcePush,
        uncommittedChangesStrategyKind: this.props.uncommittedChangesStrategyKind,
        availableShells: c,
        availableEditors: l,
        initialSchannelCheckRevoke: r,
        schannelCheckRevoke: r
      })
    }
    render() {
      return w.createElement(Im, {
        id: "preferences",
        title: "选项",
        onDismissed: this.props.onDismissed,
        onSubmit: this.onSave
      }, w.createElement("div", {
        className: "preferences-container"
      }, this.renderDisallowedCharactersError(), w.createElement(hf, {
        onTabClicked: this.onTabClicked,
        selectedIndex: this.state.selectedIndex,
        type: uf.Vertical
      }, w.createElement("span", null, w.createElement(bh, {
        className: "icon",
        symbol: Sh.home
      }), "账户"), w.createElement("span", null, w.createElement(bh, {
        className: "icon",
        symbol: Sh.person
      }), "整合"), w.createElement("span", null, w.createElement(bh, {
        className: "icon",
        symbol: Sh.gitCommit
      }), "Git"), w.createElement("span", null, w.createElement(bh, {
        className: "icon",
        symbol: Sh.paintcan
      }), "外观"), w.createElement("span", null, w.createElement(bh, {
        className: "icon",
        symbol: Sh.settings
      }), "高级")), this.renderActiveTab()), this.renderFooter())
    }
    renderDisallowedCharactersError() {
      const e = this.state.disallowedCharactersMessage;
      return null != e ? w.createElement(Om, null, e) : null
    }
    renderActiveTab() {
      const e = this.state.selectedIndex;
      let t;
      switch (e) {
        case dh.Accounts:
          t = w.createElement(Iy, {
            dotComAccount: this.props.dotComAccount,
            enterpriseAccount: this.props.enterpriseAccount,
            onDotComSignIn: this.onDotComSignIn,
            onEnterpriseSignIn: this.onEnterpriseSignIn,
            onLogout: this.onLogout
          });
          break;
        case dh.Integrations:
          t = w.createElement(Vy, {
            availableEditors: this.state.availableEditors,
            selectedExternalEditor: this.state.selectedExternalEditor,
            onSelectedEditorChanged: this.onSelectedEditorChanged,
            availableShells: this.state.availableShells,
            selectedShell: this.state.selectedShell,
            onSelectedShellChanged: this.onSelectedShellChanged
          });
          break;
        case dh.Git: {
          const {
            existingLockFilePath: e
          } = this.state, n = void 0 !== e ? w.createElement(Om, null, w.createElement(oy, {
            lockFilePath: e,
            onLockFileDeleted: this.onLockFileDeleted,
            onError: this.onLockFileDeleteError
          })) : null;
          t = w.createElement(w.Fragment, null, n, w.createElement(Ny, {
            name: this.state.committerName,
            email: this.state.committerEmail,
            defaultBranch: this.state.defaultBranch,
            onNameChanged: this.onCommitterNameChanged,
            onEmailChanged: this.onCommitterEmailChanged,
            onDefaultBranchChanged: this.onDefaultBranchChanged
          }));
          break
        }
        case dh.Appearance:
          t = w.createElement(Uy, {
            selectedTheme: this.props.selectedTheme,
            onSelectedThemeChanged: this.onSelectedThemeChanged,
            automaticallySwitchTheme: this.props.automaticallySwitchTheme,
            onAutomaticallySwitchThemeChanged: this.onAutomaticallySwitchThemeChanged
          });
          break;
        case dh.Advanced:
          t = w.createElement(Ly, {
            optOutOfUsageTracking: this.state.optOutOfUsageTracking,
            confirmRepositoryRemoval: this.state.confirmRepositoryRemoval,
            confirmDiscardChanges: this.state.confirmDiscardChanges,
            confirmForcePush: this.state.confirmForcePush,
            uncommittedChangesStrategyKind: this.state.uncommittedChangesStrategyKind,
            onOptOutofReportingchanged: this.onOptOutofReportingChanged,
            onConfirmRepositoryRemovalChanged: this.onConfirmRepositoryRemovalChanged,
            onConfirmDiscardChangesChanged: this.onConfirmDiscardChangesChanged,
            onConfirmForcePushChanged: this.onConfirmForcePushChanged,
            onUncommittedChangesStrategyKindChanged: this.onUncommittedChangesStrategyKindChanged,
            schannelCheckRevoke: this.state.schannelCheckRevoke,
            onSchannelCheckRevokeChanged: this.onSchannelCheckRevokeChanged
          });
          break;
        default:
          return X(0, "Unknown tab index: " + e)
      }
      return w.createElement("div", {
        className: "tab-container"
      }, t)
    }
    renderFooter() {
      const e = null != this.state.disallowedCharactersMessage,
        t = this.state.selectedIndex;
      switch (t) {
        case dh.Accounts:
        case dh.Appearance:
          return null;
        case dh.Integrations:
        case dh.Advanced:
        case dh.Git:
          return w.createElement(Lm, null, w.createElement(Nm, {
            okButtonText: "保存",
            okButtonDisabled: e
          }));
        default:
          return X(0, "Unknown tab index: " + t)
      }
    }
  }

  function Gy(e, t) {
    if (e.length <= t) return e;
    const n = [...e];
    if (n.length <= t) return e;
    const r = n.reduce((e, t) => (t >= "︀" && t <= "️" ? e.length && e.push(`${e.pop()}${t}`) : e.push(t), e), []);
    if (r.length <= t) return e;
    return r.slice(0, t).join("") + "…"
  }
  class $y extends w.Component {
    constructor(e) {
      super(e), this.onFilterTextChanged = e => {
        this.setState({
          filterText: e
        })
      }, this.onSelectionChanged = async e => {
        null != e ? (this.setState({
          selectedBranch: e
        }), await this.updateMergeStatus(e)) : this.setState({
          selectedBranch: e,
          commitCount: 0,
          mergeStatus: null
        })
      }, this.renderBranch = (e, t) => ng(e, t, this.props.currentBranch), this.merge = () => {
        const e = this.state.selectedBranch;
        e && (this.props.dispatcher.mergeBranch(this.props.repository, e.name, this.state.mergeStatus), this.props.onDismissed())
      };
      const t = this.resolveSelectedBranch();
      this.state = {
        selectedBranch: t,
        commitCount: void 0,
        filterText: "",
        mergeStatus: null
      }
    }
    componentDidMount() {
      const e = this.state.selectedBranch;
      e && this.updateMergeStatus(e)
    }
    renderMergeInfo() {
      const {
        currentBranch: e
      } = this.props, {
        selectedBranch: t,
        mergeStatus: n,
        commitCount: r
      } = this.state;
      return null == n || null == e || null == t || e.name === t.name || null == r ? null : w.createElement("div", {
        className: "merge-status-component"
      }, w.createElement(cg, {
        status: this.state.mergeStatus,
        classNamePrefix: "merge-status"
      }), w.createElement("p", {
        className: "merge-info"
      }, this.renderMergeStatusMessage(n, t, e, r)))
    }
    renderMergeStatusMessage(e, t, n, r) {
      return e.kind === al.Loading ? this.renderLoadingMergeMessage() : e.kind === al.Clean ? this.renderCleanMergeMessage(t, n, r) : e.kind === al.Invalid ? this.renderInvalidMergeMessage() : this.renderConflictedMergeMessage(t, n, e.conflictedFiles)
    }
    renderLoadingMergeMessage() {
      return w.createElement(w.Fragment, null, "Checking for ability to merge automatically...")
    }
    renderCleanMergeMessage(e, t, n) {
      if (0 === n) return w.createElement(w.Fragment, null, "This branch is up to date with ", w.createElement("strong", null, e.name));
      const r = 1 === n ? "commit" : "commits";
      return w.createElement(w.Fragment, null, "This will merge", w.createElement("strong", null, ` ${n} ${r}`), " from ", w.createElement("strong", null, e.name), " into ", w.createElement("strong", null, t.name))
    }
    renderInvalidMergeMessage() {
      return w.createElement(w.Fragment, null, "Unable to merge unrelated histories in this repository")
    }
    renderConflictedMergeMessage(e, t, n) {
      const r = 1 === n ? "file" : "files";
      return w.createElement(w.Fragment, null, "There will be", w.createElement("strong", null, ` ${n} conflicted ${r}`), " when merging ", w.createElement("strong", null, e.name), " into ", w.createElement("strong", null, t.name))
    }
    render() {
      const e = this.state.selectedBranch,
        t = this.props.currentBranch,
        n = null === e || null === t || t.name === e.name || 0 === this.state.commitCount,
        r = null != this.state.mergeStatus && this.state.mergeStatus.kind === al.Invalid,
        i = n || r,
        o = Gy(this.props.currentBranch.name, 40);
      return w.createElement(Im, {
        id: "merge",
        onDismissed: this.props.onDismissed,
        onSubmit: this.merge,
        title: w.createElement(w.Fragment, null, "Merge into ", w.createElement("strong", null, o))
      }, w.createElement(Mm, null, w.createElement(Vm, {
        allBranches: this.props.allBranches,
        currentBranch: t,
        defaultBranch: this.props.defaultBranch,
        recentBranches: this.props.recentBranches,
        filterText: this.state.filterText,
        onFilterTextChanged: this.onFilterTextChanged,
        selectedBranch: e,
        onSelectionChanged: this.onSelectionChanged,
        canCreateNewBranch: !1,
        renderBranch: this.renderBranch
      })), w.createElement(Lm, null, this.renderMergeInfo(), w.createElement(Nm, {
        okButtonText: w.createElement(w.Fragment, null, "Merge", " ", w.createElement("strong", null, e ? e.name : ""), " ", "into ", w.createElement("strong", null, t ? t.name : "")),
        okButtonDisabled: i,
        cancelButtonVisible: !1
      })))
    }
    async updateMergeStatus(e) {
      this.setState({
        mergeStatus: {
          kind: al.Loading
        }
      });
      const {
        currentBranch: t
      } = this.props;
      if (null != t) {
        const n = await Sc(() => dl(this.props.repository, t, e), 500);
        this.setState({
          mergeStatus: n
        })
      }
      const n = Ua("", e.name),
        r = await Wa(this.props.repository, n),
        i = r ? r.behind : 0;
      this.state.selectedBranch !== e ? this.setState({
        commitCount: void 0
      }) : this.setState({
        commitCount: i
      })
    }
    resolveSelectedBranch() {
      const {
        currentBranch: e,
        defaultBranch: t,
        initialBranch: n
      } = this.props;
      return void 0 !== n ? n : e === t ? null : t
    }
  }
  class qy extends w.Component {
    render() {
      const e = this.props.remote;
      return w.createElement(Mm, null, w.createElement("p", null, "主远程存储库 (", e.name, ")"), w.createElement(Op, {
        placeholder: "Remote URL",
        value: e.url,
        onValueChanged: this.props.onRemoteUrlChanged
      }))
    }
  }
  class Ky extends w.Component {
    constructor() {
      super(...arguments), this.onChange = e => {
        this.props.onChange && this.props.onChange(e), this.props.onValueChanged && !e.defaultPrevented && this.props.onValueChanged(e.currentTarget.value)
      }, this.onContextMenu = e => {
        e.preventDefault(), ie([{
          role: "editMenu"
        }])
      }
    }
    render() {
      const e = mh()("text-area-component", this.props.labelClassName);
      return w.createElement("label", {
        className: e
      }, this.props.label, w.createElement("textarea", {
        autoFocus: this.props.autoFocus,
        className: this.props.textareaClassName,
        disabled: this.props.disabled,
        rows: this.props.rows || 3,
        placeholder: this.props.placeholder,
        value: this.props.value,
        onChange: this.onChange,
        onKeyDown: this.props.onKeyDown,
        ref: this.props.onTextAreaRef,
        onContextMenu: this.onContextMenu
      }))
    }
  }
  class Yy extends w.Component {
    render() {
      return w.createElement(Mm, null, w.createElement("p", null, "Editing ", w.createElement(lm, null, ".gitignore"), ". 此文件指定Git应该忽略的有意未跟踪的文件。Git已经跟踪的文件不受影响.", " ", w.createElement(Ip, {
        onClick: this.props.onShowExamples
      }, "了解更多")), w.createElement(Ky, {
        placeholder: "Ignored files",
        value: this.props.text || "",
        onValueChanged: this.props.onIgnoreTextChanged,
        rows: 6
      }))
    }
  }
  class Qy extends w.Component {
    render() {
      return w.createElement(Mm, null, w.createElement(My, {
        actionTitle: "Publish",
        onAction: this.props.onPublish
      }, w.createElement("div", null, "发布你的存储库。需要帮助吗?", " ", w.createElement(Ip, {
        uri: "https://help.github.com/articles/about-remote-repositories/"
      }, "了解更多"), " 关于远程存储库.")))
    }
  }

  function Zy(e) {
    const t = e.forkContributionTarget === $i.Self ? e.repository.gitHubRepository : e.repository.gitHubRepository.parent;
    return w.createElement("ul", {
      className: "fork-settings-description"
    }, w.createElement("li", null, "Pull requests targeting ", w.createElement("strong", null, t.fullName), " ", "will be shown in the pull request list."), w.createElement("li", null, "Issues will be created in ", w.createElement("strong", null, t.fullName), "."), w.createElement("li", null, '"View on Github" will open ', w.createElement("strong", null, t.fullName), " ", "in the browser."), w.createElement("li", null, "New branches will be based on", " ", w.createElement("strong", null, t.fullName), "'s default branch."), w.createElement("li", null, "Autocompletion of user and issues will be based on", " ", w.createElement("strong", null, t.fullName), "."))
  }
  class Xy extends w.Component {
    constructor() {
      super(...arguments), this.onForkContributionTargetChanged = e => {
        this.props.onForkContributionTargetChanged(e)
      }
    }
    render() {
      return w.createElement(Mm, null, w.createElement("h2", null, "I'll be using this fork…"), w.createElement(Oy, {
        value: $i.Parent,
        checked: this.props.forkContributionTarget === $i.Parent,
        label: "To contribute to the parent repository",
        onSelected: this.onForkContributionTargetChanged
      }), w.createElement(Oy, {
        value: $i.Self,
        checked: this.props.forkContributionTarget === $i.Self,
        label: "For my own purposes",
        onSelected: this.onForkContributionTargetChanged
      }), w.createElement(Zy, {
        repository: this.props.repository,
        forkContributionTarget: this.props.forkContributionTarget
      }))
    }
  }
  var Jy;
  ! function (e) {
    e[e.Remote = 0] = "Remote", e[e.IgnoredFiles = 1] = "IgnoredFiles", e[e.ForkSettings = 2] = "ForkSettings"
  }(Jy || (Jy = {}));
  class ev extends w.Component {
    constructor(e) {
      super(e), this.onPublish = () => {
        this.props.dispatcher.showPopup({
          type: Zi.PublishRepository,
          repository: this.props.repository
        })
      }, this.onShowGitIgnoreExamples = () => {
        this.props.dispatcher.openInBrowser("https://git-scm.com/docs/gitignore")
      }, this.onSubmit = async () => {
        this.setState({
          disabled: !0,
          errors: void 0
        });
        const e = new Array;
        if (this.state.remote && this.props.remote && this.state.remote.url !== this.props.remote.url) try {
          await this.props.dispatcher.setRemoteURL(this.props.repository, this.props.remote.name, this.state.remote.url)
        } catch (t) {
          log.error("RepositorySettings: unable to set remote URL at " + this.props.repository.path, t), e.push("Failed setting the remote URL: " + t)
        }
        if (this.state.ignoreTextHasChanged && null !== this.state.ignoreText) try {
          await this.props.dispatcher.saveGitIgnore(this.props.repository, this.state.ignoreText)
        } catch (t) {
          log.error("RepositorySettings: unable to save gitignore at " + this.props.repository.path, t), e.push("Failed saving the .gitignore file: " + t)
        }
        this.state.forkContributionTarget !== this.props.repository.workflowPreferences.forkContributionTarget && await this.props.dispatcher.updateRepositoryWorkflowPreferences(this.props.repository, Object.assign(Object.assign({}, this.props.repository.workflowPreferences), {
          forkContributionTarget: this.state.forkContributionTarget
        })), e.length ? this.setState({
          disabled: !1,
          errors: e
        }) : this.props.onDismissed()
      }, this.onRemoteUrlChanged = e => {
        const t = this.props.remote;
        if (!t) return;
        const n = Object.assign(Object.assign({}, t), {
          url: e
        });
        this.setState({
          remote: n
        })
      }, this.onIgnoreTextChanged = e => {
        this.setState({
          ignoreText: e,
          ignoreTextHasChanged: !0
        })
      }, this.onTabClicked = e => {
        this.setState({
          selectedTab: e
        })
      }, this.onForkContributionTargetChanged = e => {
        this.setState({
          forkContributionTarget: e
        })
      }, this.state = {
        selectedTab: Jy.Remote,
        remote: e.remote,
        ignoreText: null,
        ignoreTextHasChanged: !1,
        disabled: !1,
        forkContributionTarget: io(e.repository)
      }
    }
    async componentWillMount() {
      try {
        const e = await Nl(this.props.repository);
        this.setState({
          ignoreText: e
        })
      } catch (e) {
        log.error("RepositorySettings: unable to read root .gitignore file for " + this.props.repository.path, e), this.setState({
          errors: ["Could not read root .gitignore: " + e]
        })
      }
    }
    renderErrors() {
      const e = this.state.errors;
      return e && e.length ? e.map((e, t) => {
        const n = "err-" + t;
        return w.createElement(Om, {
          key: n
        }, e)
      }) : null
    }
    render() {
      const e = eo(this.props.repository);
      return w.createElement(Im, {
        id: "repository-settings",
        title: "存储库设置",
        onDismissed: this.props.onDismissed,
        onSubmit: this.onSubmit,
        disabled: this.state.disabled
      }, this.renderErrors(), w.createElement("div", {
        className: "tab-container"
      }, w.createElement(hf, {
        onTabClicked: this.onTabClicked,
        selectedIndex: this.state.selectedTab,
        type: uf.Vertical
      }, w.createElement("span", null, "远程"), w.createElement("span", null, "忽略文件"), e && w.createElement("span", null, "分叉行为")), w.createElement("div", {
        className: "active-tab"
      }, this.renderActiveTab())), this.renderFooter())
    }
    renderFooter() {
      const e = this.state.selectedTab,
        t = this.state.remote;
      return e !== Jy.Remote || t ? w.createElement(Lm, null, w.createElement(Nm, {
        okButtonText: "保存"
      })) : null
    }
    renderActiveTab() {
      const e = this.state.selectedTab;
      switch (e) {
        case Jy.Remote: {
          const e = this.state.remote;
          return e ? w.createElement(qy, {
            remote: e,
            onRemoteUrlChanged: this.onRemoteUrlChanged
          }) : w.createElement(Qy, {
            onPublish: this.onPublish
          })
        }
        case Jy.IgnoredFiles:
          return w.createElement(Yy, {
            text: this.state.ignoreText,
            onIgnoreTextChanged: this.onIgnoreTextChanged,
            onShowExamples: this.onShowGitIgnoreExamples
          });
        case Jy.ForkSettings:
          return eo(this.props.repository) ? w.createElement(Xy, {
            forkContributionTarget: this.state.forkContributionTarget,
            repository: this.props.repository,
            onForkContributionTargetChanged: this.onForkContributionTargetChanged
          }) : null;
        default:
          return X(0, "Unknown tab type: " + e)
      }
    }
  }

  function tv(e) {
    return e.indexOf("\r") < 0 ? e : e.split("\n").map(e => e.split("\r").reduce((e, t) => t.length >= e.length ? t : t + e.substring(t.length))).join("\n")
  }
  class nv extends w.Component {
    constructor(e) {
      super(e), this.dialogContent = null, this.formatGitErrorMessage = $p(tv), this.onDismissed = () => {
        const e = this.state.error;
        null !== e && (this.setState({
          error: null,
          disabled: !0
        }), window.setTimeout(() => {
          this.props.onClearError(e)
        }, tb.exit))
      }, this.showPreferencesDialog = () => {
        this.onDismissed(), window.setTimeout(() => {
          this.props.onShowPopup({
            type: Zi.Preferences
          })
        }, tb.exit)
      }, this.onRetryAction = e => {
        e.preventDefault(), this.onDismissed();
        const {
          error: t
        } = this.state;
        if (null !== t && iv(t)) {
          const {
            retryAction: e
          } = t.metadata;
          void 0 !== e && this.props.onRetryAction(e)
        }
      }, this.onDialogContentRef = e => {
        this.dialogContent = e
      }, this.onCloseButtonClick = e => {
        e.preventDefault(), this.onDismissed()
      }, this.state = {
        error: e.errors[0] || null,
        disabled: !1
      }
    }
    componentWillReceiveProps(e) {
      const t = e.errors[0] || null;
      t !== this.state.error && this.setState({
        error: t,
        disabled: !1
      })
    }
    renderErrorMessage(e) {
      const t = e instanceof ae ? e.underlyingError : e;
      if (t instanceof Fo && (t.message === t.result.stderr || t.message === t.result.stdout)) {
        const e = this.formatGitErrorMessage(t.message);
        return w.createElement("p", {
          className: "monospace"
        }, e)
      }
      return w.createElement("p", null, t.message)
    }
    getTitle(e) {
      return sv(e) ? "Clone failed" : "Error"
    }
    renderDialog() {
      const e = this.state.error;
      return e ? w.createElement(Im, {
        id: "app-error",
        type: "error",
        key: "error",
        title: this.getTitle(e),
        dismissable: !1,
        onSubmit: this.onDismissed,
        onDismissed: this.onDismissed,
        disabled: this.state.disabled
      }, w.createElement(Mm, {
        onRef: this.onDialogContentRef
      }, this.renderErrorMessage(e), this.renderContentAfterErrorMessage(e)), this.renderFooter(e)) : null
    }
    renderContentAfterErrorMessage(e) {
      if (!iv(e)) return;
      const {
        retryAction: t
      } = e.metadata;
      return t && t.type === rc.Clone ? w.createElement("p", null, "Would you like to retry cloning ", w.createElement(lm, null, t.name), "?") : void 0
    }
    scrollToBottomOfGitErrorMessage() {
      if (null === this.dialogContent || null === this.state.error) return;
      const e = rv(this.state.error);
      ov(e) && (e.message !== e.result.stderr && e.message !== e.result.stdout || (this.dialogContent.scrollTop = this.dialogContent.scrollHeight))
    }
    componentDidMount() {
      this.scrollToBottomOfGitErrorMessage()
    }
    componentDidUpdate(e, t) {
      t.error !== this.state.error && this.scrollToBottomOfGitErrorMessage()
    }
    renderFooter(e) {
      if (sv(e)) return this.renderRetryCloneFooter();
      const t = rv(e);
      if (ov(t)) {
        const {
          gitError: e
        } = t.result;
        if (null !== e && Ho(e)) return this.renderOpenPreferencesFooter()
      }
      return this.renderDefaultFooter()
    }
    renderRetryCloneFooter() {
      return w.createElement(Lm, null, w.createElement(Nm, {
        okButtonText: "重试克隆",
        onOkButtonClick: this.onRetryAction,
        onCancelButtonClick: this.onCloseButtonClick
      }))
    }
    renderOpenPreferencesFooter() {
      return w.createElement(Lm, null, w.createElement(Nm, {
        okButtonText: "克隆",
        onOkButtonClick: this.onCloseButtonClick,
        cancelButtonText: "打开选项",
        onCancelButtonClick: this.showPreferencesDialog
      }))
    }
    renderDefaultFooter() {
      return w.createElement(Fm, {
        onButtonClick: this.onCloseButtonClick
      })
    }
    render() {
      const e = this.renderDialog();
      return w.createElement(O, null, e && w.createElement(K, {
        classNames: "modal",
        timeout: tb
      }, e))
    }
  }

  function rv(e) {
    return iv(e) ? e.underlyingError : e
  }

  function iv(e) {
    return e instanceof ae
  }

  function ov(e) {
    return e instanceof Fo
  }

  function sv(e) {
    if (!iv(e)) return !1;
    const {
      retryAction: t
    } = e.metadata;
    return void 0 !== t && t.type === rc.Clone
  }
  class av extends w.Component {
    constructor() {
      super(...arguments), this.checkAgain = () => {
        this.props.dispatcher.refreshRepository(this.props.repository)
      }, this.remove = () => {
        this.props.dispatcher.removeRepositories([this.props.repository], !1)
      }, this.locate = () => {
        this.props.dispatcher.relocateRepository(this.props.repository)
      }, this.cloneAgain = async () => {
        const e = this.props.repository.gitHubRepository;
        if (!e) return;
        const t = e.cloneURL;
        if (t) try {
          await this.props.dispatcher.cloneAgain(t, this.props.repository.path)
        } catch (e) {
          this.props.dispatcher.postError(e)
        }
      }
    }
    render() {
      const e = new Array;
      return e.push(w.createElement(jp, {
        key: "locate",
        onClick: this.locate,
        type: "submit"
      }, "Locate…")), this.canCloneAgain() && e.push(w.createElement(jp, {
        key: "clone-again",
        onClick: this.cloneAgain
      }, "Clone Again")), e.push(w.createElement(jp, {
        key: "remove",
        onClick: this.remove
      }, "Remove")), w.createElement(Qp, {
        id: "missing-repository-view"
      }, w.createElement("div", {
        className: "title-container"
      }, w.createElement("div", {
        className: "title"
      }, "Can't find \"", this.props.repository.name, '"'), w.createElement("div", {
        className: "details"
      }, "It was last seen at", " ", w.createElement("span", {
        className: "path"
      }, this.props.repository.path), ".", " ", w.createElement(Ip, {
        onClick: this.checkAgain
      }, "Check again."))), w.createElement(Lp, null, e))
    }
    canCloneAgain() {
      const e = this.props.repository.gitHubRepository;
      return e && e.cloneURL
    }
  }
  var lv = n(135),
    cv = n.n(lv);
  class uv extends w.Component {
    constructor(e) {
      super(e), this.onPathChanged = async e => {
        const t = await qa(e);
        this.setState({
          path: e,
          isRepository: t
        })
      }, this.showFilePicker = async () => {
        const e = r.remote.getCurrentWindow(),
          {
            filePaths: t
          } = await r.remote.dialog.showOpenDialog(e, {
            properties: ["createDirectory", "openDirectory"]
          });
        if (0 === t.length) return;
        const n = t[0],
          i = await qa(n),
          o = await $a(n);
        this.setState({
          path: n,
          isRepository: i,
          showNonGitRepositoryWarning: !i || o,
          isRepositoryBare: o
        })
      }, this.addRepository = async () => {
        this.props.onDismissed();
        const e = this.resolvedPath(this.state.path),
          t = await this.props.dispatcher.addRepositories([e]);
        if (t && t.length) {
          const e = t[0];
          this.props.dispatcher.selectRepository(e), this.props.dispatcher.recordAddExistingRepository()
        }
      }, this.onCreateRepositoryClicked = () => {
        const e = this.resolvedPath(this.state.path);
        return this.props.dispatcher.showPopup({
          type: Zi.CreateRepository,
          path: e
        })
      };
      const t = this.props.path ? this.props.path : "";
      this.state = {
        path: t,
        isRepository: !1,
        showNonGitRepositoryWarning: !1,
        isRepositoryBare: !1
      }
    }
    async componentDidMount() {
      const e = this.state.path;
      if (e.length < 1) return;
      const t = await qa(e);
      if (this.state.path !== e) return;
      !0 !== await $a(this.state.path) ? (this.setState({
        isRepository: t,
        showNonGitRepositoryWarning: !t
      }), this.setState({
        isRepositoryBare: !1
      })) : this.setState({
        isRepositoryBare: !0
      })
    }
    renderWarning() {
      return this.state.path.length && this.state.showNonGitRepositoryWarning ? this.state.isRepositoryBare ? w.createElement(Lp, {
        className: "warning-helper-text"
      }, w.createElement(bh, {
        symbol: Sh.alert
      }), w.createElement("p", null, "This directory appears to be a bare repository. Bare repositories are not currently supported.")) : w.createElement(Lp, {
        className: "warning-helper-text"
      }, w.createElement(bh, {
        symbol: Sh.alert
      }), w.createElement("p", null, "This directory does not appear to be a Git repository.", w.createElement("br", null), "Would you like to", " ", w.createElement(Ip, {
        onClick: this.onCreateRepositoryClicked
      }, "create a repository"), " ", "here instead?")) : null
    }
    render() {
      const e = 0 === this.state.path.length || !this.state.isRepository || this.state.isRepositoryBare;
      return w.createElement(Im, {
        id: "add-existing-repository",
        title: "添加本地存储库添加存储库",
        onSubmit: this.addRepository,
        onDismissed: this.props.onDismissed
      }, w.createElement(Mm, null, w.createElement(Lp, null, w.createElement(Op, {
        value: this.state.path,
        label: "本地路径",
        placeholder: "repository path",
        onValueChanged: this.onPathChanged
      }), w.createElement(jp, {
        onClick: this.showFilePicker
      }, "Choose…")), this.renderWarning()), w.createElement(Lm, null, w.createElement(Nm, {
        okButtonText: "添加存储库",
        okButtonDisabled: e
      })))
    }
    resolvedPath(e) {
      return i.resolve("/", cv()(e))
    }
  }
  const hv = new RegExp(["\ud83c[\udf00-\udfff]", "\ud83d[\udc00-\ude4f]", "\ud83d[\ude80-\udeff]"].join("|"), "g");

  function pv(e) {
    return e.replace(hv, "-").replace(/[^\w.-]/g, "-")
  }
  const dv = i.join(__dirname, "static", "gitignore");
  let fv = null;
  async function mv() {
    if (null != fv) return fv; {
      const e = (await Object(Ci.readdir)(dv)).filter(e => e.endsWith(".gitignore"));
      fv = new Map;
      for (const t of e) fv.set(i.basename(t, ".gitignore"), i.join(dv, t));
      return fv
    }
  }
  async function gv(e, t) {
    const n = i.join(e, ".gitignore"),
      r = await async function (e) {
        const t = (await mv()).get(e);
        if (!t) throw new Error(`Unknown gitignore: ${e}. Only names returned from getGitIgnoreNames() can be used.`);
        return await Object(Ci.readFile)(t, "utf8")
      }(t);
    await Object(Ci.writeFile)(n, r)
  }
  let yv = null;

  function vv(e, t, n) {
    const r = new RegExp(`\\[${t}\\]`, "g"),
      i = e.replace(r, `{${t}}`),
      o = new RegExp(`\\{${t}\\}`, "g");
    return i.replace(o, n)
  }
  async function wv(e, t, n) {
    const r = i.join(e, "LICENSE"),
      o = function (e, t, n) {
        let r = e;
        for (const e of t) {
          r = vv(r, e, n[e])
        }
        return r
      }(t.body, ["fullname", "email", "project", "description", "year"], n);
    await Object(Ci.writeFile)(r, o)
  }
  const bv = {
    name: "None",
    featured: !1,
    body: "",
    hidden: !1
  };
  class Sv extends w.Component {
    constructor(e) {
      super(e), this.onPathChanged = async e => {
        this.setState({
          path: e,
          isValidPath: null
        });
        const t = await qa(e);
        this.setState(n => n.path === e ? {
          isRepository: t
        } : null), this.updateReadMeExists(e, this.state.name)
      }, this.onNameChanged = e => {
        this.setState({
          name: e
        }), this.updateReadMeExists(this.state.path, e)
      }, this.onDescriptionChanged = e => {
        this.setState({
          description: e
        })
      }, this.showFilePicker = async () => {
        const e = r.remote.getCurrentWindow(),
          {
            filePaths: t
          } = await r.remote.dialog.showOpenDialog(e, {
            properties: ["createDirectory", "openDirectory"]
          });
        if (0 === t.length) return;
        const n = t[0],
          i = await qa(n);
        this.setState({
          isRepository: i,
          path: n
        })
      }, this.resolveRepositoryRoot = async () => {
        const e = this.state.path;
        if (this.props.initialPath && this.props.initialPath === e) try {
          return await Ci.ensureDir(e), e
        } catch (e) {}
        return i.join(e, pv(this.state.name))
      }, this.createRepository = async () => {
        const e = await this.resolveRepositoryRoot();
        try {
          await Ci.ensureDir(e), this.setState({
            isValidPath: !0
          })
        } catch (t) {
          return "EACCES" === t.code && -13 === t.errno ? this.setState({
            isValidPath: !1
          }) : (log.error(`createRepository: the directory at ${e} is not valid`, t), this.props.dispatcher.postError(t))
        }
        this.setState({
          creating: !0
        });
        try {
          await async function (e) {
            await Bo(["init"], e, "initGitRepository")
          }(e)
        } catch (t) {
          return this.setState({
            creating: !1
          }), log.error("createRepository: unable to initialize a Git repository at " + e, t), this.props.dispatcher.postError(t)
        }
        const t = await this.props.dispatcher.addRepositories([e]);
        if (t.length < 1) return;
        const n = t[0],
          r = await tu();
        if ("master" !== r) try {
          await async function (e, t) {
            await Bo(["checkout", "-b", t], e.path, "createAndCheckoutBranch")
          }(n, r)
        } catch (e) {
          log.error(`createRepository: unable to create default branch "${r}"`, e)
        }
        if (this.state.createWithReadme) try {
          await async function (e, t, n) {
            const r = i.join(e, "README.md"),
              o = function (e, t) {
                return void 0 !== t ? `# ${e}\n ${t}\n` : `# ${e}\n`
              }(t, n);
            await Object(Ci.writeFile)(r, o)
          }(e, this.state.name, this.state.description)
        } catch (t) {
          log.error("createRepository: unable to write README at " + e, t), this.props.dispatcher.postError(t)
        }
        const o = this.state.gitIgnore;
        if ("None" !== o) try {
          await gv(e, o)
        } catch (t) {
          log.error("createRepository: unable to write .gitignore file at " + e, t), this.props.dispatcher.postError(t)
        }
        const s = this.state.description;
        if (s) try {
          await async function (e, t) {
            const n = i.join(e, ".git/description");
            await Ci.writeFile(n, t)
          }(e, s)
        } catch (t) {
          log.error("createRepository: unable to write .git/description file at " + e, t), this.props.dispatcher.postError(t)
        }
        const a = this.state.license === bv.name ? null : this.state.license,
          l = (this.state.licenses || []).find(e => e.name === a);
        if (l) try {
          const t = await Al(n);
          await wv(e, l, {
            fullname: t ? t.name : "",
            email: t ? t.email : "",
            year: (new Date).getFullYear().toString(),
            description: "",
            project: this.state.name
          })
        } catch (t) {
          log.error("createRepository: unable to write LICENSE at " + e, t), this.props.dispatcher.postError(t)
        }
        try {
          const t = i.join(e, ".gitattributes");
          await Ci.pathExists(t) || await async function (e) {
            const t = Object(i.join)(e, ".gitattributes");
            await Object(Ci.writeFile)(t, "# Auto detect text files and perform LF normalization\n* text=auto\n")
          }(e)
        } catch (t) {
          log.error("createRepository: unable to write .gitattributes at " + e, t), this.props.dispatcher.postError(t)
        }
        const c = await Dl(n);
        if (null !== c) {
          try {
            const e = c.workingDirectory.files;
            e.length > 0 && await Da(n, "Initial commit", e)
          } catch (t) {
            log.error("createRepository: initial commit failed at " + e, t), this.props.dispatcher.postError(t)
          }
          this.setState({
            creating: !1
          }), this.updateDefaultDirectory(), this.props.dispatcher.selectRepository(n), this.props.dispatcher.recordCreateRepository(), this.props.onDismissed()
        } else this.props.dispatcher.postError(new Error("Unable to create the new repository because there are too many new files in this directory"))
      }, this.updateDefaultDirectory = () => {
        this.props.initialPath || Mu(this.state.path)
      }, this.onCreateWithReadmeChange = e => {
        this.setState({
          createWithReadme: e.currentTarget.checked
        })
      }, this.onGitIgnoreChange = e => {
        const t = e.currentTarget.value;
        this.setState({
          gitIgnore: t
        })
      }, this.onLicenseChange = e => {
        const t = e.currentTarget.value;
        this.setState({
          license: t
        })
      }, this.onAddRepositoryClicked = () => this.props.dispatcher.showPopup({
        type: Zi.AddRepository,
        path: this.state.path
      }), this.onWindowFocus = () => {
        this.updateReadMeExists(this.state.path, this.state.name)
      };
      const t = this.props.initialPath ? this.props.initialPath : Au(),
        n = this.props.initialPath ? pv(i.basename(this.props.initialPath)) : "";
      this.state = {
        path: t,
        name: n,
        description: "",
        createWithReadme: !1,
        creating: !1,
        gitIgnoreNames: null,
        gitIgnore: "None",
        licenses: null,
        license: bv.name,
        isValidPath: null,
        isRepository: !1,
        readMeExists: !1
      }
    }
    async componentDidMount() {
      window.addEventListener("focus", this.onWindowFocus);
      const e = await async function () {
        const e = await mv();
        return Array.from(e.keys())
      }();
      this.setState({
        gitIgnoreNames: e
      });
      const t = await async function () {
        if (null != yv) return yv; {
          const e = i.join(__dirname, "static", "available-licenses.json"),
            t = await Object(Ci.readFile)(e, "utf8"),
            n = JSON.parse(t);
          return yv = n.sort((e, t) => e.featured ? -1 : t.featured ? 1 : e.name.localeCompare(t.name)), yv
        }
      }();
      this.setState({
        licenses: t
      });
      const n = await qa(this.state.path);
      this.setState({
        isRepository: n
      }), this.updateReadMeExists(this.state.path, this.state.name)
    }
    componentWillUnmount() {
      window.removeEventListener("focus", this.onWindowFocus)
    }
    async updateReadMeExists(e, t) {
      if (!Ks()) return;
      const n = i.join(e, pv(t), "README.md"),
        r = await Ci.pathExists(n);
      this.setState(t => t.path === e ? {
        readMeExists: r
      } : null)
    }
    renderSanitizedName() {
      const e = pv(this.state.name);
      return this.state.name === e ? null : w.createElement(Lp, {
        className: "warning-helper-text"
      }, w.createElement(bh, {
        symbol: Sh.alert
      }), "Will be created as ", e)
    }
    renderGitIgnores() {
      const e = ["None", ...this.state.gitIgnoreNames || []];
      return w.createElement(Lp, null, w.createElement(Wy, {
        label: "Git ignore",
        value: this.state.gitIgnore,
        onChange: this.onGitIgnoreChange
      }, e.map(e => w.createElement("option", {
        key: e,
        value: e
      }, e))))
    }
    renderLicenses() {
      const e = this.state.licenses || [],
        t = [bv, ...e.filter(e => e.featured)],
        n = e.filter(e => !e.featured);
      return w.createElement(Lp, null, w.createElement(Wy, {
        label: "License",
        value: this.state.license,
        onChange: this.onLicenseChange
      }, t.map(e => w.createElement("option", {
        key: e.name,
        value: e.name
      }, e.name)), w.createElement("option", {
        disabled: !0
      }, "────────────────────"), n.map(e => w.createElement("option", {
        key: e.name,
        value: e.name
      }, e.name))))
    }
    renderInvalidPathError() {
      const e = this.state.isValidPath;
      return !(null !== e) || e ? null : w.createElement(Om, null, "Directory could not be created at this path. You may not have permissions to create a directory here.")
    }
    renderGitRepositoryWarning() {
      const e = this.state.isRepository;
      return this.state.path && 0 !== this.state.path.length && e ? w.createElement(Lp, {
        className: "warning-helper-text"
      }, w.createElement(bh, {
        symbol: Sh.alert
      }), w.createElement("p", null, "This directory appears to be a Git repository. Would you like to", " ", w.createElement(Ip, {
        onClick: this.onAddRepositoryClicked
      }, "add this repository"), " ", "instead?")) : null
    }
    renderReadmeOverwriteWarning() {
      return Ks() ? !1 === this.state.createWithReadme || !1 === this.state.readMeExists ? null : w.createElement(Lp, {
        className: "warning-helper-text"
      }, w.createElement(bh, {
        symbol: Sh.alert
      }), w.createElement("p", null, "This directory contains a ", w.createElement(lm, null, "README.md"), " file already. Checking this box will result in the existing file being overwritten.")) : null
    }
    render() {
      const e = 0 === this.state.path.length || 0 === this.state.name.length || this.state.creating || this.state.isRepository,
        t = !!this.props.initialPath;
      return w.createElement(Im, {
        id: "create-repository",
        title: "创建新存储库",
        loading: this.state.creating,
        onSubmit: this.createRepository,
        onDismissed: this.props.onDismissed
      }, this.renderInvalidPathError(), w.createElement(Mm, null, w.createElement(Lp, null, w.createElement(Op, {
        value: this.state.name,
        label: "名字",
        placeholder: "repository name",
        onValueChanged: this.onNameChanged
      })), this.renderSanitizedName(), w.createElement(Lp, null, w.createElement(Op, {
        value: this.state.description,
        label: "说明",
        onValueChanged: this.onDescriptionChanged
      })), w.createElement(Lp, null, w.createElement(Op, {
        value: this.state.path,
        label: "本地路径",
        placeholder: "repository path",
        onValueChanged: this.onPathChanged,
        disabled: t
      }), w.createElement(jp, {
        onClick: this.showFilePicker,
        disabled: t
      }, "Choose…")), this.renderGitRepositoryWarning(), w.createElement(Lp, null, w.createElement(Xp, {
        label: "Initialize this repository with a README",
        value: this.state.createWithReadme ? Zp.On : Zp.Off,
        onChange: this.onCreateWithReadmeChange
      })), this.renderReadmeOverwriteWarning(), this.renderGitIgnores(), this.renderLicenses()), w.createElement(Lm, null, w.createElement(Nm, {
        okButtonText: "Create repository",
        okButtonDisabled: e
      })))
    }
  }
  class Cv extends w.Component {
    constructor() {
      super(...arguments), this.onUrlChanged = e => {
        this.props.onUrlChanged(e)
      }
    }
    render() {
      return w.createElement(Mm, {
        className: "clone-generic-repository-content"
      }, w.createElement(Lp, null, w.createElement(Op, {
        placeholder: "URL or username/repository",
        value: this.props.url,
        onValueChanged: this.onUrlChanged,
        autoFocus: !0,
        label: w.createElement("span", null, "Repository URL or GitHub username and repository", w.createElement("br", null), "(", w.createElement(lm, null, "hubot/cool-repo"), ")")
      })), w.createElement(Lp, null, w.createElement(Op, {
        value: this.props.path,
        label: "Local path",
        placeholder: "repository path",
        onValueChanged: this.props.onPathChanged
      }), w.createElement(jp, {
        onClick: this.props.onChooseDirectory
      }, "Choose…")))
    }
  }

  function Ev(e) {
    return e.map(e => {
      const t = (n = e).private ? Sh.lock : n.fork ? Sh.repoForked : Sh.repo;
      var n;
      return {
        id: e.html_url,
        text: [`${e.owner.login}/${e.name}`],
        url: e.clone_url,
        name: e.name,
        icon: t
      }
    })
  }

  function kv(e, t) {
    if (null !== t)
      for (const n of e)
        for (const e of n.items)
          if (e.url === t.clone_url) return e;
    return null
  }

  function xv(e, t) {
    return e.find(e => e.clone_url === t.url) || null
  }
  class Tv extends w.PureComponent {
    constructor() {
      super(...arguments), this.getRepositoryGroups = $p((e, t) => null === e ? [] : function (e, t) {
        const n = e.filter(e => "User" === e.owner.type),
          r = e.filter(e => "Organization" === e.owner.type),
          i = [{
            identifier: "your-repositories",
            items: Ev(n)
          }],
          o = r.map(e => e.owner.login),
          s = Array.from(new Set(o));
        for (const e of s.sort(St)) {
          const t = r.filter(t => t.owner.login === e);
          i.push({
            identifier: e,
            items: Ev(t)
          })
        }
        return i
      }(e)), this.getSelectedListItem = $p(kv), this.refreshRepositories = () => {
        this.props.onRefreshRepositories(this.props.account)
      }, this.onItemClick = (e, t) => {
        const {
          onItemClicked: n,
          repositories: r
        } = this.props;
        if (void 0 === n || null === r) return;
        const i = xv(r, e);
        null !== i && n(i, t)
      }, this.onSelectionChanged = e => {
        null === e || null === this.props.repositories ? this.props.onSelectionChanged(null) : this.props.onSelectionChanged(xv(this.props.repositories, e))
      }, this.renderGroupHeader = e => {
        let t = e;
        return "your-repositories" === e && (t = "Your repositories"), w.createElement("div", {
          className: "clone-repository-list-content clone-repository-list-group-header"
        }, t)
      }, this.renderItem = (e, t) => w.createElement("div", {
        className: "clone-repository-list-item"
      }, w.createElement(bh, {
        className: "icon",
        symbol: e.icon
      }), w.createElement("div", {
        className: "name",
        title: e.text[0]
      }, w.createElement(Dh, {
        text: e.text[0],
        highlight: t.title
      }))), this.renderPostFilter = () => w.createElement(jp, {
        disabled: this.props.loading,
        onClick: this.refreshRepositories,
        tooltip: "Refresh the list of repositories"
      }, w.createElement(bh, {
        symbol: Sh.sync,
        className: this.props.loading ? "spin" : void 0
      })), this.renderNoItems = () => {
        const {
          loading: e,
          repositories: t
        } = this.props, n = this.props.account.endpoint === pt() ? "GitHub.com" : ht(this.props.account.endpoint);
        return !e || null !== t && 0 !== t.length ? 0 !== this.props.filterText.length ? w.createElement("div", {
          className: "no-items no-results-found"
        }, w.createElement("div", null, "Sorry, I can't find any repository matching", " ", w.createElement(lm, null, this.props.filterText))) : w.createElement("div", {
          className: "no-items empty-repository-list"
        }, w.createElement("div", null, "Looks like there are no repositories for", " ", w.createElement(lm, null, this.props.account.login), " on ", n, ".", " ", w.createElement(Ip, {
          onClick: this.refreshRepositories
        }, "Refresh this list"), " ", "if you've created a repository recently.")) : w.createElement("div", {
          className: "no-items loading"
        }, `Loading repositories from ${n}…`)
      }
    }
    componentDidMount() {
      null === this.props.repositories && this.refreshRepositories()
    }
    componentDidUpdate(e) {
      e.repositories !== this.props.repositories && null === this.props.repositories && this.refreshRepositories()
    }
    render() {
      const {
        repositories: e,
        account: t,
        selectedItem: n
      } = this.props, r = this.getRepositoryGroups(e, t.login), i = this.getSelectedListItem(r, n);
      return w.createElement(Hp, {
        className: "clone-github-repo",
        rowHeight: 31,
        selectedItem: i,
        renderItem: this.renderItem,
        renderGroupHeader: this.renderGroupHeader,
        onSelectionChanged: this.onSelectionChanged,
        invalidationProps: r,
        groups: r,
        filterText: this.props.filterText,
        onFilterTextChanged: this.props.onFilterTextChanged,
        renderNoItems: this.renderNoItems,
        renderPostFilter: this.renderPostFilter,
        onItemClick: this.props.onItemClicked ? this.onItemClick : void 0,
        placeholderText: "Filter your repositories"
      })
    }
  }
  class Rv extends w.PureComponent {
    render() {
      return w.createElement(Mm, {
        className: "clone-github-repository-content"
      }, w.createElement(Lp, null, w.createElement(Tv, {
        account: this.props.account,
        selectedItem: this.props.selectedItem,
        onSelectionChanged: this.props.onSelectionChanged,
        loading: this.props.loading,
        repositories: this.props.repositories,
        filterText: this.props.filterText,
        onFilterTextChanged: this.props.onFilterTextChanged,
        onRefreshRepositories: this.props.onRefreshRepositories,
        onItemClicked: this.props.onItemClicked
      })), w.createElement(Lp, {
        className: "local-path-field"
      }, w.createElement(Op, {
        value: this.props.path,
        label: "Local path",
        placeholder: "repository path",
        onValueChanged: this.props.onPathChanged
      }), w.createElement(jp, {
        onClick: this.props.onChooseDirectory
      }, "Choose…")))
    }
  }
  class Dv extends w.Component {
    constructor(e) {
      super(e), this.checkIfCloningDisabled = () => {
        const e = this.getSelectedTabState(),
          {
            error: t,
            url: n,
            path: r
          } = e,
          {
            loading: i
          } = this.state;
        return 0 === n.length || 0 === r.length || i || null !== t
      }, this.onTabClicked = e => {
        this.props.onTabSelected(e)
      }, this.onPathChanged = e => {
        this.setSelectedTabState({
          path: e
        }, this.validatePath)
      }, this.signInDotCom = () => {
        this.props.dispatcher.showDotComSignInDialog()
      }, this.signInEnterprise = () => {
        this.props.dispatcher.showEnterpriseSignInDialog()
      }, this.onFilterTextChanged = e => {
        this.props.selectedTab !== Si.Generic && this.setGitHubTabState({
          filterText: e
        }, this.props.selectedTab)
      }, this.onSelectionChanged = e => {
        this.props.selectedTab !== Si.Generic && (this.setGitHubTabState({
          selectedItem: e
        }, this.props.selectedTab), this.updateUrl(null === e ? "" : e.clone_url))
      }, this.validatePath = async () => {
        const e = this.getSelectedTabState(),
          {
            path: t,
            url: n,
            error: r
          } = e,
          {
            initialPath: i
          } = this.state;
        if (i === t && "" === n) r && this.setSelectedTabState({
          error: null
        });
        else {
          const e = await this.validateEmptyFolder(t);
          this.getSelectedTabState().path === t && this.setSelectedTabState({
            error: e,
            path: t
          })
        }
      }, this.onChooseDirectory = async () => {
        const e = r.remote.getCurrentWindow(),
          {
            filePaths: t
          } = await r.remote.dialog.showOpenDialog(e, {
            properties: ["createDirectory", "openDirectory"]
          });
        if (0 === t.length) return;
        const n = this.getSelectedTabState().lastParsedIdentifier,
          o = n ? i.join(t[0], n.name) : t[0];
        return this.setSelectedTabState({
          path: o,
          error: null
        }, this.validatePath), o
      }, this.updateUrl = async e => {
        const t = yt(e),
          n = this.getSelectedTabState();
        let r;
        r = n.lastParsedIdentifier ? t ? i.join(i.dirname(n.path), t.name) : i.dirname(n.path) : t ? i.join(n.path, t.name) : n.path, this.setSelectedTabState({
          url: e,
          lastParsedIdentifier: t,
          path: r
        }, this.validatePath)
      }, this.onItemClicked = (e, t) => {
        "keyboard" === t.kind && "Enter" === t.event.key && !1 === this.checkIfCloningDisabled() && this.clone()
      }, this.clone = async () => {
        this.setState({
          loading: !0
        });
        const e = await this.resolveCloneURL(),
          {
            path: t
          } = this.getSelectedTabState();
        if (!e) {
          const e = new Error("We couldn't find that repository. Check that you are logged in, the network is accessible, and the URL or repository alias are spelled correctly.");
          return this.setState({
            loading: !1
          }), void this.setSelectedTabState({
            error: e
          })
        }
        try {
          this.cloneImpl(e.trim(), t)
        } catch (e) {
          log.error("CloneRepostiory: clone failed to complete to " + t, e), this.setState({
            loading: !1
          }), this.setSelectedTabState({
            error: e
          })
        }
      }, this.onWindowFocus = () => {
        this.validatePath()
      };
      const t = Au(),
        n = {
          error: null,
          lastParsedIdentifier: null,
          path: t,
          url: this.props.initialURL || ""
        };
      this.state = {
        initialPath: t,
        loading: !1,
        dotComTabState: Object.assign({
          kind: "dotComTabState",
          filterText: "",
          selectedItem: null
        }, n),
        enterpriseTabState: Object.assign({
          kind: "enterpriseTabState",
          filterText: "",
          selectedItem: null
        }, n),
        urlTabState: Object.assign({
          kind: "urlTabState"
        }, n)
      }
    }
    componentDidUpdate(e) {
      e.selectedTab !== this.props.selectedTab && this.validatePath()
    }
    componentDidMount() {
      const e = this.props.initialURL;
      e && this.updateUrl(e), window.addEventListener("focus", this.onWindowFocus)
    }
    componentWillUnmount() {
      window.removeEventListener("focus", this.onWindowFocus)
    }
    render() {
      const {
        error: e
      } = this.getSelectedTabState();
      return w.createElement(Im, {
        className: "clone-repository",
        title: "克隆存储库",
        onSubmit: this.clone,
        onDismissed: this.props.onDismissed,
        loading: this.state.loading
      }, w.createElement(hf, {
        onTabClicked: this.onTabClicked,
        selectedIndex: this.props.selectedTab
      }, w.createElement("span", null, "GitHub.com"), w.createElement("span", null, "GitHub Enterprise Server"), w.createElement("span", null, "URL")), e ? w.createElement(Om, null, e.message) : null, this.renderActiveTab(), this.renderFooter())
    }
    renderFooter() {
      const e = this.props.selectedTab;
      if (e !== Si.Generic && !this.getAccountForTab(e)) return null;
      const t = this.checkIfCloningDisabled();
      return w.createElement(Lm, null, w.createElement(Nm, {
        okButtonText: "克隆",
        okButtonDisabled: t
      }))
    }
    renderActiveTab() {
      const e = this.props.selectedTab;
      switch (e) {
        case Si.Generic:
          const t = this.state.urlTabState;
          return w.createElement(Cv, {
            path: t.path,
            url: t.url,
            onPathChanged: this.onPathChanged,
            onUrlChanged: this.updateUrl,
            onChooseDirectory: this.onChooseDirectory
          });
        case Si.DotCom:
        case Si.Enterprise: {
          const t = this.getAccountForTab(e);
          if (t) {
            const n = this.props.apiRepositories.get(t),
              r = void 0 === n ? null : n.repositories,
              i = void 0 !== n && n.loading,
              o = this.getGitHubTabState(e);
            return w.createElement(Rv, {
              path: o.path,
              account: t,
              selectedItem: o.selectedItem,
              onSelectionChanged: this.onSelectionChanged,
              onPathChanged: this.onPathChanged,
              onChooseDirectory: this.onChooseDirectory,
              repositories: r,
              loading: i,
              onRefreshRepositories: this.props.onRefreshRepositories,
              filterText: o.filterText,
              onFilterTextChanged: this.onFilterTextChanged,
              onItemClicked: this.onItemClicked
            })
          }
          return w.createElement(Mm, null, this.renderSignIn(e))
        }
        default:
          return X(0, "Unknown tab: " + e)
      }
    }
    getAccountForTab(e) {
      switch (e) {
        case Si.DotCom:
          return this.props.dotComAccount;
        case Si.Enterprise:
          return this.props.enterpriseAccount;
        default:
          return null
      }
    }
    getGitHubTabState(e) {
      return e === Si.DotCom ? this.state.dotComTabState : e === Si.Enterprise ? this.state.enterpriseTabState : X(0, "Unknown tab: " + e)
    }
    getTabState(e) {
      return e === Si.DotCom ? this.state.dotComTabState : e === Si.Enterprise ? this.state.enterpriseTabState : e === Si.Generic ? this.state.urlTabState : X(0, "Unknown tab: " + e)
    }
    getSelectedTabState() {
      return this.getTabState(this.props.selectedTab)
    }
    setSelectedTabState(e, t) {
      this.setTabState(e, this.props.selectedTab, t)
    }
    setTabState(e, t, n) {
      if (t === Si.DotCom) this.setState(t => ({
        dotComTabState: Object.assign(Object.assign({}, t.dotComTabState), e)
      }), n);
      else if (t === Si.Enterprise) this.setState(t => ({
        enterpriseTabState: Object.assign(Object.assign({}, t.enterpriseTabState), e)
      }), n);
      else {
        if (t !== Si.Generic) return X(0, "Unknown tab: " + t);
        this.setState(t => ({
          urlTabState: Object.assign(Object.assign({}, t.urlTabState), e)
        }), n)
      }
    }
    setGitHubTabState(e, t) {
      if (t === Si.DotCom) this.setState(t => ({
        dotComTabState: hi(t.dotComTabState, e)
      }));
      else {
        if (t !== Si.Enterprise) return X(0, "Unknown tab: " + t);
        this.setState(t => ({
          enterpriseTabState: hi(t.enterpriseTabState, e)
        }))
      }
    }
    renderSignIn(e) {
      switch (e) {
        case Si.DotCom:
          return w.createElement(My, {
            actionTitle: "Sign in",
            onAction: this.signInDotCom
          }, w.createElement("div", null, "Sign in to your GitHub.com account to access your repositories."));
        case Si.Enterprise:
          return w.createElement(My, {
            actionTitle: "Sign in",
            onAction: this.signInEnterprise
          }, w.createElement("div", null, "If you have a GitHub Enterprise Server account at work, sign in to it to get access to your repositories."));
        case Si.Generic:
          return null;
        default:
          return X(0, "Unknown sign in tab: " + e)
      }
    }
    async validateEmptyFolder(e) {
      try {
        return 0 === (await Object(Ci.readdir)(e)).length ? null : new Error("This folder contains files. Git can only clone to empty folders.")
      } catch (e) {
        return "ENOENT" === e.code ? null : (log.error("CloneRepository: Path validation failed. Error: " + e.message), new Error("Unable to read path on disk. Please check the path and try again."))
      }
    }
    async resolveCloneURL() {
      const e = this.getSelectedTabState(),
        t = e.lastParsedIdentifier;
      let n = e.url;
      const r = [];
      this.props.dotComAccount && r.push(this.props.dotComAccount), this.props.enterpriseAccount && r.push(this.props.enterpriseAccount);
      const i = await _o(n, r);
      if (t && i) {
        const e = at.fromAccount(i),
          r = await e.fetchRepository(t.owner, t.name);
        if (r) {
          const e = gt(n);
          n = e && "ssh" === e.protocol ? r.ssh_url : r.clone_url
        }
      }
      return n
    }
    cloneImpl(e, t) {
      this.props.dispatcher.clone(e, t), this.props.onDismissed(), Mu(i.resolve(t, ".."))
    }
  }

  function _v(e, t) {
    return e.tip.kind === Qi.Detached ? Ms.Head : t === Ms.UpstreamDefaultBranch && null !== e.upstreamDefaultBranch || t === Ms.DefaultBranch && null !== e.defaultBranch || t === Ms.CurrentBranch && e.tip.kind === Qi.Valid || t === Ms.Head ? t : e.upstreamDefaultBranch ? Ms.UpstreamDefaultBranch : e.defaultBranch ? Ms.DefaultBranch : e.tip.kind === Qi.Valid ? Ms.CurrentBranch : Ms.Head
  }
  class Av extends w.Component {
    constructor(e) {
      super(e), this.onBaseBranchChanged = e => {
        this.setState({
          startPoint: e
        })
      }, this.onBranchNameChange = e => {
        this.updateBranchName(e)
      }, this.createBranch = async () => {
        const e = this.state.branchName;
        let t = null,
          n = !1;
        const {
          defaultBranch: r,
          upstreamDefaultBranch: i,
          currentBranchProtected: o,
          repository: s
        } = this.props;
        if (this.state.startPoint === Ms.DefaultBranch) {
          if (!r) return void this.setState({
            currentError: new Error("Could not determine the default branch")
          });
          t = r.name
        }
        if (this.state.startPoint === Ms.UpstreamDefaultBranch) {
          if (!i) return void this.setState({
            currentError: new Error("Could not determine the default branch")
          });
          t = i.name, n = !0
        }
        if (e.length > 0) {
          const r = o ? {
            kind: cu.MoveToNewBranch,
            transientStashEntry: null
          } : this.props.selectedUncommittedChangesStrategy;
          this.setState({
            isCreatingBranch: !0
          });
          const i = Od("create branch", s);
          await this.props.dispatcher.createBranch(s, e, t, r, n), i.done()
        }
      }, this.renderOptions = (e, t) => w.createElement(Lp, null, w.createElement(Hy, {
        label: "Create branch based on…",
        items: e,
        selectedKey: t,
        onSelectionChanged: this.onBaseBranchChanged
      }));
      const t = _v(e, Ms.UpstreamDefaultBranch);
      this.state = {
        currentError: null,
        branchName: e.initialName,
        startPoint: t,
        isCreatingBranch: !1,
        tipAtCreateStart: e.tip,
        defaultBranchAtCreateStart: Pv(t, e)
      }
    }
    componentWillReceiveProps(e) {
      if (this.setState({
          startPoint: _v(e, this.state.startPoint)
        }), !this.state.isCreatingBranch) {
        const t = _v(e, Ms.UpstreamDefaultBranch);
        this.setState({
          tipAtCreateStart: e.tip,
          defaultBranchAtCreateStart: Pv(t, e)
        })
      }
    }
    renderBranchSelection() {
      const e = this.state.isCreatingBranch ? this.state.tipAtCreateStart : this.props.tip,
        t = e.kind;
      if (e.kind === Qi.Detached) return w.createElement("p", null, "You do not currently have any branch checked out (your HEAD reference is detached). As such your new branch will be based on your currently checked out commit (", e.currentSha.substr(0, 7), ").");
      if (e.kind === Qi.Unborn) return w.createElement("p", null, "Your current branch is unborn (does not contain any commits). Creating a new branch will rename the current branch.");
      if (e.kind === Qi.Valid) {
        if (null !== this.props.upstreamGitHubRepository && null !== this.props.upstreamDefaultBranch) return this.renderForkBranchSelection(e.branch.name, this.props.upstreamDefaultBranch, this.props.upstreamGitHubRepository.fullName);
        const t = this.state.isCreatingBranch ? this.props.defaultBranch : this.state.defaultBranchAtCreateStart;
        return this.renderRegularBranchSelection(e.branch.name, t)
      }
      return X(0, "Unknown tip kind " + t)
    }
    render() {
      const e = this.state.branchName.length <= 0 || !!this.state.currentError || /^\s*$/.test(this.state.branchName),
        t = this.state.currentError;
      return w.createElement(Im, {
        id: "create-branch",
        title: "创建分支",
        onSubmit: this.createBranch,
        onDismissed: this.props.onDismissed,
        loading: this.state.isCreatingBranch,
        disabled: this.state.isCreatingBranch
      }, t ? w.createElement(Om, null, t.message) : null, w.createElement(Mm, null, w.createElement(Ig, {
        label: "名字",
        initialValue: this.props.initialName,
        onValueChange: this.onBranchNameChange
      }), (n = this.state.branchName, !1 == this.props.allBranches.findIndex(e => e.nameWithoutRemote === n && e.type === As.Remote) > -1 ? null : w.createElement(Lp, {
        className: "warning-helper-text"
      }, w.createElement(bh, {
        symbol: Sh.alert
      }), w.createElement("p", null, "A branch named ", w.createElement(lm, null, n), " already exists on the remote."))), this.renderBranchSelection()), w.createElement(Lm, null, w.createElement(Nm, {
        okButtonText: "Create branch",
        okButtonDisabled: e
      })));
      var n
    }
    updateBranchName(e) {
      const t = this.props.allBranches.findIndex(t => t.name === e) > -1 ? new Error(`A branch named ${e} already exists`) : null;
      this.setState({
        branchName: e,
        currentError: t
      })
    }
    renderRegularBranchSelection(e, t) {
      if (null === t || t.name === e) return w.createElement("p", null, "Your new branch will be based on your currently checked out branch (", w.createElement(lm, null, e), "). ", w.createElement(lm, null, e), " is the ", Mv, " for your repository."); {
        const n = [{
            title: t.name,
            description: "The default branch in your repository. Pick this to start on something new that's not dependent on your current branch.",
            key: Ms.DefaultBranch
          }, {
            title: e,
            description: "The currently checked out branch. Pick this if you need to build on work done on this branch.",
            key: Ms.CurrentBranch
          }],
          r = this.state.startPoint === Ms.DefaultBranch ? this.state.startPoint : Ms.CurrentBranch;
        return this.renderOptions(n, r)
      }
    }
    renderForkBranchSelection(e, t, n) {
      if (e === t.nameWithoutRemote) return w.createElement("p", null, "Your new branch will be based on", " ", w.createElement("strong", null, n), "'s ", Mv, " (", w.createElement(lm, null, t.nameWithoutRemote), ")."); {
        const n = [{
            title: t.name,
            description: "The default branch of the upstream repository. Pick this to start on something new that's not dependent on your current branch.",
            key: Ms.UpstreamDefaultBranch
          }, {
            title: e,
            description: "The currently checked out branch. Pick this if you need to build on work done on this branch.",
            key: Ms.CurrentBranch
          }],
          r = this.state.startPoint === Ms.UpstreamDefaultBranch ? this.state.startPoint : Ms.CurrentBranch;
        return this.renderOptions(n, r)
      }
    }
  }
  const Mv = w.createElement(Ip, {
    uri: "https://help.github.com/articles/setting-the-default-branch/"
  }, "default branch");

  function Pv(e, t) {
    return e === Ms.UpstreamDefaultBranch ? t.upstreamDefaultBranch : e === Ms.DefaultBranch ? t.defaultBranch : null
  }
  class Iv extends w.Component {
    constructor(e) {
      super(e), this.onSubmit = () => {
        const e = this.props.signInState;
        if (!e) return;
        const t = e.kind;
        switch (e.kind) {
          case Yu.EndpointEntry:
            this.props.dispatcher.setSignInEndpoint(this.state.endpoint);
            break;
          case Yu.Authentication:
            e.supportsBasicAuth ? this.props.dispatcher.setSignInCredentials(this.state.username, this.state.password) : this.props.dispatcher.requestBrowserAuthentication();
            break;
          case Yu.TwoFactorAuthentication:
            this.props.dispatcher.setSignInOTP(this.state.otpToken);
            break;
          case Yu.Success:
            this.onDismissed();
            break;
          default:
            X(0, "Unknown sign in step " + t)
        }
      }, this.onEndpointChanged = e => {
        this.setState({
          endpoint: e
        })
      }, this.onUsernameChanged = e => {
        this.setState({
          username: e
        })
      }, this.onPasswordChanged = e => {
        this.setState({
          password: e
        })
      }, this.onOTPTokenChanged = e => {
        this.setState({
          otpToken: e
        })
      }, this.onSignInWithBrowser = () => {
        this.props.dispatcher.requestBrowserAuthentication()
      }, this.onDismissed = () => {
        this.props.dispatcher.resetSignInState(), this.props.onDismissed()
      }, this.state = {
        endpoint: "",
        username: "",
        password: "",
        otpToken: ""
      }
    }
    componentWillReceiveProps(e) {
      e.signInState !== this.props.signInState && e.signInState && e.signInState.kind === Yu.Success && this.onDismissed()
    }
    renderFooter() {
      const e = this.props.signInState;
      if (!e || e.kind === Yu.Success) return null;
      let t, n = !1;
      const r = e.kind;
      switch (e.kind) {
        case Yu.EndpointEntry:
          n = 0 === this.state.endpoint.length, t = "Continue";
          break;
        case Yu.TwoFactorAuthentication:
          n = !/\S+/.test(this.state.otpToken), t = "Sign in";
          break;
        case Yu.Authentication:
          if (e.supportsBasicAuth) {
            const e = this.state.username.length > 0,
              r = this.state.password.length > 0;
            n = !e || !r, t = "Sign in"
          } else t = "Continue with browser";
          break;
        default:
          return X(0, "Unknown sign in step " + r)
      }
      return w.createElement(Lm, null, w.createElement(Nm, {
        okButtonText: t,
        okButtonDisabled: n
      }))
    }
    renderEndpointEntryStep(e) {
      return w.createElement(Mm, null, w.createElement(Lp, null, w.createElement(Op, {
        label: "Enterprise Server address",
        value: this.state.endpoint,
        onValueChanged: this.onEndpointChanged,
        placeholder: "https://github.example.com"
      })))
    }
    renderAuthenticationStep(e) {
      if (!e.supportsBasicAuth) return e.endpoint === pt() ? w.createElement(Mm, null, w.createElement("p", null, "To improve the security of your account, GitHub now requires you to sign in through your browser."), w.createElement("p", null, "Your browser will redirect you back to GitHub Desktop once you've signed in. If your browser asks for your permission to launch GitHub Desktop please allow it to.")) : w.createElement(Mm, null, w.createElement("p", null, "Your GitHub Enterprise Server instance requires you to sign in with your browser."));
      const t = e.loading;
      return w.createElement(Mm, null, w.createElement(Lp, {
        className: "sign-in-with-browser"
      }, w.createElement(jp, {
        className: "button-with-icon button-component-primary",
        onClick: this.onSignInWithBrowser,
        disabled: t
      }, "Sign in using your browser", w.createElement(bh, {
        symbol: Sh.linkExternal
      }))), w.createElement("div", {
        className: "horizontal-rule"
      }, w.createElement("span", {
        className: "horizontal-rule-content"
      }, "or")), w.createElement(Lp, null, w.createElement(Op, {
        label: "Username or email address",
        value: this.state.username,
        onValueChanged: this.onUsernameChanged
      })), w.createElement(Lp, null, w.createElement(Op, {
        label: "Password",
        value: this.state.password,
        type: "password",
        onValueChanged: this.onPasswordChanged
      })), w.createElement(Lp, null, w.createElement(Ip, {
        className: "forgot-password-link-sign-in",
        uri: e.forgotPasswordUrl
      }, "Forgot password?")))
    }
    renderTwoFactorAuthenticationStep(e) {
      return w.createElement(Mm, null, w.createElement("p", null, je(e.type)), w.createElement(Lp, null, w.createElement(Op, {
        label: "Authentication code",
        value: this.state.otpToken,
        onValueChanged: this.onOTPTokenChanged,
        labelLinkText: "What's this?",
        labelLinkUri: "https://help.github.com/articles/providing-your-2fa-authentication-code/",
        autoFocus: !0
      })))
    }
    renderStep() {
      const e = this.props.signInState;
      if (!e) return null;
      const t = e.kind;
      switch (e.kind) {
        case Yu.EndpointEntry:
          return this.renderEndpointEntryStep(e);
        case Yu.Authentication:
          return this.renderAuthenticationStep(e);
        case Yu.TwoFactorAuthentication:
          return this.renderTwoFactorAuthenticationStep(e);
        case Yu.Success:
          return null;
        default:
          return X(0, "Unknown sign in step " + t)
      }
    }
    render() {
      const e = this.props.signInState;
      if (!e || e.kind === Yu.Success) return null;
      const t = e.loading,
        n = e.error ? w.createElement(Om, null, e.error.message) : null,
        r = this.props.signInState && this.props.signInState.kind === Yu.Authentication && !this.props.signInState.supportsBasicAuth ? "Sign in using your browser" : "Sign in";
      return w.createElement(Im, {
        id: "sign-in",
        title: r,
        disabled: t,
        onDismissed: this.onDismissed,
        onSubmit: this.onSubmit,
        loading: e.loading
      }, n, this.renderStep(), this.renderFooter())
    }
  }
  class Ov extends w.Component {
    constructor(e) {
      super(e), this.onSubmit = () => {
        this.props.onOpenShell(this.props.path), this.props.onDismissed()
      }, this.onExternalLink = e => {
        ee.openExternal("https://help.github.com/articles/set-up-git/#setting-up-git")
      }
    }
    render() {
      return w.createElement(Im, {
        id: "install-git",
        type: "warning",
        title: "找不到Git",
        onSubmit: this.onSubmit,
        onDismissed: this.props.onDismissed
      }, w.createElement(Mm, null, w.createElement("p", null, "我们无法在你的系统上找到Git. 这意味着您将", "无法在命令提示符中", "执行任何Git命令", "."), w.createElement("p", null, "为了帮助您为您的操作系统安装和配置Git，我们提供了一些外部资源.")), w.createElement(Lm, null, w.createElement(Nm, {
        okButtonText: "无Git打开",
        cancelButtonText: "安装Git",
        onCancelButtonClick: this.onExternalLink
      })))
    }
  }
  class Lv extends w.Component {
    constructor(e) {
      super(e), this.onExternalLink = () => {
        ee.openExternal("https://atom.io/")
      }, this.onShowPreferencesDialog = e => {
        e.preventDefault(), this.props.onDismissed(), this.props.showPreferencesDialog()
      }
    }
    renderFooter() {
      const {
        viewPreferences: e,
        suggestAtom: t
      } = this.props;
      return e ? w.createElement(Lm, null, w.createElement(Nm, {
        okButtonText: "Close",
        cancelButtonText: "Open options",
        onCancelButtonClick: this.onShowPreferencesDialog
      })) : t ? w.createElement(Lm, null, w.createElement(Nm, {
        okButtonText: "Close",
        cancelButtonText: "Download Atom",
        onCancelButtonClick: this.onExternalLink
      })) : w.createElement(Fm, null)
    }
    render() {
      return w.createElement(Im, {
        id: "external-editor-error",
        type: "error",
        title: "无法打开外部编辑器",
        onSubmit: this.props.onDismissed,
        onDismissed: this.props.onDismissed
      }, w.createElement(Mm, null, w.createElement("p", null, this.props.message)), this.renderFooter())
    }
  }
  const Nv = Mc(__dirname, "static/logo-64x64@2x.png");
  class Fv extends w.Component {
    constructor(e) {
      super(e), this.updateStoreEventHandle = null, this.onUpdateStateChanged = e => {
        this.setState({
          updateState: e
        })
      }, this.onQuitAndInstall = () => {
        ke.quitAndInstallUpdate()
      }, this.state = {
        updateState: ke.state
      }
    }
    componentDidMount() {
      this.updateStoreEventHandle = ke.onDidChange(this.onUpdateStateChanged), this.setState({
        updateState: ke.state
      })
    }
    componentWillUnmount() {
      this.updateStoreEventHandle && (this.updateStoreEventHandle.dispose(), this.updateStoreEventHandle = null)
    }
    renderUpdateButton() {
      const e = this.state.updateState.status;
      switch (e) {
        case Ee.UpdateReady:
          return w.createElement(Lp, null, w.createElement(jp, {
            onClick: this.onQuitAndInstall
          }, "Quit and Install Update"));
        case Ee.UpdateNotAvailable:
        case Ee.CheckingForUpdates:
        case Ee.UpdateAvailable:
          const t = e !== Ee.UpdateNotAvailable;
          return w.createElement(Lp, null, w.createElement(jp, {
            disabled: t,
            onClick: this.props.onCheckForUpdates
          }, "Check for Updates"));
        default:
          return X(0, "Unknown update status " + e)
      }
    }
    renderCheckingForUpdate() {
      return w.createElement(Lp, {
        className: "update-status"
      }, w.createElement(fd, null), w.createElement("span", null, "Checking for updates…"))
    }
    renderUpdateAvailable() {
      return w.createElement(Lp, {
        className: "update-status"
      }, w.createElement(fd, null), w.createElement("span", null, "Downloading update…"))
    }
    renderUpdateNotAvailable() {
      const e = this.state.updateState.lastSuccessfulCheck;
      return e ? w.createElement("p", {
        className: "update-status"
      }, "You have the latest version (last checked", " ", w.createElement( of , {
        date: e
      }), ")") : null
    }
    renderUpdateReady() {
      return w.createElement("p", {
        className: "update-status"
      }, "An update has been downloaded and is ready to be installed.")
    }
    renderUpdateDetails() {
      const e = this.state.updateState;
      switch (e.status) {
        case Ee.CheckingForUpdates:
          return this.renderCheckingForUpdate();
        case Ee.UpdateAvailable:
          return this.renderUpdateAvailable();
        case Ee.UpdateNotAvailable:
          return this.renderUpdateNotAvailable();
        case Ee.UpdateReady:
          return this.renderUpdateReady();
        default:
          return X(e.status, "Unknown update status " + e.status)
      }
    }
    renderUpdateErrors() {
      return this.state.updateState.lastSuccessfulCheck ? null : w.createElement(Om, null, "Couldn't determine the last time an update check was performed. You may be running an old version. Please try manually checking for updates and contact GitHub Support if the problem persists")
    }
    render() {
      const e = this.props.applicationName,
        t = this.props.applicationVersion,
        n = w.createElement(Ip, {
          uri: xy
        }, "release notes"),
        r = "Version " + t;
      return w.createElement(Im, {
        id: "about",
        onSubmit: this.props.onDismissed,
        onDismissed: this.props.onDismissed
      }, this.renderUpdateErrors(), w.createElement(Mm, null, w.createElement(Lp, {
        className: "logo"
      }, w.createElement("img", {
        src: Nv,
        alt: "GitHub Desktop",
        width: "64",
        height: "64"
      })), w.createElement("h2", null, e), w.createElement("p", {
        className: "no-padding"
      }, w.createElement("span", {
        className: "selectable-text"
      }, r), " (", n, ")"), w.createElement("p", {
        className: "no-padding"
      }, w.createElement(Ip, {
        onClick: this.props.onShowTermsAndConditions
      }, "Terms and Conditions")), w.createElement("p", null, w.createElement(Ip, {
        onClick: this.props.onShowAcknowledgements
      }, "License and Open Source Notices")), this.renderUpdateDetails(), this.renderUpdateButton()), w.createElement(Fm, null))
    }
  }
  class Bv extends w.Component {
    constructor(e) {
      super(e), this.onNameChange = e => {
        this.name = e, e = pv(e), this.updateSettings({
          name: e
        })
      }, this.onDescriptionChange = e => {
        this.updateSettings({
          description: e
        })
      }, this.onPrivateChange = e => {
        this.updateSettings({
          private: e.currentTarget.checked
        })
      }, this.onOrgChange = e => {
        const {
          settings: t
        } = this.props, n = e.currentTarget.value, r = parseInt(n, 10);
        let i;
        if (r < 0 || isNaN(r)) i = Object.assign(Object.assign({}, t), {
          org: null
        });
        else {
          const e = this.state.orgs[r];
          i = Object.assign(Object.assign({}, t), {
            org: e
          })
        }
        this.props.onSettingsChanged(i)
      }, this.state = {
        orgs: []
      }, this.name = e.settings.name
    }
    async componentWillMount() {
      this.fetchOrgs(this.props.account)
    }
    componentWillReceiveProps(e) {
      this.props.account !== e.account && (this.setState({
        orgs: []
      }), this.fetchOrgs(e.account))
    }
    async fetchOrgs(e) {
      const t = at.fromAccount(e),
        n = [...await t.fetchOrgs()];
      n.sort((e, t) => St(e.login, t.login)), this.setState({
        orgs: n
      })
    }
    updateSettings(e) {
      const t = hi(this.props.settings, e);
      this.props.onSettingsChanged(t)
    }
    renderOrgs() {
      if (0 === this.state.orgs.length) return null;
      const e = new Array;
      e.push(w.createElement("option", {
        value: -1,
        key: -1
      }, "None"));
      let t = -1;
      const n = this.props.settings.org;
      for (const [r, i] of this.state.orgs.entries()) n && n.id === i.id && (t = r), e.push(w.createElement("option", {
        value: r,
        key: r
      }, i.login));
      return w.createElement(Wy, {
        label: "Organization",
        value: t.toString(),
        onChange: this.onOrgChange
      }, e)
    }
    render() {
      return w.createElement(Mm, null, w.createElement(Lp, null, w.createElement(Op, {
        label: "Name",
        value: this.name,
        onValueChanged: this.onNameChange
      })), this.renderSanitizedName(), w.createElement(Lp, null, w.createElement(Op, {
        label: "说明",
        value: this.props.settings.description,
        onValueChanged: this.onDescriptionChange
      })), w.createElement(Lp, null, w.createElement("label", null, w.createElement("input", {
        type: "checkbox",
        checked: this.props.settings.private,
        onChange: this.onPrivateChange
      }), "Keep this code private")), this.renderOrgs())
    }
    renderSanitizedName() {
      const e = this.props.settings.name;
      return this.name === e ? null : w.createElement(Lp, {
        className: "warning-helper-text"
      }, w.createElement(bh, {
        symbol: Sh.alert
      }), "Will be created as ", e)
    }
  }
  var Hv, zv;
  ! function (e) {
    e[e.enterprise = 0] = "enterprise", e[e.dotcom = 1] = "dotcom"
  }(Hv || (Hv = {})),
  function (e) {
    e[e.DotCom = 0] = "DotCom", e[e.Enterprise = 1] = "Enterprise"
  }(zv || (zv = {}));
  class Uv extends w.Component {
    constructor(e) {
      super(e), this.onSettingsChanged = e => {
        let t;
        t = e.kind === Hv.enterprise ? {
          kind: "enterprise",
          settings: e,
          error: this.state.enterpriseTabState.error
        } : {
          kind: "dotcom",
          settings: e,
          error: this.state.dotcomTabState.error
        }, this.setTabState(t)
      }, this.signInDotCom = () => {
        this.props.dispatcher.showDotComSignInDialog()
      }, this.signInEnterprise = () => {
        this.props.dispatcher.showEnterpriseSignInDialog()
      }, this.publishRepository = async () => {
        const e = this.getCurrentTabState();
        this.setCurrentTabError(null), this.setState({
          publishing: !0
        });
        const t = this.state.currentTab,
          n = this.getAccountForTab(t);
        n || Z("Tried to publish with no user. That seems impossible!");
        const r = e.settings,
          {
            org: i
          } = e.settings;
        try {
          await this.props.dispatcher.publishRepository(this.props.repository, r.name, r.description, r.private, n, i), this.props.onDismissed()
        } catch (e) {
          this.setCurrentTabError(e), this.setState({
            publishing: !1
          })
        }
      }, this.onTabClicked = e => {
        e !== this.state.currentTab && this.setState({
          currentTab: e
        })
      }, this.getCurrentTabState = () => this.state.currentTab === zv.DotCom ? this.state.dotcomTabState : this.state.enterpriseTabState, this.setTabState = e => {
        "enterprise" === e.kind ? this.setState({
          enterpriseTabState: e
        }) : this.setState({
          dotcomTabState: e
        })
      }, this.setCurrentTabSettings = e => {
        if (e.kind === Hv.enterprise) {
          const t = Object.assign(Object.assign({}, this.state.enterpriseTabState), {
            settings: e
          });
          this.setTabState(t)
        } else {
          const t = Object.assign(Object.assign({}, this.state.dotcomTabState), {
            settings: e
          });
          this.setTabState(t)
        }
      }, this.setCurrentTabError = e => {
        this.setTabState(Object.assign(Object.assign({}, this.getCurrentTabState()), {
          error: e
        }))
      };
      const t = this.getAccountForTab(zv.DotCom),
        n = this.getAccountForTab(zv.Enterprise);
      let r = zv.DotCom;
      !t && n && (r = zv.Enterprise);
      const i = {
          name: e.repository.name,
          description: "",
          private: !0
        },
        o = {
          kind: "dotcom",
          settings: Object.assign(Object.assign({}, i), {
            kind: Hv.dotcom,
            org: null
          }),
          error: null
        },
        s = {
          kind: "enterprise",
          settings: Object.assign(Object.assign({}, i), {
            kind: Hv.enterprise,
            org: null
          }),
          error: null
        };
      this.state = {
        currentTab: r,
        dotcomTabState: o,
        enterpriseTabState: s,
        publishing: !1
      }
    }
    render() {
      const e = this.getCurrentTabState();
      return w.createElement(Im, {
        id: "publish-repository",
        title: "发布存储库",
        onDismissed: this.props.onDismissed,
        onSubmit: this.publishRepository,
        disabled: this.state.publishing,
        loading: this.state.publishing
      }, w.createElement(hf, {
        onTabClicked: this.onTabClicked,
        selectedIndex: this.state.currentTab
      }, w.createElement("span", null, "GitHub.com"), w.createElement("span", null, "GitHub 企业服务器")), e.error ? w.createElement(Om, null, e.error.message) : null, this.renderContent(), this.renderFooter())
    }
    async componentDidMount() {
      const e = this.getCurrentTabState();
      try {
        const t = await async function (e) {
          const t = i.join(e, ".git/description");
          try {
            const e = await Ci.readFile(t, "utf8");
            return "Unnamed repository; edit this file 'description' to name the repository.\n" === e ? "" : e
          } catch (e) {
            return ""
          }
        }(this.props.repository.path), n = Object.assign(Object.assign({}, e.settings), {
          description: t
        });
        this.setCurrentTabSettings(n)
      } catch (e) {
        log.warn("Couldn't get the repository's description", e)
      }
    }
    renderContent() {
      const e = this.state.currentTab,
        t = this.getCurrentTabState(),
        n = this.getAccountForTab(e);
      return n ? w.createElement(Bv, {
        account: n,
        settings: t.settings,
        onSettingsChanged: this.onSettingsChanged
      }) : w.createElement(Mm, null, this.renderSignInTab(e))
    }
    getAccountForTab(e) {
      const t = this.props.accounts;
      switch (e) {
        case zv.DotCom:
          return t.find(e => e.endpoint === pt()) || null;
        case zv.Enterprise:
          return t.find(e => e.endpoint !== pt()) || null;
        default:
          return X(0, "Unknown tab: " + e)
      }
    }
    renderSignInTab(e) {
      switch (e) {
        case zv.DotCom:
          return w.createElement(My, {
            actionTitle: "Sign in",
            onAction: this.signInDotCom
          }, w.createElement("div", null, "Sign in to your GitHub.com account to access your repositories."));
        case zv.Enterprise:
          return w.createElement(My, {
            actionTitle: "Sign in",
            onAction: this.signInEnterprise
          }, w.createElement("div", null, "If you have a GitHub Enterprise Server account at work, sign in to it to get access to your repositories."));
        default:
          return X(0, "Unknown tab: " + e)
      }
    }
    renderFooter() {
      const e = !this.getCurrentTabState().settings.name.length,
        t = this.state.currentTab;
      return this.getAccountForTab(t) ? w.createElement(Lm, null, w.createElement(Nm, {
        okButtonText: "Publish repository",
        okButtonDisabled: e
      })) : null
    }
  }
  class Wv extends w.Component {
    constructor(e) {
      super(e), this.state = {
        licenses: null
      }
    }
    componentDidMount() {
      const e = i.join(Ne(), "static", "licenses.json");
      o.readFile(e, "utf8", (e, t) => {
        if (e) return void log.error("Error loading licenses", e);
        const n = JSON.parse(t);
        n ? this.setState({
          licenses: n
        }) : log.warn("Couldn't parse licenses!")
      })
    }
    renderLicenses(e) {
      const t = [];
      for (const [n, r] of Object.keys(e).sort().entries()) {
        if (0 === n) continue;
        const i = e[r],
          o = i.repository;
        let s, a;
        if (o) {
          const e = Vv(o);
          s = w.createElement(Ip, {
            uri: e
          }, r)
        } else s = r;
        a = i.sourceText ? i.sourceText : i.license ? "License: " + i.license : "Unknown license";
        const l = w.createElement("h2", {
            key: r + "-header"
          }, s),
          c = w.createElement("p", {
            key: r + "-text",
            className: "license-text"
          }, a);
        t.push(l, c)
      }
      return t
    }
    render() {
      const e = this.state.licenses;
      let t = null;
      if (e) {
        const n = e["desktop@" + this.props.applicationVersion];
        t = w.createElement("p", {
          className: "license-text"
        }, n.sourceText)
      }
      return w.createElement(Im, {
        id: "acknowledgements",
        title: "许可证和开源声明",
        onSubmit: this.props.onDismissed,
        onDismissed: this.props.onDismissed
      }, w.createElement(Mm, null, w.createElement("p", null, w.createElement(Ip, {
        uri: "https://desktop.github.com"
      }, "GitHub Desktop"), " 是一个在MIT许可下发布的开源项目. 你可以在", " ", w.createElement(Ip, {
        uri: "https://github.com/desktop/desktop"
      }, "GitHub"), "上查看源代码并为这个项目做贡献."), t, w.createElement("p", null, "GitHub Desktop还分发以下库:"), e ? this.renderLicenses(e) : w.createElement(fd, null)), w.createElement(Fm, null))
    }
  }

  function Vv(e) {
    let t = e;
    return t = t.replace("git+https://github.com", "https://github.com"), t = t.replace("git+ssh://git@github.com", "https://github.com"), t
  }
  class jv extends w.Component {
    constructor() {
      super(...arguments), this.onContinue = () => {
        this.props.onDismissed(), this.props.onContinue(this.props.certificate)
      }
    }
    render() {
      const e = Te.parse(this.props.url).hostname;
      return w.createElement(Im, {
        title: "不受信任的服务器",
        onDismissed: this.props.onDismissed,
        onSubmit: this.onContinue,
        type: "error"
      }, w.createElement(Mm, null, w.createElement("p", null, "GitHub Desktop cannot verify the identity of ", e, ". The certificate (", this.props.certificate.subjectName, ") is invalid or untrusted.", " ", w.createElement("strong", null, "This may indicate attackers are trying to steal your data.")), w.createElement("p", null, "In some cases, this may be expected. For example:"), w.createElement("ul", null, w.createElement("li", null, "If this is a GitHub Enterprise Server trial."), w.createElement("li", null, "If your GitHub Enterprise Server instance is run on an unusual top-level domain.")), w.createElement("p", null, "If you are unsure of what to do, cancel and contact your system administrator.")), w.createElement(Lm, null, w.createElement(Nm, {
        destructive: !0,
        okButtonText: "添加证书"
      })))
    }
  }
  var Gv;
  ! function (e) {
    e[e.dotCom = 0] = "dotCom", e[e.enterprise = 1] = "enterprise"
  }(Gv || (Gv = {}));
  class $v extends w.Component {
    constructor(e) {
      super(e), this.onItemClicked = (e, t) => {
        "keyboard" === t.kind && "Enter" === t.event.key && this.onCloneSelectedRepository()
      }, this.onCloneSelectedRepository = () => {
        const e = this.getSelectedAccount();
        if (null === e) return;
        const t = this.getSelectedItemForAccount(e);
        null !== t && this.props.onClone(t.clone_url)
      }, this.onSelectionChanged = e => {
        const t = this.getSelectedAccount();
        t === this.props.dotComAccount ? this.setState({
          selectedDotComRepository: e
        }) : t === this.props.enterpriseAccount && this.setState({
          selectedEnterpriseRepository: e
        })
      }, this.onFilterTextChanged = e => {
        const t = this.getSelectedAccount();
        t === this.props.dotComAccount ? this.setState({
          dotComFilterText: e
        }) : t === this.props.enterpriseAccount && this.setState({
          enterpriseFilterText: e
        })
      }, this.onTabClicked = e => {
        0 === e ? this.setState({
          selectedTab: Gv.dotCom
        }) : 1 === e && this.setState({
          selectedTab: Gv.enterprise
        })
      }, this.onShowClone = () => this.props.onClone(), this.state = {
        selectedTab: Gv.dotCom,
        dotComFilterText: "",
        enterpriseFilterText: "",
        selectedDotComRepository: null,
        selectedEnterpriseRepository: null
      }
    }
    render() {
      return w.createElement(Qp, {
        id: "no-repositories"
      }, w.createElement("header", null, w.createElement("h1", null, "让我们开始吧🎉🎉🎉"), w.createElement("p", null, "添加一个仓库到GitHub桌面，开始合作吧！加油💪💪💪")), w.createElement("div", {
        className: "content"
      }, this.renderGetStartedActions(), this.renderRepositoryList()), w.createElement("img", {
        className: "no-repositories-graphic-top",
        src: hy
      }), w.createElement("img", {
        className: "no-repositories-graphic-bottom",
        src: py
      }))
    }
    componentDidMount() {
      this.ensureRepositoriesForAccount(this.getSelectedAccount())
    }
    componentDidUpdate(e, t) {
      e.dotComAccount === this.props.dotComAccount && e.enterpriseAccount === this.props.enterpriseAccount && t.selectedTab === this.state.selectedTab || this.ensureRepositoriesForAccount(this.getSelectedAccount())
    }
    ensureRepositoriesForAccount(e) {
      if (null !== e) {
        void 0 === this.props.apiRepositories.get(e) && this.props.onRefreshRepositories(e)
      }
    }
    getSelectedAccount() {
      const {
        selectedTab: e
      } = this.state;
      return e === Gv.dotCom ? this.props.dotComAccount || this.props.enterpriseAccount : e === Gv.enterprise ? this.props.enterpriseAccount || this.props.dotComAccount : X(0, "Unknown account tab " + e)
    }
    renderRepositoryList() {
      const e = this.getSelectedAccount();
      if (null === e) return null;
      const t = this.props.apiRepositories.get(e);
      return w.createElement("div", {
        className: "content-pane repository-list"
      }, this.renderAccountsTabBar(), this.renderAccountRepositoryList(e, t))
    }
    getSelectedItemForAccount(e) {
      return e === this.props.dotComAccount ? this.state.selectedDotComRepository : this.state.selectedEnterpriseRepository
    }
    renderAccountRepositoryList(e, t) {
      const n = void 0 === t || t.loading,
        r = void 0 === t ? null : t.repositories,
        i = this.getSelectedItemForAccount(e),
        o = e === this.props.dotComAccount ? this.state.dotComFilterText : this.state.enterpriseFilterText;
      return w.createElement(w.Fragment, null, w.createElement(Tv, {
        account: e,
        selectedItem: i,
        filterText: o,
        onRefreshRepositories: this.props.onRefreshRepositories,
        loading: n,
        repositories: r,
        onSelectionChanged: this.onSelectionChanged,
        onFilterTextChanged: this.onFilterTextChanged,
        onItemClicked: this.onItemClicked
      }), this.renderCloneSelectedRepositoryButton(i))
    }
    renderCloneSelectedRepositoryButton(e) {
      return null === e ? null : w.createElement(jp, {
        type: "submit",
        className: "clone-selected-repository",
        onClick: this.onCloneSelectedRepository
      }, "Clone", " ", w.createElement("strong", null, e.owner.login, "/", e.name))
    }
    renderAccountsTabBar() {
      if (null === this.props.dotComAccount || null === this.props.enterpriseAccount) return null;
      const e = this.getSelectedAccount() === this.props.dotComAccount ? 0 : 1;
      return w.createElement(hf, {
        selectedIndex: e,
        onTabClicked: this.onTabClicked
      }, w.createElement("span", null, "GitHub.com"), w.createElement("span", null, "GitHub Enterprise Server"))
    }
    renderButtonGroupButton(e, t, n, r) {
      return w.createElement("li", null, w.createElement(jp, {
        onClick: n,
        type: r
      }, w.createElement(bh, {
        symbol: e
      }), w.createElement("div", null, t)))
    }
    renderTutorialRepositoryButton() {
      return null === this.props.dotComAccount && null === this.props.enterpriseAccount ? null : this.props.tutorialPaused ? this.renderButtonGroupButton(Sh.mortarBoard, "继续进行中的教程", this.props.onResumeTutorialRepository, "submit") : this.renderButtonGroupButton(Sh.mortarBoard, "创建教程存储库…", this.props.onCreateTutorialRepository, "submit")
    }
    renderCloneButton() {
      return this.renderButtonGroupButton(Sh.repoClone, "从互联网克隆一个存储库…", this.onShowClone)
    }
    renderCreateRepositoryButton() {
      return this.renderButtonGroupButton(Sh.plus, "在你的电脑上创建新的存储库…", this.props.onCreate)
    }
    renderAddExistingRepositoryButton() {
      return this.renderButtonGroupButton(Sh.fileDirectory, "从你的电脑添加现有存储库…", this.props.onAdd)
    }
    renderGetStartedActions() {
      return w.createElement("div", {
        className: "content-pane"
      }, w.createElement("ul", {
        className: "button-group"
      }, this.renderTutorialRepositoryButton(), this.renderCloneButton(), this.renderCreateRepositoryButton(), this.renderAddExistingRepositoryButton()), w.createElement("div", {
        className: "drag-drop-info"
      }, w.createElement(bh, {
        symbol: Sh.lightBulb
      }), w.createElement("div", null, w.createElement("strong", null, "专业提示!"), " 您可以将现有的存储库文件夹拖放到此处以将其添加到桌面")))
    }
  }
  class qv extends w.Component {
    constructor(e) {
      super(e), this.onSubmit = async () => {
        this.setState({
          isRemovingRepository: !0
        }), await this.props.onConfirmation(this.props.repository, this.state.deleteRepoFromDisk), this.props.onDismissed()
      }, this.onConfirmRepositoryDeletion = e => {
        const t = e.currentTarget.checked;
        this.setState({
          deleteRepoFromDisk: t
        })
      }, this.state = {
        deleteRepoFromDisk: !1,
        isRemovingRepository: !1
      }
    }
    render() {
      const e = this.state.isRemovingRepository;
      return w.createElement(Im, {
        id: "confirm-remove-repository",
        key: "remove-repository-confirmation",
        type: "warning",
        title: "删除存储库",
        dismissable: !e,
        loading: e,
        disabled: e,
        onDismissed: this.props.onDismissed,
        onSubmit: this.onSubmit
      }, w.createElement(Mm, null, w.createElement("p", null, '是否确实要删除存储库"', this.props.repository.name, '"?'), w.createElement("p", {
        className: "description"
      }, "将从GitHub Desktop删除存储库:", w.createElement("br", null), w.createElement(lm, null, this.props.repository.path)), w.createElement("div", null, w.createElement(Xp, {
        label: "同时将此存储库移到回收站",
        value: this.state.deleteRepoFromDisk ? Zp.On : Zp.Off,
        onChange: this.onConfirmRepositoryDeletion
      }))), w.createElement(Lm, null, w.createElement(Nm, {
        destructive: !0,
        okButtonText: "删除"
      })))
    }
  }
  const Kv = "https://github.com/contact";
  class Yv extends w.Component {
    render() {
      return w.createElement(Im, {
        id: "terms-and-conditions",
        title: "GitHub开源应用程序条款和条件",
        onSubmit: this.props.onDismissed,
        onDismissed: this.props.onDismissed
      }, w.createElement(Mm, null, w.createElement("p", null, 'These GitHub Open Source Applications Terms and Conditions ("Application Terms") are a legal agreement between you (either as an individual or on behalf of an entity) and GitHub, Inc. regarding your use of GitHub\'s applications, such as GitHub Desktop™ and associated documentation ("Software"). These Application Terms apply to the executable code version of the Software. Source code for the Software is available separately and free of charge under open source software license agreements. If you do not agree to all of the terms in these Application Terms, do not download, install, use, or copy the Software.'), w.createElement("h2", null, "Connecting to GitHub"), w.createElement("p", null, 'If you configure the Software to work with one or more accounts on the GitHub.com website or with an instance of GitHub Enterprise Server, your use of the Software will also be governed your applicable GitHub.com website Terms of Service and/or the license agreement applicable to your instance of GitHub Enterprise Server ("GitHub Terms").'), w.createElement("p", null, "Any use of the Software that violates your applicable GitHub Terms will also be a violation of these Application Terms."), w.createElement("h2", null, "Open Source Licenses and Notices"), w.createElement("p", null, 'The open source license for the Software is included in the "Open Source Notices" documentation that is included with the Software. That documentation also includes copies of all applicable open source licenses.'), w.createElement("p", null, "To the extent the terms of the licenses applicable to open source components require GitHub to make an offer to provide source code in connection with the Software, such offer is hereby made, and you may exercise it by contacting GitHub:", " ", w.createElement(Ip, {
        uri: Kv
      }, "contact"), "."), w.createElement("p", null, "Unless otherwise agreed to in writing with GitHub, your agreement with GitHub will always include, at a minimum, these Application Terms. Open source software licenses for the Software's source code constitute separate written agreements. To the limited extent that the open source software licenses expressly supersede these Application Terms, the open source licenses govern your agreement with GitHub for the use of the Software or specific included components of the Software."), w.createElement("h2", null, "GitHub's Logos"), w.createElement("p", null, 'The license grant included with the Software is not for GitHub\'s trademarks, which include the Software logo designs. GitHub reserves all trademark and copyright rights in and to all GitHub trademarks. GitHub\'s logos include, for instance, the stylized designs that include "logo" in the file title in the "logos" folder.'), w.createElement("p", null, "The names GitHub, GitHub Desktop, GitHub for Mac, GitHub for Windows, Atom, the Octocat, and related GitHub logos and/or stylized names are trademarks of GitHub. You agree not to display or use these trademarks in any manner without GitHub's prior, written permission, except as allowed by GitHub's Logos and Usage Policy:", " ", w.createElement(Ip, {
        uri: "https://github.com/logos"
      }, "logos"), "."), w.createElement("h2", null, "Privacy"), w.createElement("p", null, "The Software may collect personal information. You may control what information the Software collects in the settings panel. If the Software does collect personal information on GitHub's behalf, GitHub will process that information in accordance with the", w.createElement(Ip, {
        uri: "https://help.github.com/articles/github-privacy-statement/"
      }, "GitHub Privacy Statement"), "."), w.createElement("h2", null, "Additional Services"), w.createElement("h3", null, "Auto-Update Services"), w.createElement("p", null, 'The Software may include an auto-update service ("Service"). If you choose to use the Service or you download Software that automatically enables the Service, GitHub will automatically update the Software when a new version is available.'), w.createElement("h3", null, "Disclaimers and Limitations of Liability"), w.createElement("p", null, 'THE SERVICE IS PROVIDED ON AN "AS IS" BASIS, AND NO WARRANTY, EITHER EXPRESS OR IMPLIED, IS GIVEN. YOUR USE OF THE SERVICE IS AT YOUR SOLE RISK. GitHub does not warrant that (i) the Service will meet your specific requirements; (ii) the Service is fully compatible with any particular platform; (iii) your use of the Service will be uninterrupted, timely, secure, or error-free; (iv) the results that may be obtained from the use of the Service will be accurate or reliable; (v) the quality of any products, services, information, or other material purchased or obtained by you through the Service will meet your expectations; or (vi) any errors in the Service will be corrected.'), w.createElement("p", null, "YOU EXPRESSLY UNDERSTAND AND AGREE THAT GITHUB SHALL NOT BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, CONSEQUENTIAL OR EXEMPLARY DAMAGES, INCLUDING BUT NOT LIMITED TO, DAMAGES FOR LOSS OF PROFITS, GOODWILL, USE, DATA OR OTHER INTANGIBLE LOSSES (EVEN IF GITHUB HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES) RELATED TO THE SERVICE, including, for example: (i) the use or the inability to use the Service; (ii) the cost of procurement of substitute goods and services resulting from any goods, data, information or services purchased or obtained or messages received or transactions entered into through or from the Service; (iii) unauthorized access to or alteration of your transmissions or data; (iv) statements or conduct of any third-party on the Service; (v) or any other matter relating to the Service."), w.createElement("p", null, "GitHub reserves the right at any time and from time to time to modify or discontinue, temporarily or permanently, the Service (or any part thereof) with or without notice. GitHub shall not be liable to you or to any third-party for any price change, suspension or discontinuance of the Service."), w.createElement("h2", null, "Miscellanea"), w.createElement("ol", null, w.createElement("li", null, "No Waiver. The failure of GitHub to exercise or enforce any right or provision of these Application Terms shall not constitute a waiver of such right or provision."), w.createElement("li", null, "Entire Agreement. These Application Terms, together with any applicable Privacy Notices, constitutes the entire agreement between you and GitHub and governs your use of the Software, superseding any prior agreements between you and GitHub (including, but not limited to, any prior versions of the Application Terms)."), w.createElement("li", null, "Governing Law. You agree that these Application Terms and your use of the Software are governed under California law and any dispute related to the Software must be brought in a tribunal of competent jurisdiction located in or near San Francisco, California."), w.createElement("li", null, 'Third-Party Packages. The Software supports third-party "Packages" which may modify, add, remove, or alter the functionality of the Software. These Packages are not covered by these Application Terms and may include their own license which governs your use of that particular package.'), w.createElement("li", null, "No Modifications; Complete Agreement. These Application Terms may only be modified by a written amendment signed by an authorized representative of GitHub, or by the posting by GitHub of a revised version. These Application Terms, together with any applicable Open Source Licenses and Notices and GitHub's Privacy Statement, represent the complete and exclusive statement of the agreement between you and us. These Application Terms supersede any proposal or prior agreement oral or written, and any other communications between you and GitHub relating to the subject matter of these terms."), w.createElement("li", null, "License to GitHub Policies. These Application Terms are licensed under the", " ", w.createElement(Ip, {
        uri: "https://creativecommons.org/licenses/by/4.0/"
      }, "Creative Commons Attribution license"), ". You may use it freely under the terms of the Creative Commons license."), w.createElement("li", null, "Contact Us. Please send any questions about these Application Terms to ", w.createElement(Ip, {
        uri: Kv
      }, "support@github.com"), "."))), w.createElement(Fm, null))
    }
  }
  var Qv = n(58);
  const Zv = "/usr/local/bin/github",
    Xv = i.resolve(__dirname, "static", "github.sh");
  async function Jv() {
    if (await async function () {
        try {
          return await Ci.readlink(Zv)
        } catch (e) {
          return null
        }
      }() !== Xv) try {
      await ew(!1)
    } catch (e) {
      await ew(!0)
    }
  }
  async function ew(e) {
    await
    function (e) {
      return e ? new Promise((e, t) => {
        Qv.unlink(Zv, n => {
          null === n ? e() : t(new Error(`Failed to remove file at ${Zv}. Authorization of GitHub Desktop Helper is required.`))
        })
      }) : Ci.unlink(Zv)
    }(e), await
    function (e) {
      const t = i.dirname(Zv);
      return e ? new Promise((e, n) => {
        Qv.makeTree(t, t => {
          null === t ? e() : n(new Error("Failed to create intermediate directories to " + Zv))
        })
      }) : Ci.mkdirp(t)
    }(e), await
    function (e) {
      return e ? new Promise((e, t) => {
        Qv.symlink(Xv, Zv, n => {
          null === n ? e() : t(new Error(`Failed to symlink ${Xv} to ${Zv}`))
        })
      }) : Ci.symlink(Xv, Zv)
    }(e)
  }
  class tw extends w.Component {
    render() {
      return w.createElement(Im, {
        title: "已安装命令行工具",
        onDismissed: this.props.onDismissed,
        onSubmit: this.props.onDismissed
      }, w.createElement(Mm, null, w.createElement("div", null, "命令行工具已安装在", " ", w.createElement("strong", null, Zv), ".")), w.createElement(Fm, {
        buttonText: "Ok"
      }))
    }
  }
  class nw extends w.Component {
    constructor(e) {
      super(e), this.onUsernameChange = e => {
        this.setState({
          username: e
        })
      }, this.onPasswordChange = e => {
        this.setState({
          password: e
        })
      }, this.save = () => {
        this.props.onDismiss(), this.props.onSave(this.props.hostname, this.state.username, this.state.password, this.props.retryAction)
      }, this.state = {
        username: "",
        password: ""
      }
    }
    render() {
      const e = !this.state.password.length || !this.state.username.length;
      return w.createElement(Im, {
        id: "generic-git-auth",
        title: "身份验证失败",
        onDismissed: this.props.onDismiss,
        onSubmit: this.save
      }, w.createElement(Mm, null, w.createElement("p", null, "我们无法验证", w.createElement(lm, null, this.props.hostname), ".请输入用户名和密码再试一次."), w.createElement(Lp, null, w.createElement(Op, {
        label: "用户名",
        autoFocus: !0,
        value: this.state.username,
        onValueChanged: this.onUsernameChange
      })), w.createElement(Lp, null, w.createElement(Op, {
        label: "密码",
        type: "password",
        value: this.state.password,
        onValueChanged: this.onPasswordChange
      }))), w.createElement(Lm, null, w.createElement(Nm, {
        okButtonText: "保存并重试",
        okButtonDisabled: e
      })))
    }
  }
  class rw extends w.Component {
    constructor() {
      super(...arguments), this.onShowPreferencesDialog = e => {
        e.preventDefault(), this.props.onDismissed(), this.props.showPreferencesDialog()
      }
    }
    render() {
      return w.createElement(Im, {
        id: "shell-error",
        type: "error",
        title: "无法打开shell",
        onSubmit: this.props.onDismissed,
        onDismissed: this.props.onDismissed
      }, w.createElement(Mm, null, w.createElement("p", null, this.props.message)), w.createElement(Lm, null, w.createElement(Nm, {
        okButtonText: "关闭",
        cancelButtonText: "选项",
        onCancelButtonClick: this.onShowPreferencesDialog
      })))
    }
  }
  const iw = "https://git-lfs.github.com/";
  class ow extends w.Component {
    constructor() {
      super(...arguments), this.onInitialize = () => {
        this.props.onInitialize(this.props.repositories), this.props.onDismissed()
      }
    }
    render() {
      return w.createElement(Im, {
        id: "initialize-lfs",
        title: "初始化Git LFS",
        onDismissed: this.props.onDismissed,
        onSubmit: this.onInitialize
      }, w.createElement(Mm, null, this.renderRepositories()), w.createElement(Lm, null, w.createElement(Nm, {
        okButtonText: "初始化Git LFS",
        cancelButtonText: "以后再说"
      })))
    }
    renderRepositories() {
      if (this.props.repositories.length > 10) return w.createElement("p", null, this.props.repositories.length, " repositories use", " ", w.createElement(Ip, {
        uri: iw
      }, "Git LFS"), ". To contribute to them, Git LFS must first be initialized. Would you like to do so now?"); {
        const e = 1 !== this.props.repositories.length,
          t = e ? "The repositories use" : "This repository uses",
          n = e ? "them" : "it";
        return w.createElement("div", null, w.createElement("p", null, t, " ", w.createElement(Ip, {
          uri: iw
        }, "Git LFS"), ". To contribute to", " ", n, ", Git LFS must first be initialized. Would you like to do so now?"), w.createElement("ul", null, this.props.repositories.map(e => w.createElement("li", {
          key: e.id
        }, w.createElement($d, {
          path: e.path
        })))))
      }
    }
  }
  class sw extends w.Component {
    constructor(e) {
      super(e), this.showGlobalGitConfig = () => {
        const e = this.state.globalGitConfigPath;
        e && ee.openPath(e)
      }, this.onSumit = () => {
        this.props.onUpdateExistingFilters(), this.props.onDismissed()
      }, this.state = {
        globalGitConfigPath: null
      }
    }
    async componentDidMount() {
      try {
        const e = await async function (e) {
          const t = e ? {
              env: e
            } : void 0,
            n = (await Bo(["config", "--global", "--list", "--show-origin", "--name-only", "-z"], __dirname, "getGlobalConfigPath", t)).stdout.split("\0");
          if (n.length < 1) return null;
          const r = n[0];
          if (!r.length) return null;
          const o = r.match(/file:(.+)/i);
          return !o || o.length < 2 ? null : Object(i.normalize)(o[1])
        }();
        this.setState({
          globalGitConfigPath: e
        })
      } catch (e) {
        log.warn("Couldn't get the global git config path", e)
      }
    }
    renderGlobalGitConfigLink() {
      const e = "your global git config";
      return this.state.globalGitConfigPath ? w.createElement(Ip, {
        onClick: this.showGlobalGitConfig
      }, e) : e
    }
    render() {
      return w.createElement(Im, {
        id: "lfs-attribute-mismatch",
        title: "更新现有的Git-LFS过滤器？",
        onDismissed: this.props.onDismissed,
        onSubmit: this.onSumit
      }, w.createElement(Mm, null, w.createElement("p", null, "Git LFS filters are already configured in", " ", this.renderGlobalGitConfigLink(), " but are not the values it expects. Would you like to update them now?")), w.createElement(Lm, null, w.createElement(Nm, {
        okButtonText: "更新现有筛选器",
        cancelButtonText: "以后再说"
      })))
    }
  }
  class aw extends w.Component {
    constructor() {
      super(...arguments), this.onUpdate = () => {
        this.props.onUpdate(this.props.repository), this.props.onDismissed()
      }, this.onIgnore = e => {
        e.preventDefault(), this.props.onIgnore(this.props.repository), this.props.onDismissed()
      }
    }
    render() {
      const e = this.props.repository.name,
        t = J("A repository must have a GitHub repository to add an upstream remote", this.props.repository.gitHubRepository),
        n = J("A repository must have a parent repository to add an upstream remote", t.parent),
        r = n.fullName,
        i = this.props.existingRemote.url,
        o = n.cloneURL;
      return w.createElement(Im, {
        title: "上游已经存在",
        onDismissed: this.props.onDismissed,
        onSubmit: this.onUpdate,
        type: "warning"
      }, w.createElement(Mm, null, w.createElement("p", null, "The repository ", w.createElement(lm, null, e), " is a fork of", " ", w.createElement(lm, null, r), ", but its ", w.createElement(lm, null, "upstream"), " ", "remote points elsewhere."), w.createElement("ul", null, w.createElement("li", null, "Current: ", w.createElement(lm, null, i)), w.createElement("li", null, "Expected: ", w.createElement(lm, null, o))), w.createElement("p", null, "Would you like to update the remote to use the expected URL?")), w.createElement(Lm, null, w.createElement(Nm, {
        destructive: !0,
        okButtonText: "更新",
        cancelButtonText: "忽略",
        onCancelButtonClick: this.onIgnore
      })))
    }
  }
  const lw = new Xi("", -1, {
      dbID: null,
      name: "desktop",
      owner: {
        id: null,
        login: "desktop",
        endpoint: pt(),
        hash: ""
      },
      isPrivate: !1,
      parent: null,
      htmlURL: "https://github.com/desktop/desktop",
      defaultBranch: "master",
      cloneURL: "https://github.com/desktop/desktop",
      endpoint: pt(),
      fullName: "desktop/desktop",
      fork: !1,
      hash: "",
      issuesEnabled: null,
      isArchived: !1,
      permissions: null
    }, !0),
    cw = Mc(__dirname, "static/release-note-header-left.svg"),
    uw = Mc(__dirname, "static/release-note-header-right.svg");
  class hw extends w.Component {
    constructor() {
      super(...arguments), this.updateNow = () => {
        ke.quitAndInstallUpdate()
      }, this.showAllReleaseNotes = () => {
        ee.openExternal(xy)
      }
    }
    renderList(e, t) {
      if (0 === e.length) return null;
      const n = new Array;
      for (const [t, r] of e.entries()) n.push(w.createElement("li", {
        key: t
      }, w.createElement(rf, {
        text: r.message,
        emoji: this.props.emoji,
        renderUrlsAsLinks: !0,
        repository: lw
      })));
      return w.createElement("div", {
        className: "section"
      }, w.createElement("p", {
        className: "header"
      }, w.createElement("strong", null, t)), w.createElement("ul", {
        className: "entries"
      }, n))
    }
    drawSingleColumnLayout(e) {
      return w.createElement("div", {
        className: "container"
      }, w.createElement("div", {
        className: "column"
      }, this.renderList(e.bugfixes, "Bugfixes"), this.renderList(e.enhancements, "Enhancements"), this.renderList(e.other, "Other")))
    }
    drawTwoColumnLayout(e) {
      return w.createElement("div", {
        className: "container"
      }, w.createElement("div", {
        className: "column"
      }, this.renderList(e.enhancements, "Enhancements"), this.renderList(e.other, "Other")), w.createElement("div", {
        className: "column"
      }, this.renderList(e.bugfixes, "Bugfixes")))
    }
    render() {
      const e = this.props.newRelease,
        t = e.enhancements.length > 0 && e.bugfixes.length > 0 ? this.drawTwoColumnLayout(e) : this.drawSingleColumnLayout(e),
        n = w.createElement("div", {
          className: "release-notes-header"
        }, w.createElement("img", {
          className: "release-note-graphic-left",
          src: cw
        }), w.createElement("div", {
          className: "title"
        }, w.createElement("p", {
          className: "version"
        }, "Version ", e.latestVersion), w.createElement("p", {
          className: "date"
        }, e.datePublished)), w.createElement("img", {
          className: "release-note-graphic-right",
          src: uw
        }));
      return w.createElement(Im, {
        id: "release-notes",
        onDismissed: this.props.onDismissed,
        onSubmit: this.updateNow,
        title: n
      }, w.createElement(Mm, null, t), w.createElement(Lm, null, w.createElement(Ip, {
        onClick: this.showAllReleaseNotes
      }, "查看所有发行说明"), w.createElement(Nm, {
        destructive: !0,
        okButtonText: "安装并重新启动",
        cancelButtonText: "关闭"
      })))
    }
  }
  class pw extends w.Component {
    constructor() {
      super(...arguments), this.openPullRequest = () => {
        this.props.dispatcher.showPullRequest(this.props.repository)
      }, this.deleteBranch = () => (this.props.dispatcher.deleteBranch(this.props.repository, this.props.branch, !1), this.props.onDismissed())
    }
    render() {
      return w.createElement(Im, {
        id: "delete-branch",
        title: "删除分支",
        type: "warning",
        onDismissed: this.props.onDismissed,
        onSubmit: this.deleteBranch
      }, w.createElement(Mm, null, w.createElement("p", null, "此分支可能有一个与之相关联的打开请求."), w.createElement("p", null, "If", " ", w.createElement(Ip, {
        onClick: this.openPullRequest
      }, "#", this.props.pullRequest.pullRequestNumber), " ", "已经合并，也可以到GitHub删除远程分支")), w.createElement(Lm, null, w.createElement(Nm, {
        destructive: !0,
        okButtonText: "删除"
      })))
    }
  }

  function dw(e) {
    const t = 1 === e ? "1 conflicted file" : e + " conflicted files";
    return w.createElement("h3", {
      className: "summary"
    }, t)
  }

  function fw() {
    return w.createElement("div", {
      className: "all-conflicts-resolved"
    }, w.createElement("div", {
      className: "green-circle"
    }, w.createElement(bh, {
      symbol: Sh.check
    })), w.createElement("div", {
      className: "message"
    }, "All conflicts resolved"))
  }

  function mw(e) {
    return w.createElement("div", null, w.createElement(Ip, {
      onClick: e
    }, "在命令行中打开,"), " ", "您选择的工具，或关闭手动解决。")
  }
  const gw = e => so(e.status) && jl(e.status, e.manualResolution) ? bw({
      path: e.path,
      status: e.status,
      resolvedExternalEditor: e.resolvedExternalEditor,
      onOpenEditorClick: () => e.openFileInExternalEditor(Object(i.join)(e.repository.path, e.path)),
      repository: e.repository,
      dispatcher: e.dispatcher,
      ourBranch: e.ourBranch,
      theirBranch: e.theirBranch
    }) : ao(e.status) && jl(e.status, e.manualResolution) ? vw({
      path: e.path,
      status: e.status,
      repository: e.repository,
      dispatcher: e.dispatcher,
      ourBranch: e.ourBranch,
      theirBranch: e.theirBranch
    }) : yw({
      path: e.path,
      status: e.status,
      repository: e.repository,
      dispatcher: e.dispatcher,
      manualResolution: e.manualResolution,
      branch: xw(e.manualResolution, e.ourBranch, e.theirBranch)
    }),
    yw = e => w.createElement("li", {
      key: e.path,
      className: "unmerged-file-status-resolved"
    }, w.createElement(bh, {
      symbol: Sh.fileCode,
      className: "file-octicon"
    }), w.createElement("div", {
      className: "column-left"
    }, w.createElement($d, {
      path: e.path
    }), kw({
      path: e.path,
      status: e.status,
      branch: e.branch,
      manualResolution: e.manualResolution,
      repository: e.repository,
      dispatcher: e.dispatcher
    })), w.createElement("div", {
      className: "green-circle"
    }, w.createElement(bh, {
      symbol: Sh.check
    }))),
    vw = e => {
      const t = Sw(e.path, e.status, e.repository, e.dispatcher, e.ourBranch, e.theirBranch),
        n = w.createElement(w.Fragment, null, w.createElement("div", {
          className: "column-left"
        }, w.createElement($d, {
          path: e.path
        }), w.createElement("div", {
          className: "file-conflicts-status"
        }, Tw)), w.createElement("div", {
          className: "action-buttons"
        }, w.createElement(jp, {
          className: "small-button button-group-item resolve-arrow-menu",
          onClick: t
        }, "Resolve", w.createElement(bh, {
          symbol: Sh.triangleDown
        }))));
      return ww(e.path, n)
    };

  function ww(e, t) {
    return w.createElement("li", {
      key: e,
      className: "unmerged-file-status-conflicts"
    }, w.createElement(bh, {
      symbol: Sh.fileCode,
      className: "file-octicon"
    }), t)
  }
  const bw = e => {
      const t = (n = e.status.conflictMarkerCount, Math.ceil(n / 3));
      var n;
      const r = 1 === t ? "1 conflict" : t + " conflicts",
        i = null === e.resolvedExternalEditor,
        o = function (e) {
          if (null !== e) return;
          return "No editor configured in Options > Advanced"
        }(e.resolvedExternalEditor),
        s = Cw(e.path, e.repository, e.dispatcher, e.status, e.ourBranch, e.theirBranch),
        a = w.createElement(w.Fragment, null, w.createElement("div", {
          className: "column-left"
        }, w.createElement($d, {
          path: e.path
        }), w.createElement("div", {
          className: "file-conflicts-status"
        }, r)), w.createElement("div", {
          className: "action-buttons"
        }, w.createElement(jp, {
          onClick: e.onOpenEditorClick,
          disabled: i,
          tooltip: o,
          className: "small-button button-group-item"
        }, "用" + (e.resolvedExternalEditor || "编辑器"+"打开")), w.createElement(jp, {
          onClick: s,
          className: "small-button button-group-item arrow-menu"
        }, w.createElement(bh, {
          symbol: Sh.triangleDown
        }))));
      return ww(e.path, a)
    },
    Sw = (e, t, n, r, i, o) => () => {
      ie(Ew(e, n, r, t, i, o))
    },
    Cw = (e, t, n, o, s, a) => () => {
      const l = Object(i.join)(t.path, e);
      ie([{
        label: "Open with default program",
        action: () => af(l, n)
      }, {
        label: "Show in Explorer",
        action: () => r.shell.showItemInFolder(l)
      }, {
        type: "separator"
      }, ...Ew(e, t, n, o, s, a)])
    };

  function Ew(e, t, n, r, i, o) {
    return [{
      label: $l(r.entry.us, i),
      action: () => n.updateManualConflictResolution(t, e, Ta.ours)
    }, {
      label: $l(r.entry.them, o),
      action: () => n.updateManualConflictResolution(t, e, Ta.theirs)
    }]
  }
  const kw = e => {
    if (so(e.status) && 0 === e.status.conflictMarkerCount) return w.createElement("div", {
      className: "file-conflicts-status"
    }, "No conflicts remaining");
    const t = function (e, t, n) {
      return t === Ta.ours ? Gl(e.entry.us, n) : t === Ta.theirs ? Gl(e.entry.them, n) : "No conflicts remaining"
    }(e.status, e.manualResolution, e.branch);
    return w.createElement("div", {
      className: "file-conflicts-status"
    }, t, " ", w.createElement(Ip, {
      onClick: (n = e.path, r = e.repository, i = e.dispatcher, () => i.updateManualConflictResolution(r, n, null))
    }, "Undo"));
    var n, r, i
  };

  function xw(e, t, n) {
    return e === Ta.ours ? t : e === Ta.theirs ? n : void 0
  }
  const Tw = "Manual conflict";
  class Rw extends w.Component {
    constructor() {
      super(...arguments), this.onSubmit = async () => {
        await this.props.dispatcher.finishConflictedMerge(this.props.repository, this.props.workingDirectory, {
          type: lu.SuccessfulMerge,
          ourBranch: this.props.ourBranch,
          theirBranch: this.props.theirBranch
        }), this.props.dispatcher.setCommitMessage(this.props.repository, Nc), this.props.dispatcher.changeRepositorySection(this.props.repository, j.Changes), this.props.onDismissed(), this.props.dispatcher.recordGuidedConflictedMergeCompletion()
      }, this.onCancel = async e => {
        e.preventDefault();
        Yl(this.props.workingDirectory, this.props.manualResolutions).length > 0 ? (this.props.onDismissed(), this.props.dispatcher.showPopup({
          type: Zi.AbortMerge,
          repository: this.props.repository,
          ourBranch: this.props.ourBranch,
          theirBranch: this.props.theirBranch
        })) : (await this.props.dispatcher.abortMerge(this.props.repository), this.props.onDismissed())
      }, this.onDismissed = async () => {
        this.props.onDismissed(), this.props.dispatcher.setBanner({
          type: lu.MergeConflictsFound,
          ourBranch: this.props.ourBranch,
          popup: {
            type: Zi.MergeConflicts,
            ourBranch: this.props.ourBranch,
            theirBranch: this.props.theirBranch,
            repository: this.props.repository
          }
        }), this.props.dispatcher.recordMergeConflictsDialogDismissal();
        Ql(this.props.workingDirectory, this.props.manualResolutions).length > 0 && this.props.dispatcher.recordAnyConflictsLeftOnMergeConflictsDialogDismissal()
      }, this.openThisRepositoryInShell = () => this.props.openRepositoryInShell(this.props.repository)
    }
    renderHeaderTitle(e, t) {
      return void 0 !== t ? w.createElement("span", null, "Resolve conflicts before merging ", w.createElement("strong", null, t), " into ", w.createElement("strong", null, e)) : w.createElement("span", null, "Resolve conflicts before merging into ", w.createElement("strong", null, e))
    }
    renderUnmergedFiles(e) {
      return w.createElement("ul", {
        className: "unmerged-file-statuses"
      }, e.map(e => Wl(e.status) ? gw({
        path: e.path,
        status: e.status,
        resolvedExternalEditor: this.props.resolvedExternalEditor,
        openFileInExternalEditor: this.props.openFileInExternalEditor,
        repository: this.props.repository,
        dispatcher: this.props.dispatcher,
        manualResolution: this.props.manualResolutions.get(e.path),
        ourBranch: this.props.ourBranch,
        theirBranch: this.props.theirBranch
      }) : null))
    }
    renderContent(e, t) {
      return 0 === e.length ? fw() : w.createElement(w.Fragment, null, dw(t), this.renderUnmergedFiles(e), mw(this.openThisRepositoryInShell))
    }
    render() {
      const e = ql(this.props.workingDirectory),
        t = Ql(this.props.workingDirectory, this.props.manualResolutions).length,
        n = this.renderHeaderTitle(this.props.ourBranch, this.props.theirBranch),
        r = t > 0 ? "合并前解决所有更改" : void 0;
      return w.createElement(Im, {
        id: "merge-conflicts-list",
        dismissable: !0,
        onDismissed: this.onDismissed,
        onSubmit: this.onSubmit,
        title: n
      }, w.createElement(Mm, null, this.renderContent(e, t)), w.createElement(Lm, null, w.createElement(Nm, {
        okButtonText: "提交合并",
        okButtonDisabled: t > 0,
        okButtonTitle: r,
        cancelButtonText: "中止合并",
        onCancelButtonClick: this.onCancel
      })))
    }
  }
  class Dw extends w.Component {
    constructor() {
      super(...arguments), this.onCancel = () => {
        this.props.onDismissed()
      }, this.onSubmit = async () => {
        this.props.onDismissed(), await this.props.dispatcher.commitIncludedChanges(this.props.repository, this.props.context), this.props.dispatcher.clearBanner(), this.props.dispatcher.setCommitMessage(this.props.repository, Nc)
      }
    }
    renderFiles(e) {
      return w.createElement("div", {
        className: "conflicted-files-text"
      }, w.createElement("ul", null, e.map(e => w.createElement("li", {
        key: e.path
      }, w.createElement($d, {
        path: e.path
      })))))
    }
    render() {
      return w.createElement(Im, {
        id: "commit-conflict-markers-warning",
        onDismissed: this.onCancel,
        onSubmit: this.onSubmit,
        title: "确认提交冲突文件",
        type: "warning"
      }, w.createElement(Mm, null, w.createElement("p", null, "如果选择提交，则将把以下冲突文件提交到存储库中:"), this.renderFiles(this.props.files), w.createElement("p", null, "Are you sure you want to commit these conflicted files?")), w.createElement(Lm, null, w.createElement(Nm, {
        destructive: !0,
        okButtonText: "是的，提交文件"
      })))
    }
  }
  class _w extends w.PureComponent {
    componentDidMount() {
      this.ensureTheme()
    }
    componentDidUpdate() {
      this.ensureTheme()
    }
    componentWillUnmount() {
      this.clearThemes()
    }
    ensureTheme() {
      const e = "theme-" + di(this.props.theme),
        t = document.body;
      t.classList.contains(e) || (this.clearThemes(), t.classList.add(e))
    }
    clearThemes() {
      const e = document.body;
      for (const t of e.classList) t.startsWith("theme-") && e.classList.remove(t)
    }
    render() {
      return null
    }
  }
  class Aw extends w.Component {
    constructor() {
      super(...arguments), this.onSubmit = async () => {
        await this.props.dispatcher.abortMerge(this.props.repository), this.props.onDismissed()
      }, this.onCancel = () => {
        this.props.onDismissed(), this.props.dispatcher.showPopup({
          type: Zi.MergeConflicts,
          repository: this.props.repository,
          ourBranch: this.props.ourBranch,
          theirBranch: this.props.theirBranch
        })
      }
    }
    renderTextContent(e, t) {
      let n;
      return n = void 0 !== t ? w.createElement("p", null, "是否确实要中止合并 ", w.createElement("strong", null, t), " 进 ", w.createElement("strong", null, e), "?") : w.createElement("p", null, "是否确实要中止合并到 ", w.createElement("strong", null, e), "?"), w.createElement("div", {
        className: "column-left"
      }, n, w.createElement("p", null, "中止此合并将使您返回到预合并状态，并且已解决的冲突仍将存在."))
    }
    render() {
      return w.createElement(Im, {
        id: "abort-merge-warning",
        title: "确认中止合并",
        onDismissed: this.onCancel,
        onSubmit: this.onSubmit,
        type: "warning"
      }, w.createElement(Mm, null, this.renderTextContent(this.props.ourBranch, this.props.theirBranch)), w.createElement(Lm, null, w.createElement(Nm, {
        destructive: !0,
        okButtonText: "中止合并"
      })))
    }
  }
  class Mw extends w.Component {
    constructor(e) {
      super(e), this.onSubmit = async () => {
        this.props.onDismissed(), await this.props.dispatcher.commitIncludedChanges(this.props.repository, this.props.context), this.props.dispatcher.setCommitMessage(this.props.repository, Nc)
      }
    }
    render() {
      return w.createElement(Im, {
        id: "oversized-files",
        title: "Files too large",
        onSubmit: this.onSubmit,
        onDismissed: this.props.onDismissed,
        type: "warning"
      }, w.createElement(Mm, null, w.createElement("p", null, "The following files are over 100MB.", " ", w.createElement("strong", null, "If you commit these files, you will no longer be able to push this repository to GitHub.com.")), this.renderFileList(), w.createElement("p", {
        className: "recommendation"
      }, "We recommend you avoid committing these files or use", " ", w.createElement(Ip, {
        uri: "https://help.github.com/articles/versioning-large-files/"
      }, "Git LFS"), " to store large files on GitHub.")), w.createElement(Lm, null, w.createElement(Nm, {
        destructive: !0,
        okButtonText: "Commit anyway"
      })))
    }
    renderFileList() {
      return w.createElement("div", {
        className: "files-list"
      }, w.createElement("ul", null, this.props.oversizedFiles.map(e => w.createElement("li", {
        key: e
      }, w.createElement($d, {
        path: e
      })))))
    }
  }
  class Pw extends w.Component {
    constructor(e) {
      super(e), this.onReportingOptOutChanged = e => {
        const t = !e.currentTarget.checked;
        this.setState({
          optOutOfUsageTracking: t
        })
      }, this.onDismissed = () => {
        this.props.onSetStatsOptOut(this.state.optOutOfUsageTracking), this.props.onDismissed()
      }, this.viewMoreInfo = e => {
        e.preventDefault(), this.props.onOpenUsageDataUrl()
      }, this.state = {
        optOutOfUsageTracking: !1
      }
    }
    render() {
      return w.createElement(Im, {
        id: "usage-reporting",
        title: "Usage reporting changes",
        dismissable: !1,
        onDismissed: this.onDismissed,
        onSubmit: this.onDismissed,
        type: "normal"
      }, w.createElement(Mm, null, w.createElement(Lp, null, "GitHub Desktop has introduced a change around how it reports usage stats, to help us better understand how our GitHub users get value from Desktop:"), w.createElement(Lp, null, w.createElement("ul", null, w.createElement("li", null, w.createElement("span", null, w.createElement("strong", null, "If you are signed into a GitHub account"), ", your GitHub.com account ID will be included in the periodic usage stats.")), w.createElement("li", null, w.createElement("span", null, w.createElement("strong", null, "If you are only signed into a GitHub Enterprise Server account, or only using Desktop with non-GitHub remotes"), ", nothing is going to change.")))), w.createElement(Lp, {
        className: "selection"
      }, w.createElement(Xp, {
        label: "Help GitHub Desktop improve by submitting usage stats",
        value: this.state.optOutOfUsageTracking ? Zp.Off : Zp.On,
        onChange: this.onReportingOptOutChanged
      }))), w.createElement(Lm, null, w.createElement(Nm, {
        okButtonText: "Continue",
        cancelButtonText: "More info",
        onCancelButtonClick: this.viewMoreInfo
      })))
    }
  }
  class Iw extends w.Component {
    constructor(e) {
      super(e), this.onFetch = async () => {
        this.setState({
          isLoading: !0
        }), await this.props.dispatcher.fetch(this.props.repository, Li.UserInitiatedTask), this.setState({
          isLoading: !1
        }), this.props.onDismissed()
      }, this.state = {
        isLoading: !1
      }
    }
    render() {
      return w.createElement(Im, {
        title: "Newer commits on remote",
        dismissable: !this.state.isLoading,
        disabled: this.state.isLoading,
        onDismissed: this.props.onDismissed,
        onSubmit: this.onFetch,
        loading: this.state.isLoading,
        type: "warning"
      }, w.createElement(Mm, null, w.createElement("p", null, "Desktop is unable to push commits to this branch because there are commits on the remote that are not present on your local branch. Fetch these new commits before pushing in order to reconcile them with your local commits.")), w.createElement(Lm, null, w.createElement(Nm, {
        okButtonText: "Fetch",
        okButtonDisabled: this.state.isLoading
      })))
    }
  }
  class Ow extends w.Component {
    constructor(e) {
      super(e), this.computingRebaseForBranch = null, this.onFilterTextChanged = e => {
        this.setState({
          filterText: e
        })
      }, this.onBranchChanged = async e => {
        const {
          currentBranch: t
        } = this.props;
        await this.updateRebaseStatus(e, t)
      }, this.onSelectionChanged = e => {
        this.setState({
          selectedBranch: e
        }), null !== e && this.onBranchChanged(e)
      }, this.renderBranch = (e, t) => ng(e, t, this.props.currentBranch), this.renderRebaseStatus = () => {
        const {
          currentBranch: e
        } = this.props, {
          selectedBranch: t,
          rebasePreview: n
        } = this.state;
        return null === n || null === t || e.name === t.name ? null : w.createElement("div", {
          className: "rebase-status-component"
        }, w.createElement(cg, {
          status: n,
          classNamePrefix: "rebase-status"
        }), w.createElement("p", {
          className: "rebase-message"
        }, this.renderRebaseDetails(e, t, n)))
      }, this.startRebase = async () => {
        const {
          selectedBranch: e,
          rebasePreview: t
        } = this.state, {
          repository: n,
          currentBranch: r
        } = this.props;
        e && null !== t && t.kind === al.Clean && this.props.dispatcher.startRebase(n, e, r, t.commits)
      };
      const {
        initialBranch: t,
        currentBranch: n,
        defaultBranch: r
      } = e, i = function (e, t, n) {
        if (void 0 !== n) return n;
        return e === t ? null : t
      }(n, r, t);
      this.state = {
        selectedBranch: i,
        rebasePreview: null,
        filterText: ""
      }
    }
    componentDidMount() {
      const {
        selectedBranch: e
      } = this.state;
      null !== e && this.onBranchChanged(e)
    }
    async updateRebaseStatus(e, t) {
      this.computingRebaseForBranch = e.name;
      const {
        repository: n
      } = this.props;
      this.setState({
        rebasePreview: {
          kind: al.Loading
        }
      });
      const {
        commits: r,
        base: i
      } = await Sc(async () => ({
        commits: await ja(n, e.tip.sha, t.tip.sha),
        base: await pl(n, e.tip.sha, t.tip.sha)
      }), 500);
      if (this.computingRebaseForBranch !== e.name) return;
      if (null === r) return void this.setState({
        rebasePreview: {
          kind: al.Invalid
        }
      });
      const o = i === e.tip.sha ? [] : r;
      this.setState({
        rebasePreview: {
          kind: al.Clean,
          commits: o
        }
      })
    }
    render() {
      const {
        selectedBranch: e,
        rebasePreview: t
      } = this.state, {
        currentBranch: n
      } = this.props, r = null === e || null === n || n.name === e.name, i = null === t || t.kind !== al.Clean || 0 === t.commits.length, o = r || i, s = r ? "You are not able to rebase this branch onto itself" : i ? "There are no commits on the current branch to rebase" : void 0, a = Gy(n.name, 40);
      return w.createElement(Im, {
        id: "rebase",
        onDismissed: this.props.onDismissed,
        onSubmit: this.startRebase,
        dismissable: !0,
        title: w.createElement(w.Fragment, null, "Rebase ", w.createElement("strong", null, a), "…")
      }, w.createElement(Mm, null, w.createElement(Vm, {
        allBranches: this.props.allBranches,
        currentBranch: n,
        defaultBranch: this.props.defaultBranch,
        recentBranches: this.props.recentBranches,
        filterText: this.state.filterText,
        onFilterTextChanged: this.onFilterTextChanged,
        selectedBranch: e,
        onSelectionChanged: this.onSelectionChanged,
        canCreateNewBranch: !1,
        renderBranch: this.renderBranch
      })), w.createElement(Lm, null, this.renderRebaseStatus(), w.createElement(Nm, {
        okButtonText: "Start rebase",
        okButtonDisabled: o,
        okButtonTitle: s,
        cancelButtonVisible: !1
      })))
    }
    renderRebaseDetails(e, t, n) {
      return n.kind === al.Loading ? this.renderLoadingRebaseMessage() : n.kind === al.Clean ? this.renderCleanRebaseMessage(e, t, n.commits.length) : n.kind === al.Invalid ? this.renderInvalidRebaseMessage() : null
    }
    renderLoadingRebaseMessage() {
      return w.createElement(w.Fragment, null, "Checking for ability to rebase automatically...")
    }
    renderInvalidRebaseMessage() {
      return w.createElement(w.Fragment, null, "Unable to start rebase. Check you have chosen a valid branch.")
    }
    renderCleanRebaseMessage(e, t, n) {
      if (n <= 0) return w.createElement(w.Fragment, null, "This branch is up to date with", " ", w.createElement("strong", null, e.name));
      const r = 1 === n ? "commit" : "commits";
      return w.createElement(w.Fragment, null, "This will update ", w.createElement("strong", null, e.name), " by applying its ", w.createElement("strong", null, ` ${n} ${r}`), " on top of ", w.createElement("strong", null, t.name))
    }
  }
  class Lw extends w.Component {
    constructor(e) {
      super(e), this.onCancel = e => {
        e.preventDefault(), this.setState({
          isAborting: !0
        }), this.props.onAbortRebase(this.props.step), this.setState({
          isAborting: !1
        })
      }, this.onDismissed = () => {
        this.props.onDismissed(), this.props.showRebaseConflictsBanner(this.props.step)
      }, this.onSubmit = async () => {
        this.props.onContinueRebase(this.props.step)
      }, this.openThisRepositoryInShell = () => this.props.openRepositoryInShell(this.props.repository), this.state = {
        isAborting: !1
      }
    }
    componentWillUnmount() {
      const {
        workingDirectory: e,
        step: t,
        userHasResolvedConflicts: n
      } = this.props, {
        conflictState: r
      } = t, {
        manualResolutions: i
      } = r;
      if (n) return;
      Yl(e, i).length > 0 && this.props.dispatcher.setConflictsResolved(this.props.repository)
    }
    renderHeaderTitle(e, t) {
      return void 0 !== t ? w.createElement("span", null, "Resolve conflicts before rebasing ", w.createElement("strong", null, e), " on ", w.createElement("strong", null, t)) : w.createElement("span", null, "Resolve conflicts before rebasing ", w.createElement("strong", null, e))
    }
    renderUnmergedFiles(e) {
      const {
        manualResolutions: t,
        targetBranch: n,
        baseBranch: r
      } = this.props.step.conflictState;
      return w.createElement("ul", {
        className: "unmerged-file-statuses"
      }, e.map(e => Wl(e.status) ? gw({
        path: e.path,
        status: e.status,
        resolvedExternalEditor: this.props.resolvedExternalEditor,
        openFileInExternalEditor: this.props.openFileInExternalEditor,
        repository: this.props.repository,
        dispatcher: this.props.dispatcher,
        manualResolution: t.get(e.path),
        theirBranch: n,
        ourBranch: r
      }) : null))
    }
    renderContent(e, t) {
      return 0 === e.length ? fw() : w.createElement(w.Fragment, null, dw(t), this.renderUnmergedFiles(e), mw(this.openThisRepositoryInShell))
    }
    render() {
      const {
        workingDirectory: e,
        step: t
      } = this.props, {
        manualResolutions: n,
        targetBranch: r,
        baseBranch: i
      } = t.conflictState, o = ql(e), s = Ql(e, n).length, a = this.renderHeaderTitle(r, i), l = s > 0 ? "Resolve all conflicts before continuing" : void 0;
      return w.createElement(Im, {
        id: "rebase-conflicts-list",
        onDismissed: this.onDismissed,
        title: a,
        onSubmit: this.onSubmit
      }, w.createElement(Mm, null, this.renderContent(o, s)), w.createElement(Lm, null, w.createElement(Nm, {
        okButtonText: "Continue rebase",
        okButtonDisabled: s > 0,
        okButtonTitle: l,
        cancelButtonText: "Abort rebase",
        cancelButtonDisabled: this.state.isAborting,
        onCancelButtonClick: this.onCancel
      })))
    }
  }
  class Nw extends w.Component {
    constructor() {
      super(...arguments), this.onDismissed = () => {}
    }
    render() {
      const {
        rebasedCommitCount: e,
        totalCommitCount: t,
        value: n,
        currentCommitSummary: r
      } = this.props.progress, i = e <= 1 ? 1 : e, o = gl(n);
      return w.createElement(Im, {
        dismissable: !1,
        onDismissed: this.onDismissed,
        id: "rebase-progress",
        title: "Rebase in progress"
      }, w.createElement(Mm, null, w.createElement("div", null, w.createElement("progress", {
        value: o
      }), w.createElement("div", {
        className: "details"
      }, w.createElement("div", {
        className: "green-circle"
      }, w.createElement(bh, {
        symbol: Sh.check
      })), w.createElement("div", {
        className: "summary"
      }, w.createElement("div", {
        className: "message"
      }, "Commit ", i, " of ", t), w.createElement("div", {
        className: "detail"
      }, w.createElement(rf, {
        emoji: this.props.emoji,
        text: r || ""
      })))))))
    }
  }
  class Fw extends w.Component {
    constructor(e) {
      super(e), this.onSubmit = async () => {
        this.setState({
          isAborting: !0
        }), await this.props.onConfirmAbort(), this.setState({
          isAborting: !1
        })
      }, this.onCancel = async () => {
        await this.props.onReturnToConflicts(this.props.step)
      }, this.state = {
        isAborting: !1
      }
    }
    renderTextContent(e, t) {
      let n;
      return n = void 0 !== t ? w.createElement("p", null, "Are you sure you want to abort rebasing ", w.createElement(lm, null, t), " onto ", w.createElement(lm, null, e), "?") : w.createElement("p", null, "Are you sure you want to abort rebasing ", w.createElement(lm, null, e), "?"), w.createElement("div", {
        className: "column-left"
      }, n, w.createElement("p", null, "Aborting this rebase will take you back to the original branch state and and the conflicts you have already resolved will be discarded."))
    }
    render() {
      const {
        targetBranch: e,
        baseBranch: t
      } = this.props.step.conflictState;
      return w.createElement(Im, {
        id: "abort-merge-warning",
        title: "Confirm abort rebase",
        onDismissed: this.onCancel,
        onSubmit: this.onSubmit,
        disabled: this.state.isAborting,
        type: "warning"
      }, w.createElement(Mm, null, this.renderTextContent(e, t)), w.createElement(Lm, null, w.createElement(Nm, {
        destructive: !0,
        okButtonText: "Abort rebase"
      })))
    }
  }
  class Bw extends w.Component {
    constructor(e) {
      super(e), this.onAskForConfirmationOnForcePushChanged = e => {
        const t = !e.currentTarget.checked;
        this.setState({
          askForConfirmationOnForcePush: t
        })
      }, this.onBeginRebase = async () => {
        this.props.dispatcher.setConfirmForcePushSetting(this.state.askForConfirmationOnForcePush);
        const {
          baseBranch: e,
          targetBranch: t,
          commits: n
        } = this.props.step;
        await this.props.dispatcher.startRebase(this.props.repository, e, t, n, {
          continueWithForcePush: !0
        })
      }, this.state = {
        askForConfirmationOnForcePush: e.askForConfirmationOnForcePush
      }
    }
    render() {
      const {
        baseBranch: e,
        targetBranch: t
      } = this.props.step;
      return w.createElement(Im, {
        title: "Rebase will require force push",
        onDismissed: this.props.onDismissed,
        onSubmit: this.onBeginRebase,
        dismissable: !1,
        type: "warning"
      }, w.createElement(Mm, null, w.createElement("p", null, "Are you sure you want to rebase ", w.createElement(lm, null, t.name), " onto", " ", w.createElement(lm, null, e.name), "?"), w.createElement("p", null, "At the end of the rebase flow, GitHub Desktop will enable you to force push the branch to update the upstream branch. Force pushing will alter the history on the remote and potentially cause problems for others collaborating on this branch."), w.createElement("div", null, w.createElement(Xp, {
        label: "Do not show this message again",
        value: this.state.askForConfirmationOnForcePush ? Zp.Off : Zp.On,
        onChange: this.onAskForConfirmationOnForcePushChanged
      }))), w.createElement(Lm, null, w.createElement(Nm, {
        okButtonText: "Begin rebase",
        onCancelButtonClick: this.props.onDismissed
      })))
    }
  }
  class Hw extends w.Component {
    constructor() {
      super(...arguments), this.moveToShowConflictedFileState = e => {
        const {
          conflictState: t
        } = e;
        this.props.dispatcher.setRebaseFlowStep(this.props.repository, {
          kind: "ShowConflicts",
          conflictState: t
        })
      }, this.onContinueRebase = async e => {
        const {
          conflictState: t
        } = e;
        this.props.dispatcher.setRebaseFlowStep(this.props.repository, {
          kind: "ShowProgress",
          rebaseAction: () => this.props.dispatcher.continueRebase(this.props.repository, this.props.workingDirectory, t)
        })
      }, this.showRebaseConflictsBanner = e => {
        this.props.dispatcher.setRebaseFlowStep(this.props.repository, {
          kind: "HideConflicts"
        });
        const {
          targetBranch: t
        } = e.conflictState;
        this.props.onShowRebaseConflictsBanner(this.props.repository, t)
      }, this.onConfirmAbortRebase = e => {
        const {
          workingDirectory: t,
          userHasResolvedConflicts: n
        } = this.props, {
          conflictState: r
        } = e, {
          manualResolutions: i
        } = r;
        if (n) return void this.props.dispatcher.setRebaseFlowStep(this.props.repository, {
          kind: "ConfirmAbort",
          conflictState: r
        });
        Yl(t, i).length > 0 ? this.props.dispatcher.setRebaseFlowStep(this.props.repository, {
          kind: "ConfirmAbort",
          conflictState: r
        }) : this.onAbortRebase()
      }, this.onAbortRebase = async () => {
        await this.props.dispatcher.abortRebase(this.props.repository), this.onFlowEnded()
      }, this.onFlowEnded = () => {
        this.props.onDismissed(), this.props.onFlowEnded(this.props.repository)
      }
    }
    render() {
      const {
        step: e
      } = this.props;
      switch (e.kind) {
        case "ChooseBranch": {
          const {
            repository: t,
            dispatcher: n
          } = this.props, {
            allBranches: r,
            defaultBranch: i,
            currentBranch: o,
            recentBranches: s,
            initialBranch: a
          } = e;
          return w.createElement(Ow, {
            key: "choose-branch",
            repository: t,
            dispatcher: n,
            allBranches: r,
            defaultBranch: i,
            recentBranches: s,
            currentBranch: o,
            initialBranch: a,
            onDismissed: this.onFlowEnded
          })
        }
        case "ShowProgress":
          const {
            progress: t, emoji: n
          } = this.props;
          return null === t ? (log.error("[RebaseFlow] progress is null despite trying to show the progress view. Skipping rendering..."), null) : w.createElement(Nw, {
            progress: t,
            emoji: n
          });
        case "ShowConflicts": {
          const {
            repository: t,
            resolvedExternalEditor: n,
            openFileInExternalEditor: r,
            openRepositoryInShell: i,
            dispatcher: o,
            workingDirectory: s,
            userHasResolvedConflicts: a
          } = this.props;
          return w.createElement(Lw, {
            key: "view-conflicts",
            repository: t,
            dispatcher: o,
            step: e,
            showRebaseConflictsBanner: this.showRebaseConflictsBanner,
            workingDirectory: s,
            userHasResolvedConflicts: a,
            resolvedExternalEditor: n,
            openFileInExternalEditor: r,
            openRepositoryInShell: i,
            onAbortRebase: this.onConfirmAbortRebase,
            onDismissed: this.onFlowEnded,
            onContinueRebase: this.onContinueRebase
          })
        }
        case "ConfirmAbort":
          return w.createElement(Fw, {
            step: e,
            onConfirmAbort: this.onAbortRebase,
            onReturnToConflicts: this.moveToShowConflictedFileState
          });
        case "WarnForcePush":
          const {
            repository: r, dispatcher: i, askForConfirmationOnForcePush: o
          } = this.props;
          return w.createElement(Bw, {
            step: e,
            dispatcher: i,
            repository: r,
            askForConfirmationOnForcePush: o,
            onDismissed: this.onFlowEnded
          });
        case "HideConflicts":
        case "Completed":
          return null;
        default:
          return X(0, "Unknown rebase step found")
      }
    }
  }
  class zw extends w.Component {
    constructor(e) {
      super(e), this.onAskForConfirmationOnForcePushChanged = e => {
        const t = !e.currentTarget.checked;
        this.setState({
          askForConfirmationOnForcePush: t
        })
      }, this.onForcePush = async () => {
        this.props.dispatcher.setConfirmForcePushSetting(this.state.askForConfirmationOnForcePush), this.props.onDismissed(), await this.props.dispatcher.performForcePush(this.props.repository)
      }, this.state = {
        isLoading: !1,
        askForConfirmationOnForcePush: e.askForConfirmationOnForcePush
      }
    }
    render() {
      return w.createElement(Im, {
        title: "Are you sure you want to force push?",
        dismissable: !this.state.isLoading,
        onDismissed: this.props.onDismissed,
        onSubmit: this.onForcePush,
        type: "warning"
      }, w.createElement(Mm, null, w.createElement("p", null, "A force push will rewrite history on", " ", w.createElement(lm, null, this.props.upstreamBranch), ". Any collaborators working on this branch will need to reset their own local branch to match the history of the remote."), w.createElement("div", null, w.createElement(Xp, {
        label: "Do not show this message again",
        value: this.state.askForConfirmationOnForcePush ? Zp.Off : Zp.On,
        onChange: this.onAskForConfirmationOnForcePushChanged
      }))), w.createElement(Lm, null, w.createElement(Nm, {
        destructive: !0,
        okButtonText: "I'm sure"
      })))
    }
  }
  var Uw;
  ! function (e) {
    e[e.StashOnCurrentBranch = 0] = "StashOnCurrentBranch", e[e.MoveToNewBranch = 1] = "MoveToNewBranch"
  }(Uw || (Uw = {}));
  class Ww extends w.Component {
    constructor(e) {
      super(e), this.onSelectionChanged = e => {
        this.setState({
          selectedStashAction: e
        })
      }, this.onSubmit = async () => {
        const {
          repository: e,
          branchToCheckout: t,
          dispatcher: n,
          hasAssociatedStash: r
        } = this.props, {
          selectedStashAction: i
        } = this.state;
        if (i === Uw.StashOnCurrentBranch && r) return void n.showPopup({
          type: Zi.ConfirmOverwriteStash,
          repository: e,
          branchToCheckout: t
        });
        this.setState({
          isStashingChanges: !0
        });
        const o = Od("stash and checkout", e);
        try {
          i === Uw.StashOnCurrentBranch ? await n.checkoutBranch(e, t, pu) : i === Uw.MoveToNewBranch && await n.checkoutBranch(e, t, {
            kind: cu.MoveToNewBranch,
            transientStashEntry: null
          })
        } finally {
          o.done(), this.setState({
            isStashingChanges: !1
          }, () => {
            this.props.onDismissed()
          })
        }
      }, this.state = {
        isStashingChanges: !1,
        selectedStashAction: Uw.StashOnCurrentBranch,
        currentBranchName: e.currentBranch.name
      }
    }
    render() {
      const {
        isStashingChanges: e
      } = this.state;
      return w.createElement(Im, {
        id: "stash-changes",
        title: "Switch branch",
        onSubmit: this.onSubmit,
        onDismissed: this.props.onDismissed,
        loading: e,
        disabled: e
      }, w.createElement(Mm, null, this.renderStashActions(), this.renderStashOverwriteWarning()), w.createElement(Lm, null, w.createElement(Nm, {
        okButtonText: "Switch branch"
      })))
    }
    renderStashOverwriteWarning() {
      return this.props.hasAssociatedStash && this.state.selectedStashAction === Uw.StashOnCurrentBranch ? w.createElement(Lp, null, w.createElement(bh, {
        symbol: Sh.alert
      }), " Your current stash will be overwritten by creating a new stash") : null
    }
    renderStashActions() {
      const {
        branchToCheckout: e
      } = this.props, t = [{
        title: "Leave my changes on " + this.state.currentBranchName,
        description: "Your in-progress work will be stashed on this branch for you to return to later",
        key: Uw.StashOnCurrentBranch
      }, {
        title: "Bring my changes to " + e.name,
        description: "Your in-progress work will follow you to the new branch",
        key: Uw.MoveToNewBranch
      }];
      return w.createElement(Lp, null, w.createElement(Hy, {
        label: "You have changes on this branch. What would you like to do with them?",
        items: t,
        selectedKey: this.state.selectedStashAction,
        onSelectionChanged: this.onSelectionChanged
      }))
    }
  }
  class Vw extends w.Component {
    constructor(e) {
      super(e), this.onSubmit = async () => {
        const {
          dispatcher: e,
          repository: t,
          branchToCheckout: n,
          onDismissed: r
        } = this.props;
        this.setState({
          isLoading: !0
        });
        try {
          null !== n ? await e.checkoutBranch(t, n, pu) : await e.createStashForCurrentBranch(t, !1)
        } finally {
          this.setState({
            isLoading: !1
          })
        }
        r()
      }, this.state = {
        isLoading: !1
      }
    }
    render() {
      return w.createElement(Im, {
        id: "overwrite-stash",
        type: "warning",
        title: "Overwrite stash?",
        loading: this.state.isLoading,
        disabled: this.state.isLoading,
        onSubmit: this.onSubmit,
        onDismissed: this.props.onDismissed
      }, w.createElement(Mm, null, w.createElement(Lp, null, "Are you sure you want to proceed? This will overwrite your existing stash with your current changes.")), w.createElement(Lm, null, w.createElement(Nm, {
        destructive: !0,
        okButtonText: "Overwrite"
      })))
    }
  }
  class jw extends w.Component {
    constructor(e) {
      super(e), this.onSubmit = async () => {
        const {
          dispatcher: e,
          repository: t,
          stash: n,
          onDismissed: r
        } = this.props;
        this.setState({
          isDiscarding: !0
        });
        try {
          await e.dropStash(t, n)
        } finally {
          this.setState({
            isDiscarding: !1
          })
        }
        r()
      }, this.state = {
        isDiscarding: !1
      }
    }
    render() {
      return w.createElement(Im, {
        id: "discard-stash",
        type: "warning",
        title: "Discard stash?",
        loading: this.state.isDiscarding,
        disabled: this.state.isDiscarding,
        onSubmit: this.onSubmit,
        onDismissed: this.props.onDismissed
      }, w.createElement(Mm, null, w.createElement(Lp, null, "Are you sure you want to discard these stashed changes?")), w.createElement(Lm, null, w.createElement(Nm, {
        destructive: !0,
        okButtonText: "Discard"
      })))
    }
  }
  class Gw extends w.Component {
    constructor() {
      super(...arguments), this.onSubmit = () => this.props.onCreateTutorialRepository(this.props.account)
    }
    renderProgress() {
      const {
        progress: e
      } = this.props;
      if (void 0 === e) return null;
      const t = e.description ? w.createElement("div", {
        className: "description"
      }, e.description) : null;
      return w.createElement("div", {
        className: "progress-container"
      }, w.createElement("div", null, e.title), w.createElement("progress", {
        value: e.value
      }), t)
    }
    render() {
      const {
        account: e,
        progress: t
      } = this.props, n = void 0 !== t;
      return w.createElement(Im, {
        id: "create-tutorial-repository-dialog",
        title: "Start tutorial",
        onDismissed: this.props.onDismissed,
        onSubmit: this.onSubmit,
        dismissable: !n,
        loading: n,
        disabled: n
      }, w.createElement(Mm, null, w.createElement("div", null, "This will create a repository on your local machine, and push it to your account ", w.createElement(lm, null, "@", this.props.account.login), " on", " ", w.createElement(Ip, {
        uri: ht(e.endpoint)
      }, Ru(e)), ". This repository will only be visible to you, and not visible publicly."), this.renderProgress()), w.createElement(Lm, null, w.createElement(Nm, {
        okButtonText: "Continue"
      })))
    }
  }
  class $w extends w.Component {
    constructor(e) {
      super(e), this.onSignIn = async () => {
        this.setState({
          loading: !0
        }), await this.props.dispatcher.requestBrowserAuthenticationToDotcom(), this.props.dispatcher.push(this.props.repository), this.props.onDismissed()
      }, this.state = {
        loading: !1
      }
    }
    render() {
      return w.createElement(Im, {
        id: "workflow-push-rejected",
        title: "Push rejected",
        loading: this.state.loading,
        onDismissed: this.props.onDismissed,
        onSubmit: this.onSignIn,
        type: "error"
      }, w.createElement(Mm, null, w.createElement("p", null, "The push was rejected by the server for containing a modification to the workflow file ", w.createElement(lm, null, this.props.rejectedPath), ". In order to be able to push to workflow files GitHub Desktop needs to request additional permissions."), w.createElement("p", null, "Would you like to open a browser to grant GitHub Desktop permission to update workflow files?")), w.createElement(Lm, null, w.createElement(Nm, {
        okButtonText: "Continue in browser"
      })))
    }
  }
  class qw extends w.Component {
    constructor(e) {
      super(e), this.onSignIn = async () => {
        this.setState({
          loading: !0
        }), this.props.endpoint === pt() ? await this.props.dispatcher.beginDotComSignIn() : await this.props.dispatcher.beginEnterpriseSignIn(), await this.props.dispatcher.requestBrowserAuthentication(), void 0 !== this.props.retryAction && this.props.dispatcher.performRetry(this.props.retryAction), this.props.onDismissed()
      }, this.state = {
        loading: !1
      }
    }
    render() {
      return w.createElement(Im, {
        title: "Re-authorization required",
        loading: this.state.loading,
        onDismissed: this.props.onDismissed,
        onSubmit: this.onSignIn,
        type: "error"
      }, w.createElement(Mm, null, w.createElement("p", null, 'The "', this.props.organizationName, "\" organization has enabled or enforced SAML SSO. To access this repository, you must sign in again and grant GitHub Desktop permission to access the organization's repositories."), w.createElement("p", null, "Would you like to open a browser to grant GitHub Desktop permission to access the repository?")), w.createElement(Lm, null, w.createElement(Nm, {
        okButtonText: "Continue in browser"
      })))
    }
  }
  class Kw extends w.Component {
    constructor(e) {
      super(e), this.onSubmit = async () => {
        this.setState({
          loading: !0
        });
        const {
          gitHubRepository: e
        } = this.props.repository, t = at.fromAccount(this.props.account);
        try {
          const n = await t.forkRepository(e.owner.login, e.name);
          this.props.dispatcher.recordForkCreated();
          const r = await this.props.dispatcher.convertRepositoryToFork(this.props.repository, n);
          this.setState({
            loading: !1
          }), this.props.onDismissed(), eo(r) && this.props.dispatcher.showPopup({
            type: Zi.ChooseForkSettings,
            repository: r
          })
        } catch (e) {
          log.error(`Fork creation through API failed (${e})`), _u("forkCreation", e), this.setState({
            error: e,
            loading: !1
          })
        }
      }, this.state = {
        loading: !1
      }
    }
    render() {
      return w.createElement(Im, {
        title: "Do you want to fork this repository?",
        onDismissed: this.props.onDismissed,
        onSubmit: this.state.error ? void 0 : this.onSubmit,
        dismissable: !this.state.loading,
        loading: this.state.loading,
        type: this.state.error ? "error" : "normal",
        key: this.props.repository.name,
        id: "create-fork"
      }, void 0 !== this.state.error ? function (e, t, n) {
        const r = null !== e.gitHubRepository.htmlURL ? w.createElement(w.Fragment, null, "You can try ", w.createElement(Ip, {
          uri: e.gitHubRepository.htmlURL
        }, "creating the fork manually on GitHub"), ".") : void 0;
        return w.createElement(w.Fragment, null, w.createElement(Mm, null, w.createElement("div", null, "Creating your fork ", w.createElement("strong", null, `${t.login}/${e.gitHubRepository.name}`), " failed. ", r), w.createElement("details", null, w.createElement("summary", null, "Error details"), w.createElement("pre", {
          className: "error"
        }, n.message))), w.createElement(Fm, null))
      }(this.props.repository, this.props.account, this.state.error) : (e = this.props.repository, t = this.props.account, n = this.state.loading, w.createElement(w.Fragment, null, w.createElement(Mm, null, w.createElement("p", null, "It looks like you don’t have write access to ", w.createElement("strong", null, e.gitHubRepository.fullName), ". If you should, please check with a repository administrator."), w.createElement("p", null, " Do you want to create a fork of this repository at ", w.createElement("strong", null, `${t.login}/${e.gitHubRepository.name}`), " to continue?")), w.createElement(Lm, null, w.createElement(Nm, {
        destructive: !0,
        okButtonText: "Fork this repository",
        okButtonDisabled: n,
        cancelButtonDisabled: n
      })))));
      var e, t, n
    }
  }
  class Yw extends w.Component {
    constructor(e) {
      super(e), this.onDisableRevocationChecks = async () => {
        this.setState({
          loading: !0
        }), await Oo("http.schannelCheckRevoke", "false"), this.props.onDismissed()
      }, this.state = {
        loading: !1
      }
    }
    render() {
      return w.createElement(Im, {
        title: "Certificate revocation check failed",
        loading: this.state.loading,
        onDismissed: this.props.onDismissed,
        onSubmit: this.onDisableRevocationChecks,
        type: "error"
      }, w.createElement(Mm, null, w.createElement("p", null, "Error when attempting to access '", this.props.url, "', unable to perform certificate revocation check. See the Event Viewer for more details."), w.createElement("p", null, "This error is common when accessing the Internet through a corporate proxy server or a debugging proxy that performs SSL inspection."), w.createElement("p", null, "Would you like to disable certificate revocation checks? You can change this at any time in options.")), w.createElement(Lm, null, w.createElement(Nm, {
        okButtonText: "Disable revocation checks"
      })))
    }
  }
  class Qw extends w.Component {
    constructor(e) {
      super(e), this.updateTagName = e => {
        this.setState({
          tagName: e
        })
      }, this.createTag = async () => {
        const e = this.state.tagName,
          t = this.props.repository;
        if (e.length > 0) {
          this.setState({
            isCreatingTag: !0
          });
          const n = Od("create tag", t);
          await this.props.dispatcher.createTag(t, e, this.props.targetCommitSha), n.done()
        }
      }, this.state = {
        tagName: e.initialName || "",
        isCreatingTag: !1
      }
    }
    render() {
      const e = this.getCurrentError(),
        t = null !== e || 0 === this.state.tagName.length;
      return w.createElement(Im, {
        id: "create-tag",
        title: "Create a tag",
        onSubmit: this.createTag,
        onDismissed: this.props.onDismissed,
        loading: this.state.isCreatingTag,
        disabled: this.state.isCreatingTag
      }, e && w.createElement(Om, null, e), w.createElement(Mm, null, w.createElement(Ig, {
        label: "Name",
        initialValue: this.props.initialName,
        onValueChange: this.updateTagName
      })), w.createElement(Lm, null, w.createElement(Nm, {
        okButtonText: "Create tag",
        okButtonDisabled: t
      })))
    }
    getCurrentError() {
      if (this.state.tagName.length > 245) return w.createElement(w.Fragment, null, "The tag name cannot be longer than ", 245, " characters");
      return this.props.localTags && this.props.localTags.has(this.state.tagName) ? w.createElement(w.Fragment, null, "A tag named ", w.createElement(lm, null, this.state.tagName), " already exists") : null
    }
  }
  class Zw extends w.Component {
    constructor(e) {
      super(e), this.DeleteTag = async () => {
        const {
          dispatcher: e,
          repository: t,
          tagName: n
        } = this.props;
        this.setState({
          isDeleting: !0
        }), await e.deleteTag(t, n), this.props.onDismissed()
      }, this.state = {
        isDeleting: !1
      }
    }
    render() {
      return w.createElement(Im, {
        id: "delete-tag",
        title: "Delete tag",
        type: "warning",
        onSubmit: this.DeleteTag,
        onDismissed: this.props.onDismissed,
        disabled: this.state.isDeleting,
        loading: this.state.isDeleting
      }, w.createElement(Mm, null, w.createElement("p", null, "Are you sure you want to delete the tag", " ", w.createElement(lm, null, this.props.tagName), "?")), w.createElement(Lm, null, w.createElement(Nm, {
        destructive: !0,
        okButtonText: "Delete"
      })))
    }
  }
  class Xw extends w.Component {
    constructor(e) {
      super(e), this.onSelectionChanged = e => {
        this.setState({
          forkContributionTarget: e
        })
      }, this.onSubmit = async () => {
        this.props.dispatcher.updateRepositoryWorkflowPreferences(this.props.repository, {
          forkContributionTarget: this.state.forkContributionTarget
        }), this.props.onDismissed()
      }, this.state = {
        forkContributionTarget: io(e.repository)
      }
    }
    render() {
      const e = [{
        title: "To contribute to the parent project",
        description: w.createElement(w.Fragment, null, "We will help you contribute to the", " ", w.createElement("strong", null, this.props.repository.gitHubRepository.parent.fullName), " ", "repository"),
        key: $i.Parent
      }, {
        title: "For my own purposes",
        description: w.createElement(w.Fragment, null, "We will help you contribute to the", " ", w.createElement("strong", null, this.props.repository.gitHubRepository.fullName), " ", "repository"),
        key: $i.Self
      }];
      return w.createElement(Im, {
        id: "fork-settings",
        title: "How are you planning to use this fork?",
        onSubmit: this.onSubmit,
        onDismissed: this.props.onDismissed
      }, w.createElement(Mm, null, w.createElement(Lp, null, w.createElement(Hy, {
        label: "You have changes on this branch. What would you like to do with them?",
        items: e,
        selectedKey: this.state.forkContributionTarget,
        onSelectionChanged: this.onSelectionChanged
      })), w.createElement(Lp, null, w.createElement(Zy, {
        repository: this.props.repository,
        forkContributionTarget: this.state.forkContributionTarget
      }))), w.createElement(Lm, null, w.createElement(Nm, {
        okButtonText: "Continue"
      })))
    }
  }
  class Jw extends w.Component {
    constructor(e) {
      super(e), this.discard = async () => {
        this.setState({
          isDiscardingSelection: !0
        }), await this.props.dispatcher.discardChangesFromSelection(this.props.repository, this.props.file.path, this.props.diff, this.props.selection), this.props.dispatcher.setConfirmDiscardChangesSetting(this.state.confirmDiscardSelection), this.props.onDismissed()
      }, this.onConfirmDiscardSelectionChanged = e => {
        const t = !e.currentTarget.checked;
        this.setState({
          confirmDiscardSelection: t
        })
      }, this.state = {
        isDiscardingSelection: !1,
        confirmDiscardSelection: !0
      }
    }
    getOkButtonLabel() {
      return "Discard changes"
    }
    render() {
      const e = this.state.isDiscardingSelection;
      return w.createElement(Im, {
        id: "discard-changes",
        title: "Confirm discard changes",
        onDismissed: this.props.onDismissed,
        onSubmit: this.discard,
        dismissable: !e,
        loading: e,
        disabled: e,
        type: "warning"
      }, w.createElement(Mm, null, w.createElement("p", null, "Are you sure you want to discard the selected changes to:"), w.createElement("ul", null, w.createElement("li", null, w.createElement($d, {
        path: this.props.file.path
      }))), w.createElement(Xp, {
        label: "Do not show this message again",
        value: this.state.confirmDiscardSelection ? Zp.Off : Zp.On,
        onChange: this.onConfirmDiscardSelectionChanged
      })), w.createElement(Lm, null, w.createElement(Nm, {
        destructive: !0,
        okButtonText: this.getOkButtonLabel()
      })))
    }
  }
  class eb extends w.Component {
    constructor(e) {
      super(e), this.onSubmit = async () => {
        this.props.hasExistingStash || (this.setState({
          stashingAndRetrying: !0
        }), await this.props.dispatcher.createStashForCurrentBranch(this.props.repository, !0), await this.props.dispatcher.performRetry(this.props.retryAction)), this.props.onDismissed()
      }, this.state = {
        stashingAndRetrying: !1
      }
    }
    render() {
      return w.createElement(Im, {
        title: "Error",
        loading: this.state.stashingAndRetrying,
        disabled: this.state.stashingAndRetrying,
        onDismissed: this.props.onDismissed,
        onSubmit: this.onSubmit,
        type: "error"
      }, w.createElement(Mm, null, w.createElement("p", null, "Unable to ", this.getRetryActionName(), " when changes are present on your branch."), this.renderStashText()), this.renderFooter())
    }
    renderStashText() {
      return this.props.hasExistingStash && !this.state.stashingAndRetrying ? null : w.createElement("p", null, "You can stash your changes now and recover them afterwards.")
    }
    renderFooter() {
      return this.props.hasExistingStash && !this.state.stashingAndRetrying ? w.createElement(Fm, null) : w.createElement(Lm, null, w.createElement(Nm, {
        okButtonText: "Stash changes and continue",
        okButtonTitle: "This will create a stash with your current changes. You can recover them by restoring the stash afterwards.",
        cancelButtonText: "Close"
      }))
    }
    getRetryActionName() {
      switch (this.props.retryAction.type) {
        case rc.Checkout:
          return "checkout";
        case rc.Pull:
          return "pull";
        case rc.Merge:
          return "merge";
        case rc.Rebase:
          return "rebase";
        case rc.Clone:
          return "clone";
        case rc.Fetch:
          return "fetch";
        case rc.Push:
          return "push";
        default:
          X(this.props.retryAction, "Unknown retryAction: " + this.props.retryAction)
      }
    }
  }
  const tb = {
      enter: 250,
      exit: 100
    },
    nb = {
      enter: 500,
      exit: 400
    };
  class rb extends w.Component {
    constructor(e) {
      super(e), this.loading = !0, this.lastKeyPressed = null, this.getOnPopupDismissedFn = $p(e => () => this.onPopupDismissed(e)), this.showAddLocalRepo = () => this.props.dispatcher.showPopup({
        type: Zi.AddRepository
      }), this.showCreateRepository = () => {
        this.props.dispatcher.showPopup({
          type: Zi.CreateRepository
        })
      }, this.showCloneRepo = e => {
        let t = null;
        return void 0 !== e && (this.props.dispatcher.changeCloneRepositoriesTab(Si.Generic), t = e), this.props.dispatcher.showPopup({
          type: Zi.CloneRepository,
          initialURL: t
        })
      }, this.showCreateTutorialRepositoryPopup = () => {
        const e = this.getDotComAccount() || this.getEnterpriseAccount();
        null !== e && this.props.dispatcher.showPopup({
          type: Zi.CreateTutorialRepository,
          account: e
        })
      }, this.onResumeTutorialRepository = () => {
        const e = this.getSelectedTutorialRepository();
        e && this.props.dispatcher.resumeTutorial(e)
      }, this.onWindowKeyDown = e => {
        if (!e.defaultPrevented && !this.isShowingModal) {
          if (xe())
            if ("Shift" === e.key && e.altKey) this.props.dispatcher.setAccessKeyHighlightState(!1);
            else if ("Alt" === e.key) {
            if (e.shiftKey) return;
            this.state.currentFoldout && this.state.currentFoldout.type === V.AppMenu && this.state.appMenuState.length > 1 && (this.props.dispatcher.setAppMenuState(e => e.withReset()), this.props.dispatcher.closeFoldout(V.AppMenu)), this.props.dispatcher.setAccessKeyHighlightState(!0)
          } else if (!e.altKey || e.ctrlKey || e.metaKey) e.altKey || this.props.dispatcher.setAccessKeyHighlightState(!1);
          else if (this.state.appMenuState.length) {
            const t = this.state.appMenuState[0].items,
              n = Ri(e.key, t);
            n && Ti(n) && ("submenuItem" === n.type ? (this.props.dispatcher.setAppMenuState(e => e.withReset().withSelectedItem(n).withOpenedMenu(n, !0)), this.props.dispatcher.showFoldout({
              type: V.AppMenu,
              enableAccessKeyNavigation: !0,
              openedWithAccessKey: !0
            })) : this.props.dispatcher.executeMenuItem(n), e.preventDefault())
          }
          this.lastKeyPressed = e.key
        }
      }, this.onWindowKeyUp = e => {
        e.defaultPrevented || xe() && "Alt" === e.key && (this.props.dispatcher.setAccessKeyHighlightState(!1), "Alt" === this.lastKeyPressed && (this.state.currentFoldout && this.state.currentFoldout.type === V.AppMenu ? (this.props.dispatcher.setAppMenuState(e => e.withReset()), this.props.dispatcher.closeFoldout(V.AppMenu)) : this.props.dispatcher.showFoldout({
          type: V.AppMenu,
          enableAccessKeyNavigation: !0,
          openedWithAccessKey: !1
        })))
      }, this.removeRepository = e => {
        e && (e instanceof Ai || e.missing ? this.props.dispatcher.removeRepositories([e], !1) : this.state.askForConfirmationOnRepositoryRemoval ? this.props.dispatcher.showPopup({
          type: Zi.RemoveRepository,
          repository: e
        }) : this.props.dispatcher.removeRepositories([e], !1))
      }, this.onConfirmRepoRemoval = (e, t) => this.props.dispatcher.removeRepositories([e], t), this.openCurrentRepositoryInShell = () => {
        const e = this.getRepository();
        e && this.openInShell(e)
      }, this.onMenuBarLostFocus = () => {
        this.props.dispatcher.closeFoldout(V.AppMenu), this.props.dispatcher.setAppMenuState(e => e.withReset())
      }, this.onPopupDismissed = e => this.props.dispatcher.closePopup(e), this.onContinueWithUntrustedCertificate = e => {
        ! function (e, t) {
          r.ipcRenderer.send("show-certificate-trust-dialog", {
            certificate: e,
            message: t
          })
        }(e, "Could not securely connect to the server, because its certificate is not trusted. Attackers might be trying to steal your information.\n\nTo connect unsafely, which may put your data at risk, you can “Always trust” the certificate and try again.")
      }, this.onUpdateAvailableDismissed = () => this.props.dispatcher.setUpdateBannerVisibility(!1), this.onExitTutorialToHomeScreen = () => {
        const e = this.getSelectedTutorialRepository();
        return !!e && (this.props.dispatcher.pauseTutorial(e), !0)
      }, this.onCreateTutorialRepository = e => {
        this.props.dispatcher.createTutorialRepository(e)
      }, this.onShowRebaseConflictsBanner = (e, t) => {
        this.props.dispatcher.setBanner({
          type: lu.RebaseConflictsFound,
          targetBranch: t,
          onOpenDialog: async () => {
            const {
              changesState: t
            } = this.props.repositoryStateManager.get(e), {
              conflictState: n
            } = t;
            if (null === n || "merge" === n.kind) return void log.debug("[App.onShowRebasConflictsBanner] no conflict state found, ignoring...");
            await this.props.dispatcher.setRebaseProgressFromState(e);
            const r = ml(n);
            this.props.dispatcher.setRebaseFlowStep(e, r), this.props.dispatcher.showPopup({
              type: Zi.RebaseFlow,
              repository: e
            })
          }
        })
      }, this.onRebaseFlowEnded = e => {
        this.props.dispatcher.endRebaseFlow(e)
      }, this.onSetStatsOptOut = e => {
        this.props.appStore.setStatsOptOut(e, !0), this.props.appStore.markUsageStatsNoteSeen(), this.props.appStore._reportStats()
      }, this.openUsageDataUrl = () => {
        this.props.dispatcher.openInBrowser(lh)
      }, this.onUpdateExistingUpstreamRemote = e => {
        this.props.dispatcher.updateExistingUpstreamRemote(e)
      }, this.onIgnoreExistingUpstreamRemote = e => {
        this.props.dispatcher.ignoreExistingUpstreamRemote(e)
      }, this.updateExistingLFSFilters = () => {
        this.props.dispatcher.installGlobalLFSFilters(!0)
      }, this.initializeLFS = e => {
        this.props.dispatcher.installLFSHooks(e)
      }, this.onCloneRepositoriesTabSelected = e => {
        this.props.dispatcher.changeCloneRepositoriesTab(e)
      }, this.onRefreshRepositories = e => {
        this.props.dispatcher.refreshApiRepositories(e)
      }, this.onShowAdvancedPreferences = () => {
        this.props.dispatcher.showPopup({
          type: Zi.Preferences,
          initialSelectedTab: dh.Advanced
        })
      }, this.onOpenShellIgnoreWarning = e => {
        this.props.dispatcher.openShell(e, !0)
      }, this.onSaveCredentials = async (e, t, n, r) => {
        await this.props.dispatcher.saveGenericGitCredentials(e, t, n), this.props.dispatcher.performRetry(r)
      }, this.onCheckForUpdates = () => this.checkForUpdates(!1), this.showAcknowledgements = () => {
        this.props.dispatcher.showPopup({
          type: Zi.Acknowledgements
        })
      }, this.showTermsAndConditions = () => {
        this.props.dispatcher.showPopup({
          type: Zi.TermsAndConditions
        })
      }, this.clearError = e => this.props.dispatcher.clearError(e), this.onConfirmDiscardChangesChanged = e => {
        this.props.dispatcher.setConfirmDiscardChangesSetting(e)
      }, this.onRetryAction = e => {
        this.props.dispatcher.performRetry(e)
      }, this.showPopup = e => {
        this.props.dispatcher.showPopup(e)
      }, this.renderRepositoryList = () => {
        const e = this.state.selectedState ? this.state.selectedState.repository : null,
          t = this.state.selectedExternalEditor ? this.state.selectedExternalEditor : void 0,
          n = this.state.selectedShell,
          r = this.state.repositoryFilterText;
        return w.createElement(Yp, {
          filterText: r,
          onFilterTextChanged: this.onRepositoryFilterTextChanged,
          selectedRepository: e,
          onSelectionChanged: this.onSelectionChanged,
          repositories: this.state.repositories,
          recentRepositories: this.state.recentRepositories,
          localRepositoryStateLookup: this.state.localRepositoryStateLookup,
          askForConfirmationOnRemoveRepository: this.state.askForConfirmationOnRepositoryRemoval,
          onRemoveRepository: this.removeRepository,
          onOpenInShell: this.openInShell,
          onShowRepository: this.showRepository,
          onOpenInExternalEditor: this.openInExternalEditor,
          externalEditorLabel: t,
          shellLabel: n,
          dispatcher: this.props.dispatcher
        })
      }, this.openInShell = e => {
        e instanceof Xi && this.props.dispatcher.openShell(e.path)
      }, this.openFileInExternalEditor = e => {
        this.props.dispatcher.openInExternalEditor(e)
      }, this.openInExternalEditor = e => {
        e instanceof Xi && this.props.dispatcher.openInExternalEditor(e.path)
      }, this.showRepository = e => {
        e instanceof Xi && ee.showFolderContents(e.path)
      }, this.onRepositoryDropdownStateChanged = e => {
        "open" === e ? this.props.dispatcher.showFoldout({
          type: V.Repository
        }) : this.props.dispatcher.closeFoldout(V.Repository)
      }, this.onExitTutorial = () => {
        1 === this.state.repositories.length && Cu(this.state.currentOnboardingTutorialStep) ? this.props.dispatcher.showPopup({
          type: Zi.ConfirmExitTutorial
        }) : this.onRepositoryDropdownStateChanged("open")
      }, this.showCreateBranch = () => {
        const e = this.state.selectedState;
        if (!e || e.type !== W.Repository) return;
        if (e.state.branchesState.tip.kind === Qi.Unknown) return;
        const t = e.repository,
          n = this.props.repositoryStateManager.get(t).changesState.currentBranchProtected;
        return this.props.dispatcher.showPopup({
          type: Zi.CreateBranch,
          repository: t,
          currentBranchProtected: n
        })
      }, this.openPullRequest = () => {
        const e = this.state.selectedState;
        if (null == e || e.type !== W.Repository) return;
        const t = e.state.branchesState.currentPullRequest,
          n = this.props.dispatcher;
        null == t ? (n.createPullRequest(e.repository), n.recordCreatePullRequest()) : n.showPullRequest(e.repository)
      }, this.openCreatePullRequestInBrowser = (e, t) => {
        this.props.dispatcher.openCreatePullRequestInBrowser(e, t)
      }, this.onBranchDropdownStateChanged = e => {
        "open" === e ? this.props.dispatcher.showFoldout({
          type: V.Branch
        }) : this.props.dispatcher.closeFoldout(V.Branch)
      }, this.onBannerDismissed = () => {
        this.props.dispatcher.clearBanner()
      }, this.onRepositoryFilterTextChanged = e => {
        this.props.dispatcher.setRepositoryFilterText(e)
      }, this.onSelectionChanged = e => {
        this.props.dispatcher.selectRepository(e), this.props.dispatcher.closeFoldout(V.Repository)
      }, this.onViewCommitOnGitHub = async e => {
        const t = this.getRepository();
        if (!t || t instanceof Ai || !t.gitHubRepository) return;
        const n = t.gitHubRepository.htmlURL;
        n && this.props.dispatcher.openInBrowser(`${n}/commit/${e}`)
      }, this.onBranchDeleted = e => {
        this.props.dispatcher.executeCompare(e, {
          kind: $.History
        })
      }, e.dispatcher.loadInitialState().then(() => {
        this.loading = !1, this.forceUpdate(), requestIdleCallback(() => {
          const t = performance.now();
          var n;
          n = t - e.startTime, r.ipcRenderer.send("renderer-ready", n), requestIdleCallback(() => {
            this.performDeferredLaunchActions()
          })
        }, {
          timeout: 100
        });
        const t = window.setTimeout(async () => {
          window.clearTimeout(t), await this.props.appStore.refreshAllSidebarIndicators(), this.updateIntervalHandle = window.setInterval(() => {
            this.props.appStore.refreshAllSidebarIndicators()
          }, 9e5)
        }, 12e4)
      }), this.state = e.appStore.getState(), e.appStore.onDidUpdate(e => {
        this.setState(e)
      }), e.appStore.onDidError(t => {
        e.dispatcher.postError(t)
      }), r.ipcRenderer.on("menu-event", (e, {
        name: t
      }) => {
        this.onMenuEvent(t)
      }), ke.onDidChange(e => {
        e.status === Ee.UpdateReady && this.props.dispatcher.setUpdateBannerVisibility(!0)
      }), ke.onError(e => {
        log.error("Error checking for updates", e), this.props.dispatcher.postError(e)
      }), r.ipcRenderer.on("launch-timing-stats", (e, {
        stats: t
      }) => {
        console.info(`App ready time: ${t.mainReadyTime}ms`), console.info(`Load time: ${t.loadTime}ms`), console.info(`Renderer ready time: ${t.rendererReadyTime}ms`), this.props.dispatcher.recordLaunchStats(t)
      }), r.ipcRenderer.on("certificate-error", (e, {
        certificate: t,
        error: n,
        url: r
      }) => {
        this.props.dispatcher.showPopup({
          type: Zi.UntrustedCertificate,
          certificate: t,
          url: r
        })
      })
    }
    get isShowingModal() {
      return null !== this.state.currentPopup || this.state.errors.length > 0
    }
    componentWillUnmount() {
      window.clearInterval(this.updateIntervalHandle)
    }
    performDeferredLaunchActions() {
      this.props.appStore.loadEmoji(), this.props.dispatcher.reportStats(), setInterval(() => this.props.dispatcher.reportStats(), 144e5), this.props.dispatcher.installGlobalLFSFilters(!1), setInterval(() => this.checkForUpdates(!0), 144e5), this.checkForUpdates(!0), log.info(`launching: ${Le()} (${li()})`), log.info(`execPath: '${process.execPath}'`)
    }
    onMenuEvent(e) {
      if (!this.state.errors.length) switch (e) {
        case "push":
          return this.push();
        case "force-push":
          return this.push({
            forceWithLease: !0
          });
        case "pull":
          return this.pull();
        case "show-changes":
          return this.showChanges();
        case "show-history":
          return this.showHistory();
        case "choose-repository":
          return this.chooseRepository();
        case "add-local-repository":
          return this.showAddLocalRepo();
        case "create-branch":
          return this.showCreateBranch();
        case "show-branches":
          return this.showBranches();
        case "remove-repository":
          return this.removeRepository(this.getRepository());
        case "create-repository":
          return this.showCreateRepository();
        case "rename-branch":
          return this.renameBranch();
        case "delete-branch":
          return this.deleteBranch();
        case "discard-all-changes":
          return this.discardAllChanges();
        case "stash-all-changes":
          return this.stashAllChanges();
        case "show-preferences":
          return this.props.dispatcher.showPopup({
            type: Zi.Preferences
          });
        case "open-working-directory":
          return this.openCurrentRepositoryWorkingDirectory();
        case "update-branch":
          return this.props.dispatcher.recordMenuInitiatedUpdate(), this.updateBranch();
        case "compare-to-branch":
          return this.showHistory(!0);
        case "merge-branch":
          return this.props.dispatcher.recordMenuInitiatedMerge(), this.mergeBranch();
        case "rebase-branch":
          return this.props.dispatcher.recordMenuInitiatedRebase(), this.showRebaseDialog();
        case "show-repository-settings":
          return this.showRepositorySettings();
        case "view-repository-on-github":
          return this.viewRepositoryOnGitHub();
        case "compare-on-github":
          return this.compareBranchOnDotcom();
        case "create-issue-in-repository-on-github":
          return this.openIssueCreationOnGitHub();
        case "open-in-shell":
          return this.openCurrentRepositoryInShell();
        case "clone-repository":
          return this.showCloneRepo();
        case "show-about":
          return this.showAbout();
        case "boomtown":
          return this.boomtown();
        case "go-to-commit-message":
          return this.goToCommitMessage();
        case "open-pull-request":
          return this.openPullRequest();
        case "install-cli":
          return this.props.dispatcher.installCLI();
        case "open-external-editor":
          return this.openCurrentRepositoryInExternalEditor();
        case "select-all":
          return this.selectAll();
        case "show-release-notes-popup":
          return this.showFakeReleaseNotesPopup();
        case "show-stashed-changes":
          return this.showStashedChanges();
        case "hide-stashed-changes":
          return this.hideStashedChanges();
        case "test-prune-branches":
          return this.testPruneBranches();
        case "find-text":
          return this.findText();
        default:
          return X(0, "Unknown menu event name: " + e)
      }
    }
    showFakeReleaseNotesPopup() {
      0
    }
    testPruneBranches() {}
    selectAll() {
      const e = new CustomEvent("select-all", {
        bubbles: !0,
        cancelable: !0
      });
      null != document.activeElement && document.activeElement.dispatchEvent(e) && r.remote.getCurrentWebContents().selectAll()
    }
    findText() {
      const e = new CustomEvent("find-text", {
        bubbles: !0,
        cancelable: !0
      });
      null != document.activeElement ? document.activeElement.dispatchEvent(e) : document.dispatchEvent(e)
    }
    boomtown() {
      setImmediate(() => {
        throw new Error("Boomtown!")
      })
    }
    async goToCommitMessage() {
      await this.showChanges(), this.props.dispatcher.setCommitMessageFocus(!0)
    }
    checkForUpdates(e) {
      ke.checkForUpdates(e)
    }
    getDotComAccount() {
      return this.state.accounts.find(e => e.endpoint === pt()) || null
    }
    getEnterpriseAccount() {
      return this.state.accounts.find(e => e.endpoint !== pt()) || null
    }
    updateBranch() {
      const {
        selectedState: e
      } = this.state;
      if (null == e || e.type !== W.Repository) return;
      const {
        state: t
      } = e, n = t.branchesState.defaultBranch;
      if (!n) return;
      const {
        mergeStatus: r
      } = t.compareState;
      this.props.dispatcher.mergeBranch(e.repository, n.name, r)
    }
    mergeBranch() {
      const e = this.state.selectedState;
      null != e && e.type === W.Repository && this.props.dispatcher.showPopup({
        type: Zi.MergeBranch,
        repository: e.repository
      })
    }
    compareBranchOnDotcom() {
      const e = this.getCurrentRepositoryGitHubURL();
      if (!e) return;
      const t = this.state.selectedState;
      if (null == t || t.type !== W.Repository) return;
      const n = t.state.branchesState.tip;
      if (n.kind !== Qi.Valid || !n.branch.upstreamWithoutRemote) return;
      const r = `${e}/compare/${n.branch.upstreamWithoutRemote}`;
      this.props.dispatcher.openInBrowser(r)
    }
    openCurrentRepositoryWorkingDirectory() {
      const e = this.state.selectedState;
      null != e && e.type === W.Repository && this.showRepository(e.repository)
    }
    renameBranch() {
      const e = this.state.selectedState;
      if (null == e || e.type !== W.Repository) return;
      const t = e.state.branchesState.tip;
      t.kind === Qi.Valid && this.props.dispatcher.showPopup({
        type: Zi.RenameBranch,
        repository: e.repository,
        branch: t.branch
      })
    }
    deleteBranch() {
      const e = this.state.selectedState;
      if (null === e || e.type !== W.Repository) return;
      const t = e.state.branchesState.tip;
      if (t.kind === Qi.Valid) {
        const n = e.state.branchesState.currentPullRequest;
        if (null !== n) this.props.dispatcher.showPopup({
          type: Zi.DeletePullRequest,
          repository: e.repository,
          branch: t.branch,
          pullRequest: n
        });
        else {
          const n = null !== e.state.aheadBehind;
          this.props.dispatcher.showPopup({
            type: Zi.DeleteBranch,
            repository: e.repository,
            branch: t.branch,
            existsOnRemote: n
          })
        }
      }
    }
    discardAllChanges() {
      const e = this.state.selectedState;
      if (null == e || e.type !== W.Repository) return;
      const {
        workingDirectory: t
      } = e.state.changesState;
      this.props.dispatcher.showPopup({
        type: Zi.ConfirmDiscardChanges,
        repository: e.repository,
        files: t.files,
        showDiscardChangesSetting: !1,
        discardingAllChanges: !0
      })
    }
    stashAllChanges() {
      const e = this.getRepository();
      null !== e && e instanceof Xi && this.props.dispatcher.createStashForCurrentBranch(e)
    }
    getSelectedTutorialRepository() {
      const {
        selectedState: e
      } = this.state, t = e && e.type === W.Repository ? e.repository : null;
      return t && t.isTutorialRepository ? t : null
    }
    showAbout() {
      this.props.dispatcher.showPopup({
        type: Zi.About
      })
    }
    async showHistory(e = !1) {
      const t = this.state.selectedState;
      null != t && t.type === W.Repository && (await this.props.dispatcher.closeCurrentFoldout(), await this.props.dispatcher.initializeCompare(t.repository, {
        kind: $.History
      }), await this.props.dispatcher.changeRepositorySection(t.repository, j.History), await this.props.dispatcher.updateCompareForm(t.repository, {
        filterText: "",
        showBranchList: e
      }))
    }
    showChanges() {
      const e = this.state.selectedState;
      if (null != e && e.type === W.Repository) return this.props.dispatcher.closeCurrentFoldout(), this.props.dispatcher.changeRepositorySection(e.repository, j.Changes)
    }
    chooseRepository() {
      return this.state.currentFoldout && this.state.currentFoldout.type === V.Repository ? this.props.dispatcher.closeFoldout(V.Repository) : this.props.dispatcher.showFoldout({
        type: V.Repository
      })
    }
    showBranches() {
      const e = this.state.selectedState;
      if (null != e && e.type === W.Repository) return this.state.currentFoldout && this.state.currentFoldout.type === V.Branch ? this.props.dispatcher.closeFoldout(V.Branch) : this.props.dispatcher.showFoldout({
        type: V.Branch
      })
    }
    push(e) {
      const t = this.state.selectedState;
      null != t && t.type === W.Repository && (e && e.forceWithLease ? this.props.dispatcher.confirmOrForcePush(t.repository) : this.props.dispatcher.push(t.repository))
    }
    async pull() {
      const e = this.state.selectedState;
      null != e && e.type === W.Repository && this.props.dispatcher.pull(e.repository)
    }
    showStashedChanges() {
      const e = this.state.selectedState;
      null != e && e.type === W.Repository && this.props.dispatcher.selectStashedFile(e.repository)
    }
    hideStashedChanges() {
      const e = this.state.selectedState;
      null != e && e.type === W.Repository && this.props.dispatcher.hideStashedChanges(e.repository)
    }
    componentDidMount() {
      document.ondragover = e => {
        null != e.dataTransfer && (this.isShowingModal ? e.dataTransfer.dropEffect = "none" : e.dataTransfer.dropEffect = "copy"), e.preventDefault()
      }, document.ondrop = e => {
        e.preventDefault()
      }, document.body.ondrop = e => {
        if (!this.isShowingModal) {
          if (null != e.dataTransfer) {
            const t = e.dataTransfer.files;
            this.handleDragAndDrop(t)
          }
          e.preventDefault()
        }
      }, xe() && (window.addEventListener("keydown", this.onWindowKeyDown), window.addEventListener("keyup", this.onWindowKeyUp))
    }
    async handleDragAndDrop(e) {
      const t = [];
      for (let n = 0; n < e.length; n++) {
        const r = e[n];
        t.push(r.path)
      }
      if (t.length > 1) {
        (await this.addRepositories(t)).length > 0 && this.props.dispatcher.recordAddExistingRepository()
      } else {
        const e = t[0],
          n = await Dc(e) || e,
          r = kt(this.state.repositories, n);
        r ? await this.props.dispatcher.selectRepository(r) : await this.showPopup({
          type: Zi.AddRepository,
          path: n
        })
      }
    }
    getRepository() {
      const e = this.state.selectedState;
      return null == e ? null : e.repository
    }
    async addRepositories(e) {
      const t = await this.props.dispatcher.addRepositories(e);
      return t.length > 0 && this.props.dispatcher.selectRepository(t[0]), t
    }
    showRebaseDialog() {
      const e = this.getRepository();
      if (!e || e instanceof Ai) return;
      const t = function (e) {
        const {
          defaultBranch: t,
          allBranches: n,
          recentBranches: r,
          tip: i
        } = e.branchesState;
        let o = null;
        if (i.kind !== Qi.Valid) throw new Error("Tip is not in a valid state, which is required to start the rebase flow");
        return o = i.branch, {
          kind: "ChooseBranch",
          defaultBranch: t,
          currentBranch: o,
          allBranches: n,
          recentBranches: r
        }
      }(this.props.repositoryStateManager.get(e));
      this.props.dispatcher.setRebaseFlowStep(e, t), this.props.dispatcher.showPopup({
        type: Zi.RebaseFlow,
        repository: e
      })
    }
    showRepositorySettings() {
      const e = this.getRepository();
      !e || e instanceof Ai || this.props.dispatcher.showPopup({
        type: Zi.RepositorySettings,
        repository: e
      })
    }
    openIssueCreationOnGitHub() {
      const e = this.getRepository();
      e instanceof Xi && this.props.dispatcher.openIssueCreationPage(e)
    }
    viewRepositoryOnGitHub() {
      const e = this.getRepository();
      if (e instanceof Xi) {
        const t = no(e);
        t && this.props.dispatcher.openInBrowser(t)
      }
    }
    getCurrentRepositoryGitHubURL() {
      const e = this.getRepository();
      return !e || e instanceof Ai || !e.gitHubRepository ? null : e.gitHubRepository.htmlURL
    }
    openCurrentRepositoryInExternalEditor() {
      const e = this.getRepository();
      e && this.openInExternalEditor(e)
    }
    renderAppMenuBar() {
      if (!this.state.appMenuState.length) return null;
      if (this.state.showWelcomeFlow) return null;
      const e = this.state.currentFoldout,
        t = e && e.type === V.AppMenu ? e : null;
      return w.createElement(Ey, {
        appMenu: this.state.appMenuState,
        dispatcher: this.props.dispatcher,
        highlightAppMenuAccessKeys: this.state.highlightAccessKeys,
        foldoutState: t,
        onLostFocus: this.onMenuBarLostFocus
      })
    }
    renderTitlebar() {
      const e = "full-screen" === this.state.windowState,
        t = this.state.currentFoldout && this.state.currentFoldout.type === V.AppMenu;
      if (e && !t) return null;
      const n = !this.state.showWelcomeFlow,
        r = this.state.showWelcomeFlow,
        i = (this.inNoRepositoriesViewState(), r ? "light" : "dark");
      return w.createElement(kh, {
        showAppIcon: n,
        titleBarStyle: i,
        windowState: this.state.windowState,
        windowZoomFactor: this.state.windowZoomFactor
      }, this.renderAppMenuBar())
    }
    currentPopupContent() {
      if (this.state.errors.length) return null;
      const e = this.state.currentPopup;
      if (!e) return null;
      const t = this.getOnPopupDismissedFn(e.type);
      switch (e.type) {
        case Zi.RenameBranch:
          const n = null !== this.state.selectedState && this.state.selectedState.type === W.Repository ? this.state.selectedState.state.changesState.stashEntry : null;
          return w.createElement(Og, {
            key: "rename-branch",
            dispatcher: this.props.dispatcher,
            repository: e.repository,
            branch: e.branch,
            stash: n,
            onDismissed: t
          });
        case Zi.DeleteBranch:
          return w.createElement(Lg, {
            key: "delete-branch",
            dispatcher: this.props.dispatcher,
            repository: e.repository,
            branch: e.branch,
            existsOnRemote: e.existsOnRemote,
            onDismissed: t,
            onDeleted: this.onBranchDeleted
          });
        case Zi.ConfirmDiscardChanges:
          const r = void 0 === e.showDiscardChangesSetting || e.showDiscardChangesSetting,
            i = void 0 !== e.discardingAllChanges && e.discardingAllChanges;
          return w.createElement(Kg, {
            key: "discard-changes",
            repository: e.repository,
            dispatcher: this.props.dispatcher,
            files: e.files,
            confirmDiscardChanges: this.state.askForConfirmationOnDiscardChanges,
            showDiscardChangesSetting: r,
            discardingAllChanges: i,
            onDismissed: t,
            onConfirmDiscardChangesChanged: this.onConfirmDiscardChangesChanged
          });
        case Zi.ConfirmDiscardSelection:
          return w.createElement(Jw, {
            key: "discard-selection",
            repository: e.repository,
            dispatcher: this.props.dispatcher,
            file: e.file,
            diff: e.diff,
            selection: e.selection,
            onDismissed: t
          });
        case Zi.Preferences:
          return w.createElement(jy, {
            key: "preferences",
            initialSelectedTab: e.initialSelectedTab,
            dispatcher: this.props.dispatcher,
            dotComAccount: this.getDotComAccount(),
            confirmRepositoryRemoval: this.state.askForConfirmationOnRepositoryRemoval,
            confirmDiscardChanges: this.state.askForConfirmationOnDiscardChanges,
            confirmForcePush: this.state.askForConfirmationOnForcePush,
            uncommittedChangesStrategyKind: this.state.uncommittedChangesStrategyKind,
            selectedExternalEditor: this.state.selectedExternalEditor,
            optOutOfUsageTracking: this.state.optOutOfUsageTracking,
            enterpriseAccount: this.getEnterpriseAccount(),
            onDismissed: t,
            selectedShell: this.state.selectedShell,
            selectedTheme: this.state.selectedTheme,
            automaticallySwitchTheme: this.state.automaticallySwitchTheme
          });
        case Zi.MergeBranch: {
          const {
            repository: n,
            branch: r
          } = e, i = this.props.repositoryStateManager.get(n), o = i.branchesState.tip;
          if (o.kind !== Qi.Valid) return null;
          const s = o.branch;
          return w.createElement($y, {
            key: "merge-branch",
            dispatcher: this.props.dispatcher,
            repository: n,
            allBranches: i.branchesState.allBranches,
            defaultBranch: i.branchesState.defaultBranch,
            recentBranches: i.branchesState.recentBranches,
            currentBranch: s,
            initialBranch: r,
            onDismissed: t
          })
        }
        case Zi.RepositorySettings: {
          const n = e.repository,
            r = this.props.repositoryStateManager.get(n);
          return w.createElement(ev, {
            key: "repository-settings-" + n.hash,
            remote: r.remote,
            dispatcher: this.props.dispatcher,
            repository: n,
            onDismissed: t
          })
        }
        case Zi.SignIn:
          return w.createElement(Iv, {
            key: "sign-in",
            signInState: this.state.signInState,
            dispatcher: this.props.dispatcher,
            onDismissed: t
          });
        case Zi.AddRepository:
          return w.createElement(uv, {
            key: "add-existing-repository",
            onDismissed: t,
            dispatcher: this.props.dispatcher,
            path: e.path
          });
        case Zi.CreateRepository:
          return w.createElement(Sv, {
            key: "create-repository",
            onDismissed: t,
            dispatcher: this.props.dispatcher,
            initialPath: e.path
          });
        case Zi.CloneRepository:
          return w.createElement(Dv, {
            key: "clone-repository",
            dotComAccount: this.getDotComAccount(),
            enterpriseAccount: this.getEnterpriseAccount(),
            initialURL: e.initialURL,
            onDismissed: t,
            dispatcher: this.props.dispatcher,
            selectedTab: this.state.selectedCloneRepositoryTab,
            onTabSelected: this.onCloneRepositoriesTabSelected,
            apiRepositories: this.state.apiRepositories,
            onRefreshRepositories: this.onRefreshRepositories
          });
        case Zi.CreateBranch: {
          const n = this.props.repositoryStateManager.get(e.repository),
            r = n.branchesState,
            i = n.changesState.currentBranchProtected,
            o = e.repository;
          if (r.tip.kind === Qi.Unknown) return t(), null;
          let s = null,
            a = null;
          return Ji(o) && (s = ro(o), a = function (e, t) {
            const n = ro(e);
            if (n === e.gitHubRepository) return null;
            const r = t.find(e => e.type === As.Remote && e.name === "upstream/" + n.defaultBranch);
            return void 0 !== r ? r : null
          }(o, r.allBranches)), w.createElement(Av, {
            key: "create-branch",
            tip: r.tip,
            defaultBranch: r.defaultBranch,
            upstreamDefaultBranch: a,
            allBranches: r.allBranches,
            repository: o,
            upstreamGitHubRepository: s,
            onDismissed: t,
            dispatcher: this.props.dispatcher,
            initialName: e.initialName || "",
            currentBranchProtected: i,
            selectedUncommittedChangesStrategy: fu(this.state.uncommittedChangesStrategyKind)
          })
        }
        case Zi.InstallGit:
          return w.createElement(Ov, {
            key: "install-git",
            onDismissed: t,
            onOpenShell: this.onOpenShellIgnoreWarning,
            path: e.path
          });
        case Zi.About:
          const o = Le();
          return w.createElement(Fv, {
            key: "about",
            onDismissed: t,
            applicationName: (Me || (Me = Oe().getName()), Me),
            applicationVersion: o,
            onCheckForUpdates: this.onCheckForUpdates,
            onShowAcknowledgements: this.showAcknowledgements,
            onShowTermsAndConditions: this.showTermsAndConditions
          });
        case Zi.PublishRepository:
          return w.createElement(Uv, {
            key: "publish",
            dispatcher: this.props.dispatcher,
            repository: e.repository,
            accounts: this.state.accounts,
            onDismissed: t
          });
        case Zi.UntrustedCertificate:
          return w.createElement(jv, {
            key: "untrusted-certificate",
            certificate: e.certificate,
            url: e.url,
            onDismissed: t,
            onContinue: this.onContinueWithUntrustedCertificate
          });
        case Zi.Acknowledgements:
          return w.createElement(Wv, {
            key: "acknowledgements",
            onDismissed: t,
            applicationVersion: Le()
          });
        case Zi.RemoveRepository:
          return w.createElement(qv, {
            key: "confirm-remove-repository",
            repository: e.repository,
            onConfirmation: this.onConfirmRepoRemoval,
            onDismissed: t
          });
        case Zi.TermsAndConditions:
          return w.createElement(Yv, {
            key: "terms-and-conditions",
            onDismissed: t
          });
        case Zi.PushBranchCommits:
          return w.createElement(Hm, {
            key: "push-branch-commits",
            dispatcher: this.props.dispatcher,
            repository: e.repository,
            branch: e.branch,
            unPushedCommits: e.unPushedCommits,
            onConfirm: this.openCreatePullRequestInBrowser,
            onDismissed: t
          });
        case Zi.CLIInstalled:
          return w.createElement(tw, {
            key: "cli-installed",
            onDismissed: t
          });
        case Zi.GenericGitAuthentication:
          return w.createElement(nw, {
            key: "generic-git-authentication",
            hostname: e.hostname,
            onDismiss: t,
            onSave: this.onSaveCredentials,
            retryAction: e.retryAction
          });
        case Zi.ExternalEditorFailed:
          const s = e.openPreferences,
            a = e.suggestAtom;
          return w.createElement(Lv, {
            key: "editor-error",
            message: e.message,
            onDismissed: t,
            showPreferencesDialog: this.onShowAdvancedPreferences,
            viewPreferences: s,
            suggestAtom: a
          });
        case Zi.OpenShellFailed:
          return w.createElement(rw, {
            key: "shell-error",
            message: e.message,
            onDismissed: t,
            showPreferencesDialog: this.onShowAdvancedPreferences
          });
        case Zi.InitializeLFS:
          return w.createElement(ow, {
            key: "initialize-lfs",
            repositories: e.repositories,
            onDismissed: t,
            onInitialize: this.initializeLFS
          });
        case Zi.LFSAttributeMismatch:
          return w.createElement(sw, {
            key: "lsf-attribute-mismatch",
            onDismissed: t,
            onUpdateExistingFilters: this.updateExistingLFSFilters
          });
        case Zi.UpstreamAlreadyExists:
          return w.createElement(aw, {
            key: "upstream-already-exists",
            repository: e.repository,
            existingRemote: e.existingRemote,
            onDismissed: t,
            onUpdate: this.onUpdateExistingUpstreamRemote,
            onIgnore: this.onIgnoreExistingUpstreamRemote
          });
        case Zi.ReleaseNotes:
          return w.createElement(hw, {
            key: "release-notes",
            emoji: this.state.emoji,
            newRelease: e.newRelease,
            onDismissed: t
          });
        case Zi.DeletePullRequest:
          return w.createElement(pw, {
            key: "delete-pull-request",
            dispatcher: this.props.dispatcher,
            repository: e.repository,
            branch: e.branch,
            onDismissed: t,
            pullRequest: e.pullRequest
          });
        case Zi.MergeConflicts: {
          const {
            selectedState: n
          } = this.state;
          if (null === n || n.type !== W.Repository) return null;
          const {
            workingDirectory: r,
            conflictState: i
          } = n.state.changesState;
          return null === i || "rebase" === i.kind ? null : w.createElement(Rw, {
            key: "merge-conflicts-dialog",
            dispatcher: this.props.dispatcher,
            repository: e.repository,
            workingDirectory: r,
            onDismissed: t,
            openFileInExternalEditor: this.openFileInExternalEditor,
            resolvedExternalEditor: this.state.resolvedExternalEditor,
            openRepositoryInShell: this.openInShell,
            ourBranch: e.ourBranch,
            theirBranch: e.theirBranch,
            manualResolutions: i.manualResolutions
          })
        }
        case Zi.OversizedFiles:
          return w.createElement(Mw, {
            key: "oversized-files",
            oversizedFiles: e.oversizedFiles,
            onDismissed: t,
            dispatcher: this.props.dispatcher,
            context: e.context,
            repository: e.repository
          });
        case Zi.AbortMerge: {
          const {
            selectedState: n
          } = this.state;
          if (null === n || n.type !== W.Repository) return null;
          const {
            workingDirectory: r
          } = n.state.changesState;
          return r.files.some(e => Wl(e.status)) ? w.createElement(Aw, {
            key: "abort-merge-warning",
            dispatcher: this.props.dispatcher,
            repository: e.repository,
            onDismissed: t,
            ourBranch: e.ourBranch,
            theirBranch: e.theirBranch
          }) : null
        }
        case Zi.UsageReportingChanges:
          return w.createElement(Pw, {
            key: "usage-stats-change",
            onOpenUsageDataUrl: this.openUsageDataUrl,
            onSetStatsOptOut: this.onSetStatsOptOut,
            onDismissed: t
          });
        case Zi.CommitConflictsWarning:
          return w.createElement(Dw, {
            key: "commit-conflicts-warning",
            dispatcher: this.props.dispatcher,
            files: e.files,
            repository: e.repository,
            context: e.context,
            onDismissed: t
          });
        case Zi.PushNeedsPull:
          return w.createElement(Iw, {
            key: "push-needs-pull",
            dispatcher: this.props.dispatcher,
            repository: e.repository,
            onDismissed: t
          });
        case Zi.RebaseFlow: {
          const {
            selectedState: n,
            emoji: r
          } = this.state;
          if (null === n || n.type !== W.Repository) return null;
          const {
            changesState: i,
            rebaseState: o
          } = n.state, {
            workingDirectory: s,
            conflictState: a
          } = i, {
            progress: l,
            step: c,
            userHasResolvedConflicts: u
          } = o;
          return null !== a && "merge" === a.kind ? (log.warn("[App] invalid state encountered - rebase flow should not be used when merge conflicts found"), null) : null === c ? (log.warn("[App] invalid state encountered - rebase flow should not be active when step is null"), null) : w.createElement(Hw, {
            key: "rebase-flow",
            repository: e.repository,
            openFileInExternalEditor: this.openFileInExternalEditor,
            dispatcher: this.props.dispatcher,
            onFlowEnded: this.onRebaseFlowEnded,
            onDismissed: t,
            workingDirectory: s,
            progress: l,
            step: c,
            userHasResolvedConflicts: u,
            askForConfirmationOnForcePush: this.state.askForConfirmationOnForcePush,
            resolvedExternalEditor: this.state.resolvedExternalEditor,
            openRepositoryInShell: this.openCurrentRepositoryInShell,
            onShowRebaseConflictsBanner: this.onShowRebaseConflictsBanner,
            emoji: r
          })
        }
        case Zi.ConfirmForcePush: {
          const {
            askForConfirmationOnForcePush: n
          } = this.state;
          return w.createElement(zw, {
            key: "confirm-force-push",
            dispatcher: this.props.dispatcher,
            repository: e.repository,
            upstreamBranch: e.upstreamBranch,
            askForConfirmationOnForcePush: n,
            onDismissed: t
          })
        }
        case Zi.StashAndSwitchBranch: {
          const {
            repository: n,
            branchToCheckout: r
          } = e, {
            branchesState: i,
            changesState: o
          } = this.props.repositoryStateManager.get(n), {
            tip: s
          } = i;
          if (s.kind !== Qi.Valid) return null;
          const a = s.branch,
            l = null !== o.stashEntry;
          return w.createElement(Ww, {
            key: "stash-and-switch-branch",
            dispatcher: this.props.dispatcher,
            repository: e.repository,
            currentBranch: a,
            branchToCheckout: r,
            hasAssociatedStash: l,
            onDismissed: t
          })
        }
        case Zi.ConfirmOverwriteStash: {
          const {
            repository: n,
            branchToCheckout: r
          } = e;
          return w.createElement(Vw, {
            key: "overwite-stash",
            dispatcher: this.props.dispatcher,
            repository: n,
            branchToCheckout: r,
            onDismissed: t
          })
        }
        case Zi.ConfirmDiscardStash: {
          const {
            repository: n,
            stash: r
          } = e;
          return w.createElement(jw, {
            key: "confirm-discard-stash-dialog",
            dispatcher: this.props.dispatcher,
            repository: n,
            stash: r,
            onDismissed: t
          })
        }
        case Zi.CreateTutorialRepository:
          return w.createElement(Gw, {
            key: "create-tutorial-repository-dialog",
            account: e.account,
            progress: e.progress,
            onDismissed: t,
            onCreateTutorialRepository: this.onCreateTutorialRepository
          });
        case Zi.ConfirmExitTutorial:
          return w.createElement(_g, {
            key: "confirm-exit-tutorial",
            onDismissed: t,
            onContinue: this.onExitTutorialToHomeScreen
          });
        case Zi.PushRejectedDueToMissingWorkflowScope:
          return w.createElement($w, {
            onDismissed: t,
            rejectedPath: e.rejectedPath,
            dispatcher: this.props.dispatcher,
            repository: e.repository
          });
        case Zi.SAMLReauthRequired:
          return w.createElement(qw, {
            onDismissed: t,
            organizationName: e.organizationName,
            endpoint: e.endpoint,
            retryAction: e.retryAction,
            dispatcher: this.props.dispatcher
          });
        case Zi.CreateFork:
          return w.createElement(Kw, {
            onDismissed: t,
            dispatcher: this.props.dispatcher,
            repository: e.repository,
            account: e.account
          });
        case Zi.SChannelNoRevocationCheck:
          return w.createElement(Yw, {
            onDismissed: t,
            url: e.url
          });
        case Zi.CreateTag:
          return w.createElement(Qw, {
            key: "create-tag",
            repository: e.repository,
            onDismissed: t,
            dispatcher: this.props.dispatcher,
            targetCommitSha: e.targetCommitSha,
            initialName: e.initialName,
            localTags: e.localTags
          });
        case Zi.DeleteTag:
          return w.createElement(Zw, {
            key: "delete-tag",
            repository: e.repository,
            onDismissed: t,
            dispatcher: this.props.dispatcher,
            tagName: e.tagName
          });
        case Zi.ChooseForkSettings:
          return w.createElement(Xw, {
            repository: e.repository,
            onDismissed: t,
            dispatcher: this.props.dispatcher
          });
        case Zi.LocalChangesOverwritten:
          const l = this.state.selectedState,
            c = null !== l && l.type === W.Repository ? l.state.changesState.stashEntry : null;
          return w.createElement(eb, {
            repository: e.repository,
            dispatcher: this.props.dispatcher,
            hasExistingStash: null !== c,
            retryAction: e.retryAction,
            onDismissed: t
          });
        default:
          return X(0, "Unknown popup type: " + e)
      }
    }
    renderPopup() {
      const e = this.currentPopupContent();
      return w.createElement(O, null, e && w.createElement(K, {
        classNames: "modal",
        timeout: tb
      }, e))
    }
    renderZoomInfo() {
      return w.createElement(xh, {
        windowZoomFactor: this.state.windowZoomFactor
      })
    }
    renderFullScreenInfo() {
      return w.createElement(Rh, {
        windowState: this.state.windowState
      })
    }
    renderAppError() {
      return w.createElement(nv, {
        errors: this.state.errors,
        onClearError: this.clearError,
        onShowPopup: this.showPopup,
        onRetryAction: this.onRetryAction
      })
    }
    renderApp() {
      return w.createElement("div", {
        id: "desktop-app-contents"
      }, this.renderToolbar(), this.renderBanner(), this.renderRepository(), this.renderPopup(), this.renderAppError())
    }
    renderRepositoryToolbarButton() {
      const e = this.state.selectedState,
        t = e ? e.repository : null;
      let n, r;
      t ? (n = Ch(t), r = t.name) : this.state.repositories.length > 0 ? (n = Sh.repo, r = "Select a repository") : (n = Sh.repo, r = "No repositories");
      const i = this.state.currentFoldout && this.state.currentFoldout.type === V.Repository,
        o = i ? "open" : "closed",
        s = t && !i ? t.path : void 0,
        a = {
          position: "absolute",
          marginLeft: 0,
          width: this.state.sidebarWidth,
          minWidth: this.state.sidebarWidth,
          height: "100%",
          top: 0
        };
      return w.createElement(zg, {
        icon: n,
        title: r,
        description: "当前存储库",
        tooltip: s,
        foldoutStyle: a,
        onDropdownStateChanged: this.onRepositoryDropdownStateChanged,
        dropdownContentRenderer: this.renderRepositoryList,
        dropdownState: o
      })
    }
    renderPushPullToolbarButton() {
      const e = this.state.selectedState;
      if (!e || e.type !== W.Repository) return null;
      const t = e.state,
        n = t.revertProgress;
      if (n) return w.createElement(qg, {
        progress: n
      });
      let r = t.remote ? t.remote.name : null;
      const i = t.pushPullFetchProgress,
        {
          conflictState: o
        } = t.changesState,
        s = null !== o && "rebase" === o.kind,
        {
          aheadBehind: a,
          branchesState: l
        } = t,
        {
          pullWithRebase: c,
          tip: u
        } = l;
      u.kind === Qi.Valid && null !== u.branch.remote && (r = u.branch.remote);
      const h = yl(l, a);
      return w.createElement(Gg, {
        dispatcher: this.props.dispatcher,
        repository: e.repository,
        aheadBehind: t.aheadBehind,
        numTagsToPush: null !== t.tagsToPush ? t.tagsToPush.length : 0,
        remoteName: r,
        lastFetched: t.lastFetched,
        networkActionInProgress: t.isPushPullFetchInProgress,
        progress: i,
        tipState: u.kind,
        pullWithRebase: c,
        rebaseInProgress: s,
        isForcePush: h,
        shouldNudge: this.state.currentOnboardingTutorialStep === Su.PushBranch
      })
    }
    renderBranchToolbarButton() {
      const e = this.state.selectedState;
      if (null == e || e.type !== W.Repository) return null;
      const t = this.state.currentFoldout,
        n = null !== t && t.type === V.Branch,
        r = e.repository,
        {
          branchesState: i,
          changesState: o
        } = e.state,
        s = null !== o.stashEntry,
        a = o.workingDirectory.files.length > 0;
      return w.createElement($g, {
        dispatcher: this.props.dispatcher,
        isOpen: n,
        onDropDownStateChanged: this.onBranchDropdownStateChanged,
        repository: r,
        repositoryState: e.state,
        selectedTab: this.state.selectedBranchesTab,
        pullRequests: i.openPullRequests,
        currentPullRequest: i.currentPullRequest,
        isLoadingPullRequests: i.isLoadingPullRequests,
        shouldNudge: this.state.currentOnboardingTutorialStep === Su.CreateBranch,
        selectedUncommittedChangesStrategy: fu(this.state.uncommittedChangesStrategyKind),
        couldOverwriteStash: a && s
      })
    }
    renderBanner() {
      if (this.inNoRepositoriesViewState()) return null;
      let e = null;
      return null !== this.state.currentBanner ? e = function (e, t, n) {
        switch (e.type) {
          case lu.SuccessfulMerge:
            return w.createElement(Dy, {
              ourBranch: e.ourBranch,
              theirBranch: e.theirBranch,
              onDismissed: n,
              key: "successful-merge"
            });
          case lu.MergeConflictsFound:
            return w.createElement(Ry, {
              dispatcher: t,
              ourBranch: e.ourBranch,
              popup: e.popup,
              onDismissed: n,
              key: "merge-conflicts"
            });
          case lu.SuccessfulRebase:
            return w.createElement(Ay, {
              targetBranch: e.targetBranch,
              baseBranch: e.baseBranch,
              onDismissed: n,
              key: "successful-rebase"
            });
          case lu.RebaseConflictsFound:
            return w.createElement(_y, {
              dispatcher: t,
              targetBranch: e.targetBranch,
              onOpenDialog: e.onOpenDialog,
              onDismissed: n,
              key: "merge-conflicts"
            });
          default:
            return X(0, "Unknown popup type: " + e)
        }
      }(this.state.currentBanner, this.props.dispatcher, this.onBannerDismissed) : this.state.isUpdateAvailableBannerVisible && (e = this.renderUpdateBanner()), w.createElement(O, null, e && w.createElement(K, {
        classNames: "banner",
        timeout: nb
      }, e))
    }
    renderUpdateBanner() {
      return w.createElement(Ty, {
        dispatcher: this.props.dispatcher,
        newRelease: ke.state.newRelease,
        onDismissed: this.onUpdateAvailableDismissed,
        key: "update-available"
      })
    }
    renderToolbar() {
      return this.inNoRepositoriesViewState() ? null : w.createElement(Fg, {
        id: "desktop-app-toolbar"
      }, w.createElement("div", {
        className: "sidebar-section",
        style: {
          width: this.state.sidebarWidth
        }
      }, this.renderRepositoryToolbarButton()), this.renderBranchToolbarButton(), this.renderPushPullToolbarButton())
    }
    renderRepository() {
      const e = this.state;
      if (this.inNoRepositoriesViewState()) return w.createElement($v, {
        dotComAccount: this.getDotComAccount(),
        enterpriseAccount: this.getEnterpriseAccount(),
        onCreate: this.showCreateRepository,
        onClone: this.showCloneRepo,
        onAdd: this.showAddLocalRepo,
        onCreateTutorialRepository: this.showCreateTutorialRepositoryPopup,
        onResumeTutorialRepository: this.onResumeTutorialRepository,
        tutorialPaused: this.isTutorialPaused(),
        apiRepositories: e.apiRepositories,
        onRefreshRepositories: this.onRefreshRepositories
      });
      const t = e.selectedState;
      if (!t) return w.createElement(ib, null);
      if (t.type === W.Repository) {
        const n = e.selectedExternalEditor ? e.selectedExternalEditor : void 0;
        return w.createElement(Ag, {
          key: t.repository.hash,
          repository: t.repository,
          state: t.state,
          dispatcher: this.props.dispatcher,
          emoji: e.emoji,
          sidebarWidth: e.sidebarWidth,
          commitSummaryWidth: e.commitSummaryWidth,
          stashedFilesWidth: e.stashedFilesWidth,
          issuesStore: this.props.issuesStore,
          gitHubUserStore: this.props.gitHubUserStore,
          onViewCommitOnGitHub: this.onViewCommitOnGitHub,
          imageDiffType: e.imageDiffType,
          hideWhitespaceInDiff: e.hideWhitespaceInDiff,
          focusCommitMessage: e.focusCommitMessage,
          askForConfirmationOnDiscardChanges: e.askForConfirmationOnDiscardChanges,
          accounts: e.accounts,
          externalEditorLabel: n,
          resolvedExternalEditor: e.resolvedExternalEditor,
          onOpenInExternalEditor: this.openFileInExternalEditor,
          appMenu: e.appMenuState[0],
          currentTutorialStep: e.currentOnboardingTutorialStep,
          onExitTutorial: this.onExitTutorial,
          isShowingModal: this.isShowingModal,
          isShowingFoldout: null !== this.state.currentFoldout
        })
      }
      return t.type === W.CloningRepository ? w.createElement(Ng, {
        repository: t.repository,
        progress: t.progress
      }) : t.type === W.MissingRepository ? w.createElement(av, {
        repository: t.repository,
        dispatcher: this.props.dispatcher
      }) : X(0, "Unknown state: " + t)
    }
    renderWelcomeFlow() {
      return w.createElement(dy, {
        dispatcher: this.props.dispatcher,
        optOut: this.state.optOutOfUsageTracking,
        accounts: this.state.accounts,
        signInState: this.state.signInState
      })
    }
    render() {
      if (this.loading) return null;
      const e = this.state.appIsFocused ? "focused" : "blurred",
        t = this.state.showWelcomeFlow ? pi.Light : this.state.selectedTheme;
      return w.createElement("div", {
        id: "desktop-app-chrome",
        className: e
      }, w.createElement(_w, {
        theme: t
      }), this.renderTitlebar(), this.state.showWelcomeFlow ? this.renderWelcomeFlow() : this.renderApp(), this.renderZoomInfo(), this.renderFullScreenInfo())
    }
    inNoRepositoriesViewState() {
      return 0 === this.state.repositories.length || this.isTutorialPaused()
    }
    isTutorialPaused() {
      return this.state.currentOnboardingTutorialStep === Su.Paused
    }
  }

  function ib() {
    return w.createElement("div", {
      className: "panel blankslate"
    }, "No repository selected")
  }

  function ob(e) {
    return e.kind === Qi.Valid ? e.branch.tip.sha : e.kind === Qi.Detached ? e.currentSha : "(unknown)"
  }

  function sb(e) {
    return function (e) {
      return e instanceof Error && "string" == typeof e.code
    }(e) ? e : null
  }

  function ab(e) {
    return e instanceof ae ? e : null
  }

  function lb(e) {
    return e instanceof Fo ? e : null
  }
  const cb = /^ ! \[remote rejected\] .*? -> .*? \(refusing to allow an OAuth App to create or update workflow `(.*?)` without `workflow` scope\)/m;
  const ub = /`([^']+)' organization has enabled or enforced SAML SSO.*?you must re-authorize/s;
  const hb = /^fatal: unable to access '(.*?)': schannel: next InitializeSecurityContext failed: .*? \((0x80092012|0x80092013)\)/m;

  function pb(e) {
    const {
      login: t,
      email: n,
      avatarURL: r,
      name: i
    } = e;
    return {
      login: t,
      email: n,
      avatarURL: r,
      name: i
    }
  }

  function db(e) {
    return Object.keys(localStorage).filter(e => /^IssuesStore\/\d+\/lastFetch$/.test(e)).forEach(e => localStorage.removeItem(e)), e.table("issues").clear()
  }

  function fb(e) {
    const t = e.table("gitHubRepositories"),
      n = new Set;
    return t.toCollection().each(e => {
      const r = `${e.ownerID}+${e.name}`;
      if (n.has(r)) {
        const n = e.id;
        t.delete(n)
      } else n.add(r)
    })
  }
  new Set(["LOCAL_GIT_DIRECTORY"]);
  const mb = new Set(["button", "a", "input", "textarea", "label"].map(e => e.toUpperCase())),
    gb = new Set(["button", "option", "menuitem", "tab", "radio"]);

  function yb(e, t) {
    return e.endpoint === t.endpoint && e.id === t.id
  }

  function vb(e, t) {
    if (t.has(e)) return e;
    for (const n of t.keys())
      if (yb(n, e)) return n;
    return e
  }
  var wb = n(136),
    bb = n.n(wb),
    Sb = n(137),
    Cb = n.n(Sb);

  function Eb(e, t) {
    const {
      endpoint: n,
      owner: r,
      name: i
    } = e;
    return function (e, t, n, r) {
      return `${e}/repos/${t}/${n}/commits/${r}/status`
    }(n, r.login, i, t)
  }

  function kb(e) {
    return Date.now() - e.fetchedAt.valueOf() > 6e4
  }
  n(300);
  var xb = n(138),
    Tb = n.n(xb);
  process,
  function () {
    c.a.install({
      environment: "node",
      handleUncaughtExceptions: !1,
      retrieveSourceMap: h
    });
    const e = Error;
    d = e.prepareStackTrace, e.prepareStackTrace = f
  }(), process.env.LOCAL_GIT_DIRECTORY = i.resolve(__dirname, "git"), delete process.env.GIT_EXEC_PATH, Tb()(E);
  const Rb = performance.now();
  n(301);
  let Db = null,
    _b = null,
    Ab = null;
  const Mb = (e, t = {}, n) => {
    e = m(e), console.error("Uncaught exception", e); {
      const i = Object.assign({
        osVersion: li(),
        guid: ui()
      }, t);
      try {
        Db && (null !== Db.currentBanner && (i.currentBanner = Db.currentBanner.type), null !== Db.currentPopup && (i.currentPopup = "" + Db.currentPopup.type), null !== Db.selectedState && (i.selectedState = "" + Db.selectedState.type, Db.selectedState.type === W.Repository && (i.selectedRepositorySection = "" + Db.selectedState.state.selectedSection)), null !== Db.currentFoldout && (i.currentFoldout = "" + Db.currentFoldout.type), Db.showWelcomeFlow && (i.inWelcomeFlow = "true"), 1 !== Db.windowZoomFactor && (i.windowZoomFactor = "" + Db.windowZoomFactor), Db.errors.length > 0 && (i.activeAppErrors = "" + Db.errors.length), null !== _b && null !== Ab && (i.lastUnhandledRejection = _b, i.lastUnhandledRejectionTime = Ab.toString()), i.repositoryCount = "" + Db.repositories.length, i.windowState = Db.windowState, i.accounts = "" + Db.accounts.length)
      } catch (e) {}! function (e, t = {}, n) {
        r.ipcRenderer.send("send-error-report", {
          error: se(e),
          extra: t,
          nonFatal: n
        })
      }(e, i, n)
    }
  };
  process.once("uncaughtException", e => {
    Mb(e),
      function (e) {
        r.ipcRenderer.send("uncaught-exception", se(e))
      }(e)
  }), process.on("send-non-fatal-exception", (e, t) => {
    Mb(e, t, !0)
  }), window.addEventListener("unhandledrejection", e => {
    if (null !== e.reason && void 0 !== e.reason) try {
      _b = "" + e.reason, Ab = new Date
    } catch (e) {}
  });
  const Pb = new class extends vi {
      constructor(e) {
        super(), this.database = e, this.queryCache = null, this.pruneQueryCacheTimeoutId = null
      }
      async getByLogin(e, t) {
        const n = at.fromAccount(e),
          r = await n.fetchUser(t).catch(e => null);
        if (!r || "User" !== r.type) return null;
        const i = null !== r.email && r.email.length > 0 ? r.email : Lu(r.id, t, e.endpoint);
        return {
          avatarURL: r.avatar_url,
          email: i,
          name: r.name || r.login,
          login: r.login
        }
      }
      async updateMentionables(e, t) {
        var n;
        Bu(e);
        const r = at.fromAccount(t),
          i = await this.database.getMentionableCacheEntry(e.dbID);
        if (void 0 !== i && Date.now() - i.lastUpdated < 6e5) return;
        const o = await r.fetchMentionables(e.owner.login, e.name, null == i ? void 0 : i.eTag);
        if (null === o) return void await this.database.touchMentionableCacheEntry(e.dbID, null == i ? void 0 : i.eTag);
        const {
          endpoint: s
        } = t, a = o.users.map(e => {
          const {
            name: t,
            login: n,
            avatar_url: r
          } = e;
          return {
            name: t,
            login: n,
            email: e.email || Ou(n, s),
            avatarURL: r
          }
        });
        await this.database.updateMentionablesForRepository(e.dbID, a, o.etag), (null === (n = this.queryCache) || void 0 === n ? void 0 : n.repository.dbID) === e.dbID && (this.queryCache = null, this.clearCachePruneTimeout())
      }
      async getMentionableUsers(e) {
        return Bu(e), this.database.getAllMentionablesForRepository(e.dbID)
      }
      async getMentionableUsersMatching(e, t, n = 25) {
        var r;
        Bu(e);
        const i = (null === (r = this.queryCache) || void 0 === r ? void 0 : r.repository.dbID) === e.dbID ? this.queryCache.users : await this.getMentionableUsers(e);
        this.setQueryCache(e, i);
        const o = [],
          s = t.toLowerCase();
        for (const e of i) {
          const t = `${e.login} ${e.name}`.trim().toLowerCase().indexOf(s);
          t >= 0 && o.push({
            user: e,
            ix: t
          })
        }
        return o.sort((e, t) => vt(e.ix, t.ix) || vt(e.user.login, t.user.login)).slice(0, n).map(e => e.user)
      }
      setQueryCache(e, t) {
        this.clearCachePruneTimeout(), this.queryCache = {
          repository: e,
          users: t
        }, this.pruneQueryCacheTimeoutId = window.setTimeout(() => {
          this.pruneQueryCacheTimeoutId = null, this.queryCache = null
        }, 6e4)
      }
      clearCachePruneTimeout() {
        null !== this.pruneQueryCacheTimeoutId && (clearTimeout(this.pruneQueryCacheTimeoutId), this.pruneQueryCacheTimeoutId = null)
      }
    }(new class extends th {
      constructor(e, t) {
        super(e, t), this.conditionalVersion(1, {
          users: "++id, &[endpoint+email]"
        }), this.conditionalVersion(2, {
          users: "++id, [endpoint+email], [endpoint+login]",
          mentionables: "++id, repositoryID, &[userID+repositoryID]"
        }), this.conditionalVersion(3, {
          mentionables: null,
          users: null
        }), this.conditionalVersion(4, {
          mentionables: "&[gitHubRepositoryID+login], gitHubRepositoryID"
        }), this.conditionalVersion(5, {
          mentionableCache: "gitHubRepositoryID"
        })
      }
      updateMentionablesForRepository(e, t, n) {
        return this.transaction("rw", this.mentionables, this.mentionableCache, async () => {
          await this.mentionables.where("gitHubRepositoryID").equals(e).delete(), await this.touchMentionableCacheEntry(e, n), await this.mentionables.bulkAdd(t.map(t => Object.assign(Object.assign({}, t), {
            gitHubRepositoryID: e
          })))
        })
      }
      async getAllMentionablesForRepository(e) {
        return (await this.mentionables.where("gitHubRepositoryID").equals(e).toArray()).map(pb)
      }
      getMentionableCacheEntry(e) {
        return this.mentionableCache.get(e)
      }
      touchMentionableCacheEntry(e, t) {
        const n = {
          gitHubRepositoryID: e,
          lastUpdated: Date.now(),
          eTag: t
        };
        return this.mentionableCache.put(n)
      }
    }("GitHubUserDatabase")),
    Ib = new class extends vi {
      constructor() {
        super(...arguments), this._repositories = new Array, this.stateByID = new Map
      }
      async clone(e, t, n) {
        const r = new Ai(t, e);
        this._repositories.push(r);
        const i = "Cloning into " + t;
        this.stateByID.set(r.id, {
          kind: "clone",
          title: i,
          value: 0
        }), this.emitUpdate();
        let o = !0;
        try {
          await async function (e, t, n, r) {
            const i = [...await Vo(null, n.account), "clone", "--recursive"];
            let o = {
              env: await Js(n.account, e)
            };
            if (r) {
              i.push("--progress");
              const e = "Cloning into " + t,
                n = "clone";
              o = await ba(Object.assign(Object.assign({}, o), {
                trackLFSProgress: !0
              }), new la, t => {
                const i = "progress" === t.kind ? t.details.text : t.text,
                  o = t.percent;
                r({
                  kind: n,
                  title: e,
                  description: i,
                  value: o
                })
              }), r({
                kind: n,
                title: e,
                value: 0
              })
            }
            n.branch && i.push("-b", n.branch), i.push("--", e, t), await Bo(i, __dirname, "clone", o)
          }(e, t, n, e => {
            this.stateByID.set(r.id, e), this.emitUpdate()
          })
        } catch (i) {
          o = !1;
          const s = {
            type: rc.Clone,
            name: r.name,
            url: e,
            path: t,
            options: n
          };
          i = new ae(i, {
            retryAction: s,
            repository: r
          }), this.emitError(i)
        }
        return this.remove(r), o
      }
      get repositories() {
        return Array.from(this._repositories)
      }
      getRepositoryState(e) {
        return this.stateByID.get(e.id) || null
      }
      remove(e) {
        this.stateByID.delete(e.id);
        const t = this._repositories.findIndex(t => t.id === e.id);
        t > -1 && this._repositories.splice(t, 1), this.emitUpdate()
      }
    },
    Ob = new class {
      constructor(e) {
        this.queryCache = null, this.pruneQueryCacheTimeoutId = null, this.db = e
      }
      async getLatestUpdatedAt(e) {
        Hu(e);
        const t = this.db,
          n = await t.issues.where("[gitHubRepositoryID+updated_at]").between([e.dbID], [e.dbID + 1], !0, !1).last();
        if (!n || !n.updated_at) return null;
        const r = new Date(n.updated_at);
        return isNaN(r.getTime()) ? null : r
      }
      async refreshIssues(e, t) {
        const n = at.fromAccount(t),
          r = await this.getLatestUpdatedAt(e),
          i = r ? "all" : "open",
          o = await n.fetchIssues(e.owner.login, e.name, i, r);
        this.storeIssues(o, e)
      }
      async storeIssues(e, t) {
        var n;
        Hu(t);
        const r = e.filter(e => "closed" === e.state),
          i = e.filter(e => "open" === e.state).map(e => ({
            gitHubRepositoryID: t.dbID,
            number: e.number,
            title: e.title,
            updated_at: e.updated_at
          })),
          o = this.db;

        function s(e, t) {
          return o.issues.where("[gitHubRepositoryID+number]").equals([e, t]).limit(1).first()
        }
        await this.db.transaction("rw", this.db.issues, async () => {
          for (const e of r) {
            const n = await s(t.dbID, e.number);
            n && await this.db.issues.delete(n.id)
          }
          for (const e of i) {
            const n = await s(t.dbID, e.number);
            n ? await o.issues.update(n.id, e) : await o.issues.add(e)
          }
        }), (null === (n = this.queryCache) || void 0 === n ? void 0 : n.repository.dbID) === t.dbID && (this.queryCache = null, this.clearCachePruneTimeout())
      }
      async getAllIssueHitsFor(e) {
        Hu(e);
        return (await this.db.getIssuesForRepository(e.dbID)).map(e => ({
          number: e.number,
          title: e.title
        }))
      }
      async getIssuesMatching(e, t, n = 25) {
        var r, i;
        Hu(e);
        const o = (null === (r = this.queryCache) || void 0 === r ? void 0 : r.repository.dbID) === e.dbID ? null === (i = this.queryCache) || void 0 === i ? void 0 : i.issues : await this.getAllIssueHitsFor(e);
        if (this.setQueryCache(e, o), !t.length) return o.slice().sort((e, t) => wt(e.number, t.number)).slice(0, n);
        const s = [],
          a = t.toLowerCase();
        for (const e of o) {
          const t = `${e.number} ${e.title}`.trim().toLowerCase().indexOf(a);
          t >= 0 && s.push({
            hit: {
              number: e.number,
              title: e.title
            },
            ix: t
          })
        }
        return s.sort((e, t) => vt(e.ix, t.ix) || vt(e.hit.title, t.hit.title)).slice(0, n).map(e => e.hit)
      }
      setQueryCache(e, t) {
        this.clearCachePruneTimeout(), this.queryCache = {
          repository: e,
          issues: t
        }, this.pruneQueryCacheTimeoutId = window.setTimeout(() => {
          this.pruneQueryCacheTimeoutId = null, this.queryCache = null
        }, 6e4)
      }
      clearCachePruneTimeout() {
        null !== this.pruneQueryCacheTimeoutId && (clearTimeout(this.pruneQueryCacheTimeoutId), this.pruneQueryCacheTimeoutId = null)
      }
    }(new class extends th {
      constructor(e, t) {
        super(e, t), this.conditionalVersion(1, {
          issues: "++id, &[gitHubRepositoryID+number], gitHubRepositoryID, number"
        }), this.conditionalVersion(2, {
          issues: "++id, &[gitHubRepositoryID+number], gitHubRepositoryID, number, [gitHubRepositoryID+updated_at]"
        }, db)
      }
      getIssuesForRepository(e) {
        return this.issues.where("gitHubRepositoryID").equals(e).toArray()
      }
    }("IssuesDatabase")),
    Lb = new class {
      constructor(e, t) {
        this.uiActivityMonitorSubscription = null, this.onUiActivity = async () => (this.disableUiActivityMonitoring(), this.updateDailyMeasures(e => ({
          active: !0
        }))), this.db = e, this.uiActivityMonitor = t;
        const n = me("stats-opt-out");
        this.optOut = n || !1, me("has-sent-stats-opt-in-ping", !1) || this.sendOptInStatusPing(this.optOut, n), this.enableUiActivityMonitoring()
      }
      shouldReportDailyStats() {
        const e = ye("last-daily-stats-report", 0);
        return Date.now() - e > 864e5
      }
      async reportStats(e, t) {
        if (this.optOut) return;
        if (!si()) return;
        if (!this.shouldReportDailyStats()) return;
        const n = Date.now(),
          r = await this.getDailyStats(e, t),
          i = function (e) {
            const t = e.find(e => e.endpoint === pt());
            return void 0 !== t ? t.id : null
          }(e),
          o = null === i ? r : Object.assign(Object.assign({}, r), {
            user_id: i
          });
        try {
          const e = await this.post(o);
          if (!e.ok) throw new Error(`Unexpected status: ${e.statusText} (${e.status})`);
          log.info("Stats reported."), await this.clearDailyStats(), ve("last-daily-stats-report", n)
        } catch (e) {
          log.error("Error reporting stats:", e)
        }
      }
      async recordLaunchStats(e) {
        await this.db.launches.add(e)
      }
      async clearDailyStats() {
        await this.db.launches.clear(), await this.db.dailyMeasures.clear(), localStorage.removeItem("repositories-committed-in-without-write-access"), this.enableUiActivityMonitoring()
      }
      enableUiActivityMonitoring() {
        null === this.uiActivityMonitorSubscription && (this.uiActivityMonitorSubscription = this.uiActivityMonitor.onActivity(this.onUiActivity))
      }
      disableUiActivityMonitoring() {
        null !== this.uiActivityMonitorSubscription && (this.uiActivityMonitorSubscription.dispose(), this.uiActivityMonitorSubscription = null)
      }
      async getDailyStats(e, t) {
        const n = await this.getAverageLaunchStats(),
          r = await this.getDailyMeasures(),
          i = this.determineUserType(e),
          o = this.categorizedRepositoryCounts(t),
          s = this.getOnboardingStats(),
          a = localStorage.getItem("shell") || "none",
          l = localStorage.getItem("externalEditor") || "none",
          c = we("repositories-committed-in-without-write-access").length;
        return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
          eventType: "usage",
          version: Le(),
          osVersion: li(),
          platform: "win32",
          theme: di(fi()),
          selectedTerminalEmulator: a,
          selectedTextEditor: l
        }, n), r), i), s), {
          guid: ui()
        }), o), {
          repositoriesCommittedInWithoutWriteAccess: c
        })
      }
      getOnboardingStats() {
        if (null === hh("welcome-wizard-initiated-at")) return {};
        return {
          timeToWelcomeWizardTerminated: ph("welcome-wizard-terminated-at"),
          timeToFirstAddedRepository: ph("first-repository-added-at"),
          timeToFirstClonedRepository: ph("first-repository-cloned-at"),
          timeToFirstCreatedRepository: ph("first-repository-created-at"),
          timeToFirstCommit: ph("first-commit-created-at"),
          timeToFirstGitHubPush: ph("first-push-to-github-at"),
          timeToFirstNonDefaultBranchCheckout: ph("first-non-default-branch-checkout-at"),
          welcomeWizardSignInMethod: function () {
            const e = localStorage.getItem("welcome-wizard-sign-in-method");
            try {
              switch (e) {
                case Qu.Basic:
                case Qu.Web:
                  return e;
                case null:
                  return;
                default:
                  return X(0, "Unknown sign in method: " + e)
              }
            } catch (e) {
              return void log.error("Could not parse welcome wizard sign in method", e)
            }
          }()
        }
      }
      categorizedRepositoryCounts(e) {
        return {
          repositoryCount: e.length,
          gitHubRepositoryCount: e.filter(e => e.gitHubRepository).length
        }
      }
      determineUserType(e) {
        return {
          dotComAccount: !!e.find(e => e.endpoint === pt()),
          enterpriseAccount: !!e.find(e => e.endpoint !== pt())
        }
      }
      async getAverageLaunchStats() {
        const e = await this.db.launches.toArray();
        if (!e || !e.length) return {
          mainReadyTime: -1,
          loadTime: -1,
          rendererReadyTime: -1
        };
        const t = e.reduce((e, t) => ({
          mainReadyTime: e.mainReadyTime + t.mainReadyTime,
          loadTime: e.loadTime + t.loadTime,
          rendererReadyTime: e.rendererReadyTime + t.rendererReadyTime
        }), {
          mainReadyTime: 0,
          loadTime: 0,
          rendererReadyTime: 0
        });
        return {
          mainReadyTime: t.mainReadyTime / e.length,
          loadTime: t.loadTime / e.length,
          rendererReadyTime: t.rendererReadyTime / e.length
        }
      }
      async getDailyMeasures() {
        const e = await this.db.dailyMeasures.limit(1).first();
        return Object.assign(Object.assign(Object.assign({}, ch), e), {
          id: void 0
        })
      }
      async updateDailyMeasures(e) {
        const t = ch;
        await this.db.transaction("rw", this.db.dailyMeasures, async () => {
          const n = await this.db.dailyMeasures.limit(1).first(),
            r = Object.assign(Object.assign({}, t), n),
            i = hi(r, e(r));
          return this.db.dailyMeasures.put(i)
        })
      }
      async recordCommit() {
        await this.updateDailyMeasures(e => ({
          commits: e.commits + 1
        })), uh("first-commit-created-at")
      }
      recordPartialCommit() {
        return this.updateDailyMeasures(e => ({
          partialCommits: e.partialCommits + 1
        }))
      }
      recordCoAuthoredCommit() {
        return this.updateDailyMeasures(e => ({
          coAuthoredCommits: e.coAuthoredCommits + 1
        }))
      }
      recordOpenShell() {
        return this.updateDailyMeasures(e => ({
          openShellCount: e.openShellCount + 1
        }))
      }
      recordBranchComparison() {
        return this.updateDailyMeasures(e => ({
          branchComparisons: e.branchComparisons + 1
        }))
      }
      recordDefaultBranchComparison() {
        return this.updateDailyMeasures(e => ({
          defaultBranchComparisons: e.defaultBranchComparisons + 1
        }))
      }
      recordCompareInitiatedMerge() {
        return this.updateDailyMeasures(e => ({
          mergesInitiatedFromComparison: e.mergesInitiatedFromComparison + 1
        }))
      }
      recordMenuInitiatedUpdate() {
        return this.updateDailyMeasures(e => ({
          updateFromDefaultBranchMenuCount: e.updateFromDefaultBranchMenuCount + 1
        }))
      }
      recordMergeConflictFromPull() {
        return this.updateDailyMeasures(e => ({
          mergeConflictFromPullCount: e.mergeConflictFromPullCount + 1
        }))
      }
      recordMergeConflictFromExplicitMerge() {
        return this.updateDailyMeasures(e => ({
          mergeConflictFromExplicitMergeCount: e.mergeConflictFromExplicitMergeCount + 1
        }))
      }
      recordMenuInitiatedMerge() {
        return this.updateDailyMeasures(e => ({
          mergeIntoCurrentBranchMenuCount: e.mergeIntoCurrentBranchMenuCount + 1
        }))
      }
      recordMenuInitiatedRebase() {
        return this.updateDailyMeasures(e => ({
          rebaseCurrentBranchMenuCount: e.rebaseCurrentBranchMenuCount + 1
        }))
      }
      recordPRBranchCheckout() {
        return this.updateDailyMeasures(e => ({
          prBranchCheckouts: e.prBranchCheckouts + 1
        }))
      }
      recordRepoClicked(e) {
        return e ? this.updateDailyMeasures(e => ({
          repoWithIndicatorClicked: e.repoWithIndicatorClicked + 1
        })) : this.updateDailyMeasures(e => ({
          repoWithoutIndicatorClicked: e.repoWithoutIndicatorClicked + 1
        }))
      }
      recordUnattributedCommit() {
        return this.updateDailyMeasures(e => ({
          unattributedCommits: e.unattributedCommits + 1
        }))
      }
      recordCommitToEnterprise() {
        return this.updateDailyMeasures(e => ({
          enterpriseCommits: e.enterpriseCommits + 1
        }))
      }
      recordCommitToDotcom() {
        return this.updateDailyMeasures(e => ({
          dotcomCommits: e.dotcomCommits + 1
        }))
      }
      recordCommitToProtectedBranch() {
        return this.updateDailyMeasures(e => ({
          commitsToProtectedBranch: e.commitsToProtectedBranch + 1
        }))
      }
      recordCommitToRepositoryWithBranchProtections() {
        return this.updateDailyMeasures(e => ({
          commitsToRepositoryWithBranchProtections: e.commitsToRepositoryWithBranchProtections + 1
        }))
      }
      async setOptOut(e, t) {
        const n = this.optOut !== e;
        this.optOut = e;
        const r = me("stats-opt-out");
        ge("stats-opt-out", e), (n || t) && await this.sendOptInStatusPing(e, r)
      }
      getOptOut() {
        return this.optOut
      }
      recordDivergingBranchBannerDismissal() {
        return this.updateDailyMeasures(e => ({
          divergingBranchBannerDismissal: e.divergingBranchBannerDismissal + 1
        }))
      }
      recordDivergingBranchBannerInitatedMerge() {
        return this.updateDailyMeasures(e => ({
          divergingBranchBannerInitatedMerge: e.divergingBranchBannerInitatedMerge + 1
        }))
      }
      recordDivergingBranchBannerInitiatedCompare() {
        return this.updateDailyMeasures(e => ({
          divergingBranchBannerInitiatedCompare: e.divergingBranchBannerInitiatedCompare + 1
        }))
      }
      recordDivergingBranchBannerInfluencedMerge() {
        return this.updateDailyMeasures(e => ({
          divergingBranchBannerInfluencedMerge: e.divergingBranchBannerInfluencedMerge + 1
        }))
      }
      recordDivergingBranchBannerDisplayed() {
        return this.updateDailyMeasures(e => ({
          divergingBranchBannerDisplayed: e.divergingBranchBannerDisplayed + 1
        }))
      }
      async recordPush(e, t) {
        null === e ? await this.recordPushToGenericRemote(t) : e.endpoint === pt() ? await this.recordPushToGitHub(t) : await this.recordPushToGitHubEnterprise(t)
      }
      async recordPushToGitHub(e) {
        e && e.forceWithLease && await this.updateDailyMeasures(e => ({
          dotcomForcePushCount: e.dotcomForcePushCount + 1
        })), await this.updateDailyMeasures(e => ({
          dotcomPushCount: e.dotcomPushCount + 1
        })), uh("first-push-to-github-at")
      }
      async recordPushToGitHubEnterprise(e) {
        e && e.forceWithLease && await this.updateDailyMeasures(e => ({
          enterpriseForcePushCount: e.enterpriseForcePushCount + 1
        })), await this.updateDailyMeasures(e => ({
          enterprisePushCount: e.enterprisePushCount + 1
        })), uh("first-push-to-github-at")
      }
      async recordPushToGenericRemote(e) {
        e && e.forceWithLease && await this.updateDailyMeasures(e => ({
          externalForcePushCount: e.externalForcePushCount + 1
        })), await this.updateDailyMeasures(e => ({
          externalPushCount: e.externalPushCount + 1
        }))
      }
      recordUserProceededWhileLoading() {
        return this.updateDailyMeasures(e => ({
          mergedWithLoadingHintCount: e.mergedWithLoadingHintCount + 1
        }))
      }
      recordMergeHintSuccessAndUserProceeded() {
        return this.updateDailyMeasures(e => ({
          mergedWithCleanMergeHintCount: e.mergedWithCleanMergeHintCount + 1
        }))
      }
      recordUserProceededAfterConflictWarning() {
        return this.updateDailyMeasures(e => ({
          mergedWithConflictWarningHintCount: e.mergedWithConflictWarningHintCount + 1
        }))
      }
      recordMergeConflictsDialogDismissal() {
        return this.updateDailyMeasures(e => ({
          mergeConflictsDialogDismissalCount: e.mergeConflictsDialogDismissalCount + 1
        }))
      }
      recordAnyConflictsLeftOnMergeConflictsDialogDismissal() {
        return this.updateDailyMeasures(e => ({
          anyConflictsLeftOnMergeConflictsDialogDismissalCount: e.anyConflictsLeftOnMergeConflictsDialogDismissalCount + 1
        }))
      }
      recordMergeConflictsDialogReopened() {
        return this.updateDailyMeasures(e => ({
          mergeConflictsDialogReopenedCount: e.mergeConflictsDialogReopenedCount + 1
        }))
      }
      recordGuidedConflictedMergeCompletion() {
        return this.updateDailyMeasures(e => ({
          guidedConflictedMergeCompletionCount: e.guidedConflictedMergeCompletionCount + 1
        }))
      }
      recordUnguidedConflictedMergeCompletion() {
        return this.updateDailyMeasures(e => ({
          unguidedConflictedMergeCompletionCount: e.unguidedConflictedMergeCompletionCount + 1
        }))
      }
      recordCreatePullRequest() {
        return this.updateDailyMeasures(e => ({
          createPullRequestCount: e.createPullRequestCount + 1
        }))
      }
      recordRebaseConflictsDialogDismissal() {
        return this.updateDailyMeasures(e => ({
          rebaseConflictsDialogDismissalCount: e.rebaseConflictsDialogDismissalCount + 1
        }))
      }
      recordRebaseConflictsDialogReopened() {
        return this.updateDailyMeasures(e => ({
          rebaseConflictsDialogReopenedCount: e.rebaseConflictsDialogReopenedCount + 1
        }))
      }
      recordRebaseAbortedAfterConflicts() {
        return this.updateDailyMeasures(e => ({
          rebaseAbortedAfterConflictsCount: e.rebaseAbortedAfterConflictsCount + 1
        }))
      }
      recordPullWithRebaseEnabled() {
        return this.updateDailyMeasures(e => ({
          pullWithRebaseCount: e.pullWithRebaseCount + 1
        }))
      }
      recordRebaseSuccessWithoutConflicts() {
        return this.updateDailyMeasures(e => ({
          rebaseSuccessWithoutConflictsCount: e.rebaseSuccessWithoutConflictsCount + 1
        }))
      }
      recordRebaseSuccessAfterConflicts() {
        return this.updateDailyMeasures(e => ({
          rebaseSuccessAfterConflictsCount: e.rebaseSuccessAfterConflictsCount + 1
        }))
      }
      recordPullWithDefaultSetting() {
        return this.updateDailyMeasures(e => ({
          pullWithDefaultSettingCount: e.pullWithDefaultSettingCount + 1
        }))
      }
      recordWelcomeWizardInitiated() {
        ve("welcome-wizard-initiated-at", Date.now()), localStorage.removeItem("welcome-wizard-terminated-at")
      }
      recordWelcomeWizardTerminated() {
        ve("welcome-wizard-terminated-at", Date.now())
      }
      recordAddExistingRepository() {
        uh("first-repository-added-at")
      }
      recordCloneRepository() {
        uh("first-repository-cloned-at")
      }
      recordCreateRepository() {
        uh("first-repository-created-at")
      }
      recordNonDefaultBranchCheckout() {
        uh("first-non-default-branch-checkout-at")
      }
      recordWelcomeWizardSignInMethod(e) {
        localStorage.setItem("welcome-wizard-sign-in-method", e)
      }
      recordMergeSuccessAfterConflicts() {
        return this.updateDailyMeasures(e => ({
          mergeSuccessAfterConflictsCount: e.mergeSuccessAfterConflictsCount + 1
        }))
      }
      recordMergeAbortedAfterConflicts() {
        return this.updateDailyMeasures(e => ({
          mergeAbortedAfterConflictsCount: e.mergeAbortedAfterConflictsCount + 1
        }))
      }
      recordStashViewedAfterCheckout() {
        return this.updateDailyMeasures(e => ({
          stashViewedAfterCheckoutCount: e.stashViewedAfterCheckoutCount + 1
        }))
      }
      recordStashNotViewedAfterCheckout() {
        return this.updateDailyMeasures(e => ({
          stashNotViewedAfterCheckoutCount: e.stashNotViewedAfterCheckoutCount + 1
        }))
      }
      recordChangesTakenToNewBranch() {
        return this.updateDailyMeasures(e => ({
          changesTakenToNewBranchCount: e.changesTakenToNewBranchCount + 1
        }))
      }
      recordStashCreatedOnCurrentBranch() {
        return this.updateDailyMeasures(e => ({
          stashCreatedOnCurrentBranchCount: e.stashCreatedOnCurrentBranchCount + 1
        }))
      }
      recordStashDiscard() {
        return this.updateDailyMeasures(e => ({
          stashDiscardCount: e.stashDiscardCount + 1
        }))
      }
      recordStashView() {
        return this.updateDailyMeasures(e => ({
          stashViewCount: e.stashViewCount + 1
        }))
      }
      recordStashRestore() {
        return this.updateDailyMeasures(e => ({
          stashRestoreCount: e.stashRestoreCount + 1
        }))
      }
      recordNoActionTakenOnStash() {
        return this.updateDailyMeasures(e => ({
          noActionTakenOnStashCount: e.noActionTakenOnStashCount + 1
        }))
      }
      addStashEntriesCreatedOutsideDesktop(e) {
        return this.updateDailyMeasures(t => ({
          stashEntriesCreatedOutsideDesktop: t.stashEntriesCreatedOutsideDesktop + e
        }))
      }
      recordErrorWhenSwitchingBranchesWithUncommmittedChanges() {
        return this.updateDailyMeasures(e => ({
          errorWhenSwitchingBranchesWithUncommmittedChanges: e.errorWhenSwitchingBranchesWithUncommmittedChanges + 1
        }))
      }
      recordSuggestedStepOpenInExternalEditor() {
        return this.updateDailyMeasures(e => ({
          suggestedStepOpenInExternalEditor: e.suggestedStepOpenInExternalEditor + 1
        }))
      }
      recordSuggestedStepOpenWorkingDirectory() {
        return this.updateDailyMeasures(e => ({
          suggestedStepOpenWorkingDirectory: e.suggestedStepOpenWorkingDirectory + 1
        }))
      }
      recordSuggestedStepViewOnGitHub() {
        return this.updateDailyMeasures(e => ({
          suggestedStepViewOnGitHub: e.suggestedStepViewOnGitHub + 1
        }))
      }
      recordSuggestedStepPublishRepository() {
        return this.updateDailyMeasures(e => ({
          suggestedStepPublishRepository: e.suggestedStepPublishRepository + 1
        }))
      }
      recordSuggestedStepPublishBranch() {
        return this.updateDailyMeasures(e => ({
          suggestedStepPublishBranch: e.suggestedStepPublishBranch + 1
        }))
      }
      recordSuggestedStepCreatePullRequest() {
        return this.updateDailyMeasures(e => ({
          suggestedStepCreatePullRequest: e.suggestedStepCreatePullRequest + 1
        }))
      }
      recordSuggestedStepViewStash() {
        return this.updateDailyMeasures(e => ({
          suggestedStepViewStash: e.suggestedStepViewStash + 1
        }))
      }
      recordTutorialStarted() {
        return this.updateDailyMeasures(() => ({
          tutorialStarted: !0
        }))
      }
      recordTutorialRepoCreated() {
        return this.updateDailyMeasures(() => ({
          tutorialRepoCreated: !0
        }))
      }
      recordTutorialEditorInstalled() {
        return this.updateDailyMeasures(() => ({
          tutorialEditorInstalled: !0
        }))
      }
      recordTutorialBranchCreated() {
        return this.updateDailyMeasures(() => ({
          tutorialEditorInstalled: !0,
          tutorialBranchCreated: !0
        }))
      }
      recordTutorialFileEdited() {
        return this.updateDailyMeasures(() => ({
          tutorialEditorInstalled: !0,
          tutorialBranchCreated: !0,
          tutorialFileEdited: !0
        }))
      }
      recordTutorialCommitCreated() {
        return this.updateDailyMeasures(() => ({
          tutorialEditorInstalled: !0,
          tutorialBranchCreated: !0,
          tutorialFileEdited: !0,
          tutorialCommitCreated: !0
        }))
      }
      recordTutorialBranchPushed() {
        return this.updateDailyMeasures(() => ({
          tutorialEditorInstalled: !0,
          tutorialBranchCreated: !0,
          tutorialFileEdited: !0,
          tutorialCommitCreated: !0,
          tutorialBranchPushed: !0
        }))
      }
      recordTutorialPrCreated() {
        return this.updateDailyMeasures(() => ({
          tutorialEditorInstalled: !0,
          tutorialBranchCreated: !0,
          tutorialFileEdited: !0,
          tutorialCommitCreated: !0,
          tutorialBranchPushed: !0,
          tutorialPrCreated: !0
        }))
      }
      recordTutorialCompleted() {
        return this.updateDailyMeasures(() => ({
          tutorialCompleted: !0
        }))
      }
      recordHighestTutorialStepCompleted(e) {
        return this.updateDailyMeasures(t => ({
          highestTutorialStepCompleted: Math.max(e, t.highestTutorialStepCompleted)
        }))
      }
      recordCommitToRepositoryWithoutWriteAccess() {
        return this.updateDailyMeasures(e => ({
          commitsToRepositoryWithoutWriteAccess: e.commitsToRepositoryWithoutWriteAccess + 1
        }))
      }
      recordRepositoryCommitedInWithoutWriteAccess(e) {
        const t = we("repositories-committed-in-without-write-access");
        t.includes(e) || be("repositories-committed-in-without-write-access", [...t, e])
      }
      recordForkCreated() {
        return this.updateDailyMeasures(e => ({
          forksCreated: e.forksCreated + 1
        }))
      }
      recordIssueCreationWebpageOpened() {
        return this.updateDailyMeasures(e => ({
          issueCreationWebpageOpenedCount: e.issueCreationWebpageOpenedCount + 1
        }))
      }
      recordTagCreatedInDesktop() {
        return this.updateDailyMeasures(e => ({
          tagsCreatedInDesktop: e.tagsCreatedInDesktop + 1
        }))
      }
      recordTagCreated(e) {
        return this.updateDailyMeasures(t => ({
          tagsCreated: t.tagsCreated + e
        }))
      }
      recordTagDeleted() {
        return this.updateDailyMeasures(e => ({
          tagsDeleted: e.tagsDeleted + 1
        }))
      }
      post(e) {
        const t = {
          method: "POST",
          headers: new Headers({
            "Content-Type": "application/json"
          }),
          body: JSON.stringify(e)
        };
        return fetch("https://central.github.com/api/usage/desktop", t)
      }
      async sendOptInStatusPing(e, t) {
        const n = !e,
          r = void 0 === t ? null : !t,
          i = n ? "in" : "out";
        try {
          const e = await this.post({
            eventType: "ping",
            optIn: n,
            previousOptInValue: r
          });
          if (!e.ok) throw new Error(`Unexpected status: ${e.statusText} (${e.status})`);
          ge("has-sent-stats-opt-in-ping", !0), log.info(`Opt ${i} reported.`)
        } catch (e) {
          log.error(`Error reporting opt ${i}:`, e)
        }
      }
    }(new class extends oi {
      constructor(e) {
        super(e), this.version(1).stores({
          launches: "++"
        }), this.version(2).stores({
          dailyMeasures: "++id"
        })
      }
    }("StatsDatabase"), new class {
      constructor() {
        this.emitter = new ne.Emitter, this.subscriberCount = 0, this.onMouseDown = e => {
          null !== e.target && e.target instanceof HTMLElement && function (e) {
            for (; null !== e;) {
              if (mb.has(e.nodeName)) return !0;
              const t = e.getAttribute("role");
              if (null !== t && gb.has(t)) return !0;
              e = e instanceof HTMLElement ? e.parentElement : null
            }
            return !1
          }(e.target) && this.emit("pointer")
        }, this.onKeyDown = e => {
          this.emit("keyboard")
        }, this.onMenuEvent = e => {
          this.emit("menu")
        }
      }
      onActivity(e) {
        const t = this.emitter.on("activity", e);
        return 0 === this.subscriberCount && this.startTracking(), this.subscriberCount++, new ne.Disposable(() => {
          this.subscriberCount--, 0 === this.subscriberCount && this.stopTracking(), t.dispose()
        })
      }
      emit(e) {
        this.emitter.emit("activity", e)
      }
      startTracking() {
        document.addEventListener("mousedown", this.onMouseDown), document.addEventListener("keydown", this.onKeyDown), r.ipcRenderer.on("menu-event", this.onMenuEvent)
      }
      stopTracking() {
        document.removeEventListener("mousedown", this.onMouseDown), document.removeEventListener("keydown", this.onKeyDown), r.ipcRenderer.removeListener("menu-event", this.onMenuEvent)
      }
    }),
    Nb = new class extends wi {
      constructor() {
        super(...arguments), this.state = null, this.endpointSupportBasicAuth = new Map
      }
      emitAuthenticate(e, t) {
        const n = {
          account: e,
          method: t
        };
        this.emitter.emit("did-authenticate", n)
      }
      onDidAuthenticate(e) {
        return this.emitter.on("did-authenticate", ({
          account: t,
          method: n
        }) => {
          e(t, n)
        })
      }
      emitDotComSupportsBasicAuthUpdated(e) {
        const t = {
          dotComSupportsBasicAuth: e
        };
        this.emitter.emit("dotComSupportsBasicAuthUpdated", t)
      }
      onDotComSupportsBasicAuthUpdated(e) {
        return this.endpointSupportBasicAuth.has(pt()) || this.endpointSupportsBasicAuth(pt()).catch(e => {}), this.emitter.on("dotComSupportsBasicAuthUpdated", ({
          dotComSupportsBasicAuth: t
        }) => {
          e(t)
        })
      }
      tryGetDotComSupportsBasicAuth() {
        const e = this.endpointSupportBasicAuth.get(pt());
        return void 0 === e ? Xu() : e
      }
      getState() {
        return this.state
      }
      setState(e) {
        this.state = e, this.emitUpdate(this.getState())
      }
      async endpointSupportsBasicAuth(e) {
        const t = this.endpointSupportBasicAuth.get(e),
          n = void 0 === t ? null : {
            verifiable_password_authentication: t
          },
          r = await async function (e, t, n) {
            let r = null;
            const i = new Promise(e => {
              r = window.setTimeout(() => e(n), t)
            });
            return Promise.race([e, i]).finally(() => {
              null !== r && window.clearTimeout(r)
            })
          }(async function (e) {
            const t = e + "/meta";
            try {
              const t = await He(e, null, "GET", "meta", void 0, {
                  "Content-Type": "application/json"
                }),
                n = await Ue(t);
              return n && void 0 !== n.verifiable_password_authentication ? n : null
            } catch (e) {
              return log.error(`fetchMetadata: unable to load metadata from '${t}' as a fallback`, e), null
            }
          }(e), 2e3, n);
        if (null !== r) {
          const t = !0 === r.verifiable_password_authentication;
          return this.endpointSupportBasicAuth.set(e, t), e === pt() && this.emitDotComSupportsBasicAuthUpdated(t), t
        }
        if (e === pt()) {
          const e = Xu();
          return this.emitDotComSupportsBasicAuthUpdated(e), e
        }
        throw new Error("Unable to authenticate with the GitHub Enterprise Server instance. Verify that the URL is correct, that your GitHub Enterprise Server instance is running version 2.8.0 or later, that you have an internet connection and try again.")
      }
      getForgotPasswordURL(e) {
        return ht(e) + "/password_reset"
      }
      reset() {
        this.setState(null)
      }
      beginDotComSignIn() {
        const e = pt();
        this.setState({
          kind: Yu.Authentication,
          endpoint: e,
          supportsBasicAuth: this.tryGetDotComSupportsBasicAuth(),
          error: null,
          loading: !1,
          forgotPasswordUrl: this.getForgotPasswordURL(e)
        }), this.endpointSupportsBasicAuth(e).then(t => {
          null !== this.state && this.state.kind === Yu.Authentication && this.state.endpoint === e && this.setState(Object.assign(Object.assign({}, this.state), {
            supportsBasicAuth: t
          }))
        }).catch(e => log.error("Failed resolving whether GitHub.com supports password authentication", e))
      }
      async authenticateWithBasicAuth(e, t) {
        const n = this.state;
        if (!n || n.kind !== Yu.Authentication) {
          return Z(`Sign in step '${n?n.kind:"null"}' not compatible with authentication`)
        }
        const r = n.endpoint;
        let i;
        this.setState(Object.assign(Object.assign({}, n), {
          loading: !0
        }));
        try {
          i = await ct(r, e, t, null)
        } catch (e) {
          return void this.emitError(e)
        }
        if (this.state && this.state.kind === Yu.Authentication)
          if (i.kind === lt.Authorized) {
            const e = i.token,
              t = await ut(r, e);
            if (!this.state || this.state.kind !== Yu.Authentication) return;
            this.emitAuthenticate(t, Qu.Basic), this.setState({
              kind: Yu.Success
            })
          } else if (i.kind === lt.TwoFactorAuthenticationRequired) this.setState({
          kind: Yu.TwoFactorAuthentication,
          endpoint: r,
          username: e,
          password: t,
          type: i.type,
          error: null,
          loading: !1
        });
        else if (i.kind === lt.Error) this.emitError(new Error(`The server responded with an error while attempting to authenticate (${i.response.status})\n\n${i.response.statusText}`)), this.setState(Object.assign(Object.assign({}, n), {
          loading: !1
        }));
        else if (i.kind === lt.Failed) e.includes("@") ? this.setState(Object.assign(Object.assign({}, n), {
          loading: !1,
          error: new Error("Incorrect email or password.")
        })) : this.setState(Object.assign(Object.assign({}, n), {
          loading: !1,
          error: new Error("Incorrect username or password.")
        }));
        else if (i.kind === lt.UserRequiresVerification) this.setState(Object.assign(Object.assign({}, n), {
          loading: !1,
          error: new Error(qu(e))
        }));
        else if (i.kind === lt.PersonalAccessTokenBlocked) this.setState(Object.assign(Object.assign({}, n), {
          loading: !1,
          error: new Error("A personal access token cannot be used to login to GitHub Desktop.")
        }));
        else if (i.kind === lt.EnterpriseTooOld) this.setState(Object.assign(Object.assign({}, n), {
          loading: !1,
          error: new Error(Ku)
        }));
        else {
          if (i.kind !== lt.WebFlowRequired) return X(0, "Unsupported response: " + i);
          this.setState(Object.assign(Object.assign({}, n), {
            loading: !1,
            supportsBasicAuth: !1,
            kind: Yu.Authentication
          }))
        }
      }
      async authenticateWithBrowser() {
        const e = this.state;
        if (!e || e.kind !== Yu.Authentication) {
          return Z(`Sign in step '${e?e.kind:"null"}' not compatible with browser authentication`)
        }
        let t;
        this.setState(Object.assign(Object.assign({}, e), {
          loading: !0
        }));
        try {
          log.info("[SignInStore] initializing OAuth flow"), t = await Vu(e.endpoint), log.info("[SignInStore] account resolved")
        } catch (t) {
          return log.info("[SignInStore] error with OAuth flow", t), void this.setState(Object.assign(Object.assign({}, e), {
            error: t,
            loading: !1
          }))
        }
        this.state && this.state.kind === Yu.Authentication && (this.emitAuthenticate(t, Qu.Web), this.setState({
          kind: Yu.Success
        }))
      }
      beginEnterpriseSignIn() {
        this.setState({
          kind: Yu.EndpointEntry,
          error: null,
          loading: !1
        })
      }
      async setEndpoint(e) {
        const t = this.state;
        if (!t || t.kind !== Yu.EndpointEntry) {
          return Z(`Sign in step '${t?t.kind:"null"}' not compatible with endpoint entry`)
        }
        let n;
        this.setState(Object.assign(Object.assign({}, t), {
          loading: !0
        }));
        try {
          n = function (e) {
            const t = e.trim();
            if (0 === t.length) {
              const e = new Error("Unknown address");
              throw e.name = "invalid-url", e
            }
            let n = Te.parse(t);
            if (n.host || (e = "https://" + t, n = Te.parse(e)), !n.protocol) {
              const e = new Error("Invalid URL");
              throw e.name = "invalid-url", e
            }
            if (!$u.has(n.protocol)) {
              const e = new Error("Invalid protocol");
              throw e.name = "invalid-protocol", e
            }
            return e
          }(e)
        } catch (e) {
          let n = e;
          return "invalid-url" === e.name ? n = new Error("The GitHub Enterprise Server instance address doesn't appear to be a valid URL. We're expecting something like https://github.example.com.") : "invalid-protocol" === e.name && (n = new Error("Unsupported protocol. Only http or https is supported when authenticating with GitHub Enterprise Server instances.")), void this.setState(Object.assign(Object.assign({}, t), {
            loading: !1,
            error: n
          }))
        }
        const r = function (e) {
          const t = Te.parse(e);
          return `${t.protocol}//${t.hostname}/api/v3`
        }(n);
        try {
          const e = await this.endpointSupportsBasicAuth(r);
          if (!this.state || this.state.kind !== Yu.EndpointEntry) return;
          this.setState({
            kind: Yu.Authentication,
            endpoint: r,
            supportsBasicAuth: e,
            error: null,
            loading: !1,
            forgotPasswordUrl: this.getForgotPasswordURL(r)
          })
        } catch (e) {
          let n = e;
          "ENOTFOUND" === e.code && (n = new Error("The server could not be found. Please verify that the URL is correct and that you have a stable internet connection.")), this.setState(Object.assign(Object.assign({}, t), {
            loading: !1,
            error: n
          }))
        }
      }
      async setTwoFactorOTP(e) {
        const t = this.state;
        if (!t || t.kind !== Yu.TwoFactorAuthentication) {
          Z(`Sign in step '${t?t.kind:"null"}' not compatible with two factor authentication`)
        }
        let n;
        this.setState(Object.assign(Object.assign({}, t), {
          loading: !0
        }));
        try {
          n = await ct(t.endpoint, t.username, t.password, e)
        } catch (e) {
          return void this.emitError(e)
        }
        if (this.state && this.state.kind === Yu.TwoFactorAuthentication)
          if (n.kind === lt.Authorized) {
            const e = n.token,
              r = await ut(t.endpoint, e);
            if (!this.state || this.state.kind !== Yu.TwoFactorAuthentication) return;
            this.emitAuthenticate(r, Qu.Basic), this.setState({
              kind: Yu.Success
            })
          } else switch (n.kind) {
            case lt.Failed:
            case lt.TwoFactorAuthenticationRequired:
              this.setState(Object.assign(Object.assign({}, t), {
                loading: !1,
                error: new Error("Two-factor authentication failed.")
              }));
              break;
            case lt.Error:
              this.emitError(new Error(`The server responded with an error (${n.response.status})\n\n${n.response.statusText}`));
              break;
            case lt.UserRequiresVerification:
              this.emitError(new Error(qu(t.username)));
              break;
            case lt.PersonalAccessTokenBlocked:
              this.emitError(new Error("A personal access token cannot be used to login to GitHub Desktop."));
              break;
            case lt.EnterpriseTooOld:
              this.emitError(new Error(Ku));
              break;
            case lt.WebFlowRequired:
              this.setState(Object.assign(Object.assign({}, t), {
                forgotPasswordUrl: this.getForgotPasswordURL(t.endpoint),
                loading: !1,
                supportsBasicAuth: !1,
                kind: Yu.Authentication,
                error: null
              }));
              break;
            default:
              X(0, "Unknown response: " + n)
          }
      }
    },
    Fb = new class extends wi {
      constructor(e, t) {
        super(), this.accounts = [], this.dataStore = e, this.secureStore = t, this.loadingPromise = this.loadFromStore()
      }
      async getAll() {
        return await this.loadingPromise, this.accounts.slice()
      }
      async addAccount(e) {
        await this.loadingPromise;
        try {
          const t = gi(e);
          await this.secureStore.setItem(t, e.login, e.token)
        } catch (t) {
          return log.error(`Error adding account '${e.login}'`, t), this.emitError(t), null
        }
        const t = this.accounts.reduce((e, t) => e.set(t.endpoint, t), new Map);
        return t.set(e.endpoint, e), this.accounts = [...t.values()], this.save(), e
      }
      async refresh() {
        this.accounts = await Promise.all(this.accounts.map(e => this.tryUpdateAccount(e))), this.save(), this.emitUpdate(this.accounts)
      }
      async tryUpdateAccount(e) {
        try {
          return await async function (e) {
            if (!e.token) return Z("Cannot update an account which doesn't have a token: " + e.login);
            return ut(e.endpoint, e.token)
          }(e)
        } catch (t) {
          return log.warn(`Error refreshing account '${e.login}'`, t), e
        }
      }
      async removeAccount(e) {
        await this.loadingPromise;
        try {
          await this.secureStore.deleteItem(gi(e), e.login)
        } catch (t) {
          return log.error(`Error removing account '${e.login}'`, t), void this.emitError(t)
        }
        this.accounts = this.accounts.filter(t => !(t.endpoint === e.endpoint && t.id === e.id)), this.save()
      }
      async loadFromStore() {
        const e = this.dataStore.getItem("users");
        if (!e || !e.length) return;
        const t = JSON.parse(e),
          n = [];
        for (const e of t) {
          const t = new De(e.login, e.endpoint, "", e.emails, e.avatarURL, e.id, e.name),
            r = gi(t);
          try {
            const i = await this.secureStore.getItem(r, e.login);
            n.push(t.withToken(i || ""))
          } catch (e) {
            log.error(`Error getting token for '${r}'. Skipping.`, e), this.emitError(e)
          }
        }
        this.accounts = n, this.emitUpdate(this.accounts)
      }
      save() {
        const e = this.accounts.map(e => e.withToken(""));
        this.dataStore.setItem("users", JSON.stringify(e)), this.emitUpdate(this.accounts)
      }
    }(localStorage, Xo),
    Bb = new class extends wi {
      constructor(e) {
        super(), this.lastStashCheckCache = new Map, this.branchProtectionSettingsFoundCache = new Map, this.protectionEnabledForBranchCache = new Map, this.db = e
      }
      async upsertGitHubRepository(e, t) {
        return this.db.transaction("rw", this.db.repositories, this.db.gitHubRepositories, this.db.owners, async () => {
          const n = await this.db.gitHubRepositories.where("cloneURL").equals(t.clone_url).limit(1).first();
          return null == n ? this.putGitHubRepository(e, t) : this.buildGitHubRepository(n)
        })
      }
      async buildGitHubRepository(e) {
        const t = await this.db.owners.get(e.ownerID);
        if (null == t) throw new Error("Couldn't find repository owner " + e.ownerID);
        let n = null;
        return e.parentID && (n = await this.findGitHubRepositoryByID(e.parentID)), new Vi(e.name, new Gi(t.login, t.endpoint, t.id), e.id, e.private, e.htmlURL, e.defaultBranch, e.cloneURL, e.issuesEnabled, e.isArchived, e.permissions, n)
      }
      async findGitHubRepositoryByID(e) {
        const t = await this.db.gitHubRepositories.get(e);
        return t ? this.buildGitHubRepository(t) : null
      }
      getAll() {
        return this.db.transaction("r", this.db.repositories, this.db.gitHubRepositories, this.db.owners, async () => {
          const e = new Array,
            t = await this.db.repositories.toArray();
          for (const n of t) {
            let t = null,
              r = null;
            n.gitHubRepositoryID && (r = await this.findGitHubRepositoryByID(n.gitHubRepositoryID)), t = new Xi(n.path, n.id, r, n.missing, n.workflowPreferences, n.isTutorialRepository), e.push(t)
          }
          return e
        })
      }
      async addTutorialRepository(e, t, n) {
        await this.db.transaction("rw", this.db.repositories, this.db.gitHubRepositories, this.db.owners, async () => {
          const r = await this.upsertGitHubRepository(t, n),
            i = await this.db.repositories.get({
              path: e
            }),
            o = i && null !== i.id ? i.id : void 0;
          return await this.db.repositories.put({
            path: e,
            gitHubRepositoryID: r.dbID,
            missing: !1,
            lastStashCheckDate: null,
            isTutorialRepository: !0
          }, o)
        }), this.emitUpdatedRepositories()
      }
      async addRepository(e) {
        const t = await this.db.transaction("rw", this.db.repositories, this.db.gitHubRepositories, this.db.owners, async () => {
          const t = (await this.db.repositories.toArray()).find(t => t.path === e);
          let n, r = null;
          return null != t ? (n = t.id, null != t.gitHubRepositoryID && (r = await this.findGitHubRepositoryByID(t.gitHubRepositoryID))) : n = await this.db.repositories.add({
            path: e,
            gitHubRepositoryID: null,
            missing: !1,
            lastStashCheckDate: null
          }), new Xi(e, n, r, !1)
        });
        return this.emitUpdatedRepositories(), t
      }
      async removeRepository(e) {
        await this.db.repositories.delete(e.id), Xc(e), this.emitUpdatedRepositories()
      }
      async updateRepositoryMissing(e, t) {
        const n = e.id;
        return n ? (await this.db.repositories.update(n, {
          missing: t
        }), this.emitUpdatedRepositories(), new Xi(e.path, e.id, e.gitHubRepository, t, e.workflowPreferences, e.isTutorialRepository)) : Z("`updateRepositoryMissing` can only update `missing` for a repository which has been added to the database.")
      }
      async updateRepositoryWorkflowPreferences(e, t) {
        const n = e.id;
        if (!n) return Z("`updateRepositoryWorkflowPreferences` can only update `workflowPreferences` for a repository which has been added to the database.");
        await this.db.repositories.update(n, {
          workflowPreferences: t
        }), this.emitUpdatedRepositories()
      }
      async updateRepositoryPath(e, t) {
        const n = e.id;
        return n ? (await this.db.repositories.update(n, {
          missing: !1,
          path: t
        }), this.emitUpdatedRepositories(), new Xi(t, e.id, e.gitHubRepository, !1, e.workflowPreferences, e.isTutorialRepository)) : Z("`updateRepositoryPath` can only update the path for a repository which has been added to the database.")
      }
      async updateLastStashCheckDate(e, t = Date.now()) {
        const n = e.id;
        if (0 === n) return Z("`updateLastStashCheckDate` can only update the last stash check date for a repository which has been added to the database.");
        await this.db.repositories.update(n, {
          lastStashCheckDate: t
        }), this.lastStashCheckCache.set(n, t)
      }
      async getLastStashCheckDate(e) {
        const t = e.id;
        if (!t) return Z("`getLastStashCheckDate` - can only retrieve the last stash check date for a repositories that have been stored in the database.");
        let n = this.lastStashCheckCache.get(t) || null;
        if (null !== n) return n;
        const r = await this.db.repositories.get(t);
        return void 0 === r ? Z("'getLastStashCheckDate' - unable to find repository with ID: " + t) : (n = r.lastStashCheckDate, null !== n && this.lastStashCheckCache.set(t, n), n)
      }
      async putOwner(e, t) {
        t = t.toLowerCase();
        const n = await this.db.owners.where("[endpoint+login]").equals([e, t]).first();
        if (n) return new Gi(t, e, n.id);
        const r = {
            login: t,
            endpoint: e
          },
          i = await this.db.owners.add(r);
        return new Gi(t, e, i)
      }
      async putGitHubRepository(e, t) {
        let n = null;
        t.parent && (n = await this.putGitHubRepository(e, t.parent));
        const r = t.owner.login.toLowerCase(),
          i = await this.putOwner(e, r),
          o = await this.db.gitHubRepositories.where("[ownerID+name]").equals([i.id, t.name]).first(),
          s = function (e) {
            return e ? e.admin ? "admin" : e.push ? "write" : e.pull ? "read" : null : null
          }(t.permissions) || (o ? o.permissions : void 0);
        let a = {
          ownerID: i.id,
          name: t.name,
          private: t.private,
          htmlURL: t.html_url,
          defaultBranch: t.default_branch,
          cloneURL: t.clone_url,
          parentID: n ? n.dbID : null,
          lastPruneDate: null,
          issuesEnabled: t.has_issues,
          isArchived: t.archived,
          permissions: s
        };
        o && (a = Object.assign(Object.assign({}, a), {
          id: o.id
        }));
        const l = await this.db.gitHubRepositories.put(a);
        return new Vi(a.name, i, l, a.private, a.htmlURL, a.defaultBranch, a.cloneURL, a.issuesEnabled, a.isArchived, a.permissions, n)
      }
      async updateGitHubRepository(e, t, n) {
        const r = e.id;
        if (!r) return Z("`updateGitHubRepository` can only update a GitHub repository for a repository which has been added to the database.");
        const i = await this.db.transaction("rw", this.db.repositories, this.db.gitHubRepositories, this.db.owners, async () => {
          const e = await this.db.repositories.get(r),
            i = await this.putGitHubRepository(t, n);
          return await this.db.repositories.update(e.id, {
            gitHubRepositoryID: i.dbID
          }), i
        });
        return this.emitUpdatedRepositories(), new Xi(e.path, e.id, i, e.missing, e.workflowPreferences, e.isTutorialRepository)
      }
      async updateBranchProtections(e, t) {
        const n = e.dbID;
        if (!n) return Z("`updateBranchProtections` can only update a GitHub repository for a repository which has been added to the database.");
        await this.db.transaction("rw", this.db.protectedBranches, async () => {
          const e = Uu(n);
          for (const t of this.protectionEnabledForBranchCache.keys()) t.startsWith(e) && this.protectionEnabledForBranchCache.delete(t);
          const r = t.map(e => ({
            repoId: n,
            name: e.name
          }));
          for (const e of r) {
            const t = zu(n, e.name);
            this.protectionEnabledForBranchCache.set(t, !0)
          }
          await this.db.protectedBranches.where("repoId").equals(n).delete();
          const i = r.length > 0;
          this.branchProtectionSettingsFoundCache.set(n, i), r.length > 0 && await this.db.protectedBranches.bulkAdd(r)
        })
      }
      async updateLastPruneDate(e, t) {
        if (0 === e.id) return Z("`updateLastPruneDate` can only update the last prune date for a repository which has been added to the database.");
        const n = e.gitHubRepository;
        if (null === n) return Z("'updateLastPruneDate' can only update GitHub repositories");
        const r = n.dbID;
        if (null === r) return Z("'updateLastPruneDate' can only update GitHub repositories with a valid ID: received ID of " + r);
        await this.db.gitHubRepositories.update(r, {
          lastPruneDate: t
        })
      }
      async getLastPruneDate(e) {
        if (!e.id) return Z("`getLastPruneDate` - can only retrieve the last prune date for a repositories that have been stored in the database.");
        const t = e.gitHubRepository;
        if (null === t) return Z("'getLastPruneDate' - can only retrieve the last prune date for GitHub repositories.");
        const n = t.dbID;
        if (null === n) return Z("'getLastPruneDate' - can only retrieve the last prune date for GitHub repositories that have been stored in the database.");
        const r = await this.db.gitHubRepositories.get(n);
        return void 0 === r ? Z("'getLastPruneDate' - unable to find GitHub repository with ID: " + n) : r.lastPruneDate
      }
      async loadAndCacheBranchProtection(e) {
        const t = await this.db.protectedBranches.where("repoId").equals(e).toArray(),
          n = t.length > 0;
        this.branchProtectionSettingsFoundCache.set(e, n);
        for (const n of t) {
          const t = zu(e, n.name);
          this.protectionEnabledForBranchCache.set(t, !0)
        }
        return n
      }
      async hasBranchProtectionsConfigured(e) {
        if (null === e.dbID) return Z("unable to get protected branches, GitHub repository has a null dbID");
        const {
          dbID: t
        } = e, n = this.branchProtectionSettingsFoundCache.get(t);
        return void 0 === n ? this.loadAndCacheBranchProtection(t) : n
      }
      async emitUpdatedRepositories() {
        this.emitUpdate(await this.getAll())
      }
    }(new class extends th {
      constructor(e, t) {
        super(e, t), this.conditionalVersion(1, {
          repositories: "++id, &path",
          gitHubRepositories: "++id, name",
          owners: "++id, login"
        }), this.conditionalVersion(2, {
          owners: "++id, &[endpoint+login]"
        }), this.conditionalVersion(3, {}, fb), this.conditionalVersion(4, {
          gitHubRepositories: "++id, name, &[ownerID+name]"
        }), this.conditionalVersion(5, {
          gitHubRepositories: "++id, name, &[ownerID+name], cloneURL"
        }), this.conditionalVersion(6, {
          protectedBranches: "[repoId+name], repoId"
        })
      }
    }("Database")),
    Hb = new class {
      constructor(e, t) {
        this.db = e, this.repositoryStore = t, this.emitter = new ne.Emitter, this.currentRefreshOperations = new Map, this.lastRefreshForRepository = new Map
      }
      emitPullRequestsChanged(e, t) {
        this.emitter.emit("onPullRequestsChanged", {
          repository: e,
          pullRequests: t
        })
      }
      onPullRequestsChanged(e) {
        return this.emitter.on("onPullRequestsChanged", t => {
          const {
            repository: n,
            pullRequests: r
          } = t;
          e(n, r)
        })
      }
      refreshPullRequests(e, t) {
        const n = e.dbID;
        if (null === n) return Promise.resolve();
        const r = this.currentRefreshOperations.get(n);
        if (void 0 !== r) return r;
        this.lastRefreshForRepository.set(n, Date.now());
        const i = this.fetchAndStorePullRequests(e, t).catch(t => {
          log.error(`Error refreshing pull requests for '${e.fullName}'`, t)
        }).then(() => {
          this.currentRefreshOperations.delete(n)
        });
        return this.currentRefreshOperations.set(n, i), i
      }
      async fetchAndStorePullRequests(e, t) {
        const n = at.fromAccount(t),
          r = await this.db.getLastUpdated(e);
        return r ? this.fetchAndStoreUpdatedPullRequests(n, e, r) : this.fetchAndStoreOpenPullRequests(n, e)
      }
      async fetchAndStoreOpenPullRequests(e, t) {
        const {
          name: n,
          owner: r
        } = oh(t), i = await e.fetchAllOpenPullRequests(r, n);
        await this.storePullRequestsAndEmitUpdate(i, t)
      }
      async fetchAndStoreUpdatedPullRequests(e, t, n) {
        const {
          name: r,
          owner: i
        } = oh(t), o = await e.fetchUpdatedPullRequests(i, r, n).catch(e => e instanceof it || e instanceof Fe ? Promise.resolve(null) : Promise.reject(e));
        if (null !== o) return await this.storePullRequestsAndEmitUpdate(o, t);
        await this.db.deleteAllPullRequestsInRepository(t), await this.fetchAndStoreOpenPullRequests(e, t)
      }
      getLastRefreshed(e) {
        return e.dbID ? this.lastRefreshForRepository.get(e.dbID) : void 0
      }
      async getAll(e) {
        if (null === e.dbID) return [];
        const t = await this.db.getAllPullRequestsInRepository(e),
          n = new Array,
          r = this.repositoryStore,
          i = eh()(r.findGitHubRepositoryByID.bind(r));
        for (const e of t) {
          const t = await i(e.head.repoId),
            r = await i(e.base.repoId);
          if (null === t) return Z("head repository can't be null");
          if (null === r) return Z("base repository can't be null");
          n.push(new ih(new Date(e.createdAt), e.title, e.number, new rh(e.head.ref, e.head.sha, t), new rh(e.base.ref, e.base.sha, r), e.author))
        }
        return n.reverse()
      }
      async storePullRequestsAndEmitUpdate(e, t) {
        await this.storePullRequests(e, t) && this.emitPullRequestsChanged(t, await this.getAll(t))
      }
      async storePullRequests(e, t) {
        if (0 === e.length) return !1;
        let n = e[0].updated_at;
        const r = new Array,
          i = new Array,
          {
            endpoint: o
          } = t,
          s = this.repositoryStore,
          a = eh()(s.upsertGitHubRepository.bind(s), {
            cacheKey: (e, t) => t.clone_url
          });
        for (const s of e) {
          if (s.updated_at > n && (n = s.updated_at), null === s.base.repo) return Z("PR cannot have a null base repo");
          const e = await a(o, s.base.repo);
          if (null === e.dbID) return Z("PR cannot have a null parent database id");
          if ("closed" === s.state) {
            r.push(nh(e, s.number));
            continue
          }
          if (null == s.head.repo) {
            log.debug(`Unable to store pull request #${s.number} for repository ${t.fullName} as it has no head repository associated with it`), r.push(nh(e, s.number));
            continue
          }
          const l = await a(o, s.head.repo);
          if (null === l.dbID) return Z("PR cannot have non-existent repo");
          i.push({
            number: s.number,
            title: s.title,
            createdAt: s.created_at,
            updatedAt: s.updated_at,
            head: {
              ref: s.head.ref,
              sha: s.head.sha,
              repoId: l.dbID
            },
            base: {
              ref: s.base.ref,
              sha: s.base.sha,
              repoId: e.dbID
            },
            author: s.user.login
          })
        }
        if (0 === r.length && 1 === i.length) {
          const e = i[0],
            n = await this.db.getPullRequest(t, e.number);
          if (void 0 !== n && yu(e, n)) return !1
        }
        return await this.db.transaction("rw", this.db.pullRequests, this.db.pullRequestsLastUpdated, async () => {
          await this.db.deletePullRequests(r), await this.db.putPullRequests(i), await this.db.setLastUpdated(t, new Date(n))
        }), !0
      }
    }(new class extends th {
      constructor(e, t) {
        super(e, t), this.conditionalVersion(1, {
          pullRequests: "id++, base.repoId"
        }), this.conditionalVersion(2, {
          pullRequestStatus: "id++, &[sha+pullRequestId]"
        }), this.conditionalVersion(3, {
          pullRequestStatus: "id++, &[sha+pullRequestId], pullRequestId"
        }), this.conditionalVersion(4, {}), this.conditionalVersion(5, {
          pullRequestStatus: null
        }), this.conditionalVersion(6, {
          pullRequests: null
        }), this.conditionalVersion(7, {
          pullRequests: "[base.repoId+number]",
          pullRequestsLastUpdated: "repoId"
        })
      }
      async deleteAllPullRequestsInRepository(e) {
        const t = J("Can't delete PRs for repository, no dbId", e.dbID);
        await this.transaction("rw", this.pullRequests, this.pullRequestsLastUpdated, async () => {
          await this.clearLastUpdated(e), await this.pullRequests.where("[base.repoId+number]").between([t], [t + 1]).delete()
        })
      }
      async deletePullRequests(e) {
        await this.pullRequests.bulkDelete(e)
      }
      async putPullRequests(e) {
        await this.pullRequests.bulkPut(e)
      }
      getAllPullRequestsInRepository(e) {
        return null === e.dbID ? Z("Can't retrieve PRs for repository, no dbId") : this.pullRequests.where("[base.repoId+number]").between([e.dbID], [e.dbID + 1]).toArray()
      }
      getPullRequest(e, t) {
        return null === e.dbID ? Z("Can't retrieve PRs for repository with a null dbID") : this.pullRequests.get([e.dbID, t])
      }
      async getLastUpdated(e) {
        if (null === e.dbID) return Z("Can't retrieve PRs for repository with a null dbID");
        const t = await this.pullRequestsLastUpdated.get(e.dbID);
        return t ? new Date(t.lastUpdated) : null
      }
      async clearLastUpdated(e) {
        if (null === e.dbID) throw new Error("Can't clear last updated PR for repository with a null dbID");
        await this.pullRequestsLastUpdated.delete(e.dbID)
      }
      async setLastUpdated(e, t) {
        if (null === e.dbID) throw new Error("Can't set last updated for PR with a null dbID");
        await this.pullRequestsLastUpdated.put({
          repoId: e.dbID,
          lastUpdated: t.getTime()
        })
      }
    }("PullRequestDatabase"), Bb),
    zb = new class {
      constructor(e, t) {
        this.pullRequestStore = e, this.repositoriesStore = t, this.currentPullRequestUpdater = null, this.repositories = new Array, this.prCache = new Map, this.emitter = new ne.Emitter, this.repositoriesStore.onDidUpdate(e => {
          this.repositories = e.filter(Ji)
        })
      }
      onPullRequestsChanged(e) {
        return this.pullRequestStore.onPullRequestsChanged((t, n) => {
          null !== t.dbID && this.prCache.set(t.dbID, n);
          const r = ah(t, this.repositories);
          for (const t of r) e(t, n)
        })
      }
      onIsLoadingPullRequests(e) {
        return this.emitter.on("onIsLoadingPullRequest", t => {
          const {
            repository: n,
            isLoadingPullRequests: r
          } = t;
          e(n, r)
        })
      }
      async refreshPullRequests(e, t) {
        const n = ro(e),
          r = ah(n, this.repositories);
        for (const e of r) this.emitIsLoadingPullRequests(e, !0);
        await this.pullRequestStore.refreshPullRequests(n, t);
        for (const e of r) this.emitIsLoadingPullRequests(e, !1)
      }
      getLastRefreshed(e) {
        const t = ro(e);
        return this.pullRequestStore.getLastRefreshed(t)
      }
      async getAllPullRequests(e) {
        return this.getPullRequestsFor(ro(e))
      }
      startPullRequestUpdater(e, t) {
        null !== this.currentPullRequestUpdater && this.stopPullRequestUpdater(), this.currentPullRequestUpdater = new sh(e, t, this), this.currentPullRequestUpdater.start()
      }
      stopPullRequestUpdater() {
        null !== this.currentPullRequestUpdater && (this.currentPullRequestUpdater.stop(), this.currentPullRequestUpdater = null)
      }
      emitIsLoadingPullRequests(e, t) {
        this.emitter.emit("onIsLoadingPullRequest", {
          repository: e,
          isLoadingPullRequests: t
        })
      }
      async getPullRequestsFor(e) {
        const {
          dbID: t
        } = e;
        return null === t ? [] : (this.prCache.has(t) || this.prCache.set(t, await this.pullRequestStore.getAll(e)), this.prCache.get(t) || [])
      }
    }(Hb, Bb),
    Ub = new class {
      constructor() {
        this.repositoryState = new Map
      }
      get(e) {
        const t = this.repositoryState.get(e.hash);
        if (null != t) return t;
        const n = {
          commitSelection: {
            sha: null,
            file: null,
            changedFiles: new Array,
            diff: null
          },
          changesState: {
            workingDirectory: ho.fromFiles(new Array),
            selection: {
              kind: G.WorkingDirectory,
              selectedFileIDs: [],
              diff: null
            },
            commitMessage: Nc,
            coAuthors: [],
            showCoAuthoredBy: !1,
            conflictState: null,
            stashEntry: null,
            currentBranchProtected: !1
          },
          selectedSection: j.Changes,
          branchesState: {
            tip: {
              kind: Qi.Unknown
            },
            defaultBranch: null,
            allBranches: new Array,
            recentBranches: new Array,
            openPullRequests: new Array,
            currentPullRequest: null,
            isLoadingPullRequests: !1,
            rebasedBranches: new Map
          },
          compareState: {
            divergingBranchBannerState: {
              isPromptVisible: !1,
              isPromptDismissed: !1,
              isNudgeVisible: !1
            },
            formState: {
              kind: $.History
            },
            tip: null,
            mergeStatus: null,
            showBranchList: !1,
            filterText: "",
            commitSHAs: [],
            aheadBehindCache: new wc,
            allBranches: new Array,
            recentBranches: new Array,
            defaultBranch: null,
            inferredComparisonBranch: {
              branch: null,
              aheadBehind: null
            }
          },
          rebaseState: {
            step: null,
            progress: null,
            commits: null,
            userHasResolvedConflicts: !1
          },
          commitAuthor: null,
          commitLookup: new Map,
          localCommitSHAs: [],
          localTags: null,
          tagsToPush: null,
          aheadBehind: null,
          remote: null,
          isPushPullFetchInProgress: !1,
          isCommitting: !1,
          lastFetched: null,
          checkoutProgress: null,
          pushPullFetchProgress: null,
          revertProgress: null
        };
        return this.repositoryState.set(e.hash, n), n
      }
      update(e, t) {
        const n = this.get(e),
          r = t(n);
        this.repositoryState.set(e.hash, hi(n, r))
      }
      updateCompareState(e, t) {
        this.update(e, e => {
          const n = e.compareState;
          return {
            compareState: hi(n, t(n))
          }
        })
      }
      updateChangesState(e, t) {
        this.update(e, e => {
          const n = e.changesState;
          return {
            changesState: hi(n, t(n))
          }
        })
      }
      updateCommitSelection(e, t) {
        this.update(e, e => {
          const {
            commitSelection: n
          } = e;
          return {
            commitSelection: hi(n, t(n))
          }
        })
      }
      updateBranchesState(e, t) {
        this.update(e, e => {
          const n = e.branchesState;
          return {
            branchesState: hi(n, t(n))
          }
        })
      }
      updateRebaseState(e, t) {
        this.update(e, e => {
          const {
            rebaseState: n
          } = e;
          return {
            rebaseState: hi(n, t(n))
          }
        })
      }
    },
    Wb = new class extends vi {
      constructor(e) {
        super(), this.accountState = new Map, this.onAccountsChanged = e => {
          const t = new Map;
          for (const n of e)
            for (const [e, r] of this.accountState.entries())
              if (yb(e, n)) {
                t.set(n, r);
                break
              } this.accountState = t, this.emitUpdate()
        }, e.onDidUpdate(this.onAccountsChanged)
      }
      updateAccount(e, t) {
        const n = new Map(this.accountState),
          r = vb(e, n),
          i = n.get(r),
          o = hi(void 0 === i ? {
            loading: !1,
            repositories: []
          } : i, t);
        n.set(r, o), this.accountState = n, this.emitUpdate()
      }
      async loadRepositories(e) {
        const t = vb(e, this.accountState),
          n = this.accountState.get(t);
        if (void 0 !== n && n.loading) return;
        this.updateAccount(t, {
          loading: !0
        });
        const r = at.fromAccount(t),
          i = await r.fetchRepositories();
        null === i ? this.updateAccount(e, {
          loading: !1
        }) : this.updateAccount(e, {
          loading: !1,
          repositories: i
        })
      }
      getState() {
        return this.accountState
      }
    }(Fb),
    Vb = new class {
      constructor(e) {
        this.accounts = [], this.backgroundRefreshHandle = null, this.refreshQueued = !1, this.subscriptions = new Map, this.cache = new Cb.a({
          maxSize: 250
        }), this.queue = new Set, this.limit = bb()(5), this.onAccountsUpdated = e => {
          this.accounts = e
        }, e.getAll().then(this.onAccountsUpdated), e.onDidUpdate(this.onAccountsUpdated)
      }
      startBackgroundRefresh() {
        null === this.backgroundRefreshHandle && (this.backgroundRefreshHandle = window.setInterval(() => this.queueRefresh(), 18e4), this.queueRefresh())
      }
      stopBackgroundRefresh() {
        null !== this.backgroundRefreshHandle && (window.clearInterval(this.backgroundRefreshHandle), this.backgroundRefreshHandle = null)
      }
      queueRefresh() {
        this.refreshQueued || (this.refreshQueued = !0, setImmediate(() => {
          this.refreshQueued = !1, this.refreshEligibleSubscriptions()
        }))
      }
      refreshEligibleSubscriptions() {
        for (const e of this.subscriptions.keys()) {
          if (this.queue.has(e)) continue;
          const t = this.cache.get(e);
          t && !kb(t) || (this.limit(() => this.refreshSubscription(e)).catch(e => log.error("Failed refreshing commit status", e)).then(() => this.queue.delete(e)), this.queue.add(e))
        }
      }
      async refreshSubscription(e) {
        const t = this.subscriptions.get(e);
        if (void 0 === t) return;
        const {
          endpoint: n,
          owner: r,
          name: i,
          ref: o
        } = t, s = this.accounts.find(e => e.endpoint === n);
        if (void 0 !== s) try {
          const n = at.fromAccount(s),
            a = await n.fetchCombinedRefStatus(r, i, o);
          this.cache.set(e, {
            status: a,
            fetchedAt: new Date
          }), t.callbacks.forEach(e => e(a))
        } catch (t) {
          log.debug(`Failed fetching status for ref ${o} (${r}/${i})`, t);
          const n = this.cache.get(e),
            s = void 0 === n ? null : n.status;
          this.cache.set(e, {
            status: s,
            fetchedAt: new Date
          })
        }
      }
      tryGetStatus(e, t) {
        const n = this.cache.get(Eb(e, t));
        return void 0 !== n ? n.status : null
      }
      getOrCreateSubscription(e, t) {
        const n = Eb(e, t);
        let r = this.subscriptions.get(n);
        return void 0 !== r || (r = {
          endpoint: e.endpoint,
          owner: e.owner.login,
          name: e.name,
          ref: t,
          callbacks: new Set
        }, this.subscriptions.set(n, r)), r
      }
      subscribe(e, t, n) {
        const r = Eb(e, t),
          i = this.getOrCreateSubscription(e, t);
        return i.callbacks.add(n), this.queueRefresh(), new ne.Disposable(() => {
          i.callbacks.delete(n), 0 === i.callbacks.size && this.subscriptions.delete(r)
        })
      }
    }(Fb),
    jb = new class extends wi {
      constructor(e, t, n, i, o, s, a, l, c, u) {
        super(), this.gitHubUserStore = e, this.cloningRepositoriesStore = t, this.issuesStore = n, this.statsStore = i, this.signInStore = o, this.accountsStore = s, this.repositoriesStore = a, this.pullRequestCoordinator = l, this.repositoryStateCache = c, this.apiRepositoriesStore = u, this.accounts = new Array, this.repositories = new Array, this.recentRepositories = new Array, this.selectedRepository = null, this.currentBackgroundFetcher = null, this.currentAheadBehindUpdater = null, this.currentBranchPruner = null, this.showWelcomeFlow = !1, this.focusCommitMessage = !1, this.currentPopup = null, this.currentFoldout = null, this.currentBanner = null, this.errors = new Array, this.emitQueued = !1, this.localRepositoryStateLookup = new Map, this.emoji = new Map, this.appMenu = null, this.highlightAccessKeys = !1, this.appIsFocused = !1, this.sidebarWidth = 250, this.commitSummaryWidth = 250, this.stashedFilesWidth = 250, this.windowZoomFactor = 1, this.isUpdateAvailableBannerVisible = !1, this.askForConfirmationOnRepositoryRemoval = !0, this.confirmDiscardChanges = !0, this.askForConfirmationOnForcePush = !0, this.imageDiffType = Nu, this.hideWhitespaceInDiff = !1, this.uncommittedChangesStrategyKind = uu, this.selectedExternalEditor = null, this.resolvedExternalEditor = null, this.selectedShell = hc, this.repositoryFilterText = "", this.currentMergeTreePromise = null, this.resolveOpenInDesktop = null, this.selectedCloneRepositoryTab = Si.DotCom, this.selectedBranchesTab = bi.Branches, this.selectedTheme = pi.Light, this.automaticallySwitchTheme = !1, this.hasUserViewedStash = !1, this.currentOnboardingTutorialStep = Su.NotApplicable, this.getResolvedExternalEditor = () => this.resolvedExternalEditor, this.showWelcomeFlow = !si(), this.gitStoreCache = new ru(ee, this.statsStore, (e, t) => this.onGitStoreUpdated(e, t), e => this.emitError(e));
        const h = r.remote.getCurrentWindow();
        this.windowState = gc(h), this.onWindowZoomFactorChanged(h.webContents.zoomFactor), this.wireupIpcEventHandlers(h), this.wireupStoreEventHandlers(), r.ipcRenderer.send("get-app-menu"), this.tutorialAssessor = new ku(this.getResolvedExternalEditor)
      }
      async updateCurrentTutorialStep(e) {
        const t = await this.tutorialAssessor.getCurrentStep(e.isTutorialRepository, this.repositoryStateCache.get(e));
        t !== this.currentOnboardingTutorialStep && (this.currentOnboardingTutorialStep = t, log.info("Current tutorial step is now " + t), this.recordTutorialStepCompleted(t), this.emitUpdate())
      }
      recordTutorialStepCompleted(e) {
        if (Cu(e)) switch (this.statsStore.recordHighestTutorialStepCompleted(Eu.indexOf(e)), e) {
          case Su.PickEditor:
            break;
          case Su.CreateBranch:
            this.statsStore.recordTutorialEditorInstalled();
            break;
          case Su.EditFile:
            this.statsStore.recordTutorialBranchCreated();
            break;
          case Su.MakeCommit:
            this.statsStore.recordTutorialFileEdited();
            break;
          case Su.PushBranch:
            this.statsStore.recordTutorialCommitCreated();
            break;
          case Su.OpenPullRequest:
            this.statsStore.recordTutorialBranchPushed();
            break;
          case Su.AllDone:
            this.statsStore.recordTutorialPrCreated(), this.statsStore.recordTutorialCompleted();
            break;
          default:
            X(0, "Unaccounted for step type")
        }
      }
      async _resumeTutorial(e) {
        this.tutorialAssessor.resumeTutorial(), await this.updateCurrentTutorialStep(e)
      }
      async _pauseTutorial(e) {
        this.tutorialAssessor.pauseTutorial(), await this.updateCurrentTutorialStep(e)
      }
      async _skipPickEditorTutorialStep(e) {
        this.tutorialAssessor.skipPickEditor(), await this.updateCurrentTutorialStep(e)
      }
      async _markPullRequestTutorialStepAsComplete(e) {
        this.tutorialAssessor.markPullRequestTutorialStepAsComplete(), await this.updateCurrentTutorialStep(e)
      }
      wireupIpcEventHandlers(e) {
        r.ipcRenderer.on("window-state-changed", (e, t) => {
          this.windowState = t, this.emitUpdate()
        }), r.ipcRenderer.on("zoom-factor-changed", (e, t) => {
          this.onWindowZoomFactorChanged(t)
        }), r.ipcRenderer.on("app-menu", (e, {
          menu: t
        }) => {
          this.setAppMenu(t)
        })
      }
      wireupStoreEventHandlers() {
        this.gitHubUserStore.onDidUpdate(() => {
          this.emitUpdate()
        }), this.cloningRepositoriesStore.onDidUpdate(() => {
          this.emitUpdate()
        }), this.cloningRepositoriesStore.onDidError(e => this.emitError(e)), this.signInStore.onDidAuthenticate((e, t) => {
          this._addAccount(e), this.showWelcomeFlow && this.statsStore.recordWelcomeWizardSignInMethod(t)
        }), this.signInStore.onDidUpdate(() => this.emitUpdate()), this.signInStore.onDidError(e => this.emitError(e)), this.accountsStore.onDidUpdate(e => {
          this.accounts = e, this.emitUpdate()
        }), this.accountsStore.onDidError(e => this.emitError(e)), this.repositoriesStore.onDidUpdate(e => {
          this.repositories = e, this.updateRepositorySelectionAfterRepositoriesChanged(), this.emitUpdate()
        }), this.pullRequestCoordinator.onPullRequestsChanged((e, t) => this.onPullRequestChanged(e, t)), this.pullRequestCoordinator.onIsLoadingPullRequests((e, t) => {
          this.repositoryStateCache.updateBranchesState(e, () => ({
            isLoadingPullRequests: t
          })), this.emitUpdate()
        }), this.apiRepositoriesStore.onDidUpdate(() => this.emitUpdate()), this.apiRepositoriesStore.onDidError(e => this.emitError(e))
      }
      loadEmoji() {
        Lc(Ne()).then(e => {
          this.emoji = e, this.emitUpdate()
        }).catch(e => {
          log.warn("Unexpected issue when trying to read emoji into memory", e)
        })
      }
      emitUpdate() {
        "hidden" !== this.windowState ? this.emitQueued || (this.emitQueued = !0, window.requestAnimationFrame(() => {
          this.emitUpdateNow()
        })) : this.emitUpdateNow()
      }
      emitUpdateNow() {
        this.emitQueued = !1;
        const e = this.getState();
        super.emitUpdate(e), nc(e, this.appMenu)
      }
      onWindowZoomFactorChanged(e) {
        const t = this.windowZoomFactor;
        this.windowZoomFactor = e, e !== t && this.emitUpdate()
      }
      getSelectedState() {
        const e = this.selectedRepository;
        if (!e) return null;
        if (e instanceof Ai) {
          const t = this.cloningRepositoriesStore.getRepositoryState(e);
          return t ? {
            type: W.CloningRepository,
            repository: e,
            progress: t
          } : null
        }
        return e.missing ? {
          type: W.MissingRepository,
          repository: e
        } : {
          type: W.Repository,
          repository: e,
          state: this.repositoryStateCache.get(e)
        }
      }
      getState() {
        const e = [...this.repositories, ...this.cloningRepositoriesStore.repositories];
        return {
          accounts: this.accounts,
          repositories: e,
          recentRepositories: this.recentRepositories,
          localRepositoryStateLookup: this.localRepositoryStateLookup,
          windowState: this.windowState,
          windowZoomFactor: this.windowZoomFactor,
          appIsFocused: this.appIsFocused,
          selectedState: this.getSelectedState(),
          signInState: this.signInStore.getState(),
          currentPopup: this.currentPopup,
          currentFoldout: this.currentFoldout,
          errors: this.errors,
          showWelcomeFlow: this.showWelcomeFlow,
          focusCommitMessage: this.focusCommitMessage,
          emoji: this.emoji,
          sidebarWidth: this.sidebarWidth,
          commitSummaryWidth: this.commitSummaryWidth,
          stashedFilesWidth: this.stashedFilesWidth,
          appMenuState: this.appMenu ? this.appMenu.openMenus : [],
          highlightAccessKeys: this.highlightAccessKeys,
          isUpdateAvailableBannerVisible: this.isUpdateAvailableBannerVisible,
          currentBanner: this.currentBanner,
          askForConfirmationOnRepositoryRemoval: this.askForConfirmationOnRepositoryRemoval,
          askForConfirmationOnDiscardChanges: this.confirmDiscardChanges,
          askForConfirmationOnForcePush: this.askForConfirmationOnForcePush,
          uncommittedChangesStrategyKind: this.uncommittedChangesStrategyKind,
          selectedExternalEditor: this.selectedExternalEditor,
          imageDiffType: this.imageDiffType,
          hideWhitespaceInDiff: this.hideWhitespaceInDiff,
          selectedShell: this.selectedShell,
          repositoryFilterText: this.repositoryFilterText,
          resolvedExternalEditor: this.resolvedExternalEditor,
          selectedCloneRepositoryTab: this.selectedCloneRepositoryTab,
          selectedBranchesTab: this.selectedBranchesTab,
          selectedTheme: this.selectedTheme,
          automaticallySwitchTheme: this.automaticallySwitchTheme,
          apiRepositories: this.apiRepositoriesStore.getState(),
          optOutOfUsageTracking: this.statsStore.getOptOut(),
          currentOnboardingTutorialStep: this.currentOnboardingTutorialStep
        }
      }
      onGitStoreUpdated(e, t) {
        const n = this.repositoryStateCache.get(e);
        this.repositoryStateCache.updateBranchesState(e, r => {
          let {
            currentPullRequest: i
          } = r;
          const {
            tip: o,
            currentRemote: s
          } = t;
          if (! function (e, t) {
              if (e === t) return !0;
              const n = e.kind;
              switch (e.kind) {
                case Qi.Unknown:
                  return e.kind === t.kind;
                case Qi.Unborn:
                  return e.kind === t.kind && e.ref === t.ref;
                case Qi.Detached:
                  return e.kind === t.kind && e.currentSha === t.currentSha;
                case Qi.Valid:
                  return e.kind === t.kind && function (e, t) {
                    return e.type === t.type && e.tip.sha === t.tip.sha && e.remote === t.remote && e.upstream === t.upstream
                  }(e.branch, t.branch);
                default:
                  return X(0, "Unknown tip state " + n)
              }
            }(r.tip, o) || (a = n.remote) !== (l = s) && (null === a || null === l || a.name !== l.name || a.url !== l.url))
            if (o.kind !== Qi.Valid || null === s) i = null;
            else {
              const {
                branch: t
              } = o;
              if (!i || !Tu(t, i, s)) {
                i = xu(t, r.openPullRequests, s)
              }
              o.kind === Qi.Valid && r.tip.kind === Qi.Valid && o.branch.name !== r.tip.branch.name && this.refreshBranchProtectionState(e)
            } var a, l;
          return {
            tip: t.tip,
            defaultBranch: t.defaultBranch,
            allBranches: t.allBranches,
            recentBranches: t.recentBranches,
            pullWithRebase: t.pullWithRebase,
            currentPullRequest: i
          }
        });
        let r = !1,
          i = !1;
        this.repositoryStateCache.updateChangesState(e, e => {
          const n = t.currentBranchStashEntry;
          return e.selection.kind === G.Stash && null !== e.stashEntry && (null === n ? r = !0 : e.stashEntry.stashSha !== n.stashSha && (i = !0)), {
            commitMessage: t.commitMessage,
            showCoAuthoredBy: t.showCoAuthoredBy,
            coAuthors: t.coAuthors,
            stashEntry: n
          }
        }), this.repositoryStateCache.update(e, () => ({
          commitLookup: t.commitLookup,
          localCommitSHAs: t.localCommitSHAs,
          localTags: t.localTags,
          aheadBehind: t.aheadBehind,
          tagsToPush: t.tagsToPush,
          remote: t.currentRemote,
          lastFetched: t.lastFetched
        })), r ? this._selectWorkingDirectoryFiles(e) : i ? this._selectStashedFile(e) : this.emitUpdate()
      }
      clearBranchProtectionState(e) {
        this.repositoryStateCache.updateChangesState(e, () => ({
          currentBranchProtected: !1
        })), this.emitUpdate()
      }
      async refreshBranchProtectionState(e) {
        const t = this.gitStoreCache.get(e);
        if (t.tip.kind === Qi.Valid && null !== e.gitHubRepository) {
          const n = e.gitHubRepository,
            r = bu(t.tip, t.currentRemote, n);
          if (null !== r) {
            const t = dt(this.accounts, n.endpoint);
            if (null === t) return;
            if (!ji(n)) return this.repositoryStateCache.updateChangesState(e, () => ({
              currentBranchProtected: !1
            })), void this.emitUpdate();
            const i = n.name,
              o = n.owner.login,
              s = at.fromAccount(t),
              a = ! function (e) {
                const {
                  allow_actor: t,
                  required_status_checks: n,
                  required_approving_review_count: r
                } = e, i = Array.isArray(n) ? n.length : 0;
                return !1 !== t && (0 === i && 0 === r)
              }(await s.fetchPushControl(o, i, r));
            this.repositoryStateCache.updateChangesState(e, () => ({
              currentBranchProtected: a
            })), this.emitUpdate()
          }
        }
      }
      clearSelectedCommit(e) {
        this.repositoryStateCache.updateCommitSelection(e, () => ({
          sha: null,
          file: null,
          changedFiles: [],
          diff: null
        }))
      }
      async _changeCommitSelection(e, t) {
        const {
          commitSelection: n
        } = this.repositoryStateCache.get(e);
        n.sha !== t && (this.repositoryStateCache.updateCommitSelection(e, () => ({
          sha: t,
          file: null,
          changedFiles: [],
          diff: null
        })), this.emitUpdate())
      }
      updateOrSelectFirstCommit(e, t) {
        let n = this.repositoryStateCache.get(e).commitSelection.sha;
        if (null != n) {
          t.findIndex(e => e === n) < 0 && (n = null, this.clearSelectedCommit(e))
        }
        null == n && t.length > 0 && (this._changeCommitSelection(e, t[0]), this._loadChangedFilesForCurrentSelection(e))
      }
      startAheadBehindUpdater(e) {
        null != this.currentAheadBehindUpdater && Z("An ahead/behind updater is already active and cannot start updating on " + e.name);
        const t = new bc(e, t => {
          this.repositoryStateCache.updateCompareState(e, () => ({
            aheadBehindCache: t
          })), this.emitUpdate()
        });
        this.currentAheadBehindUpdater = t, this.currentAheadBehindUpdater.start()
      }
      stopAheadBehindUpdate() {
        const e = this.currentAheadBehindUpdater;
        null != e && (e.stop(), this.currentAheadBehindUpdater = null)
      }
      async _initializeCompare(e, t) {
        const n = this.repositoryStateCache.get(e),
          {
            branchesState: r,
            compareState: i
          } = n,
          {
            tip: o,
            currentPullRequest: s
          } = r,
          a = o.kind === Qi.Valid ? o.branch : null,
          l = null != a ? r.allBranches.filter(e => e.name !== a.name) : r.allBranches,
          c = a ? r.recentBranches.filter(e => e.name !== a.name) : r.recentBranches,
          u = r.defaultBranch,
          h = null != a && null != u && a.name !== u.name ? u : null,
          p = this.currentAheadBehindUpdater;
        let d = null,
          f = null;
        o.kind === Qi.Valid && null !== p && (d = await Tc(e, l, s, zs), null !== d && (f = await p.executeAsyncTask(o.branch.tip.sha, d.tip.sha))), this.repositoryStateCache.updateCompareState(e, () => ({
          allBranches: l,
          recentBranches: c,
          defaultBranch: h,
          inferredComparisonBranch: {
            branch: d,
            aheadBehind: f
          }
        }));
        let m = 0,
          g = !1;
        if (null !== d) {
          m = Fu(f);
          const e = Fu(n.compareState.inferredComparisonBranch.aheadBehind);
          g = m > 0 && e !== m
        }
        g ? this._updateDivergingBranchBannerState(e, {
          isPromptVisible: !0,
          isNudgeVisible: !0,
          isPromptDismissed: !1
        }) : m > 0 ? this._updateDivergingBranchBannerState(e, {
          isPromptVisible: !0
        }) : this._updateDivergingBranchBannerState(e, {
          isPromptVisible: !1,
          isNudgeVisible: !1
        });
        const y = i.formState,
          v = null != t ? t : function (e) {
            if (e.kind === $.History) return {
              kind: $.History
            };
            const {
              comparisonMode: t,
              comparisonBranch: n
            } = e;
            return {
              kind: $.Compare,
              comparisonMode: t,
              branch: n
            }
          }(y);
        this._executeCompare(e, v)
      }
      async _executeCompare(e, t) {
        const n = this.gitStoreCache.get(e),
          r = t.kind;
        if (t.kind === $.History) {
          const {
            tip: t
          } = n;
          let r = null;
          t.kind === Qi.Valid ? r = t.branch.tip.sha : t.kind === Qi.Detached && (r = t.currentSha);
          const {
            compareState: i
          } = this.repositoryStateCache.get(e), {
            formState: o,
            commitSHAs: s
          } = i, a = i.tip;
          if (null !== r && null !== a && r === a && o.kind === $.History && s.length > 0) return;
          const l = await n.loadCommitBatch("HEAD");
          if (null === l) return;
          const c = {
            kind: $.History
          };
          return this.repositoryStateCache.updateCompareState(e, () => ({
            tip: r,
            formState: c,
            commitSHAs: l,
            filterText: "",
            showBranchList: !1
          })), this.updateOrSelectFirstCommit(e, l), this.emitUpdate()
        }
        return t.kind === $.Compare ? this.updateCompareToBranch(e, t) : X(0, "Unknown action: " + r)
      }
      async updateCompareToBranch(e, t) {
        const n = this.gitStoreCache.get(e),
          r = t.branch,
          i = await n.getCompareCommits(r, t.comparisonMode);
        this.statsStore.recordBranchComparison();
        const {
          branchesState: o
        } = this.repositoryStateCache.get(e);
        if (null !== o.defaultBranch && r.name === o.defaultBranch.name && this.statsStore.recordDefaultBranchComparison(), null == i) return;
        const {
          ahead: s,
          behind: a
        } = i, l = {
          ahead: s,
          behind: a
        }, c = i.commits.map(e => e.sha), u = {
          kind: $.Compare,
          comparisonBranch: r,
          comparisonMode: t.comparisonMode,
          aheadBehind: l
        };
        this.repositoryStateCache.updateCompareState(e, e => ({
          formState: u,
          filterText: r.name,
          commitSHAs: c
        }));
        const h = n.tip;
        let p = null;
        if (h.kind === Qi.Valid ? p = h.branch.tip.sha : h.kind === Qi.Detached && (p = h.currentSha), null != this.currentAheadBehindUpdater && null != p) {
          const e = t.comparisonMode === q.Ahead ? r.tip.sha : p,
            n = t.comparisonMode === q.Ahead ? p : r.tip.sha;
          this.currentAheadBehindUpdater.insert(e, n, l)
        }
        const d = {
          kind: al.Loading
        };
        if (this.repositoryStateCache.updateCompareState(e, () => ({
            mergeStatus: d
          })), this.emitUpdate(), this.updateOrSelectFirstCommit(e, c), null != this.currentMergeTreePromise) return this.currentMergeTreePromise;
        if (h.kind === Qi.Valid && l.behind > 0) {
          const n = Sc(() => dl(e, h.branch, t.branch), 500).catch(e => (log.warn(`Error occurred while trying to merge ${h.branch.name} (${h.branch.tip.sha}) and ${t.branch.name} (${t.branch.tip.sha})`, e), null)).then(t => {
              this.repositoryStateCache.updateCompareState(e, () => ({
                mergeStatus: t
              })), this.emitUpdate()
            }),
            r = () => {
              this.currentMergeTreePromise = null
            };
          return n.then(r, r), this.currentMergeTreePromise = n, this.currentMergeTreePromise
        }
        return this.repositoryStateCache.updateCompareState(e, () => ({
          mergeStatus: null
        })), this.emitUpdate()
      }
      _updateCompareForm(e, t) {
        this.repositoryStateCache.updateCompareState(e, e => hi(e, t)), this.emitUpdate();
        const {
          branchesState: n,
          compareState: r
        } = this.repositoryStateCache.get(e);
        if (n.tip.kind === Qi.Valid && null !== this.currentAheadBehindUpdater)
          if (r.showBranchList) {
            const e = n.tip.branch;
            this.currentAheadBehindUpdater.schedule(e, r.defaultBranch, r.recentBranches, r.allBranches)
          } else this.currentAheadBehindUpdater.clear()
      }
      async _loadNextCommitBatch(e) {
        const t = this.gitStoreCache.get(e),
          n = this.repositoryStateCache.get(e),
          {
            formState: r
          } = n.compareState;
        if (r.kind === $.History) {
          const r = n.compareState.commitSHAs,
            i = r[r.length - 1],
            o = await t.loadCommitBatch(i + "^");
          if (null == o) return;
          this.repositoryStateCache.updateCompareState(e, () => ({
            commitSHAs: r.concat(o)
          })), this.emitUpdate()
        }
      }
      async _loadChangedFilesForCurrentSelection(e) {
        const t = this.repositoryStateCache.get(e),
          {
            commitSelection: n
          } = t,
          r = n.sha;
        if (null == r) return;
        const i = this.gitStoreCache.get(e),
          o = await i.performFailableOperation(() => async function (e, t) {
            const n = ["log", t, "-C", "-M", "-m", "-1", "--no-show-signature", "--first-parent", "--name-status", "--format=format:", "-z", "--"];
            return Na((await Bo(n, e.path, "getChangedFiles")).stdout, t)
          }(e, r));
        if (!o) return;
        if (r !== t.commitSelection.sha) return;
        const s = null === n.file && o.length ? o[0] : n.file;
        this.repositoryStateCache.updateCommitSelection(e, () => ({
          file: s,
          changedFiles: o,
          diff: null
        })), this.emitUpdate(), null !== s && this._changeFileSelection(e, s)
      }
      async _setRepositoryFilterText(e) {
        this.repositoryFilterText = e, this.emitUpdate()
      }
      async _changeFileSelection(e, t) {
        this.repositoryStateCache.updateCommitSelection(e, () => ({
          file: t,
          diff: null
        })), this.emitUpdate();
        const n = this.repositoryStateCache.get(e),
          r = n.commitSelection.sha;
        if (!r) return void 0;
        const i = await ms(e, t, r, this.hideWhitespaceInDiff),
          o = this.repositoryStateCache.get(e);
        o.commitSelection.sha === n.commitSelection.sha && o.commitSelection.file && o.commitSelection.file.id === t.id && (this.repositoryStateCache.updateCommitSelection(e, () => ({
          diff: i
        })), this.emitUpdate())
      }
      async _selectRepository(e) {
        const t = this.selectedRepository;
        if (!(this.currentOnboardingTutorialStep !== Su.NotApplicable) || e instanceof Xi && e.isTutorialRepository || (this.currentOnboardingTutorialStep = Su.NotApplicable), this.selectedRepository = e, this.emitUpdate(), this.stopBackgroundFetching(), this.stopPullRequestUpdater(), this._clearBanner(), this.stopBackgroundPruner(), null == e) return Promise.resolve(null);
        if (!(e instanceof Xi)) return Promise.resolve(null);
        ve("last-selected-repository-id", e.id);
        const n = t ? t.id : null;
        this.updateRecentRepositories(n, e.id);
        const r = await this.recoverMissingRepository(e);
        return r.missing ? (this.gitStoreCache.remove(e), Promise.resolve(null)) : (this.updateBranchProtectionsFromAPI(e), this._selectRepositoryRefreshTasks(r, t))
      }
      updateRecentRepositories(e, t) {
        const n = we("recently-selected-repositories").filter(n => n !== t && n !== e);
        null !== e && n.unshift(e);
        const r = n.slice(0, 3);
        be("recently-selected-repositories", r), this.recentRepositories = r, this.emitUpdate()
      }
      async _selectRepositoryRefreshTasks(e, t) {
        if (this._refreshRepository(e), Ji(e)) {
          const t = ro(e);
          this._refreshIssues(t), this.refreshMentionables(t), this.pullRequestCoordinator.getAllPullRequests(e).then(t => {
            this.onPullRequestChanged(e, t)
          })
        }
        return this.selectedRepository !== e ? null : (this.stopBackgroundFetching(), this.stopPullRequestUpdater(), this.stopAheadBehindUpdate(), this.stopBackgroundPruner(), this.startBackgroundFetching(e, !t), this.startPullRequestUpdater(e), this.startAheadBehindUpdater(e), this.startBackgroundPruner(e), this.addUpstreamRemoteIfNeeded(e), this.repositoryWithRefreshedGitHubRepository(e))
      }
      stopBackgroundPruner() {
        const e = this.currentBranchPruner;
        null !== e && (e.stop(), this.currentBranchPruner = null)
      }
      startBackgroundPruner(e) {
        null !== this.currentBranchPruner && Z("A branch pruner is already active and cannot start updating on " + e.name);
        const t = new au(e, this.gitStoreCache, this.repositoriesStore, this.repositoryStateCache, e => this._refreshRepository(e));
        this.currentBranchPruner = t, this.currentBranchPruner.start()
      }
      async _refreshIssues(e) {
        const t = dt(this.accounts, e.endpoint);
        if (t) try {
          await this.issuesStore.refreshIssues(e, t)
        } catch (t) {
          log.warn("Unable to fetch issues for " + e.fullName, t)
        }
      }
      stopBackgroundFetching() {
        const e = this.currentBackgroundFetcher;
        e && (e.stop(), this.currentBackgroundFetcher = null)
      }
      refreshMentionables(e) {
        const t = dt(this.accounts, e.endpoint);
        t && this.gitHubUserStore.updateMentionables(e, t)
      }
      startPullRequestUpdater(e) {
        if (this.appIsFocused && Ji(e)) {
          const t = ns(this.accounts, e);
          if (null !== t) return this.pullRequestCoordinator.startPullRequestUpdater(e, t)
        }
        this.pullRequestCoordinator.stopPullRequestUpdater()
      }
      stopPullRequestUpdater() {
        this.pullRequestCoordinator.stopPullRequestUpdater()
      }
      async fetchPullRequest(e, t) {
        const n = function (e) {
            const t = Te.parse(e);
            return "github.com" === t.hostname ? pt() : `${t.protocol}//${t.hostname}/api`
          }(e),
          r = dt(this.accounts, n);
        if (r) {
          const n = at.fromAccount(r),
            i = gt(e);
          if (i && i.owner && i.name) return await n.fetchPullRequest(i.owner, i.name, t)
        }
        return null
      }
      shouldBackgroundFetch(e, t) {
        const n = this.gitStoreCache.get(e).lastFetched;
        if (null === n) return !0;
        const r = (new Date).getTime() - n.getTime(),
          i = to(e);
        if (r < 18e5) {
          const e = Math.floor(r / 1e3);
          return log.debug(`Skipping background fetch as '${i}' was fetched ${e}s ago`), !1
        }
        return null === t || (n < t || (log.debug(`Skipping background fetch since nothing has been pushed to '${i}' since the last fetch at ${n}`), !1))
      }
      startBackgroundFetching(e, t) {
        this.currentBackgroundFetcher && Z(`We should only have on background fetcher active at once, but we're trying to start background fetching on ${e.name} while another background fetcher is still active!`);
        const n = ns(this.accounts, e);
        if (!n) return;
        if (!e.gitHubRepository) return;
        const r = new Ec(e, n, e => this.performFetch(e, n, Li.BackgroundTask), e => this.shouldBackgroundFetch(e, null));
        r.start(t), this.currentBackgroundFetcher = r
      }
      async loadInitialState() {
        const [e, t] = await Promise.all([this.accountsStore.getAll(), this.repositoriesStore.getAll()]);
        log.info(`[AppStore] loading ${t.length} repositories from store`), e.forEach(e => {
          log.info(`[AppStore] found account: ${e.login} (${e.name})`)
        }), this.accounts = e, this.repositories = t, this.updateRepositorySelectionAfterRepositoriesChanged(), this.sidebarWidth = ye("sidebar-width", 250), this.commitSummaryWidth = ye("commit-summary-width", 250), this.stashedFilesWidth = ye("stashed-files-width", 250), this.askForConfirmationOnRepositoryRemoval = me("confirmRepoRemoval", !0), this.confirmDiscardChanges = me("confirmDiscardChanges", !0), this.askForConfirmationOnForcePush = me("confirmForcePush", !0);
        const n = function (e) {
          switch (e) {
            case cu.AskForConfirmation:
              return cu.AskForConfirmation;
            case cu.StashOnCurrentBranch:
              return cu.StashOnCurrentBranch;
            case cu.MoveToNewBranch:
              return cu.MoveToNewBranch;
            default:
              return null
          }
        }(localStorage.getItem("uncommittedChangesStrategyKind"));
        this.uncommittedChangesStrategyKind = n || uu, this.updateSelectedExternalEditor(await this.lookupSelectedExternalEditor()).catch(e => log.error("Failed resolving current editor at startup", e));
        const r = localStorage.getItem("shell");
        this.selectedShell = r ? dc(r) : hc, this.updateMenuLabelsForSelectedRepository();
        const i = localStorage.getItem("image-diff-type");
        this.imageDiffType = null === i ? Nu : parseInt(i), this.hideWhitespaceInDiff = me("hide-whitespace-in-diff", !1), this.automaticallySwitchTheme = me("autoSwitchTheme", !1), this.automaticallySwitchTheme ? (this.selectedTheme = fo() ? pi.Dark : pi.Light, mi(this.selectedTheme)) : this.selectedTheme = fi(), mo.onThemeChanged(e => {
          this.automaticallySwitchTheme && (this.selectedTheme = e, this.emitUpdate())
        }), this.emitUpdateNow(), this.accountsStore.refresh()
      }
      updateSelectedExternalEditor(e) {
        return this.selectedExternalEditor = e, this._resolveCurrentEditor()
      }
      async lookupSelectedExternalEditor() {
        const e = (await xo()).map(e => e.editor),
          t = localStorage.getItem("externalEditor");
        if (t) {
          const n = Co(t);
          if (n && e.includes(n)) return n
        }
        if (e.length) {
          const t = e[0];
          return localStorage.setItem("externalEditor", t), t
        }
        return null
      }
      updateMenuLabelsForSelectedRepository() {
        const {
          selectedState: e
        } = this.getState();
        null !== e && e.type === W.Repository ? this.updateMenuItemLabels(e.state) : this.updateMenuItemLabels(null)
      }
      updateMenuItemLabels(e) {
        const {
          selectedShell: t,
          selectedExternalEditor: n,
          askForConfirmationOnRepositoryRemoval: r,
          askForConfirmationOnForcePush: i
        } = this, o = {
          selectedShell: t,
          selectedExternalEditor: n,
          askForConfirmationOnRepositoryRemoval: r,
          askForConfirmationOnForcePush: i
        };
        if (null === e) return void oe(o);
        const {
          changesState: s,
          branchesState: a,
          aheadBehind: l
        } = e, {
          defaultBranch: c,
          currentPullRequest: u
        } = a, h = null === c || null === c.upstreamWithoutRemote ? void 0 : c.upstreamWithoutRemote, p = yl(a, l), d = s.selection.kind === G.Stash, f = null !== s.stashEntry;
        oe(Object.assign(Object.assign({}, o), {
          defaultBranchName: h,
          isForcePushForCurrentRepository: p,
          isStashedChangesVisible: d,
          hasCurrentPullRequest: null !== u,
          askForConfirmationWhenStashingAllChanges: f
        }))
      }
      updateRepositorySelectionAfterRepositoriesChanged() {
        const e = this.selectedRepository;
        let t = this.selectedRepository;
        if (e) {
          t = this.repositories.find(t => t.constructor === e.constructor && t.id === e.id) || null
        }
        if (null === t && this.repositories.length > 0) {
          const e = ye("last-selected-repository-id", 0);
          e > 0 && (t = this.repositories.find(t => t.id === e) || null), t || (t = this.repositories[0])
        }(e && t && e.hash !== t.hash || e && !t || !e && t) && (this._selectRepository(t), this.emitUpdate())
      }
      async _loadStatus(e, t = !1) {
        const n = this.gitStoreCache.get(e),
          r = await n.loadStatus();
        return null === r ? null : (this.repositoryStateCache.updateChangesState(e, e => function (e, t, n) {
          const r = new Map;
          e.workingDirectory.files.forEach(e => r.set(e.id, e));
          const i = t.workingDirectory.files.map(e => {
              const t = r.get(e.id);
              return t ? n && t.selection.getSelectionType() === Ii.Partial ? e.withIncludeAll(!1) : e.withSelection(t.selection) : e
            }).sort((e, t) => St(e.path, t.path)),
            o = new Set(i.map(e => e.id)),
            s = ho.fromFiles(i),
            a = e.selection.kind;
          if (e.selection.kind === G.WorkingDirectory) {
            let t = e.selection.selectedFileIDs.filter(e => o.has(e));
            0 === t.length && i.length > 0 && (t = [i[0].id]);
            const n = 1 === t.length && 1 === e.selection.selectedFileIDs.length && e.selection.selectedFileIDs[0] === t[0] ? e.selection.diff : null;
            return {
              workingDirectory: s,
              selection: {
                kind: G.WorkingDirectory,
                selectedFileIDs: t,
                diff: n
              }
            }
          }
          return e.selection.kind === G.Stash ? {
            workingDirectory: s,
            selection: e.selection
          } : X(e.selection, "Unknown selection kind " + a)
        }(e, r, t)), this.repositoryStateCache.updateChangesState(e, e => ({
          conflictState: iu(e, r, this.statsStore)
        })), this.updateRebaseFlowConflictsIfFound(e), this.selectedRepository === e && this._triggerConflictsFlow(e), this.emitUpdate(), this.updateChangesWorkingDirectoryDiff(e), r)
      }
      updateRebaseFlowConflictsIfFound(e) {
        const {
          changesState: t,
          rebaseState: n
        } = this.repositoryStateCache.get(e), {
          conflictState: r
        } = t;
        if (null === r || Y(r)) return;
        const {
          step: i
        } = n;
        if (null !== i && ("ShowConflicts" === i.kind || "ConfirmAbort" === i.kind)) {
          const {
            baseBranch: t,
            targetBranch: n
          } = i.conflictState, o = Object.assign(Object.assign({}, r), {
            baseBranch: t,
            targetBranch: n
          });
          this.repositoryStateCache.updateRebaseState(e, () => ({
            step: Object.assign(Object.assign({}, i), {
              conflictState: o
            })
          }))
        }
      }
      async _triggerConflictsFlow(e) {
        const t = this.repositoryStateCache.get(e),
          {
            conflictState: n
          } = t.changesState;
        null !== n ? "merge" === n.kind ? await this.showMergeConflictsDialog(e, n) : "rebase" === n.kind ? await this.showRebaseConflictsDialog(e, n) : X(0, "Unsupported conflict kind") : this.clearConflictsFlowVisuals(t)
      }
      clearConflictsFlowVisuals(e) {
        (function (e, t) {
          if (null === e) return !1;
          if (e.type !== Zi.RebaseFlow) return !1;
          if (null === t.step) return !1;
          if ("ChooseBranch" === t.step.kind || "WarnForcePush" === t.step.kind || "ShowProgress" === t.step.kind) return !0;
          return !1
        })(this.currentPopup, e.rebaseState) || (this._closePopup(Zi.MergeConflicts), this._closePopup(Zi.AbortMerge), this._clearBanner(lu.MergeConflictsFound), this._closePopup(Zi.RebaseFlow), this._clearBanner(lu.RebaseConflictsFound))
      }
      async showRebaseConflictsDialog(e, t) {
        if (null !== this.currentPopup && this.currentPopup.type === Zi.RebaseFlow) return;
        if (null !== this.currentBanner && this.currentBanner.type === lu.RebaseConflictsFound) return;
        await this._setRebaseProgressFromState(e);
        const n = ml(t);
        this.repositoryStateCache.updateRebaseState(e, () => ({
          step: n
        })), this._showPopup({
          type: Zi.RebaseFlow,
          repository: e
        })
      }
      async showMergeConflictsDialog(e, t) {
        const n = null !== this.currentPopup && (this.currentPopup.type === Zi.MergeConflicts || this.currentPopup.type === Zi.AbortMerge),
          r = null !== this.currentBanner && this.currentBanner.type === lu.MergeConflictsFound;
        if (n || r) return;
        const i = await async function (e, t) {
          const n = ["branch", "--points-at=" + t, "--format=%(refname:short)"],
            {
              stdout: r,
              exitCode: i
            } = await Bo(n, e.path, "branchPointedAt", {
              successExitCodes: new Set([0, 1, 129])
            });
          return 1 === i || 129 === i ? null : r.split("\n").slice(0, -1)
        }(e, "MERGE_HEAD");
        if (null === i) return;
        const o = 1 === i.length ? i[0] : void 0,
          s = t.currentBranch;
        this._showPopup({
          type: Zi.MergeConflicts,
          repository: e,
          ourBranch: s,
          theirBranch: o
        })
      }
      async _changeRepositorySection(e, t) {
        return this.repositoryStateCache.update(e, () => ({
          selectedSection: t
        })), this.emitUpdate(), t === j.History ? this.refreshHistorySection(e) : t === j.Changes ? this.refreshChangesSection(e, {
          includingStatus: !0,
          clearPartialState: !1
        }) : void 0
      }
      async _selectWorkingDirectoryFiles(e, t) {
        this.repositoryStateCache.updateChangesState(e, e => function (e, t) {
          let n;
          if (void 0 === t) {
            if (e.selection.kind === G.WorkingDirectory) return {
              selection: e.selection
            };
            n = e.workingDirectory.files.length > 0 ? [e.workingDirectory.files[0].id] : new Array
          } else n = t.map(e => e.id);
          return {
            selection: {
              kind: G.WorkingDirectory,
              selectedFileIDs: n,
              diff: null
            }
          }
        }(e, t)), this.updateMenuLabelsForSelectedRepository(), this.emitUpdate(), this.updateChangesWorkingDirectoryDiff(e)
      }
      async updateChangesWorkingDirectoryDiff(e) {
        const t = this.repositoryStateCache.get(e).changesState;
        if (t.selection.kind !== G.WorkingDirectory) return;
        const n = t.selection,
          r = n.selectedFileIDs;
        if (1 !== r.length) return void(null !== n.diff && (this.repositoryStateCache.updateChangesState(e, () => ({
          selection: Object.assign(Object.assign({}, n), {
            diff: null
          })
        })), this.emitUpdate()));
        const i = r[0],
          o = t.workingDirectory.findFileWithID(i);
        if (null === o) return;
        const s = await gs(e, o),
          a = this.repositoryStateCache.get(e).changesState;
        if (a.selection.kind !== G.WorkingDirectory || !wu(a.selection.selectedFileIDs, r)) return;
        const l = a.selection.selectedFileIDs[0];
        if (l !== i) return;
        const c = a.workingDirectory.findFileWithID(l);
        if (null === c) return;
        const u = new Set;
        s.kind !== Mi.Text && s.kind !== Mi.LargeText || s.hunks.forEach(e => {
          e.lines.forEach((t, n) => {
            t.isIncludeableLine() && u.add(e.unifiedDiffStart + n)
          })
        });
        const h = c.selection.withSelectableLines(u),
          p = c.withSelection(h),
          d = a.workingDirectory.files.map(e => e.id === p.id ? p : e),
          f = ho.fromFiles(d),
          m = Object.assign(Object.assign({}, a.selection), {
            diff: s
          });
        this.repositoryStateCache.updateChangesState(e, () => ({
          selection: m,
          workingDirectory: f
        })), this.emitUpdate()
      }
      _hideStashedChanges(e) {
        const {
          changesState: t
        } = this.repositoryStateCache.get(e);
        t.selection.kind === G.Stash && (this.repositoryStateCache.updateChangesState(e, e => {
          const t = e.workingDirectory.files.filter(e => e.selection.getSelectionType() !== Ii.None).map(e => e.id);
          return {
            selection: {
              kind: G.WorkingDirectory,
              diff: null,
              selectedFileIDs: t
            }
          }
        }), this.emitUpdate(), this.updateMenuLabelsForSelectedRepository())
      }
      async _selectStashedFile(e, t) {
        this.repositoryStateCache.update(e, () => ({
          selectedSection: j.Changes
        })), this.repositoryStateCache.updateChangesState(e, e => {
          let n = null;
          const {
            stashEntry: r,
            selection: i
          } = e, o = i.kind === G.Stash ? i.selectedStashedFile : null, s = null !== r && r.files.kind === zc.Loaded ? r.files.files : [];
          return void 0 === t ? n = null !== o ? s.find(e => e.id === o.id) || s[0] || null : s[0] || null : null !== t && (n = s.find(e => e.id === t.id) || null), {
            selection: {
              kind: G.Stash,
              selectedStashedFile: n,
              selectedStashedFileDiff: null
            }
          }
        }), this.updateMenuLabelsForSelectedRepository(), this.emitUpdate(), this.updateChangesStashDiff(e), this.hasUserViewedStash || (this.statsStore.recordStashViewedAfterCheckout(), this.hasUserViewedStash = !0)
      }
      async updateChangesStashDiff(e) {
        const t = this.repositoryStateCache.get(e).changesState,
          n = t.selection;
        if (n.kind !== G.Stash) return;
        const r = t.stashEntry;
        if (null === r) return;
        let i = n.selectedStashedFile;
        if (null === i && r.files.kind === zc.Loaded && r.files.files.length > 0 && (i = r.files.files[0]), null === i) return this.repositoryStateCache.updateChangesState(e, () => ({
          selection: {
            kind: G.Stash,
            selectedStashedFile: null,
            selectedStashedFileDiff: null
          }
        })), void this.emitUpdate();
        const o = await ms(e, i, i.commitish),
          s = this.repositoryStateCache.get(e).changesState;
        s.selection.kind === G.Stash && s.selection.selectedStashedFile === n.selectedStashedFile && (this.repositoryStateCache.updateChangesState(e, () => ({
          selection: {
            kind: G.Stash,
            selectedStashedFile: i,
            selectedStashedFileDiff: o
          }
        })), this.emitUpdate())
      }
      async _commitIncludedChanges(e, t) {
        const n = this.repositoryStateCache.get(e),
          r = n.changesState.workingDirectory.files,
          i = r.filter(e => e.selection.getSelectionType() !== Ii.None),
          o = this.gitStoreCache.get(e),
          s = await this.isCommitting(e, () => o.performFailableOperation(async () => {
            const n = await Qo(e, t);
            return Da(e, n, i)
          }));
        if (s) {
          this.statsStore.recordCommit();
          r.some(e => e.selection.getSelectionType() === Ii.Partial) && this.statsStore.recordPartialCommit();
          const {
            trailers: i
          } = t;
          void 0 !== i && i.some(Go) && this.statsStore.recordCoAuthoredCommit();
          const s = ns(this.accounts, e);
          if (null !== e.gitHubRepository) {
            if (null !== s) {
              s.endpoint === pt() ? this.statsStore.recordCommitToDotcom() : this.statsStore.recordCommitToEnterprise();
              const {
                commitAuthor: e
              } = n;
              if (null !== e) {
                const t = e.email.toLowerCase();
                (function (e) {
                  const {
                    id: t,
                    login: n,
                    endpoint: r
                  } = e;
                  return [...new Set([...e.emails.map(e => e.email), Ou(n, r), Lu(t, n, r)])]
                })(s).some(e => e.toLowerCase() === t) || this.statsStore.recordUnattributedCommit()
              }
            }
            await this.repositoriesStore.hasBranchProtectionsConfigured(e.gitHubRepository) && this.statsStore.recordCommitToRepositoryWithBranchProtections();
            if (null !== bu(o.tip, o.currentRemote, e.gitHubRepository)) {
              const {
                changesState: t
              } = this.repositoryStateCache.get(e);
              t.currentBranchProtected && this.statsStore.recordCommitToProtectedBranch()
            }
            null === e.gitHubRepository || ji(e.gitHubRepository) || (this.statsStore.recordCommitToRepositoryWithoutWriteAccess(), null !== e.gitHubRepository.dbID && this.statsStore.recordRepositoryCommitedInWithoutWriteAccess(e.gitHubRepository.dbID))
          }
          await this._refreshRepository(e), await this.refreshChangesSection(e, {
            includingStatus: !0,
            clearPartialState: !0
          })
        }
        return s || !1
      }
      _changeFileIncluded(e, t, n) {
        const r = n ? t.selection.withSelectAll() : t.selection.withSelectNone();
        return this.updateWorkingDirectoryFileSelection(e, t, r), Promise.resolve()
      }
      _changeFileLineSelection(e, t, n) {
        return this.updateWorkingDirectoryFileSelection(e, t, n), Promise.resolve()
      }
      updateWorkingDirectoryFileSelection(e, t, n) {
        this.repositoryStateCache.updateChangesState(e, e => {
          const r = e.workingDirectory.files.map(e => e.id === t.id ? e.withSelection(n) : e);
          return {
            workingDirectory: ho.fromFiles(r)
          }
        }), this.emitUpdate()
      }
      _changeIncludeAllFiles(e, t) {
        return this.repositoryStateCache.updateChangesState(e, e => ({
          workingDirectory: e.workingDirectory.withIncludeAllFiles(t)
        })), this.emitUpdate(), Promise.resolve()
      }
      async _refreshOrRecoverRepository(e) {
        if (!e.missing) return this._refreshRepository(e); {
          const t = await this.recoverMissingRepository(e);
          if (!t.missing) return this._refreshRepository(t)
        }
      }
      async recoverMissingRepository(e) {
        if (!e.missing) return e;
        return await Object(Ci.pathExists)(e.path) && await qa(e.path) && null !== await this._loadStatus(e) ? await this._updateRepositoryMissing(e, !1) : e
      }
      async _refreshRepository(e) {
        if (e.missing) return;
        if (!await Object(Ci.pathExists)(e.path)) return void this._updateRepositoryMissing(e, !0);
        const t = this.repositoryStateCache.get(e),
          n = this.gitStoreCache.get(e),
          r = await this._loadStatus(e);
        if (this.updateSidebarIndicator(e, r), null === r) return void await this._updateRepositoryMissing(e, !0);
        await n.loadBranches();
        const i = t.selectedSection;
        let o;
        if (i === j.History) o = this.refreshHistorySection(e);
        else {
          if (i !== j.Changes) return X(0, "Unknown section: " + i);
          o = this.refreshChangesSection(e, {
            includingStatus: !1,
            clearPartialState: !1
          })
        }
        await Promise.all([n.loadRemotes(), n.updateLastFetched(), n.loadStashEntries(), this.refreshAuthor(e), o]), await n.refreshTags(), this.updateStashEntryCountMetric(e, n.desktopStashEntryCount, n.stashEntryCount), this.updateCurrentPullRequest(e);
        const s = this.repositoryStateCache.get(e);
        this.updateMenuItemLabels(s), this._initializeCompare(e), this.updateCurrentTutorialStep(e)
      }
      async updateStashEntryCountMetric(e, t, n) {
        const r = await this.repositoriesStore.getLastStashCheckDate(e),
          i = k()().subtract(24, "hours");
        if (null == r || i.isAfter(r)) {
          await this.repositoriesStore.updateLastStashCheckDate(e);
          const r = n - t;
          this.statsStore.addStashEntriesCreatedOutsideDesktop(r)
        }
      }
      async updateSidebarIndicator(e, t) {
        const n = this.localRepositoryStateLookup;
        e.missing ? n.delete(e.id) : null !== t ? n.set(e.id, {
          aheadBehind: t.branchAheadBehind || null,
          changedFilesCount: t.workingDirectory.files.length
        }) : n.delete(e.id)
      }
      async refreshAllSidebarIndicators() {
        const e = performance && performance.now ? performance.now() : null,
          t = new Array(...this.repositories);
        for (const e of t) await this.refreshIndicatorForRepository(e);
        if (e && t.length > 1) {
          const n = ((performance.now() - e) / 1e3).toFixed(3);
          log.info(`Background fetch for ${t.length} repositories took ${n}sec`)
        }
        this.emitUpdate()
      }
      async refreshIndicatorForRepository(e) {
        const t = this.localRepositoryStateLookup;
        if (e.missing) return void t.delete(e.id);
        if (!await Object(Ci.pathExists)(e.path)) return void t.delete(e.id);
        const n = this.gitStoreCache.get(e),
          r = await n.loadStatus();
        if (null === r) return void t.delete(e.id);
        const i = await async function (e, t, n) {
          const r = ns(e, n);
          if (null == r) return null;
          await t.loadRemotes();
          const i = at.fromAccount(r);
          let o = null;
          if (null !== t.currentRemote) {
            const n = Ct(e, t.currentRemote.url);
            if (null !== n) {
              const {
                owner: e,
                name: t
              } = n, r = await i.fetchRepository(e, t);
              null !== r && (o = new Date(r.pushed_at))
            }
          }
          if (null !== n.gitHubRepository) {
            const {
              owner: e,
              name: t
            } = n.gitHubRepository, r = await i.fetchRepository(e.login, t);
            null !== r && (o = new Date(r.pushed_at))
          }
          return await t.updateLastFetched(), o
        }(this.accounts, n, e);
        this.shouldBackgroundFetch(e, i) && await this._fetch(e, Li.BackgroundTask), t.set(e.id, {
          aheadBehind: n.aheadBehind,
          changedFilesCount: r.workingDirectory.files.length
        })
      }
      async refreshChangesSection(e, t) {
        t.includingStatus && await this._loadStatus(e, t.clearPartialState);
        const n = this.gitStoreCache.get(e),
          r = this.repositoryStateCache.get(e);
        if (r.branchesState.tip.kind === Qi.Valid) {
          const e = r.branchesState.tip.branch;
          await n.loadLocalCommits(e)
        } else r.branchesState.tip.kind === Qi.Unborn && await n.loadLocalCommits(null)
      }
      async refreshHistorySection(e) {
        const t = this.gitStoreCache.get(e),
          n = this.repositoryStateCache.get(e),
          r = n.branchesState.tip;
        return r.kind === Qi.Valid && await t.loadLocalCommits(r.branch), this.updateOrSelectFirstCommit(e, n.compareState.commitSHAs)
      }
      async refreshAuthor(e) {
        const t = this.gitStoreCache.get(e),
          n = await t.performFailableOperation(() => Al(e)) || null;
        this.repositoryStateCache.update(e, () => ({
          commitAuthor: n
        })), this.emitUpdate()
      }
      async _showPopup(e) {
        this._closePopup(), this._closeFoldout(V.AppMenu), this.currentPopup = e, this.emitUpdate()
      }
      _closePopup(e) {
        const t = this.currentPopup;
        null != t && (void 0 !== e && t.type !== e || (t.type === Zi.CloneRepository && this._completeOpenInDesktop(() => Promise.resolve(null)), this.currentPopup = null, this.emitUpdate()))
      }
      async _showFoldout(e) {
        this.currentFoldout = e, this.emitUpdate()
      }
      async _closeCurrentFoldout() {
        null != this.currentFoldout && (this.currentFoldout = null, this.emitUpdate())
      }
      async _closeFoldout(e) {
        null != this.currentFoldout && (void 0 !== e && this.currentFoldout.type !== e || (this.currentFoldout = null, this.emitUpdate()))
      }
      async _createBranch(e, t, n, r = fu(this.uncommittedChangesStrategyKind), i = !1) {
        const o = this.gitStoreCache.get(e),
          s = await o.performFailableOperation(() => async function (e, t, n, r) {
            const i = null !== n ? ["branch", t, n] : ["branch", t];
            r && i.push("--no-track"), await Bo(i, e.path, "createBranch");
            const o = await Ls(e, "refs/heads/" + t);
            return o.length > 0 ? o[0] : null
          }(e, t, n, i));
        if (null == s) return e;
        const {
          changesState: a,
          branchesState: l
        } = this.repositoryStateCache.get(e), {
          tip: c
        } = l, u = c.kind === Qi.Valid ? c.branch : null;
        if (a.workingDirectory.files.length > 0 && null !== u && r.kind === cu.AskForConfirmation) return this._showPopup({
          type: Zi.StashAndSwitchBranch,
          branchToCheckout: s,
          repository: e
        }), e;
        const h = await this._checkoutBranch(e, s, r);
        return this._closePopup(), h
      }
      async _createTag(e, t, n) {
        const r = this.gitStoreCache.get(e);
        await r.createTag(t, n), this._closePopup()
      }
      async _deleteTag(e, t) {
        const n = this.gitStoreCache.get(e);
        await n.deleteTag(t)
      }
      updateCheckoutProgress(e, t) {
        this.repositoryStateCache.update(e, () => ({
          checkoutProgress: t
        })), this.selectedRepository === e && this.emitUpdate()
      }
      getLocalBranch(e, t) {
        return this.gitStoreCache.get(e).allBranches.find(e => e.nameWithoutRemote === t) || null
      }
      async _checkoutBranch(e, t, n = fu(this.uncommittedChangesStrategyKind)) {
        const r = this.gitStoreCache.get(e),
          {
            changesState: i,
            branchesState: o
          } = this.repositoryStateCache.get(e);
        let s = null;
        if (i.workingDirectory.files.length > 0) {
          if (n.kind === hu.kind) return this._showPopup({
            type: Zi.StashAndSwitchBranch,
            branchToCheckout: t,
            repository: e
          }), e;
          s = await this.stashToPopAfterBranchCheckout(e, t, n)
        }
        const a = void 0 !== await this.withAuthenticatingUser(e, (e, n) => r.performFailableOperation(() => Ca(e, n, t, t => {
          this.updateCheckoutProgress(e, t)
        }), {
          repository: e,
          retryAction: {
            type: rc.Checkout,
            repository: e,
            branch: t
          },
          gitContext: {
            kind: "checkout",
            branchToCheckout: t
          }
        }));
        if (a && this.clearBranchProtectionState(e), n.kind === cu.MoveToNewBranch && a && (this.statsStore.recordChangesTakenToNewBranch(), s)) {
          const t = s.stashSha;
          await r.performFailableOperation(() => qc(e, t))
        }
        this._selectWorkingDirectoryFiles(e);
        try {
          this.updateCheckoutProgress(e, {
            kind: "checkout",
            title: "Refreshing repository",
            value: 1,
            targetBranch: t.name
          }), await this._refreshRepository(e)
        } finally {
          this.updateCheckoutProgress(e, null), this._initializeCompare(e, {
            kind: $.History
          })
        }
        const {
          defaultBranch: l
        } = o;
        return null !== l && t.name !== l.name && this.statsStore.recordNonDefaultBranchCheckout(), null === i.stashEntry || this.hasUserViewedStash || this.statsStore.recordStashNotViewedAfterCheckout(), this.hasUserViewedStash = !1, e
      }
      async stashToPopAfterBranchCheckout(e, t, n = fu(this.uncommittedChangesStrategyKind)) {
        const {
          changesState: r,
          branchesState: {
            tip: i
          }
        } = this.repositoryStateCache.get(e), o = i.kind === Qi.Valid ? i.branch : null;
        if (null !== o && n.kind === cu.StashOnCurrentBranch) await this._createStashAndDropPreviousEntry(e, o.name), this.statsStore.recordStashCreatedOnCurrentBranch();
        else if (n.kind === cu.MoveToNewBranch) {
          const i = r.workingDirectory.files.some(e => e.status.kind === Ki.Deleted),
            {
              transientStashEntry: o
            } = n;
          if (i && !o) {
            const n = this.gitStoreCache.get(e);
            if (await n.performFailableOperation(() => jc(e, t.name, Kl(r.workingDirectory)))) return Vc(e, t.name)
          }
          return o
        }
        return null
      }
      async _createStashForCurrentBranch(e, t) {
        const n = this.repositoryStateCache.get(e),
          r = n.branchesState.tip,
          i = r.kind === Qi.Valid ? r.branch : null,
          o = null !== n.changesState.stashEntry;
        if (null !== i) {
          if (t && o) return this._showPopup({
            type: Zi.ConfirmOverwriteStash,
            branchToCheckout: null,
            repository: e
          });
          await this._createStashAndDropPreviousEntry(e, i.name), this.statsStore.recordStashCreatedOnCurrentBranch(), await this._refreshRepository(e)
        }
      }
      async repositoryWithRefreshedGitHubRepository(e) {
        const t = e.gitHubRepository,
          n = await this.matchGitHubRepository(e);
        if (!n) return e;
        const r = new Gi(n.owner, n.endpoint, null),
          i = new Vi(n.name, r, null),
          o = new Xi(e.path, e.id, i, e.missing, {}, !1),
          s = dt(this.accounts, n.endpoint);
        if (!s) return t && n.endpoint === t.endpoint ? e : o;
        const {
          owner: a,
          name: l
        } = n, c = at.fromAccount(s), u = await c.fetchRepository(a, l);
        if (!u) return t && n.endpoint === t.endpoint ? e : o;
        e.gitHubRepository && await async function (e, t, n) {
          if (null === e.defaultRemote) return;
          const r = e.defaultRemote.url,
            i = n.clone_url,
            o = Tt(i, e.defaultRemote),
            s = Te.parse(r),
            a = Te.parse(i),
            l = null !== s.protocol && null !== a.protocol && s.protocol === a.protocol,
            c = e.defaultRemote && Tt(t.cloneURL, e.defaultRemote);
          l && c && !o && await e.setRemoteURL(e.defaultRemote.name, i)
        }(this.gitStoreCache.get(e), e.gitHubRepository, u);
        const h = n.endpoint,
          p = await this.repositoriesStore.updateGitHubRepository(e, h, u);
        return await this.refreshBranchProtectionState(e), p
      }
      async updateBranchProtectionsFromAPI(e) {
        if (null === e.gitHubRepository || null === e.gitHubRepository.dbID) return;
        const {
          owner: t,
          name: n
        } = e.gitHubRepository, r = dt(this.accounts, e.gitHubRepository.endpoint);
        if (null === r) return;
        const i = at.fromAccount(r),
          o = await i.fetchProtectedBranches(t.login, n);
        await this.repositoriesStore.updateBranchProtections(e.gitHubRepository, o)
      }
      async matchGitHubRepository(e) {
        const t = this.gitStoreCache.get(e);
        t.defaultRemote || await t.loadRemotes();
        const n = t.defaultRemote;
        return null !== n ? Ct(this.accounts, n.url) : null
      }
      _pushError(e) {
        const t = Array.from(this.errors);
        return t.push(e), this.errors = t, this.emitUpdate(), Promise.resolve()
      }
      _clearError(e) {
        return this.errors = this.errors.filter(t => t !== e), this.emitUpdate(), Promise.resolve()
      }
      async _renameBranch(e, t, n) {
        const r = this.gitStoreCache.get(e);
        return await r.performFailableOperation(() => async function (e, t, n) {
          await Bo(["branch", "-m", t.nameWithoutRemote, n], e.path, "renameBranch")
        }(e, t, n)), this._refreshRepository(e)
      }
      async _deleteBranch(e, t, n) {
        return this.withAuthenticatingUser(e, async (e, r) => {
          const {
            branchesState: i
          } = this.repositoryStateCache.get(e), {
            defaultBranch: o
          } = i;
          if (null == o) throw new Error("A default branch cannot be found for this repository, so the app is unable to identify which branch to switch to before removing the current branch.");
          const s = this.gitStoreCache.get(e);
          return await s.performFailableOperation(() => Ca(e, r, o)), await s.performFailableOperation(() => ta(e, t, r, n)), this._refreshRepository(e)
        })
      }
      updatePushPullFetchProgress(e, t) {
        this.repositoryStateCache.update(e, () => ({
          pushPullFetchProgress: t
        })), $s() && (null !== t ? r.remote.getCurrentWindow().setProgressBar(t.value) : r.remote.getCurrentWindow().setProgressBar(-1)), this.selectedRepository === e && this.emitUpdate()
      }
      async _push(e, t) {
        return this.withAuthenticatingUser(e, (e, n) => this.performPush(e, n, t))
      }
      async performPush(e, t, n) {
        const r = this.repositoryStateCache.get(e),
          {
            remote: i
          } = r;
        if (null !== i) return this.withPushPullFetch(e, t, async () => {
          const {
            tip: o
          } = r.branchesState;
          if (o.kind === Qi.Unborn) throw new Error("The current branch is unborn.");
          if (o.kind === Qi.Detached) throw new Error("The current repository is in a detached HEAD state.");
          if (o.kind === Qi.Valid) {
            const {
              branch: r
            } = o, s = r.remote || i.name, a = "Pushing to " + s;
            this.updatePushPullFetchProgress(e, {
              kind: "push",
              title: a,
              value: 0,
              remote: s,
              branch: r.name
            });
            let l = 2.5,
              c = 1;
            const u = .1,
              h = 1 / (l + c) * (1 - u);
            l *= h, c *= h;
            const p = {
                type: rc.Push,
                repository: e
              },
              d = {
                name: s,
                url: i.url
              };
            d.name !== i.name && _u("remoteNameMismatch", new Error("The current remote name differs from the branch remote"));
            const f = this.gitStoreCache.get(e);
            await f.performFailableOperation(async () => {
              await async function (e, t, n, r, i, o, s = {
                forceWithLease: !1
              }, a) {
                const l = [...await Vo(e, t), "push", n.name, i ? `${r}:${i}` : r];
                null !== o && l.push(...o), i ? !0 === s.forceWithLease && l.push("--force-with-lease") : l.push("--set-upstream");
                const c = new Set(js);
                c.add(Ao.GitError.ProtectedBranchForcePush);
                let u = {
                  env: await Js(t, n.url),
                  expectedErrors: c
                };
                if (a) {
                  l.push("--progress");
                  const e = "Pushing to " + n.name,
                    t = "push";
                  u = await ba(Object.assign(Object.assign({}, u), {
                    trackLFSProgress: !0
                  }), new ua, i => {
                    const o = "progress" === i.kind ? i.details.text : i.text,
                      s = i.percent;
                    a({
                      kind: t,
                      title: e,
                      description: o,
                      value: s,
                      remote: n.name,
                      branch: r
                    })
                  }), a({
                    kind: "push",
                    title: e,
                    value: 0,
                    remote: n.name,
                    branch: r
                  })
                }
                const h = await Bo(l, e.path, "push", u);
                if (h.gitErrorDescription) throw new Fo(h, l)
              }(e, t, d, r.name, r.upstreamWithoutRemote, f.tagsToPush, n, t => {
                this.updatePushPullFetchProgress(e, Object.assign(Object.assign({}, t), {
                  title: a,
                  value: l * t.value
                }))
              }), f.clearTagsToPush(), await f.fetchRemotes(t, [d], !1, t => {
                this.updatePushPullFetchProgress(e, Object.assign(Object.assign({}, t), {
                  value: l + t.value * c
                }))
              });
              const i = l + c;
              this.updatePushPullFetchProgress(e, {
                kind: "generic",
                title: "Refreshing repository",
                value: i
              }), await this.refreshBranchProtectionState(e), await this._refreshRepository(e), this.updatePushPullFetchProgress(e, {
                kind: "generic",
                title: "Refreshing repository",
                description: "Fast-forwarding branches",
                value: i + .5 * u
              }), await this.fastForwardBranches(e)
            }, {
              retryAction: p
            }), this.updatePushPullFetchProgress(e, null), this.updateMenuLabelsForSelectedRepository();
            const {
              accounts: m
            } = this.getState(), g = await _o(i.url, m);
            this.statsStore.recordPush(g, n)
          }
        });
        this._showPopup({
          type: Zi.PublishRepository,
          repository: e
        })
      }
      async isCommitting(e, t) {
        if (!this.repositoryStateCache.get(e).isCommitting) {
          this.repositoryStateCache.update(e, () => ({
            isCommitting: !0
          })), this.emitUpdate();
          try {
            return void 0 !== await t()
          } finally {
            this.repositoryStateCache.update(e, () => ({
              isCommitting: !1
            })), this.emitUpdate()
          }
        }
      }
      async withPushPullFetch(e, t, n) {
        if (!this.repositoryStateCache.get(e).isPushPullFetchInProgress) {
          this.repositoryStateCache.update(e, () => ({
            isPushPullFetchInProgress: !0
          })), this.emitUpdate();
          try {
            await n()
          } finally {
            this.repositoryStateCache.update(e, () => ({
              isPushPullFetchInProgress: !1
            })), this.emitUpdate()
          }
        }
      }
      async _pull(e) {
        return this.withAuthenticatingUser(e, (e, t) => this.performPull(e, t))
      }
      async performPull(e, t) {
        return this.withPushPullFetch(e, t, async () => {
          const n = this.gitStoreCache.get(e),
            r = n.currentRemote;
          if (!r) throw new Error("The repository has no remotes.");
          const i = this.repositoryStateCache.get(e).branchesState.tip;
          if (i.kind === Qi.Unborn) throw new Error("The current branch is unborn.");
          if (i.kind === Qi.Detached) throw new Error("The current repository is in a detached HEAD state.");
          if (i.kind === Qi.Valid) {
            let o = null,
              s = void 0;
            null !== i.branch.upstream && (o = await pl(e, i.branch.name, i.branch.upstream), s = {
              kind: "pull",
              theirBranch: i.branch.upstream,
              currentBranch: i.branch.name
            });
            const a = "Pulling " + r.name,
              l = "pull";
            this.updatePushPullFetchProgress(e, {
              kind: l,
              title: a,
              value: 0,
              remote: r.name
            });
            try {
              let i = 2,
                a = 1;
              const l = .1,
                c = 1 / (i + a) * (1 - l);
              i *= c, a *= c;
              const u = {
                type: rc.Pull,
                repository: e
              };
              n.pullWithRebase ? this.statsStore.recordPullWithRebaseEnabled() : this.statsStore.recordPullWithDefaultSetting(), await n.performFailableOperation(() => Ba(e, t, r, t => {
                this.updatePushPullFetchProgress(e, Object.assign(Object.assign({}, t), {
                  value: t.value * i
                }))
              }), {
                gitContext: s,
                retryAction: u
              });
              const h = i + a,
                p = "Refreshing repository";
              this.updatePushPullFetchProgress(e, {
                kind: "generic",
                title: p,
                value: h
              }), o && await n.reconcileHistory(o), await this.refreshBranchProtectionState(e), await this._refreshRepository(e), this.updatePushPullFetchProgress(e, {
                kind: "generic",
                title: p,
                description: "Fast-forwarding branches",
                value: h + .5 * l
              }), await this.fastForwardBranches(e)
            } finally {
              this.updatePushPullFetchProgress(e, null)
            }
          }
        })
      }
      async fastForwardBranches(e) {
        const {
          branchesState: t
        } = this.repositoryStateCache.get(e), n = function (e) {
          const {
            allBranches: t,
            tip: n,
            defaultBranch: r,
            recentBranches: i
          } = e, o = n.kind === Qi.Valid ? n.branch.name : null, s = t.filter(e => Ps(e, o));
          return s.length < 20 ? s : (log.info(`skipping fast-forward for all branches as there are ${s.length} eligible branches (Threshold is 20 eligible branches).`), (null !== r ? [...i, r] : i).filter(e => Ps(e, o)))
        }(t);
        for (const t of n) {
          const n = await Va(e, t);
          if (!n) continue;
          const {
            ahead: r,
            behind: i
          } = n;
          if (0 === r && i > 0) {
            const n = t.upstream,
              r = Ns(t.name);
            await Bs(e, r, t.tip.sha, n, "pull: Fast-forward")
          }
        }
      }
      async _publishRepository(e, t, n, r, i, o) {
        const s = at.fromAccount(i),
          a = await s.createRepository(o, t, n, r),
          l = this.gitStoreCache.get(e);
        return await l.performFailableOperation(() => Us(e, "origin", a.clone_url)), await l.loadRemotes(), l.tip.kind === Qi.Valid && await this.performPush(e, i), this.repositoryWithRefreshedGitHubRepository(e)
      }
      getAccountForRemoteURL(e) {
        const t = Ct(this.accounts, e);
        if (t) {
          const n = dt(this.accounts, t.endpoint);
          if (n) {
            const t = n.token.length > 0 ? "has token" : "empty token";
            return log.info(`[AppStore.getAccountForRemoteURL] account found for remote: ${e} - ${n.login} (${t})`), n
          }
        }
        const n = Jo(e),
          r = ts(n);
        return null != r ? (log.info(`[AppStore.getAccountForRemoteURL] found generic credentials for '${n}' and '${r}'`), {
          login: r,
          endpoint: n
        }) : (log.info(`[AppStore.getAccountForRemoteURL] no generic credentials found for '${e}'`), null)
      }
      _clone(e, t, n) {
        const r = this.getAccountForRemoteURL(e),
          i = this.cloningRepositoriesStore.clone(e, t, Object.assign(Object.assign({}, n), {
            account: r
          })),
          o = this.cloningRepositoriesStore.repositories.find(n => n.url === e && n.path === t);
        return i.then(e => {
          e && this.statsStore.recordCloneRepository()
        }), {
          promise: i,
          repository: o
        }
      }
      _removeCloningRepository(e) {
        this.cloningRepositoriesStore.remove(e)
      }
      async _discardChanges(e, t) {
        const n = this.gitStoreCache.get(e);
        return await n.discardChanges(t), this._refreshRepository(e)
      }
      async _discardChangesFromSelection(e, t, n, r) {
        const i = this.gitStoreCache.get(e);
        return await i.discardChangesFromSelection(t, n, r), this._refreshRepository(e)
      }
      async _undoCommit(e, t) {
        const n = this.gitStoreCache.get(e);
        await n.undoCommit(t);
        const {
          commitSelection: r
        } = this.repositoryStateCache.get(e);
        return r.sha === t.sha && this.clearSelectedCommit(e), this._refreshRepository(e)
      }
      async _fetchRefspec(e, t) {
        return this.withAuthenticatingUser(e, async (e, n) => {
          const r = this.gitStoreCache.get(e);
          return await r.fetchRefspec(n, t), this._refreshRepository(e)
        })
      }
      _fetch(e, t) {
        return this.withAuthenticatingUser(e, (e, n) => this.performFetch(e, n, t))
      }
      _fetchRemote(e, t, n) {
        return this.withAuthenticatingUser(e, (e, r) => this.performFetch(e, r, n, [t]))
      }
      async performFetch(e, t, n, r) {
        await this.withPushPullFetch(e, t, async () => {
          const i = this.gitStoreCache.get(e);
          try {
            const o = .9,
              s = .1,
              a = n === Li.BackgroundTask,
              l = t => {
                this.updatePushPullFetchProgress(e, Object.assign(Object.assign({}, t), {
                  value: t.value * o
                }))
              };
            void 0 === r ? await i.fetch(t, a, l) : await i.fetchRemotes(t, r, a, l);
            const c = "Refreshing repository";
            this.updatePushPullFetchProgress(e, {
              kind: "generic",
              title: c,
              value: o
            }), await this.refreshBranchProtectionState(e), await this._refreshRepository(e), this.updatePushPullFetchProgress(e, {
              kind: "generic",
              title: c,
              description: "Fast-forwarding branches",
              value: o + .5 * s
            }), await this.fastForwardBranches(e)
          } finally {
            this.updatePushPullFetchProgress(e, null), n === Li.UserInitiatedTask && null != e.gitHubRepository && this._refreshIssues(e.gitHubRepository)
          }
        })
      }
      _endWelcomeFlow() {
        return this.showWelcomeFlow = !1, this.emitUpdate(), ge("has-shown-welcome-flow", !0), this.statsStore.recordWelcomeWizardTerminated(), Promise.resolve()
      }
      _setCommitMessageFocus(e) {
        this.focusCommitMessage !== e && (this.focusCommitMessage = e, this.emitUpdate())
      }
      _setSidebarWidth(e) {
        return this.sidebarWidth = e, ve("sidebar-width", e), this.emitUpdate(), Promise.resolve()
      }
      _resetSidebarWidth() {
        return this.sidebarWidth = 250, localStorage.removeItem("sidebar-width"), this.emitUpdate(), Promise.resolve()
      }
      _setCommitSummaryWidth(e) {
        return this.commitSummaryWidth = e, ve("commit-summary-width", e), this.emitUpdate(), Promise.resolve()
      }
      _resetCommitSummaryWidth() {
        return this.commitSummaryWidth = 250, localStorage.removeItem("commit-summary-width"), this.emitUpdate(), Promise.resolve()
      }
      _setCommitMessage(e, t) {
        return this.gitStoreCache.get(e).setCommitMessage(t)
      }
      setAppMenu(e) {
        return this.appMenu ? this.appMenu = this.appMenu.withMenu(e) : this.appMenu = Di.fromMenu(e), this.emitUpdate(), Promise.resolve()
      }
      _setAppMenuState(e) {
        return this.appMenu && (this.appMenu = e(this.appMenu), this.emitUpdate()), Promise.resolve()
      }
      _setAccessKeyHighlightState(e) {
        return this.highlightAccessKeys !== e && (this.highlightAccessKeys = e, this.emitUpdate()), Promise.resolve()
      }
      async _mergeBranch(e, t, n) {
        const r = this.gitStoreCache.get(e);
        null !== n && (n.kind === al.Clean ? this.statsStore.recordMergeHintSuccessAndUserProceeded() : n.kind === al.Conflicts ? this.statsStore.recordUserProceededAfterConflictWarning() : n.kind === al.Loading && this.statsStore.recordUserProceededWhileLoading());
        const i = await r.merge(t),
          {
            tip: o
          } = r;
        return i && o.kind === Qi.Valid && this._setBanner({
          type: lu.SuccessfulMerge,
          ourBranch: o.branch.name,
          theirBranch: t
        }), this._refreshRepository(e)
      }
      async _setRebaseProgressFromState(e) {
        const t = await bl(e);
        if (null === t) return;
        const {
          progress: n,
          commits: r
        } = t;
        this.repositoryStateCache.updateRebaseState(e, () => ({
          progress: n,
          commits: r
        }))
      }
      _initializeRebaseProgress(e, t) {
        this.repositoryStateCache.updateRebaseState(e, () => {
          const e = t.length > 0 ? t[0].summary : null;
          return {
            progress: {
              value: gl(0),
              rebasedCommitCount: 0,
              currentCommitSummary: e,
              totalCommitCount: t.length
            },
            commits: t
          }
        }), this.emitUpdate()
      }
      _setConflictsResolved(e) {
        this.repositoryStateCache.updateRebaseState(e, () => ({
          userHasResolvedConflicts: !0
        }))
      }
      async _setRebaseFlowStep(e, t) {
        this.repositoryStateCache.updateRebaseState(e, () => ({
          step: t
        })), this.emitUpdate(), "ShowProgress" === t.kind && null !== t.rebaseAction && (await Cc(500), await t.rebaseAction())
      }
      _endRebaseFlow(e) {
        this.repositoryStateCache.updateRebaseState(e, () => ({
          step: null,
          progress: null,
          commits: null,
          preview: null,
          userHasResolvedConflicts: !1
        })), this.emitUpdate()
      }
      async _rebase(e, t, n) {
        const r = t => {
            this.repositoryStateCache.updateRebaseState(e, () => ({
              progress: t
            })), this.emitUpdate()
          },
          i = this.gitStoreCache.get(e);
        return await i.performFailableOperation(() => async function (e, t, n, r) {
          const i = {
            expectedErrors: new Set([Ao.GitError.RebaseConflicts])
          };
          let o = i;
          if (void 0 !== r) {
            const s = await ja(e, t.tip.sha, n.tip.sha);
            if (null === s) return vl.Error;
            o = El(i, {
              rebasedCommitCount: 0,
              totalCommitCount: s.length,
              progressCallback: r
            })
          }
          return kl(await Bo(["-c", "rebase.backend=merge", "rebase", t.name, n.name], e.path, "rebase", o))
        }(e, t, n, r), {
          retryAction: {
            type: rc.Rebase,
            repository: e,
            baseBranch: t,
            targetBranch: n
          }
        }) || vl.Error
      }
      async _abortRebase(e) {
        const t = this.gitStoreCache.get(e);
        return await t.performFailableOperation(() => async function (e) {
          await Bo(["rebase", "--abort"], e.path, "abortRebase")
        }(e))
      }
      async _continueRebase(e, t, n) {
        const r = t => {
            this.repositoryStateCache.updateRebaseState(e, () => ({
              progress: t
            })), this.emitUpdate()
          },
          i = this.gitStoreCache.get(e);
        return await i.performFailableOperation(() => xl(e, t.files, n, r)) || vl.Error
      }
      async _abortMerge(e) {
        const t = this.gitStoreCache.get(e);
        return await t.performFailableOperation(() => async function (e) {
          await Bo(["merge", "--abort"], e.path, "abortMerge")
        }(e))
      }
      async _finishConflictedMerge(e, t, n) {
        const r = t.files.filter(e => e.status.kind === Ki.Conflicted),
          i = this.gitStoreCache.get(e);
        return await i.performFailableOperation(() => async function (e, t, n = new Map) {
          try {
            for (const [r, i] of n) {
              const n = t.find(e => e.path === r);
              void 0 !== n ? await Ra(e, n, i) : log.error(`couldn't find file ${r} even though there's a manual resolution for it`)
            }
            const r = t.filter(e => !n.has(e.path));
            await ka(e, r);
            return jo(await Bo(["commit", "--no-edit", "--cleanup=strip"], e.path, "createMergeCommit"))
          } catch (e) {
            return void _a(e)
          }
        }(e, r, n))
      }
      async _setRemoteURL(e, t, n) {
        const r = this.gitStoreCache.get(e);
        await r.setRemoteURL(t, n)
      }
      async _openShell(e) {
        this.statsStore.recordOpenShell();
        try {
          const t = await async function (e) {
            const t = await fc(),
              n = t.find(t => t.shell === e);
            return n || t.find(e => e.shell === hc)
          }(this.selectedShell);
          await mc(t, e, e => this._pushError(e))
        } catch (e) {
          this.emitError(e)
        }
      }
      _openInBrowser(e) {
        return ee.openExternal(e)
      }
      async _openInExternalEditor(e) {
        const {
          selectedExternalEditor: t
        } = this.getState();
        try {
          const n = await To(t);
          if (null === n) return void this.emitError(new Eo("No suitable editors installed for GitHub Desktop to launch. Install Atom for your platform and restart GitHub Desktop to try again.", {
            suggestAtom: !0
          }));
          await async function (e, t) {
            const n = t.path;
            if (!await Object(Ci.pathExists)(n)) {
              const e = "Options";
              throw new Eo(`Could not find executable for '${t.editor}' at path '${t.path}'.  Please open ${e} and select an available editor.`, {
                openPreferences: !0
              })
            }
            t.usesShell ? Object(Ro.spawn)(`"${n}"`, [`"${e}"`], {
              shell: !0
            }) : Object(Ro.spawn)(n, [e])
          }(e, n)
        } catch (e) {
          this.emitError(e)
        }
      }
      async _saveGitIgnore(e, t) {
        return await Fl(e, t), this._refreshRepository(e)
      }
      async setStatsOptOut(e, t) {
        await this.statsStore.setOptOut(e, t), this.emitUpdate()
      }
      markUsageStatsNoteSeen() {
        ge("has-seen-usage-stats-note", !0)
      }
      _setConfirmRepositoryRemovalSetting(e) {
        return this.askForConfirmationOnRepositoryRemoval = e, ge("confirmRepoRemoval", e), this.updateMenuLabelsForSelectedRepository(), this.emitUpdate(), Promise.resolve()
      }
      _setConfirmDiscardChangesSetting(e) {
        return this.confirmDiscardChanges = e, ge("confirmDiscardChanges", e), this.emitUpdate(), Promise.resolve()
      }
      _setConfirmForcePushSetting(e) {
        return this.askForConfirmationOnForcePush = e, ge("confirmForcePush", e), this.updateMenuLabelsForSelectedRepository(), this.emitUpdate(), Promise.resolve()
      }
      _setUncommittedChangesStrategyKindSetting(e) {
        return this.uncommittedChangesStrategyKind = e, localStorage.setItem("uncommittedChangesStrategyKind", e), this.emitUpdate(), Promise.resolve()
      }
      _setExternalEditor(e) {
        const t = this.updateSelectedExternalEditor(e);
        return localStorage.setItem("externalEditor", e), this.emitUpdate(), this.updateMenuLabelsForSelectedRepository(), t
      }
      _setShell(e) {
        return this.selectedShell = e, localStorage.setItem("shell", e), this.emitUpdate(), this.updateMenuLabelsForSelectedRepository(), Promise.resolve()
      }
      _changeImageDiffType(e) {
        return this.imageDiffType = e, localStorage.setItem("image-diff-type", JSON.stringify(this.imageDiffType)), this.emitUpdate(), Promise.resolve()
      }
      _setHideWhitespaceInDiff(e, t, n) {
        return ge("hide-whitespace-in-diff", e), this.hideWhitespaceInDiff = e, null === n ? this.updateChangesWorkingDirectoryDiff(t) : this._changeFileSelection(t, n)
      }
      _setUpdateBannerVisibility(e) {
        this.isUpdateAvailableBannerVisible = e, this.emitUpdate()
      }
      _setBanner(e) {
        this.currentBanner = e, this.emitUpdate()
      }
      _clearBanner(e) {
        const {
          currentBanner: t
        } = this;
        null !== t && (void 0 !== e && t.type !== e || (this.currentBanner = null, this.emitUpdate()))
      }
      _updateDivergingBranchBannerState(e, t) {
        const n = this.repositoryStateCache.get(e).compareState.divergingBranchBannerState,
          r = Object.assign(Object.assign({}, n), t);
        vu(n, r) || (this.repositoryStateCache.updateCompareState(e, () => ({
          divergingBranchBannerState: r
        })), this.emitUpdate())
      }
      _reportStats() {
        return this.showWelcomeFlow || me("has-seen-usage-stats-note", !1) ? this.statsStore.reportStats(this.accounts, this.repositories) : (this._showPopup({
          type: Zi.UsageReportingChanges
        }), Promise.resolve())
      }
      _recordLaunchStats(e) {
        return this.statsStore.recordLaunchStats(e)
      }
      async _appendIgnoreRule(e, t) {
        return await async function (e, t) {
          const n = await Nl(e) || "",
            r = await Bl(n, e),
            i = t instanceof Array ? t.join("\n") : t,
            o = await Bl(`${r}${i}`, e);
          await Fl(e, o)
        }(e, t), this._refreshRepository(e)
      }
      _resetSignInState() {
        return this.signInStore.reset(), Promise.resolve()
      }
      _onDotComSupportsBasicAuthUpdated(e) {
        return this.signInStore.onDotComSupportsBasicAuthUpdated(e)
      }
      _tryGetDotComSupportsBasicAuth() {
        return this.signInStore.tryGetDotComSupportsBasicAuth()
      }
      _beginDotComSignIn() {
        return this.signInStore.beginDotComSignIn(), Promise.resolve()
      }
      _beginEnterpriseSignIn() {
        return this.signInStore.beginEnterpriseSignIn(), Promise.resolve()
      }
      _setSignInEndpoint(e) {
        return this.signInStore.setEndpoint(e)
      }
      _setSignInCredentials(e, t) {
        return this.signInStore.authenticateWithBasicAuth(e, t)
      }
      _requestBrowserAuthentication() {
        return this.signInStore.authenticateWithBrowser()
      }
      _setSignInOTP(e) {
        return this.signInStore.setTwoFactorOTP(e)
      }
      async _setAppFocusState(e) {
        this.appIsFocused !== e && (this.appIsFocused = e, this.emitUpdate()), this.appIsFocused ? this.selectedRepository instanceof Xi && (this.startPullRequestUpdater(this.selectedRepository), this.currentOnboardingTutorialStep === Su.PickEditor && await this._resolveCurrentEditor()) : this.stopPullRequestUpdater()
      }
      _startOpenInDesktop(e) {
        const t = new Promise(e => this.resolveOpenInDesktop = e);
        return e(), t
      }
      async _completeOpenInDesktop(e) {
        const t = this.resolveOpenInDesktop;
        this.resolveOpenInDesktop = null;
        const n = await e();
        return t && t(n), n
      }
      _updateRepositoryPath(e, t) {
        return this.repositoriesStore.updateRepositoryPath(e, t)
      }
      _removeAccount(e) {
        return log.info(`[AppStore] removing account ${e.login} (${e.name}) from store`), this.accountsStore.removeAccount(e)
      }
      async _addAccount(e) {
        log.info(`[AppStore] adding account ${e.login} (${e.name}) to store`);
        const t = await this.accountsStore.addAccount(e);
        this.showWelcomeFlow && null !== t && this.apiRepositoriesStore.loadRepositories(t)
      }
      _updateRepositoryMissing(e, t) {
        return this.repositoriesStore.updateRepositoryMissing(e, t)
      }
      async _updateRepositoryWorkflowPreferences(e, t) {
        await this.repositoriesStore.updateRepositoryWorkflowPreferences(e, t)
      }
      async _addTutorialRepository(e, t, n) {
        const r = await Dc(e);
        if (r) log.info(`[AppStore] adding tutorial repository at ${r} to store`), await this.repositoriesStore.addTutorialRepository(r, t, n), this.tutorialAssessor.onNewTutorialRepository();
        else {
          const t = new Error(e + " isn't a git repository.");
          this.emitError(t)
        }
      }
      async _addRepositories(e) {
        const t = new Array,
          n = new Array,
          r = [];
        for (const i of e) {
          const e = await Dc(i);
          if (e) {
            log.info(`[AppStore] adding repository at ${e} to store`);
            const r = await this.repositoriesStore.addRepository(e),
              i = this.gitStoreCache.get(r);
            await i.loadRemotes();
            const [o, s] = await Promise.all([this.repositoryWithRefreshedGitHubRepository(r), this.isUsingLFS(r)]);
            t.push(o), s && n.push(o)
          } else r.push(i)
        }
        return r.length > 0 && this.emitError(new Error(this.getInvalidRepoPathsMessage(r))), n.length > 0 && this._showPopup({
          type: Zi.InitializeLFS,
          repositories: n
        }), t
      }
      async _removeRepositories(e) {
        const t = e.filter(e => e instanceof Xi);
        e.filter(e => e instanceof Ai).forEach(e => {
          this._removeCloningRepository(e)
        });
        for (const e of t) await this.repositoriesStore.removeRepository(e);
        0 === (await this.repositoriesStore.getAll()).length ? this._closeFoldout(V.Repository) : this._showFoldout({
          type: V.Repository
        })
      }
      async _cloneAgain(e, t) {
        const {
          promise: n,
          repository: r
        } = this._clone(e, t);
        await this._selectRepository(r);
        if (!await n) return;
        const i = this.repositories.find(e => e.path === t);
        if (i) {
          const e = await this._updateRepositoryMissing(i, !1);
          await this._selectRepository(e)
        }
      }
      getInvalidRepoPathsMessage(e) {
        return 1 === e.length ? e + " isn't a Git repository." : `The following paths aren't Git repositories:\n\n${e.slice(0,3).map(e=>"- "+e).join("\n")}${e.length>3?`\n\n(and ${e.length-3} more)`:""}`
      }
      async withAuthenticatingUser(e, t) {
        let n = e,
          r = ns(this.accounts, n);
        if (r || (n = await this.repositoryWithRefreshedGitHubRepository(e), r = ns(this.accounts, n)), !r) {
          const t = this.gitStoreCache.get(e).currentRemote;
          if (t) {
            const e = Jo(t.url),
              n = ts(e);
            null != n && (r = {
              login: n,
              endpoint: e
            })
          }
        }
        if (r instanceof De) {
          const t = r.token.length > 0 ? "has token" : "empty token";
          log.info(`[AppStore.withAuthenticatingUser] account found for repository: ${e.name} - ${r.login} (${t})`)
        }
        return t(n, r)
      }
      updateRevertProgress(e, t) {
        this.repositoryStateCache.update(e, () => ({
          revertProgress: t
        })), this.selectedRepository === e && this.emitUpdate()
      }
      async _revertCommit(e, t) {
        return this.withAuthenticatingUser(e, async (n, r) => {
          const i = this.gitStoreCache.get(n);
          await i.revertCommit(n, t, r, e => {
            this.updateRevertProgress(n, e)
          }), this.updateRevertProgress(n, null), await this._refreshRepository(e)
        })
      }
      async promptForGenericGitAuthentication(e, t) {
        let n;
        if (e instanceof Xi) {
          const t = this.gitStoreCache.get(e).currentRemote;
          if (!t) return;
          n = t.url
        } else n = e.url;
        const r = Jo(n);
        return this._showPopup({
          type: Zi.GenericGitAuthentication,
          hostname: r,
          retryAction: t
        })
      }
      async _installGlobalLFSFilters(e) {
        try {
          await async function (e) {
            const t = ["lfs", "install", "--skip-repo"];
            e && t.push("--force"), await Bo(t, __dirname, "installGlobalLFSFilter")
          }(e)
        } catch (e) {
          this.emitError(e)
        }
      }
      async isUsingLFS(e) {
        try {
          return await async function (e) {
            return (await Bo(["lfs", "track"], e.path, "isUsingLFS", {
              env: {
                GIT_LFS_TRACK_NO_INSTALL_HOOKS: "1"
              }
            })).stdout.length > 0
          }(e)
        } catch (e) {
          return !1
        }
      }
      async _installLFSHooks(e) {
        for (const t of e) try {
          await Hl(t, !0)
        } catch (e) {
          this.emitError(e)
        }
      }
      _changeCloneRepositoriesTab(e) {
        return this.selectedCloneRepositoryTab = e, this.emitUpdate(), Promise.resolve()
      }
      _refreshApiRepositories(e) {
        return this.apiRepositoriesStore.loadRepositories(e)
      }
      _changeBranchesTab(e) {
        return this.selectedBranchesTab = e, this.emitUpdate(), Promise.resolve()
      }
      async _showGitHubExplore(e) {
        const {
          gitHubRepository: t
        } = e;
        if (!t || null === t.htmlURL) return;
        const n = new URL(t.htmlURL);
        n.pathname = "/explore", await this._openInBrowser(n.toString())
      }
      async _createPullRequest(e) {
        if (!e.gitHubRepository) return;
        const t = this.repositoryStateCache.get(e),
          n = t.branchesState.tip;
        if (n.kind !== Qi.Valid) return;
        const r = n.branch,
          i = t.aheadBehind;
        null == i ? this._showPopup({
          type: Zi.PushBranchCommits,
          repository: e,
          branch: r
        }) : i.ahead > 0 ? this._showPopup({
          type: Zi.PushBranchCommits,
          repository: e,
          branch: r,
          unPushedCommits: i.ahead
        }) : await this._openCreatePullRequestInBrowser(e, r)
      }
      async _showPullRequest(e) {
        if (null === e.gitHubRepository) return;
        const t = this.repositoryStateCache.get(e).branchesState.currentPullRequest;
        if (null === t) return;
        const {
          htmlURL: n
        } = t.base.gitHubRepository;
        if (null === n) return;
        const r = `${n}/pull/${t.pullRequestNumber}`;
        await this._openInBrowser(r)
      }
      async _refreshPullRequests(e) {
        if (Ji(e)) {
          const t = ns(this.accounts, e);
          null !== t && await this.pullRequestCoordinator.refreshPullRequests(e, t)
        }
      }
      async onPullRequestChanged(e, t) {
        this.repositoryStateCache.updateBranchesState(e, () => ({
          openPullRequests: t
        })), this.updateCurrentPullRequest(e), this.gitStoreCache.get(e).pruneForkedRemotes(t);
        const n = this.getSelectedState();
        n && n.type === W.Repository && n.repository.id === e.id && this.updateMenuLabelsForSelectedRepository(), this.emitUpdate()
      }
      updateCurrentPullRequest(e) {
        e.gitHubRepository && (this.repositoryStateCache.updateBranchesState(e, t => {
          let n = null;
          const {
            remote: r
          } = this.repositoryStateCache.get(e);
          return t.tip.kind === Qi.Valid && r && (n = xu(t.tip.branch, t.openPullRequests, r)), {
            currentPullRequest: n
          }
        }), this.emitUpdate())
      }
      async _openCreatePullRequestInBrowser(e, t) {
        const n = e.gitHubRepository;
        if (!n) return;
        const r = Object(Ei.escape)(t.nameWithoutRemote),
          i = `${n.htmlURL}/pull/new/${r}`;
        await this._openInBrowser(i), this.currentOnboardingTutorialStep === Su.OpenPullRequest && this._markPullRequestTutorialStepAsComplete(e)
      }
      async _updateExistingUpstreamRemote(e) {
        const t = this.gitStoreCache.get(e);
        return await t.updateExistingUpstreamRemote(), this._refreshRepository(e)
      }
      getIgnoreExistingUpstreamRemoteKey(e) {
        return `repository/${e.id}/ignoreExistingUpstreamRemote`
      }
      _ignoreExistingUpstreamRemote(e) {
        return ge(this.getIgnoreExistingUpstreamRemoteKey(e), !0), Promise.resolve()
      }
      getIgnoreExistingUpstreamRemote(e) {
        const t = this.getIgnoreExistingUpstreamRemoteKey(e);
        return Promise.resolve(me(t, !1))
      }
      async addUpstreamRemoteIfNeeded(e) {
        const t = this.gitStoreCache.get(e);
        if (!await this.getIgnoreExistingUpstreamRemote(e)) return t.addUpstreamRemoteIfNeeded()
      }
      async _checkoutPullRequest(e, t) {
        const n = J("Cannot checkout a PR if the repository doesn't have a GitHub repository", e.gitHubRepository),
          r = t.head;
        if (r.gitHubRepository.cloneURL === n.cloneURL) {
          const t = this.gitStoreCache.get(e),
            n = t.defaultRemote;
          if (null != n) {
            const i = `${n.name}/${r.ref}`;
            null != t.allBranches.find(e => e.name === i) || await this._fetchRemote(e, n, Li.UserInitiatedTask)
          }
          const i = this.getLocalBranch(e, r.ref);
          null !== i && await this._checkoutBranch(e, i)
        } else {
          const n = J("This pull request's clone URL is not populated but should be", r.gitHubRepository.cloneURL),
            i = function (e) {
              return "github-desktop-" + e
            }(r.gitHubRepository.owner.login),
            o = (await zs(e)).find(e => e.name === i) || await Us(e, i, n);
          if (o.url !== n) {
            const e = new Error(`Expected PR remote ${i} url to be ${n} got ${o.url}.`);
            return log.error(e.message), this.emitError(e)
          }
          await this._fetchRemote(e, o, Li.UserInitiatedTask);
          const s = "pr/" + t.pullRequestNumber,
            a = this.getLocalBranch(e, s);
          null === a ? await this._createBranch(e, s, `${i}/${r.ref}`) : await this._checkoutBranch(e, a)
        }
        this.statsStore.recordPRBranchCheckout()
      }
      _setShowCoAuthoredBy(e, t) {
        return this.gitStoreCache.get(e).setShowCoAuthoredBy(t), Promise.resolve()
      }
      _setCoAuthors(e, t) {
        return this.gitStoreCache.get(e).setCoAuthors(t), Promise.resolve()
      }
      _setSelectedTheme(e) {
        return mi(e), this.selectedTheme = e, this.emitUpdate(), Promise.resolve()
      }
      _setAutomaticallySwitchTheme(e) {
        return ge("autoSwitchTheme", e), this.automaticallySwitchTheme = e, this.emitUpdate(), Promise.resolve()
      }
      async _resolveCurrentEditor() {
        const e = await To(this.selectedExternalEditor),
          t = null != e ? e.editor : null;
        this.resolvedExternalEditor !== t && (this.resolvedExternalEditor = t, this.currentOnboardingTutorialStep === Su.PickEditor && this.selectedRepository instanceof Xi && this.updateCurrentTutorialStep(this.selectedRepository), this.emitUpdate())
      }
      _updateManualConflictResolution(e, t, n) {
        this.repositoryStateCache.updateChangesState(e, e => {
          const {
            conflictState: r
          } = e;
          if (null === r) return {
            conflictState: r
          };
          const i = new Map(r.manualResolutions);
          return null !== n ? i.set(t, n) : i.delete(t), {
            conflictState: Object.assign(Object.assign({}, r), {
              manualResolutions: i
            })
          }
        });
        const r = this.repositoryStateCache.get(e),
          {
            changesState: i,
            rebaseState: o
          } = r,
          {
            conflictState: s
          } = i,
          {
            step: a
          } = o;
        null !== s && "rebase" === s.kind && null !== a && "ShowConflicts" === a.kind && this.repositoryStateCache.updateRebaseState(e, () => ({
          step: Object.assign(Object.assign({}, a), {
            conflictState: s
          })
        })), this.emitUpdate()
      }
      async _createStashAndDropPreviousEntry(e, t) {
        const n = await Vc(e, t);
        null !== n && (await $c(e, n.stashSha), log.info(`Dropped stash '${n.stashSha}' associated with ${n.branchName}`));
        const {
          changesState: {
            workingDirectory: r
          }
        } = this.repositoryStateCache.get(e);
        await jc(e, t, Kl(r))
      }
      async _moveChangesToBranchAndCheckout(e, t) {
        const {
          changesState: {
            workingDirectory: n
          }
        } = this.repositoryStateCache.get(e), r = this.gitStoreCache.get(e);
        if (!await r.performFailableOperation(() => jc(e, t.name, Kl(n)))) return;
        const i = await Vc(e, t.name),
          o = {
            kind: cu.MoveToNewBranch,
            transientStashEntry: i
          };
        await this._checkoutBranch(e, t, o)
      }
      async _popStashEntry(e, t) {
        const n = this.gitStoreCache.get(e);
        await n.performFailableOperation(() => qc(e, t.stashSha)), log.info("[AppStore. _popStashEntry] popped stash with commit id " + t.stashSha), this.statsStore.recordStashRestore(), await this._refreshRepository(e)
      }
      async _dropStashEntry(e, t) {
        const n = this.gitStoreCache.get(e);
        await n.performFailableOperation(() => $c(e, t.stashSha)), log.info("[AppStore. _dropStashEntry] dropped stash with commit id " + t.stashSha), this.statsStore.recordStashDiscard(), await n.loadStashEntries()
      }
      _setStashedFilesWidth(e) {
        return this.stashedFilesWidth = e, ve("stashed-files-width", e), this.emitUpdate(), Promise.resolve()
      }
      _resetStashedFilesWidth() {
        return this.stashedFilesWidth = 250, localStorage.removeItem("stashed-files-width"), this.emitUpdate(), Promise.resolve()
      }
      async _testPruneBranches() {
        null !== this.currentBranchPruner && await this.currentBranchPruner.testPrune()
      }
      async _showCreateforkDialog(e) {
        const t = ns(this.accounts, e);
        null !== t && await this._showPopup({
          type: Zi.CreateFork,
          repository: e,
          account: t
        })
      }
      async _convertRepositoryToFork(e, t) {
        const n = this.gitStoreCache.get(e),
          r = n.defaultRemote ? n.defaultRemote.name : void 0,
          i = n.defaultRemote ? n.defaultRemote.url : void 0;
        if (void 0 !== r && void 0 !== i && await n.setRemoteURL(r, t.clone_url)) {
          await n.ensureUpstreamRemoteURL(i);
          return await this.repositoriesStore.updateGitHubRepository(e, e.gitHubRepository.endpoint, t)
        }
        return e
      }
      async _createTutorialRepository(e) {
        try {
          await this.statsStore.recordTutorialStarted();
          const t = "desktop-tutorial",
            n = i.resolve(Au(), t),
            r = await Du(e, t, n, (e, t, n) => {
              null !== this.currentPopup && this.currentPopup.type === Zi.CreateTutorialRepository && (this.currentPopup = Object.assign(Object.assign({}, this.currentPopup), {
                progress: {
                  kind: "generic",
                  title: e,
                  value: t,
                  description: n
                }
              }), this.emitUpdate())
            });
          await this._addTutorialRepository(n, e.endpoint, r), await this.statsStore.recordTutorialRepoCreated()
        } catch (e) {
          _u("tutorialRepoCreation", e), e instanceof Fo ? this.emitError(e) : this.emitError(new Error("Failed creating the tutorial repository.\n\n" + e.message))
        } finally {
          this._closePopup(Zi.CreateTutorialRepository)
        }
      }
    }(Pb, Ib, Ob, Lb, Nb, Fb, Bb, zb, Ub, Wb);
  jb.onDidUpdate(e => {
    Db = e
  });
  const Gb = new class {
    constructor(e, t, n, r) {
      this.appStore = e, this.repositoryStateManager = t, this.statsStore = n, this.commitStatusStore = r, this.errorHandlers = new Array, this.addRebasedBranchToForcePushList = (e, t, n) => {
        if (t.branch.tip.sha === n) return;
        const r = this.repositoryStateManager.get(e),
          {
            rebasedBranches: i
          } = r.branchesState,
          o = new Map(i);
        o.set(t.branch.nameWithoutRemote, t.branch.tip.sha), this.repositoryStateManager.updateBranchesState(e, () => ({
          rebasedBranches: o
        }))
      }, this.dropCurrentBranchFromForcePushList = e => {
        const t = this.repositoryStateManager.get(e),
          {
            rebasedBranches: n,
            tip: r
          } = t.branchesState;
        if (r.kind !== Qi.Valid) return;
        const i = new Map(n);
        i.delete(r.branch.nameWithoutRemote), this.repositoryStateManager.updateBranchesState(e, () => ({
          rebasedBranches: i
        }))
      }, this.switchToConflicts = (e, t) => {
        this.setRebaseFlowStep(e, {
          kind: "ShowConflicts",
          conflictState: t
        })
      }, this.setStashedFilesWidth = e => this.appStore._setStashedFilesWidth(e), this.resetStashedFilesWidth = () => this.appStore._resetStashedFilesWidth()
    }
    loadInitialState() {
      return this.appStore.loadInitialState()
    }
    addRepositories(e) {
      return this.appStore._addRepositories(e)
    }
    addTutorialRepository(e, t, n) {
      return this.appStore._addTutorialRepository(e, t, n)
    }
    resumeTutorial(e) {
      return this.appStore._resumeTutorial(e)
    }
    pauseTutorial(e) {
      return this.appStore._pauseTutorial(e)
    }
    async removeRepositories(e, t) {
      return t && e.forEach(e => {
        ee.moveItemToTrash(e.path)
      }), this.appStore._removeRepositories(e)
    }
    async updateRepositoryMissing(e, t) {
      return this.appStore._updateRepositoryMissing(e, t)
    }
    loadNextCommitBatch(e) {
      return this.appStore._loadNextCommitBatch(e)
    }
    loadChangedFilesForCurrentSelection(e) {
      return this.appStore._loadChangedFilesForCurrentSelection(e)
    }
    changeCommitSelection(e, t) {
      return this.appStore._changeCommitSelection(e, t)
    }
    changeFileSelection(e, t) {
      return this.appStore._changeFileSelection(e, t)
    }
    setRepositoryFilterText(e) {
      return this.appStore._setRepositoryFilterText(e)
    }
    selectRepository(e) {
      return this.appStore._selectRepository(e)
    }
    changeRepositorySection(e, t) {
      return this.appStore._changeRepositorySection(e, t)
    }
    selectWorkingDirectoryFiles(e, t) {
      return this.appStore._selectWorkingDirectoryFiles(e, t)
    }
    selectStashedFile(e, t) {
      return this.appStore._selectStashedFile(e, t)
    }
    async commitIncludedChanges(e, t) {
      return this.appStore._commitIncludedChanges(e, t)
    }
    changeFileIncluded(e, t, n) {
      return this.appStore._changeFileIncluded(e, t, n)
    }
    changeFileLineSelection(e, t, n) {
      return this.appStore._changeFileLineSelection(e, t, n)
    }
    changeIncludeAllFiles(e, t) {
      return this.appStore._changeIncludeAllFiles(e, t)
    }
    refreshRepository(e) {
      return this.appStore._refreshOrRecoverRepository(e)
    }
    showPopup(e) {
      return this.appStore._showPopup(e)
    }
    closePopup(e) {
      return this.appStore._closePopup(e)
    }
    showFoldout(e) {
      return this.appStore._showFoldout(e)
    }
    closeCurrentFoldout() {
      return this.appStore._closeCurrentFoldout()
    }
    closeFoldout(e) {
      return this.appStore._closeFoldout(e)
    }
    async warnAboutRemoteCommits(e, t, n) {
      if (null === n.upstream) return !1;
      if (0 === (await Ls(e, "refs/remotes/" + n.upstream)).length) return !1;
      const r = await ja(e, t.tip.sha, n.upstream);
      return null !== r && r.length > 0
    }
    async startRebase(e, t, n, r, i) {
      const {
        askForConfirmationOnForcePush: o
      } = this.appStore.getState(), s = void 0 !== i && i.continueWithForcePush;
      if (o && !s) {
        if (await this.warnAboutRemoteCommits(e, t, n)) return void this.setRebaseFlowStep(e, {
          kind: "WarnForcePush",
          baseBranch: t,
          targetBranch: n,
          commits: r
        })
      }
      this.initializeRebaseProgress(e, r);
      this.setRebaseFlowStep(e, {
        kind: "ShowProgress",
        rebaseAction: () => this.rebase(e, t, n)
      })
    }
    async launchRebaseFlow(e, t) {
      await this.appStore._loadStatus(e);
      const n = this.repositoryStateManager.get(e),
        {
          conflictState: r
        } = n.changesState;
      if (null === r || "merge" === r.kind) return;
      const i = Object.assign(Object.assign({}, r), {
        targetBranch: t
      });
      this.repositoryStateManager.updateChangesState(e, () => ({
        conflictState: i
      })), await this.setRebaseProgressFromState(e);
      const o = ml(i);
      this.setRebaseFlowStep(e, o), this.showPopup({
        type: Zi.RebaseFlow,
        repository: e
      })
    }
    createBranch(e, t, n, r, i = !1) {
      return this.appStore._createBranch(e, t, n, r, i)
    }
    createTag(e, t, n) {
      return this.appStore._createTag(e, t, n)
    }
    deleteTag(e, t) {
      return this.appStore._deleteTag(e, t)
    }
    showCreateTagDialog(e, t, n, r) {
      return this.showPopup({
        type: Zi.CreateTag,
        repository: e,
        targetCommitSha: t,
        initialName: r,
        localTags: n
      })
    }
    showDeleteTagDialog(e, t) {
      return this.showPopup({
        type: Zi.DeleteTag,
        repository: e,
        tagName: t
      })
    }
    checkoutBranch(e, t, n) {
      return this.appStore._checkoutBranch(e, t, n)
    }
    push(e) {
      return this.appStore._push(e)
    }
    pushWithOptions(e, t) {
      return void 0 !== t && t.forceWithLease && this.dropCurrentBranchFromForcePushList(e), this.appStore._push(e, t)
    }
    pull(e) {
      return this.appStore._pull(e)
    }
    fetchRefspec(e, t) {
      return this.appStore._fetchRefspec(e, t)
    }
    fetch(e, t) {
      return this.appStore._fetch(e, t)
    }
    publishRepository(e, t, n, r, i, o) {
      return this.appStore._publishRepository(e, t, n, r, i, o)
    }
    async postError(e) {
      let t = e;
      for (let e = this.errorHandlers.length - 1; e >= 0; e--) {
        const n = this.errorHandlers[e];
        if (t = await n(t, this), !t) break
      }
      t && Z(`Unhandled error ${t}. This shouldn't happen! All errors should be handled, even if it's just by the default handler.`)
    }
    presentError(e) {
      return this.appStore._pushError(e)
    }
    clearError(e) {
      return this.appStore._clearError(e)
    }
    cloneAgain(e, t) {
      return this.appStore._cloneAgain(e, t)
    }
    async clone(e, t, n) {
      return this.appStore._completeOpenInDesktop(async () => {
        const {
          promise: r,
          repository: i
        } = this.appStore._clone(e, t, n);
        await this.selectRepository(i);
        if (!await r) return null;
        const o = (await this.addRepositories([t]))[0];
        return await this.selectRepository(o), eo(o) && this.showPopup({
          type: Zi.ChooseForkSettings,
          repository: o
        }), o
      })
    }
    renameBranch(e, t, n) {
      return this.appStore._renameBranch(e, t, n)
    }
    deleteBranch(e, t, n) {
      return this.appStore._deleteBranch(e, t, n)
    }
    discardChanges(e, t) {
      return this.appStore._discardChanges(e, t)
    }
    discardChangesFromSelection(e, t, n, r) {
      return this.appStore._discardChangesFromSelection(e, t, n, r)
    }
    undoCommit(e, t) {
      return this.appStore._undoCommit(e, t)
    }
    revertCommit(e, t) {
      return this.appStore._revertCommit(e, t)
    }
    setSidebarWidth(e) {
      return this.appStore._setSidebarWidth(e)
    }
    setUpdateBannerVisibility(e) {
      return this.appStore._setUpdateBannerVisibility(e)
    }
    setBanner(e) {
      return this.appStore._setBanner(e)
    }
    clearBanner(e) {
      return this.appStore._clearBanner(e)
    }
    setDivergingBranchNudgeVisibility(e, t) {
      return this.appStore._updateDivergingBranchBannerState(e, {
        isNudgeVisible: t
      })
    }
    dismissDivergingBranchBanner(e) {
      return this.appStore._updateDivergingBranchBannerState(e, {
        isPromptDismissed: !0
      })
    }
    resetSidebarWidth() {
      return this.appStore._resetSidebarWidth()
    }
    setCommitSummaryWidth(e) {
      return this.appStore._setCommitSummaryWidth(e)
    }
    resetCommitSummaryWidth() {
      return this.appStore._resetCommitSummaryWidth()
    }
    refreshIssues(e) {
      return this.appStore._refreshIssues(e)
    }
    endWelcomeFlow() {
      return this.appStore._endWelcomeFlow()
    }
    setCommitMessageFocus(e) {
      this.appStore._setCommitMessageFocus(e)
    }
    setCommitMessage(e, t) {
      return this.appStore._setCommitMessage(e, t)
    }
    removeAccount(e) {
      return this.appStore._removeAccount(e)
    }
    setAppMenuState(e) {
      return this.appStore._setAppMenuState(e)
    }
    executeMenuItem(e) {
      return function (e) {
        r.ipcRenderer.send("execute-menu-item", {
          id: e.id
        })
      }(e), Promise.resolve()
    }
    setAccessKeyHighlightState(e) {
      return this.appStore._setAccessKeyHighlightState(e)
    }
    mergeBranch(e, t, n) {
      return this.appStore._mergeBranch(e, t, n)
    }
    setConflictsResolved(e) {
      return this.appStore._setConflictsResolved(e)
    }
    initializeRebaseProgress(e, t) {
      return this.appStore._initializeRebaseProgress(e, t)
    }
    setRebaseProgressFromState(e) {
      return this.appStore._setRebaseProgressFromState(e)
    }
    setRebaseFlowStep(e, t) {
      return this.appStore._setRebaseFlowStep(e, t)
    }
    endRebaseFlow(e) {
      return this.appStore._endRebaseFlow(e)
    }
    async rebase(e, t, n) {
      const r = ob(this.repositoryStateManager.get(e).branchesState.tip);
      log.info(`[rebase] starting rebase for ${n.name} at ${r}`), log.info("[rebase] to restore the previous state if this completed rebase is unsatisfactory:"), log.info("[rebase] - git checkout " + n.name), log.info(`[rebase] - git reset ${r} --hard`);
      const i = await this.appStore._rebase(e, t, n);
      await this.appStore._loadStatus(e);
      const o = this.repositoryStateManager.get(e),
        {
          tip: s
        } = o.branchesState,
        a = ob(s);
      if (log.info(`[rebase] completed rebase - got ${i} and on tip ${a} - kind ${s.kind}`), i === vl.ConflictsEncountered) {
        const {
          conflictState: r
        } = o.changesState;
        if (null === r) return void log.warn("[rebase] conflict state after rebase is null - unable to continue");
        if (Y(r)) return void log.warn("[rebase] conflict state after rebase is merge conflicts - unable to continue");
        const i = Object.assign(Object.assign({}, r), {
          baseBranch: t.name,
          targetBranch: n.name
        });
        this.switchToConflicts(e, i)
      } else if (i === vl.CompletedWithoutError) {
        if (s.kind !== Qi.Valid) return void log.warn(`[rebase] tip after completing rebase is ${s.kind} but this should be a valid tip if the rebase completed without error`);
        this.statsStore.recordRebaseSuccessWithoutConflicts(), await this.completeRebase(e, {
          type: lu.SuccessfulRebase,
          targetBranch: n.name,
          baseBranch: t.name
        }, s, r)
      } else i === vl.Error && this.endRebaseFlow(e)
    }
    async abortRebase(e) {
      await this.appStore._abortRebase(e), await this.appStore._loadStatus(e)
    }
    async continueRebase(e, t, n) {
      const r = this.repositoryStateManager.get(e),
        {
          targetBranch: i,
          baseBranch: o,
          originalBranchTip: s,
          manualResolutions: a
        } = n,
        l = ob(r.branchesState.tip);
      log.info("[continueRebase] continuing rebase for " + l);
      const c = await this.appStore._continueRebase(e, t, a);
      await this.appStore._loadStatus(e);
      const u = this.repositoryStateManager.get(e),
        {
          tip: h
        } = u.branchesState,
        p = ob(h);
      if (log.info(`[continueRebase] completed rebase - got ${c} and on tip ${p} - kind ${h.kind}`), c === vl.ConflictsEncountered) {
        const {
          conflictState: t
        } = u.changesState;
        if (null === t) return void log.warn("[continueRebase] conflict state after rebase is null - unable to continue");
        if (Y(t)) return void log.warn("[continueRebase] conflict state after rebase is merge conflicts - unable to continue");
        const n = Object.assign(Object.assign({}, t), {
          baseBranch: o,
          targetBranch: i
        });
        this.switchToConflicts(e, n)
      } else if (c === vl.CompletedWithoutError) {
        if (h.kind !== Qi.Valid) return void log.warn(`[continueRebase] tip after completing rebase is ${h.kind} but this should be a valid tip if the rebase completed without error`);
        this.statsStore.recordRebaseSuccessAfterConflicts(), await this.completeRebase(e, {
          type: lu.SuccessfulRebase,
          targetBranch: i,
          baseBranch: o
        }, h, s)
      }
    }
    async completeRebase(e, t, n, r) {
      this.closePopup(), this.setBanner(t), n.kind === Qi.Valid && this.addRebasedBranchToForcePushList(e, n, r), this.endRebaseFlow(e), await this.refreshRepository(e)
    }
    async abortMerge(e) {
      await this.appStore._abortMerge(e), await this.appStore._loadStatus(e)
    }
    async finishConflictedMerge(e, t, n) {
      const r = this.repositoryStateManager.get(e),
        {
          conflictState: i
        } = r.changesState;
      if (null === i) return void log.error("Conflict state missing during finishConflictedMerge. No merge will be committed.");
      void 0 !== await this.appStore._finishConflictedMerge(e, t, i.manualResolutions) && this.setBanner(n)
    }
    recordLaunchStats(e) {
      return this.appStore._recordLaunchStats(e)
    }
    reportStats() {
      return this.appStore._reportStats()
    }
    setRemoteURL(e, t, n) {
      return this.appStore._setRemoteURL(e, t, n)
    }
    openInBrowser(e) {
      return this.appStore._openInBrowser(e)
    }
    appendIgnoreRule(e, t) {
      return this.appStore._appendIgnoreRule(e, t)
    }
    async openShell(e, t = !1) {
      await async function () {
        return void 0 !== await oc()
      }() || t ? this.appStore._openShell(e) : this.appStore._showPopup({
        type: Zi.InstallGit,
        path: e
      })
    }
    async openInExternalEditor(e) {
      return this.appStore._openInExternalEditor(e)
    }
    saveGitIgnore(e, t) {
      return this.appStore._saveGitIgnore(e, t)
    }
    setStatsOptOut(e, t) {
      return this.appStore.setStatsOptOut(e, t)
    }
    markUsageStatsNoteSeen() {
      this.appStore.markUsageStatsNoteSeen()
    }
    resetSignInState() {
      return this.appStore._resetSignInState()
    }
    onDotComSupportsBasicAuthUpdated(e) {
      return this.appStore._onDotComSupportsBasicAuthUpdated(e)
    }
    tryGetDotComSupportsBasicAuth() {
      return this.appStore._tryGetDotComSupportsBasicAuth()
    }
    beginDotComSignIn() {
      return this.appStore._beginDotComSignIn()
    }
    beginEnterpriseSignIn() {
      return this.appStore._beginEnterpriseSignIn()
    }
    setSignInEndpoint(e) {
      return this.appStore._setSignInEndpoint(e)
    }
    setSignInCredentials(e, t) {
      return this.appStore._setSignInCredentials(e, t)
    }
    requestBrowserAuthentication() {
      return this.appStore._requestBrowserAuthentication()
    }
    async requestBrowserAuthenticationToDotcom() {
      return await this.beginDotComSignIn(), this.requestBrowserAuthentication()
    }
    setSignInOTP(e) {
      return this.appStore._setSignInOTP(e)
    }
    async showDotComSignInDialog() {
      await this.appStore._beginDotComSignIn(), await this.appStore._showPopup({
        type: Zi.SignIn
      })
    }
    async showEnterpriseSignInDialog() {
      await this.appStore._beginEnterpriseSignIn(), await this.appStore._showPopup({
        type: Zi.SignIn
      })
    }
    async showCreateForkDialog(e) {
      await this.appStore._showCreateforkDialog(e)
    }
    registerErrorHandler(e) {
      return this.errorHandlers.push(e), new ne.Disposable(() => {
        const t = this.errorHandlers.indexOf(e);
        t >= 0 && this.errorHandlers.splice(t, 1)
      })
    }
    async relocateRepository(e) {
      const t = r.remote.getCurrentWindow(),
        {
          filePaths: n
        } = await r.remote.dialog.showOpenDialog(t, {
          properties: ["openDirectory"]
        });
      if (n.length > 0) {
        const t = n[0];
        await this.updateRepositoryPath(e, t)
      }
    }
    async updateRepositoryWorkflowPreferences(e, t) {
      await this.appStore._updateRepositoryWorkflowPreferences(e, t)
    }
    async updateRepositoryPath(e, t) {
      await this.appStore._updateRepositoryPath(e, t)
    }
    async setAppFocusState(e) {
      await this.appStore._setAppFocusState(e), e ? this.commitStatusStore.startBackgroundRefresh() : this.commitStatusStore.stopBackgroundRefresh()
    }
    async getForkAndUpstreamRepos(e) {
      const t = this.appStore.getState().repositories,
        n = [],
        r = [];
      for (const i of t)
        if (i instanceof Xi && Ji(i)) {
          const t = i.gitHubRepository.htmlURL,
            o = i.gitHubRepository.parent && i.gitHubRepository.parent.htmlURL;
          t && Dt(t, e) ? r.push(i) : o && Dt(o, e) && n.push(i)
        } return {
        forks: n,
        upstreams: r
      }
    }
    async openRepositoryFromUrl(e) {
      const {
        url: t,
        pr: n
      } = e, r = n ? await this.appStore.fetchPullRequest(t, n) : null, i = r && r.head.repo && r.head.repo.html_url, {
        forks: o,
        upstreams: s
      } = await this.getForkAndUpstreamRepos(t), a = o.find(e => Boolean(e.gitHubRepository && e.gitHubRepository.htmlURL && i && Dt(e.gitHubRepository.htmlURL, i)));
      if (a) {
        await this.selectRepository(a);
        const e = r && r.head.ref;
        return void(e && await this.checkoutLocalBranch(a, e))
      }
      const l = s.find(e => Boolean(e.gitHubRepository && e.gitHubRepository.htmlURL && i && Dt(e.gitHubRepository.htmlURL, i)));
      if (l) return await this.selectRepository(l), void await this.handleCloneInDesktopOptions(l, e);
      if (o.length > 0 && 0 === s.length) {
        const t = o[0];
        return await this.selectRepository(t), void await this.handleCloneInDesktopOptions(t, e)
      }
      const c = await this.openOrCloneRepository(t);
      c ? await this.handleCloneInDesktopOptions(c, e) : log.warn(`Open Repository from URL failed, did not find or clone repository: ${t} - payload: ${JSON.stringify(e)}`)
    }
    async dispatchURLAction(e) {
      switch (e.name) {
        case "oauth":
          try {
            log.info("[Dispatcher] requesting authenticated user");
            const n = await ju(e.code, e.state);
            n ? (t = n, Wu || Z("`askUserToOAuth` must be called before resolving an auth request."), Wu.resolve(t), Wu = null) : null === n && Gu(new Error("Unable to fetch authenticated user."))
          } catch (e) {
            Gu(e)
          }
          0;
          break;
        case "open-repository-from-url":
          this.openRepositoryFromUrl(e);
          break;
        case "open-repository-from-path":
          const n = await Dc(e.path) || e.path;
          let r = kt(this.appStore.getState().repositories, n);
          if (null == r) {
            if (await qa(n)) {
              r = (await this.addRepositories([n]))[0]
            }
          }
          r ? (await this.selectRepository(r), this.statsStore.recordAddExistingRepository()) : await this.showPopup({
            type: Zi.AddRepository,
            path: n
          });
          break;
        default:
          const i = e;
          log.warn(`Unknown URL action: ${i.name} - payload: ${JSON.stringify(i)}`)
      }
      var t
    }
    setConfirmRepoRemovalSetting(e) {
      return this.appStore._setConfirmRepositoryRemovalSetting(e)
    }
    setConfirmDiscardChangesSetting(e) {
      return this.appStore._setConfirmDiscardChangesSetting(e)
    }
    setUncommittedChangesStrategyKindSetting(e) {
      return this.appStore._setUncommittedChangesStrategyKindSetting(e)
    }
    setExternalEditor(e) {
      return this.appStore._setExternalEditor(e)
    }
    setShell(e) {
      return this.appStore._setShell(e)
    }
    async checkoutLocalBranch(e, t) {
      let n = !0;
      const r = this.repositoryStateManager.get(e),
        i = r.branchesState.allBranches,
        {
          tip: o
        } = r.branchesState;
      o.kind === Qi.Valid && (n = o.branch.nameWithoutRemote !== t);
      const s = i.find(e => e.nameWithoutRemote === t);
      n && void 0 !== s && await this.checkoutBranch(e, s)
    }
    async handleCloneInDesktopOptions(e, t) {
      const {
        filepath: n,
        pr: r,
        branch: i
      } = t;
      null != r && null != i && await this.fetchRefspec(e, `pull/${r}/head:${i}`), await this.appStore._refreshRepository(e);
      const o = this.repositoryStateManager.get(e).branchesState.allBranches;
      if (null == r && null != i) {
        null == (o.find(e => e.upstreamWithoutRemote === i) || null) && await this.fetch(e, Li.BackgroundTask)
      }
      if (null != i && await this.checkoutLocalBranch(e, i), null != n) {
        const t = await
        function (e, ...t) {
          return Pc(e, t)
        }(e.path, n);
        null !== t ? ee.showItemInFolder(t) : log.error("Prevented attempt to open path outside of the repository root: " + n)
      }
    }
    async openOrCloneRepository(e) {
      const t = this.appStore.getState().repositories.find(t => {
        if (t instanceof Xi) {
          const n = t.gitHubRepository;
          return !!n && Rt(e, n)
        }
        return !1
      });
      return t ? await this.selectRepository(t) : this.appStore._startOpenInDesktop(() => {
        this.changeCloneRepositoriesTab(Si.Generic), this.showPopup({
          type: Zi.CloneRepository,
          initialURL: e
        })
      })
    }
    async installCLI() {
      try {
        await Jv(), this.showPopup({
          type: Zi.CLIInstalled
        })
      } catch (e) {
        log.error("Error installing CLI", e), this.postError(e)
      }
    }
    promptForGenericGitAuthentication(e, t) {
      return this.appStore.promptForGenericGitAuthentication(e, t)
    }
    async saveGenericGitCredentials(e, t, n) {
      log.info(`storing generic credentials for '${e}' and '${t}'`),
        function (e, t) {
          const n = es(e);
          localStorage.setItem(n, t)
        }(e, t);
      try {
        await
        function (e, t, n) {
          const r = yi(e);
          return Xo.setItem(r, t, n)
        }(e, t, n)
      } catch (n) {
        log.error(`Error saving generic git credentials: ${t}@${e}`, n), this.postError(n)
      }
    }
    async performRetry(e) {
      switch (e.type) {
        case rc.Push:
          return this.push(e.repository);
        case rc.Pull:
          return this.pull(e.repository);
        case rc.Fetch:
          return this.fetch(e.repository, Li.UserInitiatedTask);
        case rc.Clone:
          await this.clone(e.url, e.path, e.options);
          break;
        case rc.Checkout:
          await this.checkoutBranch(e.repository, e.branch);
          break;
        case rc.Merge:
          return this.mergeBranch(e.repository, e.theirBranch, null);
        case rc.Rebase:
          return this.rebase(e.repository, e.baseBranch, e.targetBranch);
        default:
          return X(0, "Unknown retry action: " + e)
      }
    }
    changeImageDiffType(e) {
      return this.appStore._changeImageDiffType(e)
    }
    onHideWhitespaceInDiffChanged(e, t, n = null) {
      return this.appStore._setHideWhitespaceInDiff(e, t, n)
    }
    installGlobalLFSFilters(e) {
      return this.appStore._installGlobalLFSFilters(e)
    }
    installLFSHooks(e) {
      return this.appStore._installLFSHooks(e)
    }
    changeCloneRepositoriesTab(e) {
      return this.appStore._changeCloneRepositoriesTab(e)
    }
    refreshApiRepositories(e) {
      return this.appStore._refreshApiRepositories(e)
    }
    changeBranchesTab(e) {
      return this.appStore._changeBranchesTab(e)
    }
    showGitHubExplore(e) {
      return this.appStore._showGitHubExplore(e)
    }
    createPullRequest(e) {
      return this.appStore._createPullRequest(e)
    }
    showPullRequest(e) {
      return this.appStore._showPullRequest(e)
    }
    openCreatePullRequestInBrowser(e, t) {
      return this.appStore._openCreatePullRequestInBrowser(e, t)
    }
    updateExistingUpstreamRemote(e) {
      return this.appStore._updateExistingUpstreamRemote(e)
    }
    ignoreExistingUpstreamRemote(e) {
      return this.appStore._ignoreExistingUpstreamRemote(e)
    }
    async checkoutPullRequest(e, t) {
      return this.appStore._checkoutPullRequest(e, t)
    }
    setShowCoAuthoredBy(e, t) {
      return this.appStore._setShowCoAuthoredBy(e, t)
    }
    setCoAuthors(e, t) {
      return this.appStore._setCoAuthors(e, t)
    }
    initializeCompare(e, t) {
      return this.appStore._initializeCompare(e, t)
    }
    executeCompare(e, t) {
      return this.appStore._executeCompare(e, t)
    }
    updateCompareForm(e, t) {
      return this.appStore._updateCompareForm(e, t)
    }
    updateManualConflictResolution(e, t, n) {
      return this.appStore._updateManualConflictResolution(e, t, n)
    }
    async confirmOrForcePush(e) {
      const {
        askForConfirmationOnForcePush: t
      } = this.appStore.getState(), {
        branchesState: n
      } = this.repositoryStateManager.get(e), {
        tip: r
      } = n;
      if (r.kind !== Qi.Valid) return void log.warn("Could not find a branch to perform force push");
      const {
        upstream: i
      } = r.branch;
      null !== i ? t ? this.showPopup({
        type: Zi.ConfirmForcePush,
        repository: e,
        upstreamBranch: i
      }) : await this.performForcePush(e) : log.warn("Could not find an upstream branch which will be pushed")
    }
    async performForcePush(e) {
      await this.pushWithOptions(e, {
        forceWithLease: !0
      }), await this.appStore._loadStatus(e)
    }
    setConfirmForcePushSetting(e) {
      return this.appStore._setConfirmForcePushSetting(e)
    }
    async convertRepositoryToFork(e, t) {
      return this.appStore._convertRepositoryToFork(e, t)
    }
    mergeConflictDetectedFromPull() {
      return this.statsStore.recordMergeConflictFromPull()
    }
    mergeConflictDetectedFromExplicitMerge() {
      return this.statsStore.recordMergeConflictFromExplicitMerge()
    }
    recordMenuInitiatedMerge() {
      return this.statsStore.recordMenuInitiatedMerge()
    }
    recordMenuInitiatedRebase() {
      return this.statsStore.recordMenuInitiatedRebase()
    }
    recordMenuInitiatedUpdate() {
      return this.statsStore.recordMenuInitiatedUpdate()
    }
    recordCompareInitiatedMerge() {
      return this.statsStore.recordCompareInitiatedMerge()
    }
    setSelectedTheme(e) {
      return this.appStore._setSelectedTheme(e)
    }
    onAutomaticallySwitchThemeChanged(e) {
      return this.appStore._setAutomaticallySwitchTheme(e)
    }
    recordRepoClicked(e) {
      return this.statsStore.recordRepoClicked(e)
    }
    recordDivergingBranchBannerDismissal() {
      return this.statsStore.recordDivergingBranchBannerDismissal()
    }
    recordDivergingBranchBannerInitiatedCompare() {
      return this.statsStore.recordDivergingBranchBannerInitiatedCompare()
    }
    recordDivergingBranchBannerInfluencedMerge() {
      return this.statsStore.recordDivergingBranchBannerInfluencedMerge()
    }
    recordDivergingBranchBannerInitatedMerge() {
      return this.statsStore.recordDivergingBranchBannerInitatedMerge()
    }
    recordCreatePullRequest() {
      return this.statsStore.recordCreatePullRequest()
    }
    recordWelcomeWizardInitiated() {
      return this.statsStore.recordWelcomeWizardInitiated()
    }
    recordCreateRepository() {
      this.statsStore.recordCreateRepository()
    }
    recordAddExistingRepository() {
      this.statsStore.recordAddExistingRepository()
    }
    recordMergeConflictsDialogDismissal() {
      this.statsStore.recordMergeConflictsDialogDismissal()
    }
    recordMergeConflictsDialogReopened() {
      this.statsStore.recordMergeConflictsDialogReopened()
    }
    recordAnyConflictsLeftOnMergeConflictsDialogDismissal() {
      this.statsStore.recordAnyConflictsLeftOnMergeConflictsDialogDismissal()
    }
    recordGuidedConflictedMergeCompletion() {
      this.statsStore.recordGuidedConflictedMergeCompletion()
    }
    recordUnguidedConflictedMergeCompletion() {
      this.statsStore.recordUnguidedConflictedMergeCompletion()
    }
    recordRebaseConflictsDialogDismissal() {
      this.statsStore.recordRebaseConflictsDialogDismissal()
    }
    recordRebaseConflictsDialogReopened() {
      this.statsStore.recordRebaseConflictsDialogReopened()
    }
    recordErrorWhenSwitchingBranchesWithUncommmittedChanges() {
      return this.statsStore.recordErrorWhenSwitchingBranchesWithUncommmittedChanges()
    }
    refreshPullRequests(e) {
      return this.appStore._refreshPullRequests(e)
    }
    tryGetCommitStatus(e, t) {
      return this.commitStatusStore.tryGetStatus(e, t)
    }
    subscribeToCommitStatus(e, t, n) {
      return this.commitStatusStore.subscribe(e, t, n)
    }
    createStashForCurrentBranch(e, t = !0) {
      return this.appStore._createStashForCurrentBranch(e, t)
    }
    dropStash(e, t) {
      return this.appStore._dropStashEntry(e, t)
    }
    popStash(e, t) {
      return this.appStore._popStashEntry(e, t)
    }
    hideStashedChanges(e) {
      return this.appStore._hideStashedChanges(e)
    }
    recordSuggestedStepOpenInExternalEditor() {
      return this.statsStore.recordSuggestedStepOpenInExternalEditor()
    }
    recordSuggestedStepOpenWorkingDirectory() {
      return this.statsStore.recordSuggestedStepOpenWorkingDirectory()
    }
    recordSuggestedStepViewOnGitHub() {
      return this.statsStore.recordSuggestedStepViewOnGitHub()
    }
    recordSuggestedStepPublishRepository() {
      return this.statsStore.recordSuggestedStepPublishRepository()
    }
    recordSuggestedStepPublishBranch() {
      return this.statsStore.recordSuggestedStepPublishBranch()
    }
    recordSuggestedStepCreatePullRequest() {
      return this.statsStore.recordSuggestedStepCreatePullRequest()
    }
    recordSuggestedStepViewStash() {
      return this.statsStore.recordSuggestedStepViewStash()
    }
    async moveChangesToBranchAndCheckout(e, t) {
      return this.appStore._moveChangesToBranchAndCheckout(e, t)
    }
    recordNoActionTakenOnStash() {
      return this.statsStore.recordNoActionTakenOnStash()
    }
    recordStashView() {
      return this.statsStore.recordStashView()
    }
    skipPickEditorTutorialStep(e) {
      return this.appStore._skipPickEditorTutorialStep(e)
    }
    markPullRequestTutorialStepAsComplete(e) {
      return this.appStore._markPullRequestTutorialStepAsComplete(e)
    }
    recordForkCreated() {
      return this.statsStore.recordForkCreated()
    }
    createTutorialRepository(e) {
      return this.appStore._createTutorialRepository(e)
    }
    async openIssueCreationPage(e) {
      const t = no(e);
      return null !== t && (this.statsStore.recordIssueCreationWebpageOpened(), this.appStore._openInBrowser(t + "/issues/new/choose"))
    }
  }(jb, Ub, Lb, Vb);
  Gb.registerErrorHandler((async function (e, t) {
    const n = ab(e) || e;
    return await t.presentError(n), null
  })), Gb.registerErrorHandler((async function (e, t) {
    return e instanceof Bc ? (t.showPopup({
      type: Zi.UpstreamAlreadyExists,
      repository: e.repository,
      existingRemote: e.existingRemote
    }), null) : e
  })), Gb.registerErrorHandler((async function (e, t) {
    const n = function (e) {
      return e instanceof Eo ? e : null
    }(e);
    if (!n) return e;
    const {
      suggestAtom: r,
      openPreferences: i
    } = n.metadata;
    return await t.showPopup({
      type: Zi.ExternalEditorFailed,
      message: n.message,
      suggestAtom: r,
      openPreferences: i
    }), null
  })), Gb.registerErrorHandler((async function (e, t) {
    return e instanceof uc ? (await t.showPopup({
      type: Zi.OpenShellFailed,
      message: e.message
    }), null) : e
  })), Gb.registerErrorHandler((async function (e, t) {
    const n = ab(e);
    if (!n) return e;
    const r = lb(n.underlyingError);
    if (!r) return e;
    const i = r.result.gitError;
    if (!i) return e;
    if (i !== Ao.GitError.MergeConflicts) return e;
    const {
      repository: o,
      gitContext: s
    } = n.metadata;
    if (null == o) return e;
    if (!(o instanceof Xi)) return e;
    if (null == s) return e;
    if ("merge" !== s.kind && "pull" !== s.kind) return e;
    switch (s.kind) {
      case "pull":
        t.mergeConflictDetectedFromPull();
        break;
      case "merge":
        t.mergeConflictDetectedFromExplicitMerge()
    }
    const {
      currentBranch: a,
      theirBranch: l
    } = s;
    return t.showPopup({
      type: Zi.MergeConflicts,
      repository: o,
      ourBranch: a,
      theirBranch: l
    }), null
  })), Gb.registerErrorHandler((async function (e, t) {
    const n = lb(e);
    if (!n) return e;
    const r = n.result.gitError;
    return r ? r !== Ao.GitError.LFSAttributeDoesNotMatch ? e : (t.showPopup({
      type: Zi.LFSAttributeMismatch
    }), null) : e
  })), Gb.registerErrorHandler((async function (e, t) {
    const n = ab(e);
    if (!n) return e;
    const r = lb(n.underlyingError);
    if (!r || null === r.result.gitError) return e;
    if (!Ho(r.result.gitError)) return e;
    const {
      repository: i,
      retryAction: o
    } = n.metadata;
    return i instanceof Xi && Ji(i) ? void 0 === o || o.type !== rc.Push || ji(i.gitHubRepository) ? e : (t.showCreateForkDialog(i), null) : e
  })), Gb.registerErrorHandler((async function (e, t) {
    const n = ab(e),
      r = lb(null === n ? e : n.underlyingError);
    if (null === r) return e;
    const i = hb.exec(r.message);
    return i ? (_u("schannelUnableToCheckRevocationForCertificate", e), t.showPopup({
      type: Zi.SChannelNoRevocationCheck,
      url: i[1]
    }), null) : e
  })), Gb.registerErrorHandler((async function (e, t) {
    const n = ab(e);
    if (!n) return e;
    const r = lb(n.underlyingError);
    if (!r) return e;
    const i = r.result.gitError;
    if (!i) return e;
    if (!js.has(i)) return e;
    const o = n.metadata.repository;
    if (!o) return e;
    if (o instanceof Xi && o.gitHubRepository) return e;
    const s = n.metadata.retryAction;
    return s ? (await t.promptForGenericGitAuthentication(o, s), null) : (log.error("No retry action provided for a git authentication error.", n), e)
  })), Gb.registerErrorHandler((async function (e, t) {
    const n = ab(e);
    if (!n) return e;
    const r = lb(n.underlyingError);
    if (!r) return e;
    const i = r.result.gitError;
    if (!i) return e;
    if (i !== Ao.GitError.PushNotFastForward) return e;
    const o = n.metadata.repository;
    return o && o instanceof Xi ? (t.showPopup({
      type: Zi.PushNeedsPull,
      repository: o
    }), null) : e
  })), Gb.registerErrorHandler((async function (e, t) {
    const n = ab(e);
    if (!n) return e;
    const r = lb(n.underlyingError);
    if (!r || null === r.result.gitError) return e;
    if (!Ho(r.result.gitError)) return e;
    const {
      repository: i
    } = n.metadata;
    if (!(i instanceof Xi)) return e;
    if (null === i.gitHubRepository) return e;
    const o = r.result.stderr.split(/\r?\n/).filter(e => e.startsWith("remote: ")).map(e => e.substr("remote: ".length)).join("\n"),
      s = ub.exec(o);
    if (!s) return e;
    const a = s[1],
      l = i.gitHubRepository.endpoint;
    return t.showPopup({
      type: Zi.SAMLReauthRequired,
      organizationName: a,
      endpoint: l,
      retryAction: n.metadata.retryAction
    }), null
  })), Gb.registerErrorHandler((async function (e, t) {
    const n = ab(e);
    return n && n.metadata.backgroundTask ? null : e
  })), Gb.registerErrorHandler((async function (e, t) {
    const n = ab(e);
    if (!n) return e;
    const r = n.metadata.repository;
    if (!(r && r instanceof Xi)) return e;
    if (r.missing) return null;
    const i = sb(n.underlyingError),
      o = lb(n.underlyingError);
    return o && o.result.gitError === Ao.GitError.NotAGitRepository || i && i.code === Ao.RepositoryDoesNotExistErrorCode ? (await t.updateRepositoryMissing(r, !0), null) : e
  })), Gb.registerErrorHandler((async function (e, t) {
    const n = ab(e);
    if (null === n) return e;
    const r = lb(n.underlyingError);
    if (null === r) return e;
    const i = r.result.gitError;
    if (null === i) return e;
    if (i !== Ao.GitError.LocalChangesOverwritten && i !== Ao.GitError.MergeWithLocalChanges && i !== Ao.GitError.RebaseWithLocalChanges) return e;
    const {
      repository: o
    } = n.metadata;
    return o instanceof Xi ? void 0 === n.metadata.retryAction ? e : (t.showPopup({
      type: Zi.LocalChangesOverwritten,
      repository: o,
      retryAction: n.metadata.retryAction
    }), null) : e
  })), Gb.registerErrorHandler((async function (e, t) {
    const n = ab(e);
    if (!n) return e;
    const r = lb(n.underlyingError);
    if (!r) return e;
    const i = r.result.gitError;
    if (!i) return e;
    if (i !== Ao.GitError.LocalChangesOverwritten) return e;
    const {
      repository: o,
      gitContext: s
    } = n.metadata;
    if (null == o) return e;
    if (!(o instanceof Xi)) return e;
    if (void 0 === s || "checkout" !== s.kind) return t.recordErrorWhenSwitchingBranchesWithUncommmittedChanges(), e;
    const {
      branchToCheckout: a
    } = s;
    return await t.moveChangesToBranchAndCheckout(o, a), null
  })), Gb.registerErrorHandler((async function (e, t) {
    const n = ab(e);
    if (!n) return e;
    const r = lb(n.underlyingError);
    if (!r) return e;
    const i = r.result.gitError;
    if (!i) return e;
    if (i !== Ao.GitError.RebaseConflicts) return e;
    const {
      repository: o,
      gitContext: s
    } = n.metadata;
    if (null == o) return e;
    if (!(o instanceof Xi)) return e;
    if (null == s) return e;
    if ("merge" !== s.kind && "pull" !== s.kind) return e;
    const {
      currentBranch: a
    } = s;
    return t.launchRebaseFlow(o, a), null
  })), Gb.registerErrorHandler((async function (e, t) {
    const n = ab(e);
    if (!n) return e;
    if (!lb(n.underlyingError)) return e;
    const {
      repository: r
    } = n.metadata;
    if (!(r instanceof Xi)) return e;
    if (null === r.gitHubRepository) return e;
    if (r.gitHubRepository.endpoint !== pt()) return e;
    const i = cb.exec(e.message);
    return i ? (t.showPopup({
      type: Zi.PushRejectedDueToMissingWorkflowScope,
      rejectedPath: i[1],
      repository: r
    }), null) : e
  })), document.body.classList.add("platform-win32"), Gb.setAppFocusState(r.remote.getCurrentWindow().isFocused()), r.ipcRenderer.on("focus", () => {
    const {
      selectedState: e
    } = jb.getState();
    e && e.type !== W.CloningRepository && Gb.refreshRepository(e.repository), Gb.setAppFocusState(!0)
  }), r.ipcRenderer.on("blur", () => {
    Gb.setAccessKeyHighlightState(!1), Gb.setAppFocusState(!1)
  }), r.ipcRenderer.on("url-action", (e, {
    action: t
  }) => {
    Gb.dispatchURLAction(t)
  }), S.render(w.createElement(rb, {
    dispatcher: Gb,
    appStore: jb,
    repositoryStateManager: Ub,
    issuesStore: Ob,
    gitHubUserStore: Pb,
    startTime: Rb
  }), document.getElementById("desktop-app-container"))
}]);
//# sourceMappingURL=renderer.js.map